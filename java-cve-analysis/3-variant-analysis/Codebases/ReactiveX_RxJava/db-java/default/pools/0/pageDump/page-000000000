C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/BackpressureKind.javaBackpressureKindjavaC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotationsannotationsC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3rxjava3C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivexreactivexC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/ioioC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/javaC:/Users/Semiu/Java/ReactiveX_RxJava/src/mainmainC:/Users/Semiu/Java/ReactiveX_RxJava/srcsrcC:/Users/Semiu/Java/ReactiveX_RxJavaReactiveX_RxJavaC:/Users/Semiu/JavaJavaC:/Users/SemiuSemiuC:/UsersUsersC:/io.reactivex.rxjava3.annotationsvoidBackpressureKind()C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/BackpressureKind.classclassprivate<clinit><clinit>()staticintCopyright (c) 2016-present, RxJava Contributors.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except incompliance with the License. You may obtain a copy of the License athttp://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License isdistributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Seethe License for the specific language governing permissions and limitations under the License.Enumeration for various kinds of backpressure support.@since2.0The backpressure-related requests pass through this operator without change.The operator fully supports backpressure and may coordinate downstream requestswith upstream requests through batching, arbitration or by other means.The operator performs special backpressure management; see the associated javadoc.The operator requests {@link Long#MAX_VALUE} from upstream but respects the backpressureof the downstream.The operator will emit a {@link io.reactivex.rxjava3.exceptions.MissingBackpressureException MissingBackpressureException}if the downstream didn't request enough or in time.The operator ignores all kinds of backpressure and may overflow the downstream.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/BackpressureSupport.javaBackpressureSupportjava.lang.annotationElementType[]lengthpublicfinalcloneclone()Indicates the backpressure support kind of the associated operator or class.The backpressure supported by this method or class.@returnbackpressure supported by this method or class.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/Beta.javaBetaIndicates the feature is in beta state: it will be most likely stay butthe signature may change between versions without warning.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/CheckReturnValue.javaCheckReturnValueMarks methods whose return values should be checked.<p>History: 2.0.2 - experimental2.1C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/Experimental.javaExperimentalIndicates the feature is in experimental state: its existence, signature or behaviormight change without warning from one release to the next.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/NonNull.javaNonNullCLASSIndicates that a field/parameter/variable/type parameter/return type is never null.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/Nullable.javaNullableIndicates that a field/parameter/variable/type parameter/return type may be null.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/annotations/SchedulerSupport.javaSchedulerSupport"none"none"custom"custom"io.reactivex:computation"io.reactivex:computation"io.reactivex:io"io.reactivex:io"io.reactivex:new-thread"io.reactivex:new-thread"io.reactivex:trampoline"io.reactivex:trampoline"io.reactivex:single"io.reactivex:singleIndicates what kind of scheduler the class or method uses.<p>Constants are provided for instances from {@link Schedulers} as well as values for{@linkplain #NONE not using a scheduler} and {@linkplain #CUSTOM a manually-specified scheduler}.Libraries providing their own values should namespace them with their base package name followedby a colon ({@code :}) and then a human-readable name (e.g., {@code com.example:ui-thread}).A special value indicating the operator/class doesn't use schedulers.A special value indicating the operator/class requires a scheduler to be manually specified. Built-in schedulers:The operator/class runs on RxJava's {@linkplain Schedulers#computation() computationscheduler} or takes timing information from it.The operator/class runs on RxJava's {@linkplain Schedulers#io() I/O scheduler} or takestiming information from it.The operator/class runs on RxJava's {@linkplain Schedulers#newThread() new thread scheduler}or takes timing information from it.The operator/class runs on RxJava's {@linkplain Schedulers#trampoline() trampoline scheduler}The operator/class runs on RxJava's {@linkplain Schedulers#single() single scheduler}<p>History: 2.0.8 - experimental2.2The kind of scheduler the class or method uses.the name of the scheduler the class or method usesC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/BackpressureOverflowStrategy.javaBackpressureOverflowStrategyC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/corecoreio.reactivex.rxjava3.coreBackpressureOverflowStrategy()C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/BackpressureOverflowStrategy.classLicensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License atUnless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.Options to deal with buffer overflow when using onBackpressureBuffer.Signal a {@link io.reactivex.rxjava3.exceptions.MissingBackpressureException MissingBackpressureException}and terminate the sequence.Drop the oldest value from the buffer.Drop the latest value from the buffer.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/BackpressureStrategy.javaBackpressureStrategyBackpressureStrategy()C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/BackpressureStrategy.classRepresents the options for applying backpressure to a source sequence.The {@code onNext} events are written without any buffering or dropping.Downstream has to deal with any overflow.<p>Useful when one applies one of the custom-parameter onBackpressureXXX operators.Signals a {@link io.reactivex.rxjava3.exceptions.MissingBackpressureException MissingBackpressureException}in case the downstream can't keep up.Buffers <em>all</em> {@code onNext} values until the downstream consumes it.Drops the most recent {@code onNext} value if the downstream can't keep up.Keeps only the latest {@code onNext} value, overwriting any previous value if thedownstream can't keep up.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Completable.javaCompletablejava.utiljava.util.concurrentorg.reactivestreamsio.reactivex.rxjava3.exceptionsio.reactivex.rxjava3.functionsio.reactivex.rxjava3.internal.functionsio.reactivex.rxjava3.internal.fuseableio.reactivex.rxjava3.internal.jdk8io.reactivex.rxjava3.internal.observersio.reactivex.rxjava3.internal.operators.completableio.reactivex.rxjava3.internal.operators.maybeio.reactivex.rxjava3.internal.operators.mixedio.reactivex.rxjava3.internal.operators.singlelongtimeout0timeout0(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.CompletableSource)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Completable.class? super DisposableConsumer<? super Disposable>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Consumer.classConsumerC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functionsfunctionsabstract? super ThrowableConsumer<? super Throwable>doOnLifecycledoOnLifecycle(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action)toNpetoNpe(java.lang.Throwable)? extends CompletableSourcePublisher<? extends CompletableSource>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.3/d9fb7a7926ffa635b3dcaa5049fb2bfa25b3e7d0/reactive-streams-1.0.3.jarreactive-streams-1.0.3jarC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.3/d9fb7a7926ffa635b3dcaa5049fb2bfa25b3e7d0d9fb7a7926ffa635b3dcaa5049fb2bfa25b3e7d0C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.31.0.3C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streamsreactive-streamsC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreamsC:/Users/Semiu/.gradle/caches/modules-2/files-2.1files-2.1C:/Users/Semiu/.gradle/caches/modules-2modules-2C:/Users/Semiu/.gradle/cachescachesC:/Users/Semiu/.gradle.gradleC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.3/d9fb7a7926ffa635b3dcaa5049fb2bfa25b3e7d0/reactive-streams-1.0.3.jar/orgorgC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.3/d9fb7a7926ffa635b3dcaa5049fb2bfa25b3e7d0/reactive-streams-1.0.3.jar/org/reactivestreamsreactivestreamsC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.3/d9fb7a7926ffa635b3dcaa5049fb2bfa25b3e7d0/reactive-streams-1.0.3.jar/org/reactivestreams/Publisher.classPublisherbooleanmerge0merge0(org.reactivestreams.Publisher,int,boolean)CompletableSource[]sources"sources is null"sources is null01<nulltype>java.langIterable<? extends CompletableSource>C:/modules/java.base/java/lang/Iterable.classIterableC:/modules/java.base/java/langlangC:/modules/java.base/javaC:/modules/java.basejava.baseC:/modulesmodulesFlowable<CompletableSource>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Flowable.classFlowablePublisher<CompletableSource>? super CompletableSourceFunction<? super CompletableSource,? extends CompletableSource>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Function.classFunction? super TFunction<? super T,? extends CompletableSource>concatMapCompletableDelayErrorconcatMapCompletableDelayError(io.reactivex.rxjava3.functions.Function,boolean,int)Subscriber<? super T>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.reactivestreams/reactive-streams/1.0.3/d9fb7a7926ffa635b3dcaa5049fb2bfa25b3e7d0/reactive-streams-1.0.3.jar/org/reactivestreams/Subscriber.classSubscribersubscribesubscribe(org.reactivestreams.Subscriber)Subscriber<? super CompletableSource>Function<>Flowable<>Publisher<>RFlowable<R>Publisher<R>flatMapStreamflatMapStream(io.reactivex.rxjava3.functions.Function,int)? extends Rjava.util.streamStream<? extends R>C:/modules/java.base/java/util/stream/Stream.classStreamC:/modules/java.base/java/util/streamstreamC:/modules/java.base/java/utilutilBaseStream<? extends R,Stream<? extends R>>C:/modules/java.base/java/util/stream/BaseStream.classBaseStream? extends Stream<? extends R>Function<? super T,? extends Stream<? extends R>>Function<? super CompletableSource,? extends Stream<? extends R>>flatMapStream(io.reactivex.rxjava3.functions.Function)concatMapStreamconcatMapStream(io.reactivex.rxjava3.functions.Function,int)concatMapStream(io.reactivex.rxjava3.functions.Function)Stream<>BaseStream<>Stream<T>BaseStream<T,Stream<T>>blockingStreamblockingStream(int)Stream<CompletableSource>BaseStream<CompletableSource,Stream<CompletableSource>>blockingStream()CompletionStage<>C:/modules/java.base/java/util/concurrent/CompletionStage.classCompletionStageC:/modules/java.base/java/util/concurrentconcurrentCompletionStage<T>lastOrErrorStagelastOrErrorStage()CompletionStage<CompletableSource>singleOrErrorStagesingleOrErrorStage()firstOrErrorStagefirstOrErrorStage()lastStagelastStage(java.lang.Object)lastStage(io.reactivex.rxjava3.core.CompletableSource)singleStagesingleStage(java.lang.Object)singleStage(io.reactivex.rxjava3.core.CompletableSource)firstStagefirstStage(java.lang.Object)firstStage(io.reactivex.rxjava3.core.CompletableSource)Collector<>C:/modules/java.base/java/util/stream/Collector.classCollectorSingle<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Single.classSingleSingleSource<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/SingleSource.classSingleSourceASingle<R>SingleSource<R>collectcollect(java.util.stream.Collector)Collector<? super T,A,R>Collector<? super CompletableSource,A,R>mapOptionalmapOptional(io.reactivex.rxjava3.functions.Function)Optional<? extends R>C:/modules/java.base/java/util/Optional.classOptionalFunction<? super T,Optional<? extends R>>Function<? super CompletableSource,Optional<? extends R>>TFlowable<T>Publisher<T>fromStreamfromStream(java.util.stream.Stream)fromCompletionStagefromCompletionStage(java.util.concurrent.CompletionStage)Optional<>fromOptionalfromOptional(java.util.Optional)Optional<T>io.reactivex.rxjava3.subscribersTestSubscriber<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/subscribers/TestSubscriber.classTestSubscriberC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/subscriberssubscribersio.reactivex.rxjava3.observersBaseTestConsumer<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.classBaseTestConsumerC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/observersobserversFlowableSubscriber<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableSubscriber.classFlowableSubscriberSubscriber<>TestSubscriber<T>BaseTestConsumer<T,TestSubscriber<T>>FlowableSubscriber<T>Subscriber<T>testtest(long,boolean)TestSubscriber<CompletableSource>BaseTestConsumer<CompletableSource,TestSubscriber<CompletableSource>>FlowableSubscriber<CompletableSource>Subscriber<CompletableSource>test(long)test()BiFunction<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/BiFunction.classBiFunctionUzipWithzipWith(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiFunction,boolean,int)? extends UPublisher<? extends U>? super UBiFunction<? super T,? super U,? extends R>BiFunction<? super CompletableSource,? super U,? extends R>zipWith(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiFunction,boolean)zipWith(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiFunction)Iterable<>zipWith(java.lang.Iterable,io.reactivex.rxjava3.functions.BiFunction)Iterable<U>withLatestFromwithLatestFrom(java.lang.Iterable,io.reactivex.rxjava3.functions.Function)?Publisher<?>? extends Publisher<?>Iterable<? extends Publisher<?>>Object[]? super Object[]Function<? super Object[],R>Publisher[]Publisher<>[]withLatestFrom(org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function)Publisher<?>[]Function5<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Function5.classFunction5T1T2T3T4withLatestFrom(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function5)Publisher<T1>Publisher<T2>Publisher<T3>Publisher<T4>? super T1? super T2? super T3? super T4Function5<? super T,? super T1,? super T2,? super T3,? super T4,R>Function5<? super CompletableSource,? super T1,? super T2,? super T3,? super T4,R>Function4<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Function4.classFunction4withLatestFrom(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function4)Function4<? super T,? super T1,? super T2,? super T3,R>Function4<? super CompletableSource,? super T1,? super T2,? super T3,R>Function3<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Function3.classFunction3withLatestFrom(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function3)Function3<? super T,? super T1,? super T2,R>Function3<? super CompletableSource,? super T1,? super T2,R>withLatestFrom(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiFunction)VFlowable<Flowable>Publisher<Flowable>windowwindow(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,int)Publisher<U>Publisher<V>? extends Publisher<V>Function<? super U,? extends Publisher<V>>Flowable<Flowable<CompletableSource>>Publisher<Flowable<CompletableSource>>window(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function)Bwindow(org.reactivestreams.Publisher,int)Publisher<B>window(org.reactivestreams.Publisher)window(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,long,boolean,int)window(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,long,boolean)window(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,long)window(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)window(long,java.util.concurrent.TimeUnit,long,boolean)window(long,java.util.concurrent.TimeUnit,long)window(long,java.util.concurrent.TimeUnit)window(long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int)window(long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)window(long,long,java.util.concurrent.TimeUnit)window(long,long,int)window(long,long)window(long)unsubscribeOnunsubscribeOn(io.reactivex.rxjava3.core.Scheduler)List<T>C:/modules/java.base/java/util/List.classListCollection<T>C:/modules/java.base/java/util/Collection.classCollectionIterable<T>Single<List<T>>SingleSource<List<T>>toSortedListtoSortedList(int)List<CompletableSource>Collection<CompletableSource>Iterable<CompletableSource>Single<List<CompletableSource>>SingleSource<List<CompletableSource>>Comparator<? super T>C:/modules/java.base/java/util/Comparator.classComparatortoSortedList(java.util.Comparator,int)Comparator<? super CompletableSource>toSortedList(java.util.Comparator)toSortedList()Observable<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Observable.classObservableObservableSource<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableSource.classObservableSourceObservable<T>ObservableSource<T>toObservabletoObservable()Observable<CompletableSource>ObservableSource<CompletableSource>Supplier<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Supplier.classSupplierKCollection<V>Iterable<V>Map<K,Collection<V>>C:/modules/java.base/java/util/Map.classMapSingle<Map<K,Collection<V>>>SingleSource<Map<K,Collection<V>>>toMultimaptoMultimap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)? extends KFunction<? super T,? extends K>? extends VFunction<? super T,? extends V>Supplier<Map<K,Collection<V>>>Function<? super CompletableSource,? extends K>Function<? super CompletableSource,? extends V>toMultimap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function)? extends Map<K,Collection<V>>Supplier<? extends Map<K,Collection<V>>>? super K? super VCollection<? super V>Iterable<? super V>? extends Collection<? super V>Function<? super K,? extends Collection<? super V>>toMultimap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function)Map<K,Collection<T>>Single<Map<K,Collection<T>>>SingleSource<Map<K,Collection<T>>>toMultimap(io.reactivex.rxjava3.functions.Function)Map<K,Collection<CompletableSource>>Single<Map<K,Collection<CompletableSource>>>SingleSource<Map<K,Collection<CompletableSource>>>Map<K,V>Single<Map<K,V>>SingleSource<Map<K,V>>toMaptoMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)? extends Map<K,V>Supplier<? extends Map<K,V>>toMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function)Map<K,T>Single<Map<K,T>>SingleSource<Map<K,T>>toMap(io.reactivex.rxjava3.functions.Function)Map<K,CompletableSource>Single<Map<K,CompletableSource>>SingleSource<Map<K,CompletableSource>>Collection<? super T>Iterable<? super T>Single<U>SingleSource<U>toListtoList(io.reactivex.rxjava3.functions.Supplier)Supplier<U>toList(int)toList()FlowableConverter<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableConverter.classFlowableConvertertoto(io.reactivex.rxjava3.core.FlowableConverter)FlowableConverter<T,? extends R>FlowableConverter<CompletableSource,? extends R>io.reactivex.rxjava3.schedulersTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/schedulers/Timed.classTimedC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/schedulersschedulersFlowable<Timed<T>>Publisher<Timed<T>>timestamptimestamp(java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)Timed<CompletableSource>Flowable<Timed<CompletableSource>>Publisher<Timed<CompletableSource>>timestamp(java.util.concurrent.TimeUnit)timestamp(io.reactivex.rxjava3.core.Scheduler)timestamp()timeouttimeout(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,org.reactivestreams.Publisher)Function<? super T,? extends Publisher<V>>? extends TPublisher<? extends T>Function<? super CompletableSource,? extends Publisher<V>>timeout(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function)timeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)timeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,org.reactivestreams.Publisher)timeout(long,java.util.concurrent.TimeUnit,org.reactivestreams.Publisher)timeout(long,java.util.concurrent.TimeUnit)timeout(io.reactivex.rxjava3.functions.Function,org.reactivestreams.Publisher)timeout(io.reactivex.rxjava3.functions.Function)timeIntervaltimeInterval(java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)timeInterval(java.util.concurrent.TimeUnit)timeInterval(io.reactivex.rxjava3.core.Scheduler)timeInterval()throttleWithTimeoutthrottleWithTimeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)throttleWithTimeout(long,java.util.concurrent.TimeUnit)throttleLatestthrottleLatest(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)throttleLatest(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)throttleLatest(long,java.util.concurrent.TimeUnit,boolean)throttleLatest(long,java.util.concurrent.TimeUnit)throttleLastthrottleLast(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)throttleLast(long,java.util.concurrent.TimeUnit)throttleFirstthrottleFirst(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)throttleFirst(long,java.util.concurrent.TimeUnit)Predicate<? super T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Predicate.classPredicatetakeWhiletakeWhile(io.reactivex.rxjava3.functions.Predicate)Predicate<? super CompletableSource>takeUntiltakeUntil(org.reactivestreams.Publisher)takeUntil(io.reactivex.rxjava3.functions.Predicate)takeLasttakeLast(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean,int)takeLast(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)takeLast(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)takeLast(long,java.util.concurrent.TimeUnit,boolean)takeLast(long,java.util.concurrent.TimeUnit)takeLast(long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean,int)takeLast(long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)takeLast(long,long,java.util.concurrent.TimeUnit)takeLast(int)taketake(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)take(long,java.util.concurrent.TimeUnit)take(long)switchMapSingleDelayErrorswitchMapSingleDelayError(io.reactivex.rxjava3.functions.Function)SingleSource<? extends R>? extends SingleSource<? extends R>Function<? super T,? extends SingleSource<? extends R>>Function<? super CompletableSource,? extends SingleSource<? extends R>>switchMapSingleswitchMapSingle(io.reactivex.rxjava3.functions.Function)switchMapMaybeDelayErrorswitchMapMaybeDelayError(io.reactivex.rxjava3.functions.Function)MaybeSource<? extends R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeSource.classMaybeSource? extends MaybeSource<? extends R>Function<? super T,? extends MaybeSource<? extends R>>Function<? super CompletableSource,? extends MaybeSource<? extends R>>switchMapMaybeswitchMapMaybe(io.reactivex.rxjava3.functions.Function)switchMap0switchMap0(io.reactivex.rxjava3.functions.Function,int,boolean)Publisher<? extends R>? extends Publisher<? extends R>Function<? super T,? extends Publisher<? extends R>>Function<? super CompletableSource,? extends Publisher<? extends R>>switchMapDelayErrorswitchMapDelayError(io.reactivex.rxjava3.functions.Function,int)switchMapDelayError(io.reactivex.rxjava3.functions.Function)switchMapCompletableDelayErrorswitchMapCompletableDelayError(io.reactivex.rxjava3.functions.Function)switchMapCompletableswitchMapCompletable(io.reactivex.rxjava3.functions.Function)switchMapswitchMap(io.reactivex.rxjava3.functions.Function,int)switchMap(io.reactivex.rxjava3.functions.Function)switchIfEmptyswitchIfEmpty(org.reactivestreams.Publisher)subscribeOnsubscribeOn(io.reactivex.rxjava3.core.Scheduler,boolean)subscribeOn(io.reactivex.rxjava3.core.Scheduler)EsubscribeWithsubscribeWith(org.reactivestreams.Subscriber)subscribeActualsubscribeActual(org.reactivestreams.Subscriber)protectedFlowableSubscriber<? super T>subscribe(io.reactivex.rxjava3.core.FlowableSubscriber)FlowableSubscriber<? super CompletableSource>Consumer<? super T>subscribe(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)Consumer<? super CompletableSource>subscribe(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer)subscribe(io.reactivex.rxjava3.functions.Consumer)subscribe()T[]startWithArraystartWithArray(java.lang.Object[])startWithArray(io.reactivex.rxjava3.core.CompletableSource[])startWithItemstartWithItem(java.lang.Object)startWithItem(io.reactivex.rxjava3.core.CompletableSource)startWithstartWith(org.reactivestreams.Publisher)MaybeSource<T>startWith(io.reactivex.rxjava3.core.MaybeSource)MaybeSource<CompletableSource>SingleSource<T>startWith(io.reactivex.rxjava3.core.SingleSource)SingleSource<CompletableSource>startWith(io.reactivex.rxjava3.core.CompletableSource)Iterable<? extends T>startWithIterablestartWithIterable(java.lang.Iterable)sortedsorted(java.util.Comparator)sorted()skipWhileskipWhile(io.reactivex.rxjava3.functions.Predicate)skipUntilskipUntil(org.reactivestreams.Publisher)skipLastskipLast(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean,int)skipLast(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)skipLast(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)skipLast(long,java.util.concurrent.TimeUnit,boolean)skipLast(long,java.util.concurrent.TimeUnit)skipLast(int)skipskip(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)skip(long,java.util.concurrent.TimeUnit)skip(long)Single<T>singleOrErrorsingleOrError()Single<CompletableSource>singlesingle(java.lang.Object)single(io.reactivex.rxjava3.core.CompletableSource)Maybe<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Maybe.classMaybeMaybeSource<>Maybe<T>singleElementsingleElement()Maybe<CompletableSource>shareshare()serializeserialize()scanWithscanWith(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)Supplier<R>BiFunction<R,? super T,R>BiFunction<R,? super CompletableSource,R>scanscan(java.lang.Object,io.reactivex.rxjava3.functions.BiFunction)BiFunction<T,T,T>scan(io.reactivex.rxjava3.functions.BiFunction)BiFunction<CompletableSource,CompletableSource,CompletableSource>samplesample(org.reactivestreams.Publisher,boolean)sample(org.reactivestreams.Publisher)sample(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)sample(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)sample(long,java.util.concurrent.TimeUnit,boolean)sample(long,java.util.concurrent.TimeUnit)safeSubscribesafeSubscribe(org.reactivestreams.Subscriber)Flowable<Throwable>Publisher<Throwable>? super Flowable<Throwable>Function<? super Flowable<Throwable>,? extends Publisher<?>>retryWhenretryWhen(io.reactivex.rxjava3.functions.Function)retryUntilretryUntil(io.reactivex.rxjava3.functions.BooleanSupplier)Predicate<? super Throwable>retryretry(io.reactivex.rxjava3.functions.Predicate)retry(long,io.reactivex.rxjava3.functions.Predicate)retry(long)? super IntegerBiPredicate<? super Integer,? super Throwable>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/BiPredicate.classBiPredicateretry(io.reactivex.rxjava3.functions.BiPredicate)retry()io.reactivex.rxjava3.flowablesConnectableFlowable<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/flowables/ConnectableFlowable.classConnectableFlowableC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/flowablesflowablesConnectableFlowable<T>replayreplay(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)ConnectableFlowable<CompletableSource>replay(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)replay(long,java.util.concurrent.TimeUnit)replay(int,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)replay(int,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)replay(int,long,java.util.concurrent.TimeUnit)replay(int,boolean)replay(int)replay(io.reactivex.rxjava3.functions.Function,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)? super Flowable? extends Publisher<R>Function<? super Flowable,? extends Publisher<R>>? super Flowable<CompletableSource>Function<? super Flowable<CompletableSource>,? extends Publisher<R>>replay(io.reactivex.rxjava3.functions.Function,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)replay(io.reactivex.rxjava3.functions.Function,long,java.util.concurrent.TimeUnit)replay(io.reactivex.rxjava3.functions.Function,int,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)replay(io.reactivex.rxjava3.functions.Function,int,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)replay(io.reactivex.rxjava3.functions.Function,int,long,java.util.concurrent.TimeUnit)replay(io.reactivex.rxjava3.functions.Function,int,boolean)replay(io.reactivex.rxjava3.functions.Function,int)replay(io.reactivex.rxjava3.functions.Function)replay()Flowable<Object>Publisher<Object>? super Flowable<Object>Function<? super Flowable<Object>,? extends Publisher<?>>repeatWhenrepeatWhen(io.reactivex.rxjava3.functions.Function)repeatUntilrepeatUntil(io.reactivex.rxjava3.functions.BooleanSupplier)repeatrepeat(long)repeat()reduceWithreduceWith(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)reducereduce(java.lang.Object,io.reactivex.rxjava3.functions.BiFunction)reduce(io.reactivex.rxjava3.functions.BiFunction)rebatchRequestsrebatchRequests(int)publishpublish(int)publish(io.reactivex.rxjava3.functions.Function,int)Function<? super Flowable,? extends Publisher<? extends R>>Function<? super Flowable<CompletableSource>,? extends Publisher<? extends R>>publish(io.reactivex.rxjava3.functions.Function)publish()io.reactivex.rxjava3.parallelParallelFlowable<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/parallel/ParallelFlowable.classParallelFlowableC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/parallelparallelParallelFlowable<T>parallel(int,int)ParallelFlowable<CompletableSource>parallel(int)parallel()onTerminateDetachonTerminateDetach()onErrorReturnItemonErrorReturnItem(java.lang.Object)onErrorReturnItem(io.reactivex.rxjava3.core.CompletableSource)Function<? super Throwable,? extends T>onErrorReturnonErrorReturn(io.reactivex.rxjava3.functions.Function)Function<? super Throwable,? extends CompletableSource>onErrorResumeWithonErrorResumeWith(org.reactivestreams.Publisher)? extends Publisher<? extends T>Function<? super Throwable,? extends Publisher<? extends T>>onErrorResumeNextonErrorResumeNext(io.reactivex.rxjava3.functions.Function)? extends Publisher<? extends CompletableSource>Function<? super Throwable,? extends Publisher<? extends CompletableSource>>onErrorCompleteonErrorComplete(io.reactivex.rxjava3.functions.Predicate)onErrorComplete()onBackpressureReduceonBackpressureReduce(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)onBackpressureReduce(io.reactivex.rxjava3.functions.BiFunction)onBackpressureLatestonBackpressureLatest()onBackpressureDroponBackpressureDrop(io.reactivex.rxjava3.functions.Consumer)onBackpressureDrop()onBackpressureBufferonBackpressureBuffer(long,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.core.BackpressureOverflowStrategy)onBackpressureBuffer(int,io.reactivex.rxjava3.functions.Action)onBackpressureBuffer(int,boolean,boolean,io.reactivex.rxjava3.functions.Action)onBackpressureBuffer(int,boolean,boolean)onBackpressureBuffer(int,boolean)onBackpressureBuffer(int)onBackpressureBuffer(boolean)onBackpressureBuffer()Class<>C:/modules/java.base/java/lang/Class.classClassjava.lang.invokeOfField<>C:/modules/java.base/java/lang/invoke/TypeDescriptor$OfField.classTypeDescriptor$OfFieldC:/modules/java.base/java/lang/invokeinvokeFlowable<U>ofTypeofType(java.lang.Class)Class<U>Class<?>OfField<Class<?>>observeOnobserveOn(io.reactivex.rxjava3.core.Scheduler,boolean,int)observeOn(io.reactivex.rxjava3.core.Scheduler,boolean)observeOn(io.reactivex.rxjava3.core.Scheduler)mergeWithmergeWith(io.reactivex.rxjava3.core.CompletableSource)MaybeSource<? extends T>mergeWith(io.reactivex.rxjava3.core.MaybeSource)MaybeSource<? extends CompletableSource>SingleSource<? extends T>mergeWith(io.reactivex.rxjava3.core.SingleSource)SingleSource<? extends CompletableSource>mergeWith(org.reactivestreams.Publisher)Notification<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Notification.classNotificationFlowable<Notification<T>>Publisher<Notification<T>>materializematerialize()Notification<CompletableSource>Flowable<Notification<CompletableSource>>Publisher<Notification<CompletableSource>>mapmap(io.reactivex.rxjava3.functions.Function)Function<? super T,? extends R>Function<? super CompletableSource,? extends R>FlowableOperator<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableOperator.classFlowableOperatorliftlift(io.reactivex.rxjava3.core.FlowableOperator)FlowableOperator<? extends R,? super T>FlowableOperator<? extends R,? super CompletableSource>lastOrErrorlastOrError()lastlast(java.lang.Object)last(io.reactivex.rxjava3.core.CompletableSource)lastElementlastElement()TRightTLeftEndTRightEndjoinjoin(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)? extends TRightPublisher<? extends TRight>Publisher<TLeftEnd>? extends Publisher<TLeftEnd>Function<? super T,? extends Publisher<TLeftEnd>>? super TRightPublisher<TRightEnd>? extends Publisher<TRightEnd>Function<? super TRight,? extends Publisher<TRightEnd>>BiFunction<? super T,? super TRight,? extends R>Function<? super CompletableSource,? extends Publisher<TLeftEnd>>BiFunction<? super CompletableSource,? super TRight,? extends R>Single<Boolean>SingleSource<Boolean>isEmptyisEmpty()ignoreElementsignoreElements()hidehide()groupJoingroupJoin(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)Flowable<TRight>Publisher<TRight>? super Flowable<TRight>BiFunction<? super T,? super Flowable<TRight>,? extends R>BiFunction<? super CompletableSource,? super Flowable<TRight>,? extends R>GroupedFlowable<K,V>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/flowables/GroupedFlowable.classGroupedFlowableFlowable<V>Flowable<GroupedFlowable<K,V>>Publisher<GroupedFlowable<K,V>>groupBygroupBy(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,boolean,int,io.reactivex.rxjava3.functions.Function)Consumer<Object>? super Consumer<Object>Map<K,Object>? extends Map<K,Object>Function<? super Consumer<Object>,? extends Map<K,Object>>groupBy(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,boolean,int)groupBy(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,boolean)groupBy(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function)GroupedFlowable<K,T>Flowable<GroupedFlowable<K,T>>Publisher<GroupedFlowable<K,T>>groupBy(io.reactivex.rxjava3.functions.Function,boolean)GroupedFlowable<K,CompletableSource>Flowable<GroupedFlowable<K,CompletableSource>>Publisher<GroupedFlowable<K,CompletableSource>>groupBy(io.reactivex.rxjava3.functions.Function)forEachWhileforEachWhile(io.reactivex.rxjava3.functions.Predicate,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)forEachWhile(io.reactivex.rxjava3.functions.Predicate,io.reactivex.rxjava3.functions.Consumer)forEachWhile(io.reactivex.rxjava3.functions.Predicate)forEachforEach(io.reactivex.rxjava3.functions.Consumer)flatMapSingleflatMapSingle(io.reactivex.rxjava3.functions.Function,boolean,int)flatMapSingle(io.reactivex.rxjava3.functions.Function)flatMapMaybeflatMapMaybe(io.reactivex.rxjava3.functions.Function,boolean,int)flatMapMaybe(io.reactivex.rxjava3.functions.Function)flatMapIterableflatMapIterable(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction,int)Iterable<? extends U>? extends Iterable<? extends U>Function<? super T,? extends Iterable<? extends U>>BiFunction<? super T,? super U,? extends V>Function<? super CompletableSource,? extends Iterable<? extends U>>BiFunction<? super CompletableSource,? super U,? extends V>flatMapIterable(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)flatMapIterable(io.reactivex.rxjava3.functions.Function,int)flatMapIterable(io.reactivex.rxjava3.functions.Function)flatMapCompletableflatMapCompletable(io.reactivex.rxjava3.functions.Function,boolean,int)flatMapCompletable(io.reactivex.rxjava3.functions.Function)flatMapflatMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction,int)? extends Publisher<? extends U>Function<? super T,? extends Publisher<? extends U>>Function<? super CompletableSource,? extends Publisher<? extends U>>flatMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction,boolean,int,int)flatMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction,boolean,int)flatMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction,boolean)flatMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)flatMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier,int)Function<Throwable,? extends Publisher<? extends R>>Supplier<? extends Publisher<? extends R>>flatMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)Function<? super Throwable,? extends Publisher<? extends R>>flatMap(io.reactivex.rxjava3.functions.Function,boolean,int,int)flatMap(io.reactivex.rxjava3.functions.Function,boolean,int)flatMap(io.reactivex.rxjava3.functions.Function,int)flatMap(io.reactivex.rxjava3.functions.Function,boolean)flatMap(io.reactivex.rxjava3.functions.Function)firstOrErrorfirstOrError()firstfirst(java.lang.Object)first(io.reactivex.rxjava3.core.CompletableSource)firstElementfirstElement()filterfilter(io.reactivex.rxjava3.functions.Predicate)elementAtOrErrorelementAtOrError(long)elementAtelementAt(long,java.lang.Object)elementAt(long,io.reactivex.rxjava3.core.CompletableSource)elementAt(long)doOnTerminatedoOnTerminate(io.reactivex.rxjava3.functions.Action)? super SubscriptionConsumer<? super Subscription>doOnSubscribedoOnSubscribe(io.reactivex.rxjava3.functions.Consumer)doOnRequestdoOnRequest(io.reactivex.rxjava3.functions.LongConsumer)doOnNextdoOnNext(io.reactivex.rxjava3.functions.Consumer)doOnLifecycle(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.LongConsumer,io.reactivex.rxjava3.functions.Action)doOnErrordoOnError(io.reactivex.rxjava3.functions.Consumer)doOnEachdoOnEach(org.reactivestreams.Subscriber)? super Notification<T>Consumer<? super Notification<T>>doOnEach(io.reactivex.rxjava3.functions.Consumer)? super Notification<CompletableSource>Consumer<? super Notification<CompletableSource>>doOnCompletedoOnComplete(io.reactivex.rxjava3.functions.Action)doOnCanceldoOnCancel(io.reactivex.rxjava3.functions.Action)doAfterTerminatedoAfterTerminate(io.reactivex.rxjava3.functions.Action)doAfterNextdoAfterNext(io.reactivex.rxjava3.functions.Consumer)doFinallydoFinally(io.reactivex.rxjava3.functions.Action)BiPredicate<? super T,? super T>distinctUntilChangeddistinctUntilChanged(io.reactivex.rxjava3.functions.BiPredicate)BiPredicate<? super CompletableSource,? super CompletableSource>distinctUntilChanged(io.reactivex.rxjava3.functions.Function)Function<? super T,K>Function<? super CompletableSource,K>distinctUntilChanged()distinctdistinct(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)Collection<? super K>Iterable<? super K>? extends Collection<? super K>Supplier<? extends Collection<? super K>>distinct(io.reactivex.rxjava3.functions.Function)distinct()dematerializedematerialize(io.reactivex.rxjava3.functions.Function)Notification<R>Function<? super T,Notification<R>>Function<? super CompletableSource,Notification<R>>delaySubscriptiondelaySubscription(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)delaySubscription(long,java.util.concurrent.TimeUnit)delaySubscription(org.reactivestreams.Publisher)delaydelay(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function)delay(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)delay(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)delay(long,java.util.concurrent.TimeUnit,boolean)delay(long,java.util.concurrent.TimeUnit)delay(io.reactivex.rxjava3.functions.Function)? extends Publisher<U>Function<? super T,? extends Publisher<U>>Function<? super CompletableSource,? extends Publisher<U>>defaultIfEmptydefaultIfEmpty(java.lang.Object)defaultIfEmpty(io.reactivex.rxjava3.core.CompletableSource)debouncedebounce(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)debounce(long,java.util.concurrent.TimeUnit)debounce(io.reactivex.rxjava3.functions.Function)Single<Long>SingleSource<Long>countcount()containscontains(java.lang.Object)concatWithconcatWith(io.reactivex.rxjava3.core.CompletableSource)concatWith(io.reactivex.rxjava3.core.MaybeSource)concatWith(io.reactivex.rxjava3.core.SingleSource)concatWith(org.reactivestreams.Publisher)concatMapSingleDelayErrorconcatMapSingleDelayError(io.reactivex.rxjava3.functions.Function,boolean,int)concatMapSingleDelayError(io.reactivex.rxjava3.functions.Function,boolean)concatMapSingleDelayError(io.reactivex.rxjava3.functions.Function)concatMapSingleconcatMapSingle(io.reactivex.rxjava3.functions.Function,int)concatMapSingle(io.reactivex.rxjava3.functions.Function)concatMapMaybeDelayErrorconcatMapMaybeDelayError(io.reactivex.rxjava3.functions.Function,boolean,int)concatMapMaybeDelayError(io.reactivex.rxjava3.functions.Function,boolean)concatMapMaybeDelayError(io.reactivex.rxjava3.functions.Function)concatMapMaybeconcatMapMaybe(io.reactivex.rxjava3.functions.Function,int)concatMapMaybe(io.reactivex.rxjava3.functions.Function)concatMapIterableconcatMapIterable(io.reactivex.rxjava3.functions.Function,int)concatMapIterable(io.reactivex.rxjava3.functions.Function)concatMapEagerDelayErrorconcatMapEagerDelayError(io.reactivex.rxjava3.functions.Function,boolean,int,int)concatMapEagerDelayError(io.reactivex.rxjava3.functions.Function,boolean)concatMapEagerconcatMapEager(io.reactivex.rxjava3.functions.Function,int,int)concatMapEager(io.reactivex.rxjava3.functions.Function)concatMapDelayErrorconcatMapDelayError(io.reactivex.rxjava3.functions.Function,boolean,int,io.reactivex.rxjava3.core.Scheduler)concatMapDelayError(io.reactivex.rxjava3.functions.Function,boolean,int)concatMapDelayError(io.reactivex.rxjava3.functions.Function)concatMapCompletableDelayError(io.reactivex.rxjava3.functions.Function,boolean)concatMapCompletableDelayError(io.reactivex.rxjava3.functions.Function)concatMapCompletableconcatMapCompletable(io.reactivex.rxjava3.functions.Function,int)concatMapCompletable(io.reactivex.rxjava3.functions.Function)concatMapconcatMap(io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.core.Scheduler)concatMap(io.reactivex.rxjava3.functions.Function,int)concatMap(io.reactivex.rxjava3.functions.Function)FlowableTransformer<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableTransformer.classFlowableTransformercomposecompose(io.reactivex.rxjava3.core.FlowableTransformer)FlowableTransformer<? super T,? extends R>FlowableTransformer<? super CompletableSource,? extends R>BiConsumer<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/BiConsumer.classBiConsumercollectIntocollectInto(java.lang.Object,io.reactivex.rxjava3.functions.BiConsumer)BiConsumer<? super U,? super T>BiConsumer<? super U,? super CompletableSource>collect(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiConsumer)Supplier<? extends U>castcast(java.lang.Class)cacheWithInitialCapacitycacheWithInitialCapacity(int)cachecache()bufferbuffer(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Supplier)Flowable<List<T>>Publisher<List<T>>buffer(org.reactivestreams.Publisher,int)Flowable<List<CompletableSource>>Publisher<List<CompletableSource>>buffer(org.reactivestreams.Publisher)TOpeningTClosingbuffer(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)? extends TOpeningPublisher<? extends TOpening>? super TOpening? extends TClosingPublisher<? extends TClosing>? extends Publisher<? extends TClosing>Function<? super TOpening,? extends Publisher<? extends TClosing>>buffer(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function)buffer(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)buffer(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,io.reactivex.rxjava3.functions.Supplier,boolean)buffer(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int)buffer(long,java.util.concurrent.TimeUnit,int)buffer(long,java.util.concurrent.TimeUnit)buffer(long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.functions.Supplier)buffer(long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)buffer(long,long,java.util.concurrent.TimeUnit)buffer(int,io.reactivex.rxjava3.functions.Supplier)buffer(int,int,io.reactivex.rxjava3.functions.Supplier)buffer(int,int)buffer(int)blockingSubscribeblockingSubscribe(org.reactivestreams.Subscriber)blockingSubscribe(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,int)blockingSubscribe(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)blockingSubscribe(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,int)blockingSubscribe(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer)blockingSubscribe(io.reactivex.rxjava3.functions.Consumer,int)blockingSubscribe(io.reactivex.rxjava3.functions.Consumer)blockingSubscribe()Future<>C:/modules/java.base/java/util/concurrent/Future.classFutureFuture<T>toFuturetoFuture()Future<CompletableSource>blockingSingleblockingSingle(java.lang.Object)blockingSingle(io.reactivex.rxjava3.core.CompletableSource)blockingSingle()blockingNextblockingNext()blockingMostRecentblockingMostRecent(java.lang.Object)blockingMostRecent(io.reactivex.rxjava3.core.CompletableSource)blockingLatestblockingLatest()blockingLastblockingLast(java.lang.Object)blockingLast(io.reactivex.rxjava3.core.CompletableSource)blockingLast()blockingIterableblockingIterable(int)blockingIterable()blockingForEachblockingForEach(io.reactivex.rxjava3.functions.Consumer,int)blockingForEach(io.reactivex.rxjava3.functions.Consumer)blockingFirstblockingFirst(java.lang.Object)blockingFirst(io.reactivex.rxjava3.core.CompletableSource)blockingFirst()anyany(io.reactivex.rxjava3.functions.Predicate)ambWithambWith(org.reactivestreams.Publisher)allall(io.reactivex.rxjava3.functions.Predicate)zipArrayzipArray(io.reactivex.rxjava3.functions.Function,boolean,int,org.reactivestreams.Publisher[])Function<? super Object[],? extends R>Publisher<? extends T>[]Function9<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Function9.classFunction9T5T6T7T8T9zipzip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function9)? extends T1Publisher<? extends T1>? extends T2Publisher<? extends T2>? extends T3Publisher<? extends T3>? extends T4Publisher<? extends T4>? extends T5Publisher<? extends T5>? extends T6Publisher<? extends T6>? extends T7Publisher<? extends T7>? extends T8Publisher<? extends T8>? extends T9Publisher<? extends T9>? super T5? super T6? super T7? super T8? super T9Function9<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? super T9,? extends R>Function8<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Function8.classFunction8zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function8)Function8<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? super T8,? extends R>Function7<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Function7.classFunction7zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function7)Function7<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? super T7,? extends R>Function6<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/functions/Function6.classFunction6zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function6)Function6<? super T1,? super T2,? super T3,? super T4,? super T5,? super T6,? extends R>zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function5)Function5<? super T1,? super T2,? super T3,? super T4,? super T5,? extends R>zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function4)Function4<? super T1,? super T2,? super T3,? super T4,? extends R>zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function3)Function3<? super T1,? super T2,? super T3,? extends R>zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiFunction,boolean,int)BiFunction<? super T1,? super T2,? extends R>zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiFunction,boolean)zip(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiFunction)zip(java.lang.Iterable,io.reactivex.rxjava3.functions.Function,boolean,int)Iterable<? extends Publisher<? extends T>>zip(java.lang.Iterable,io.reactivex.rxjava3.functions.Function)Consumer<>Dusingusing(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)? extends DSupplier<? extends D>? super DFunction<? super D,? extends Publisher<? extends T>>Consumer<? super D>using(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer)unsafeCreateunsafeCreate(org.reactivestreams.Publisher)Flowable<Long>Publisher<Long>timertimer(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)timer(long,java.util.concurrent.TimeUnit)switchOnNextDelayErrorswitchOnNextDelayError(org.reactivestreams.Publisher,int)Publisher<? extends Publisher<? extends T>>switchOnNextDelayError(org.reactivestreams.Publisher)switchOnNextswitchOnNext(org.reactivestreams.Publisher)switchOnNext(org.reactivestreams.Publisher,int)sequenceEqualsequenceEqual(org.reactivestreams.Publisher,org.reactivestreams.Publisher,int)BiPredicate<>sequenceEqual(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiPredicate,int)sequenceEqual(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiPredicate)sequenceEqual(org.reactivestreams.Publisher,org.reactivestreams.Publisher)rangeLongrangeLong(long,long)Flowable<Integer>Publisher<Integer>rangerange(int,int)nevernever()mergeDelayErrormergeDelayError(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher)mergeDelayError(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher)mergeDelayError(org.reactivestreams.Publisher,org.reactivestreams.Publisher)mergeArrayDelayErrormergeArrayDelayError(org.reactivestreams.Publisher[])mergeDelayError(org.reactivestreams.Publisher,int)mergeDelayError(org.reactivestreams.Publisher)mergeDelayError(java.lang.Iterable,int)mergeArrayDelayError(int,int,org.reactivestreams.Publisher[])mergeDelayError(java.lang.Iterable,int,int)mergeDelayError(java.lang.Iterable)mergemerge(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher)merge(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher)merge(org.reactivestreams.Publisher,org.reactivestreams.Publisher)mergeArraymergeArray(org.reactivestreams.Publisher[])merge(org.reactivestreams.Publisher,int)merge(org.reactivestreams.Publisher)merge(java.lang.Iterable,int)merge(java.lang.Iterable)mergeArray(int,int,org.reactivestreams.Publisher[])merge(java.lang.Iterable,int,int)justjust(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)just(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)just(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)just(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)just(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)just(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)just(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)just(java.lang.Object,java.lang.Object,java.lang.Object)just(java.lang.Object,java.lang.Object)just(java.lang.Object)intervalRangeintervalRange(long,long,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)intervalRange(long,long,long,long,java.util.concurrent.TimeUnit)intervalinterval(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)interval(long,java.util.concurrent.TimeUnit)interval(long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)interval(long,long,java.util.concurrent.TimeUnit)Sgenerategenerate(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction,io.reactivex.rxjava3.functions.Consumer)Supplier<S>Emitter<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Emitter.classEmitterBiFunction<S,Emitter<T>,S>? super SConsumer<? super S>generate(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)generate(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiConsumer,io.reactivex.rxjava3.functions.Consumer)BiConsumer<S,Emitter<T>>generate(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiConsumer)generate(io.reactivex.rxjava3.functions.Consumer)Consumer<Emitter<T>>fromSupplierfromSupplier(io.reactivex.rxjava3.functions.Supplier)Supplier<? extends T>fromSinglefromSingle(io.reactivex.rxjava3.core.SingleSource)fromRunnablefromRunnable(java.lang.Runnable)fromPublisherfromPublisher(org.reactivestreams.Publisher)fromObservablefromObservable(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.BackpressureStrategy)fromMaybefromMaybe(io.reactivex.rxjava3.core.MaybeSource)fromIterablefromIterable(java.lang.Iterable)fromFuturefromFuture(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit)Future<? extends T>fromFuture(java.util.concurrent.Future)fromCompletablefromCompletable(io.reactivex.rxjava3.core.CompletableSource)Callable<>C:/modules/java.base/java/util/concurrent/Callable.classCallablefromCallablefromCallable(java.util.concurrent.Callable)Callable<? extends T>fromArrayfromArray(java.lang.Object[])fromActionfromAction(io.reactivex.rxjava3.functions.Action)errorerror(java.lang.Throwable)error(io.reactivex.rxjava3.functions.Supplier)? extends ThrowableSupplier<? extends Throwable>emptyempty()deferdefer(io.reactivex.rxjava3.functions.Supplier)Supplier<? extends Publisher<? extends T>>FlowableOnSubscribe<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableOnSubscribe.classFlowableOnSubscribecreatecreate(io.reactivex.rxjava3.core.FlowableOnSubscribe,io.reactivex.rxjava3.core.BackpressureStrategy)FlowableOnSubscribe<T>concatEagerDelayErrorconcatEagerDelayError(org.reactivestreams.Publisher,int,int)concatEagerDelayError(org.reactivestreams.Publisher)concatEagerDelayError(java.lang.Iterable,int,int)concatEagerDelayError(java.lang.Iterable)concatEagerconcatEager(org.reactivestreams.Publisher,int,int)concatEager(org.reactivestreams.Publisher)concatEager(java.lang.Iterable,int,int)concatEager(java.lang.Iterable)concatDelayErrorconcatDelayError(org.reactivestreams.Publisher,int,boolean)concatDelayError(org.reactivestreams.Publisher)concatDelayError(java.lang.Iterable)concatArrayEagerDelayErrorconcatArrayEagerDelayError(int,int,org.reactivestreams.Publisher[])concatArrayEagerDelayError(org.reactivestreams.Publisher[])concatArrayEagerconcatArrayEager(int,int,org.reactivestreams.Publisher[])concatArrayEager(org.reactivestreams.Publisher[])concatArrayDelayErrorconcatArrayDelayError(org.reactivestreams.Publisher[])concatArrayconcatArray(org.reactivestreams.Publisher[])concatconcat(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher)concat(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher)concat(org.reactivestreams.Publisher,org.reactivestreams.Publisher)concat(org.reactivestreams.Publisher,int)concat(org.reactivestreams.Publisher)concat(java.lang.Iterable)combineLatestcombineLatest(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function9)combineLatest(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function8)combineLatest(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function7)combineLatest(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function6)combineLatest(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function5)combineLatest(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function4)combineLatest(org.reactivestreams.Publisher,org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function3)combineLatest(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiFunction)combineLatestDelayErrorcombineLatestDelayError(java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int)combineLatestDelayError(java.lang.Iterable,io.reactivex.rxjava3.functions.Function)combineLatestArrayDelayErrorcombineLatestArrayDelayError(org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function,int)combineLatestArrayDelayError(org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function)combineLatest(java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int)combineLatest(java.lang.Iterable,io.reactivex.rxjava3.functions.Function)combineLatestArraycombineLatestArray(org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function,int)combineLatestArray(org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function)bufferSizebufferSize()ambArrayambArray(org.reactivestreams.Publisher[])ambamb(java.lang.Iterable)BUFFER_SIZEFlowable()Flowable<CompletableSource>()Function<CompletableSource,CompletableSource>Comparator<>Predicate<>Flowable<>()true2prefetch"prefetch"Flowable<? extends CompletableSource>? super ? extends CompletableSourceFunction<? super ? extends CompletableSource,? extends CompletableSource>Subscriber<? super ? extends CompletableSource>Function<? super ? extends CompletableSource,? extends Stream<? extends R>>Stream<? extends CompletableSource>BaseStream<? extends CompletableSource,Stream<? extends CompletableSource>>CompletionStage<? extends CompletableSource>Collector<? super ? extends CompletableSource,A,R>Function<? super ? extends CompletableSource,Optional<? extends R>>TestSubscriber<? extends CompletableSource>BaseTestConsumer<? extends CompletableSource,TestSubscriber<? extends CompletableSource>>FlowableSubscriber<? extends CompletableSource>Subscriber<? extends CompletableSource>BiFunction<? super ? extends CompletableSource,? super U,? extends R>Function5<? super ? extends CompletableSource,? super T1,? super T2,? super T3,? super T4,R>Function4<? super ? extends CompletableSource,? super T1,? super T2,? super T3,R>Function3<? super ? extends CompletableSource,? super T1,? super T2,R>Flowable<Flowable<? extends CompletableSource>>Publisher<Flowable<? extends CompletableSource>>List<? extends CompletableSource>Collection<? extends CompletableSource>Single<List<? extends CompletableSource>>SingleSource<List<? extends CompletableSource>>Comparator<? super ? extends CompletableSource>Observable<? extends CompletableSource>ObservableSource<? extends CompletableSource>Function<? super ? extends CompletableSource,? extends K>Function<? super ? extends CompletableSource,? extends V>Map<K,Collection<? extends CompletableSource>>Single<Map<K,Collection<? extends CompletableSource>>>SingleSource<Map<K,Collection<? extends CompletableSource>>>Map<K,? extends CompletableSource>Single<Map<K,? extends CompletableSource>>SingleSource<Map<K,? extends CompletableSource>>FlowableConverter<? extends CompletableSource,? extends R>Timed<? extends CompletableSource>Flowable<Timed<? extends CompletableSource>>Publisher<Timed<? extends CompletableSource>>Function<? super ? extends CompletableSource,? extends Publisher<V>>? extends ? extends CompletableSourcePublisher<? extends ? extends CompletableSource>Predicate<? super ? extends CompletableSource>Function<? super ? extends CompletableSource,? extends SingleSource<? extends R>>Function<? super ? extends CompletableSource,? extends MaybeSource<? extends R>>Function<? super ? extends CompletableSource,? extends Publisher<? extends R>>FlowableSubscriber<? super ? extends CompletableSource>Consumer<? super ? extends CompletableSource>? extends CompletableSource[]Iterable<? extends ? extends CompletableSource>Single<? extends CompletableSource>Maybe<? extends CompletableSource>BiFunction<R,? super ? extends CompletableSource,R>BiFunction<? extends CompletableSource,? extends CompletableSource,? extends CompletableSource>ConnectableFlowable<? extends CompletableSource>? super Flowable<? extends CompletableSource>Function<? super Flowable<? extends CompletableSource>,? extends Publisher<R>>Function<? super Flowable<? extends CompletableSource>,? extends Publisher<? extends R>>ParallelFlowable<? extends CompletableSource>Function<? super Throwable,? extends ? extends CompletableSource>? extends Publisher<? extends ? extends CompletableSource>Function<? super Throwable,? extends Publisher<? extends ? extends CompletableSource>>MaybeSource<? extends ? extends CompletableSource>SingleSource<? extends ? extends CompletableSource>Notification<? extends CompletableSource>Flowable<Notification<? extends CompletableSource>>Publisher<Notification<? extends CompletableSource>>Function<? super ? extends CompletableSource,? extends R>FlowableOperator<? extends R,? super ? extends CompletableSource>Function<? super ? extends CompletableSource,? extends Publisher<TLeftEnd>>BiFunction<? super ? extends CompletableSource,? super TRight,? extends R>BiFunction<? super ? extends CompletableSource,? super Flowable<TRight>,? extends R>GroupedFlowable<K,? extends CompletableSource>Flowable<GroupedFlowable<K,? extends CompletableSource>>Publisher<GroupedFlowable<K,? extends CompletableSource>>Function<? super ? extends CompletableSource,? extends Iterable<? extends U>>BiFunction<? super ? extends CompletableSource,? super U,? extends V>Function<? super ? extends CompletableSource,? extends Publisher<? extends U>>? super Notification<? extends CompletableSource>Consumer<? super Notification<? extends CompletableSource>>BiPredicate<? super ? extends CompletableSource,? super ? extends CompletableSource>Function<? super ? extends CompletableSource,K>Function<? super ? extends CompletableSource,Notification<R>>Function<? super ? extends CompletableSource,? extends Publisher<U>>FlowableTransformer<? super ? extends CompletableSource,? extends R>BiConsumer<? super U,? super ? extends CompletableSource>Flowable<List<? extends CompletableSource>>Publisher<List<? extends CompletableSource>>Future<? extends CompletableSource>Flowable<? extends CompletableSource>()Function<? extends CompletableSource,? extends CompletableSource>source"source is null"source is nullsource1source2"source1 is null"source1 is null"source2 is null"source2 is nullSingleObserver<? super T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/SingleObserver.classSingleObserversubscribe(io.reactivex.rxjava3.core.SingleObserver)SingleObserver<>Observable<R>ObservableSource<R>flattenStreamAsObservableflattenStreamAsObservable(io.reactivex.rxjava3.functions.Function)flattenStreamAsFlowableflattenStreamAsFlowable(io.reactivex.rxjava3.functions.Function)toCompletionStagetoCompletionStage()Maybe<R>MaybeSource<R>TestObserver<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/observers/TestObserver.classTestObserverObserver<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Observer.classObserverMaybeObserver<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeObserver.classMaybeObserverTestObserver<T>BaseTestConsumer<T,TestObserver<T>>Observer<T>MaybeObserver<T>SingleObserver<T>test(boolean)zipWith(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.BiFunction)toMaybetoMaybe()toFlowabletoFlowable()ignoreElementignoreElement()SingleConverter<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/SingleConverter.classSingleConverterto(io.reactivex.rxjava3.core.SingleConverter)SingleConverter<T,? extends R>timeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.SingleSource)timeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.SingleSource)takeUntil(io.reactivex.rxjava3.core.SingleSource)? extends ESingleSource<? extends E>Publisher<E>takeUntil(io.reactivex.rxjava3.core.CompletableSource)Single<Timed<T>>SingleSource<Timed<T>>subscribeWith(io.reactivex.rxjava3.core.SingleObserver)subscribeActual(io.reactivex.rxjava3.core.SingleObserver)BiConsumer<? super T,? super Throwable>subscribe(io.reactivex.rxjava3.functions.BiConsumer)startWith(io.reactivex.rxjava3.core.ObservableSource)safeSubscribe(io.reactivex.rxjava3.core.SingleObserver)? extends SingleSource<? extends T>Function<? super Throwable,? extends SingleSource<? extends T>>onErrorResumeWith(io.reactivex.rxjava3.core.SingleSource)Function<Throwable,? extends T>Maybe<U>MaybeSource<U>BiPredicate<Object,Object>contains(java.lang.Object,io.reactivex.rxjava3.functions.BiPredicate)Single<Notification<T>>SingleSource<Notification<T>>SingleOperator<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/SingleOperator.classSingleOperatorlift(io.reactivex.rxjava3.core.SingleOperator)SingleOperator<? extends R,? super T>blockingSubscribe(io.reactivex.rxjava3.core.SingleObserver)blockingGetblockingGet()flatMapObservableflatMapObservable(io.reactivex.rxjava3.functions.Function)ObservableSource<? extends R>? extends ObservableSource<? extends R>Function<? super T,? extends ObservableSource<? extends R>>Observable<U>ObservableSource<U>flattenAsObservableflattenAsObservable(io.reactivex.rxjava3.functions.Function)flattenAsFlowableflattenAsFlowable(io.reactivex.rxjava3.functions.Function)flatMapPublisherflatMapPublisher(io.reactivex.rxjava3.functions.Function)flatMap(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function)Function<? super Throwable,? extends SingleSource<? extends R>>SingleSource<? extends U>? extends SingleSource<? extends U>Function<? super T,? extends SingleSource<? extends U>>doOnDisposedoOnDispose(io.reactivex.rxjava3.functions.Action)doOnEventdoOnEvent(io.reactivex.rxjava3.functions.BiConsumer)doOnSuccessdoOnSuccess(io.reactivex.rxjava3.functions.Consumer)doOnLifecycle(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)doAfterSuccessdoAfterSuccess(io.reactivex.rxjava3.functions.Consumer)delaySubscription(io.reactivex.rxjava3.core.ObservableSource)delaySubscription(io.reactivex.rxjava3.core.SingleSource)delaySubscription(io.reactivex.rxjava3.core.CompletableSource)Class<? extends U>SingleTransformer<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/SingleTransformer.classSingleTransformercompose(io.reactivex.rxjava3.core.SingleTransformer)SingleTransformer<? super T,? extends R>ambWith(io.reactivex.rxjava3.core.SingleSource)SingleSource[]SingleSource<>[]zipArray(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.core.SingleSource[])SingleSource<? extends T>[]zip(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function9)SingleSource<? extends T1>SingleSource<? extends T2>SingleSource<? extends T3>SingleSource<? extends T4>SingleSource<? extends T5>SingleSource<? extends T6>SingleSource<? extends T7>SingleSource<? extends T8>SingleSource<? extends T9>zip(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function8)zip(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function7)zip(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function6)zip(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function5)zip(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function4)zip(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function3)zip(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.BiFunction)Iterable<? extends SingleSource<? extends T>>wrapwrap(io.reactivex.rxjava3.core.SingleSource)Function<? super U,? extends SingleSource<? extends T>>Consumer<? super U>unsafeCreate(io.reactivex.rxjava3.core.SingleSource)Publisher<? extends SingleSource<? extends T>>sequenceEqual(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)mergeDelayError(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)mergeDelayError(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)mergeDelayError(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)mergeArrayDelayError(io.reactivex.rxjava3.core.SingleSource[])mergeArray(io.reactivex.rxjava3.core.SingleSource[])merge(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)merge(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)merge(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)merge(io.reactivex.rxjava3.core.SingleSource)SingleSource<? extends SingleSource<? extends T>>fromObservable(io.reactivex.rxjava3.core.ObservableSource)ObservableSource<? extends T>fromMaybe(io.reactivex.rxjava3.core.MaybeSource,java.lang.Object)Supplier<? extends SingleSource<? extends T>>SingleOnSubscribe<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/SingleOnSubscribe.classSingleOnSubscribecreate(io.reactivex.rxjava3.core.SingleOnSubscribe)SingleOnSubscribe<T>concatEagerDelayError(org.reactivestreams.Publisher,int)concatEagerDelayError(java.lang.Iterable,int)concatEager(org.reactivestreams.Publisher,int)concatEager(java.lang.Iterable,int)concatDelayError(org.reactivestreams.Publisher,int)concatArrayEagerDelayError(io.reactivex.rxjava3.core.SingleSource[])concatArrayEager(io.reactivex.rxjava3.core.SingleSource[])concatArrayDelayError(io.reactivex.rxjava3.core.SingleSource[])concatArray(io.reactivex.rxjava3.core.SingleSource[])concat(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)concat(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)concat(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)concat(io.reactivex.rxjava3.core.ObservableSource)ObservableSource<? extends SingleSource<? extends T>>ambArray(io.reactivex.rxjava3.core.SingleSource[])Single()Single<>()onSubscribe"onSubscribe is null"onSubscribe is null"Use of unsafeCreate(Completable)!"Use of unsafeCreate(Completable)!Supplier<? extends CompletableSource>supplier"supplier is null"supplier is nullthrowable"throwable is null"throwable is nullaction"action is null"action is nullCallable<?>callable"callable is null"callable is nullFuture<?>future"future is null"future is nullmaybe"maybe is null"maybe is nullMaybeIgnoreElementCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeIgnoreElementCompletable.classMaybeIgnoreElementCompletableC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybeC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operatorsoperatorsC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internalinternalFuseToMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToMaybe.classFuseToMaybeC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseablefuseableMaybeIgnoreElementCompletable<T>(io.reactivex.rxjava3.core.MaybeSource)fuseToMaybefuseToMaybe()subscribeActual(io.reactivex.rxjava3.core.CompletableObserver)MaybeIgnoreElementCompletable(io.reactivex.rxjava3.core.MaybeSource)run"run is null"run is nullobservable"observable is null"observable is nullCompletableFromObservable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromObservable.classCompletableFromObservableC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completablecompletableCompletableFromObservable<T>(io.reactivex.rxjava3.core.ObservableSource)CompletableFromObservable(io.reactivex.rxjava3.core.ObservableSource)publisher"publisher is null"publisher is nullCompletableFromPublisher<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromPublisher.classCompletableFromPublisherCompletableFromPublisher<T>(org.reactivestreams.Publisher)CompletableFromPublisher(org.reactivestreams.Publisher)flowable"single is null"single is nullCompletableFromSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableFromSingle.classCompletableFromSingleCompletableFromSingle<T>(io.reactivex.rxjava3.core.SingleSource)CompletableFromSingle(io.reactivex.rxjava3.core.SingleSource)Supplier<?>falsemaxConcurrencydelayErrors"maxConcurrency"unitscheduler"unit is null"unit is null"scheduler is null"scheduler is nullexnpe"Actually not, but can't pass out an exception otherwise..."Actually not, but can't pass out an exception otherwise...FlowableSwitchMapCompletablePublisher<? extends CompletableSource>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableSwitchMapCompletablePublisher.classFlowableSwitchMapCompletablePublisherC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixedmixedFlowableSwitchMapCompletablePublisher<? extends CompletableSource>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean)FlowableSwitchMapCompletablePublisher(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean)mapperresourceSupplier? super RFunction<? super R,? extends CompletableSource>sourceSupplierConsumer<? super R>resourceCleanupeager"resourceSupplier is null"resourceSupplier is null"sourceSupplier is null"sourceSupplier is null"resourceCleanup is null"resourceCleanup is nullCompletableUsing<R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableUsing.classCompletableUsingCompletableUsing<R>(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)CompletableUsing(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)disposercompletableFunctionother"other is null"other is nullnext"next is null"next is nullCompletableAndThenObservable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/CompletableAndThenObservable.classCompletableAndThenObservableCompletableAndThenObservable<R>CompletableAndThenObservable<R>(io.reactivex.rxjava3.core.CompletableSource,io.reactivex.rxjava3.core.ObservableSource)Observer<? super T>subscribe(io.reactivex.rxjava3.core.Observer)Observer<? super R>Function<? super R,? extends Stream<? extends R>>Stream<R>BaseStream<R,Stream<R>>CompletionStage<R>Collector<? super R,A,R>Function<? super R,Optional<? extends R>>TestObserver<R>BaseTestConsumer<R,TestObserver<R>>Observer<R>MaybeObserver<R>SingleObserver<R>zipWith(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction,boolean,int)ObservableSource<? extends U>BiFunction<? super R,? super U,? extends R>zipWith(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction,boolean)zipWith(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction)ObservableSource<?>? extends ObservableSource<?>Iterable<? extends ObservableSource<?>>ObservableSource[]ObservableSource<>[]withLatestFrom(io.reactivex.rxjava3.core.ObservableSource[],io.reactivex.rxjava3.functions.Function)ObservableSource<?>[]withLatestFrom(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function5)ObservableSource<T1>ObservableSource<T2>ObservableSource<T3>ObservableSource<T4>Function5<? super R,? super T1,? super T2,? super T3,? super T4,R>withLatestFrom(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function4)Function4<? super R,? super T1,? super T2,? super T3,R>withLatestFrom(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function3)Function3<? super R,? super T1,? super T2,R>withLatestFrom(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction)Observable<Observable>ObservableSource<Observable>window(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int)ObservableSource<V>? extends ObservableSource<V>Function<? super U,? extends ObservableSource<V>>Observable<Observable<R>>ObservableSource<Observable<R>>window(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)window(io.reactivex.rxjava3.core.ObservableSource,int)ObservableSource<B>window(io.reactivex.rxjava3.core.ObservableSource)List<R>Collection<R>Iterable<R>Single<List<R>>SingleSource<List<R>>Comparator<? super R>toFlowable(io.reactivex.rxjava3.core.BackpressureStrategy)Function<? super R,? extends K>Function<? super R,? extends V>Map<K,Collection<R>>Single<Map<K,Collection<R>>>SingleSource<Map<K,Collection<R>>>Map<K,R>Single<Map<K,R>>SingleSource<Map<K,R>>ObservableConverter<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableConverter.classObservableConverterto(io.reactivex.rxjava3.core.ObservableConverter)ObservableConverter<T,? extends R>ObservableConverter<R,? extends R>Observable<Timed<T>>ObservableSource<Timed<T>>Timed<R>Observable<Timed<R>>ObservableSource<Timed<R>>timeout(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.core.ObservableSource)Function<? super T,? extends ObservableSource<V>>Function<? super R,? extends ObservableSource<V>>timeout(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)timeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.ObservableSource)timeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.ObservableSource)timeout(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.core.ObservableSource)Predicate<? super R>takeUntil(io.reactivex.rxjava3.core.ObservableSource)Function<? super R,? extends ObservableSource<? extends R>>Function<? super R,? extends SingleSource<? extends R>>Function<? super R,? extends MaybeSource<? extends R>>switchIfEmpty(io.reactivex.rxjava3.core.ObservableSource)subscribeWith(io.reactivex.rxjava3.core.Observer)subscribeActual(io.reactivex.rxjava3.core.Observer)R[]Iterable<? extends R>skipUntil(io.reactivex.rxjava3.core.ObservableSource)BiFunction<R,? super R,R>BiFunction<R,R,R>sample(io.reactivex.rxjava3.core.ObservableSource,boolean)sample(io.reactivex.rxjava3.core.ObservableSource)safeSubscribe(io.reactivex.rxjava3.core.Observer)Observable<Throwable>ObservableSource<Throwable>? super Observable<Throwable>Function<? super Observable<Throwable>,? extends ObservableSource<?>>io.reactivex.rxjava3.observablesConnectableObservable<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/observables/ConnectableObservable.classConnectableObservableC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/observablesobservablesConnectableObservable<T>ConnectableObservable<R>? super Observable? extends ObservableSource<R>Function<? super Observable,? extends ObservableSource<R>>? super Observable<R>Function<? super Observable<R>,? extends ObservableSource<R>>Observable<Object>ObservableSource<Object>? super Observable<Object>Function<? super Observable<Object>,? extends ObservableSource<?>>Function<? super Throwable,? extends R>onErrorResumeWith(io.reactivex.rxjava3.core.ObservableSource)? extends ObservableSource<? extends T>Function<? super Throwable,? extends ObservableSource<? extends T>>Function<? super Throwable,? extends ObservableSource<? extends R>>mergeWith(io.reactivex.rxjava3.core.ObservableSource)Observable<Notification<T>>ObservableSource<Notification<T>>Observable<Notification<R>>ObservableSource<Notification<R>>Function<? super R,? extends R>ObservableOperator<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableOperator.classObservableOperatorlift(io.reactivex.rxjava3.core.ObservableOperator)ObservableOperator<? extends R,? super T>ObservableOperator<? extends R,? super R>join(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)ObservableSource<? extends TRight>ObservableSource<TLeftEnd>? extends ObservableSource<TLeftEnd>Function<? super T,? extends ObservableSource<TLeftEnd>>ObservableSource<TRightEnd>? extends ObservableSource<TRightEnd>Function<? super TRight,? extends ObservableSource<TRightEnd>>Function<? super R,? extends ObservableSource<TLeftEnd>>BiFunction<? super R,? super TRight,? extends R>groupJoin(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)Observable<TRight>ObservableSource<TRight>? super Observable<TRight>BiFunction<? super T,? super Observable<TRight>,? extends R>BiFunction<? super R,? super Observable<TRight>,? extends R>GroupedObservable<K,V>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/observables/GroupedObservable.classGroupedObservableObservable<V>Observable<GroupedObservable<K,V>>ObservableSource<GroupedObservable<K,V>>GroupedObservable<K,T>Observable<GroupedObservable<K,T>>ObservableSource<GroupedObservable<K,T>>GroupedObservable<K,R>Observable<GroupedObservable<K,R>>ObservableSource<GroupedObservable<K,R>>flatMapSingle(io.reactivex.rxjava3.functions.Function,boolean)flatMapMaybe(io.reactivex.rxjava3.functions.Function,boolean)Function<? super R,? extends Iterable<? extends U>>BiFunction<? super R,? super U,? extends V>flatMapCompletable(io.reactivex.rxjava3.functions.Function,boolean)? extends ObservableSource<? extends U>Function<? super T,? extends ObservableSource<? extends U>>Function<? super R,? extends ObservableSource<? extends U>>Function<Throwable,? extends ObservableSource<? extends R>>Supplier<? extends ObservableSource<? extends R>>doOnEach(io.reactivex.rxjava3.core.Observer)? super Notification<R>Consumer<? super Notification<R>>BiPredicate<? super R,? super R>Function<? super R,K>Function<? super R,Notification<R>>delay(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)? extends ObservableSource<U>Function<? super T,? extends ObservableSource<U>>Function<? super R,? extends ObservableSource<U>>concatWith(io.reactivex.rxjava3.core.ObservableSource)ObservableTransformer<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableTransformer.classObservableTransformercompose(io.reactivex.rxjava3.core.ObservableTransformer)ObservableTransformer<? super T,? extends R>ObservableTransformer<? super R,? extends R>BiConsumer<? super U,? super R>buffer(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier)Observable<List<T>>ObservableSource<List<T>>buffer(io.reactivex.rxjava3.core.ObservableSource,int)Observable<List<R>>ObservableSource<List<R>>buffer(io.reactivex.rxjava3.core.ObservableSource)buffer(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)ObservableSource<? extends TOpening>ObservableSource<? extends TClosing>? extends ObservableSource<? extends TClosing>Function<? super TOpening,? extends ObservableSource<? extends TClosing>>buffer(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)blockingSubscribe(io.reactivex.rxjava3.core.Observer)Future<R>ambWith(io.reactivex.rxjava3.core.ObservableSource)zipArray(io.reactivex.rxjava3.functions.Function,boolean,int,io.reactivex.rxjava3.core.ObservableSource[])ObservableSource<? extends T>[]zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function9)ObservableSource<? extends T1>ObservableSource<? extends T2>ObservableSource<? extends T3>ObservableSource<? extends T4>ObservableSource<? extends T5>ObservableSource<? extends T6>ObservableSource<? extends T7>ObservableSource<? extends T8>ObservableSource<? extends T9>zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function8)zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function7)zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function6)zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function5)zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function4)zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function3)zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction,boolean,int)zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction,boolean)zip(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction)Iterable<? extends ObservableSource<? extends T>>wrap(io.reactivex.rxjava3.core.ObservableSource)Function<? super D,? extends ObservableSource<? extends T>>unsafeCreate(io.reactivex.rxjava3.core.ObservableSource)Observable<Long>ObservableSource<Long>switchOnNextDelayError(io.reactivex.rxjava3.core.ObservableSource,int)ObservableSource<? extends ObservableSource<? extends T>>switchOnNextDelayError(io.reactivex.rxjava3.core.ObservableSource)switchOnNext(io.reactivex.rxjava3.core.ObservableSource)switchOnNext(io.reactivex.rxjava3.core.ObservableSource,int)sequenceEqual(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,int)sequenceEqual(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiPredicate,int)sequenceEqual(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiPredicate)sequenceEqual(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)Observable<Integer>ObservableSource<Integer>mergeArrayDelayError(io.reactivex.rxjava3.core.ObservableSource[])mergeDelayError(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)mergeDelayError(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)mergeDelayError(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)mergeDelayError(io.reactivex.rxjava3.core.ObservableSource,int)mergeDelayError(io.reactivex.rxjava3.core.ObservableSource)mergeArrayDelayError(int,int,io.reactivex.rxjava3.core.ObservableSource[])mergeArray(io.reactivex.rxjava3.core.ObservableSource[])merge(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)merge(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)merge(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)merge(io.reactivex.rxjava3.core.ObservableSource,int)merge(io.reactivex.rxjava3.core.ObservableSource)mergeArray(int,int,io.reactivex.rxjava3.core.ObservableSource[])Supplier<? extends ObservableSource<? extends T>>ObservableOnSubscribe<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableOnSubscribe.classObservableOnSubscribecreate(io.reactivex.rxjava3.core.ObservableOnSubscribe)ObservableOnSubscribe<T>concatEagerDelayError(io.reactivex.rxjava3.core.ObservableSource,int,int)concatEagerDelayError(io.reactivex.rxjava3.core.ObservableSource)concatEager(io.reactivex.rxjava3.core.ObservableSource,int,int)concatEager(io.reactivex.rxjava3.core.ObservableSource)concatDelayError(io.reactivex.rxjava3.core.ObservableSource,int,boolean)concatDelayError(io.reactivex.rxjava3.core.ObservableSource)concatArrayEagerDelayError(int,int,io.reactivex.rxjava3.core.ObservableSource[])concatArrayEagerDelayError(io.reactivex.rxjava3.core.ObservableSource[])concatArrayEager(int,int,io.reactivex.rxjava3.core.ObservableSource[])concatArrayEager(io.reactivex.rxjava3.core.ObservableSource[])concatArrayDelayError(io.reactivex.rxjava3.core.ObservableSource[])concatArray(io.reactivex.rxjava3.core.ObservableSource[])concat(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)concat(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)concat(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)concat(io.reactivex.rxjava3.core.ObservableSource,int)combineLatestArrayDelayError(io.reactivex.rxjava3.core.ObservableSource[],io.reactivex.rxjava3.functions.Function,int)combineLatestArrayDelayError(io.reactivex.rxjava3.core.ObservableSource[],io.reactivex.rxjava3.functions.Function)combineLatest(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function9)combineLatest(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function8)combineLatest(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function7)combineLatest(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function6)combineLatest(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function5)combineLatest(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function4)combineLatest(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function3)combineLatest(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction)combineLatestArray(io.reactivex.rxjava3.core.ObservableSource[],io.reactivex.rxjava3.functions.Function,int)combineLatestArray(io.reactivex.rxjava3.core.ObservableSource[],io.reactivex.rxjava3.functions.Function)ambArray(io.reactivex.rxjava3.core.ObservableSource[])Observable()Observable<R>()CompletableAndThenObservable(io.reactivex.rxjava3.core.CompletableSource,io.reactivex.rxjava3.core.ObservableSource)CompletableAndThenPublisher<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/CompletableAndThenPublisher.classCompletableAndThenPublisherCompletableAndThenPublisher<R>CompletableAndThenPublisher<R>(io.reactivex.rxjava3.core.CompletableSource,org.reactivestreams.Publisher)Subscriber<? super R>TestSubscriber<R>BaseTestConsumer<R,TestSubscriber<R>>FlowableSubscriber<R>Subscriber<R>Flowable<Flowable<R>>Publisher<Flowable<R>>FlowableConverter<R,? extends R>Flowable<Timed<R>>Publisher<Timed<R>>Function<? super R,? extends Publisher<V>>Function<? super R,? extends Publisher<? extends R>>FlowableSubscriber<? super R>ConnectableFlowable<R>? super Flowable<R>Function<? super Flowable<R>,? extends Publisher<R>>Function<? super Flowable<R>,? extends Publisher<? extends R>>ParallelFlowable<R>Flowable<Notification<R>>Publisher<Notification<R>>FlowableOperator<? extends R,? super R>Function<? super R,? extends Publisher<TLeftEnd>>BiFunction<? super R,? super Flowable<TRight>,? extends R>GroupedFlowable<K,R>Flowable<GroupedFlowable<K,R>>Publisher<GroupedFlowable<K,R>>Function<? super R,? extends Publisher<? extends U>>Function<? super R,? extends Publisher<U>>FlowableTransformer<? super R,? extends R>Flowable<List<R>>Publisher<List<R>>Flowable<R>()CompletableAndThenPublisher(io.reactivex.rxjava3.core.CompletableSource,org.reactivestreams.Publisher)SingleDelayWithCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDelayWithCompletable.classSingleDelayWithCompletableC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/singleSingleDelayWithCompletable<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.CompletableSource)Single<T>()SingleDelayWithCompletable(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.CompletableSource)MaybeDelayWithCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDelayWithCompletable.classMaybeDelayWithCompletableMaybeDelayWithCompletable<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.CompletableSource)MaybeObserver<? super T>subscribe(io.reactivex.rxjava3.core.MaybeObserver)toCompletionStage(java.lang.Object)zipWith(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.BiFunction)MaybeSource<? extends U>timeout(org.reactivestreams.Publisher,io.reactivex.rxjava3.core.MaybeSource)timeout(org.reactivestreams.Publisher)timeout(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)timeout(io.reactivex.rxjava3.core.MaybeSource)timeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.MaybeSource)timeout(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.MaybeSource)Maybe<Timed<T>>MaybeSource<Timed<T>>takeUntil(io.reactivex.rxjava3.core.MaybeSource)switchIfEmpty(io.reactivex.rxjava3.core.SingleSource)switchIfEmpty(io.reactivex.rxjava3.core.MaybeSource)subscribeWith(io.reactivex.rxjava3.core.MaybeObserver)subscribeActual(io.reactivex.rxjava3.core.MaybeObserver)safeSubscribe(io.reactivex.rxjava3.core.MaybeObserver)? extends MaybeSource<? extends T>Function<? super Throwable,? extends MaybeSource<? extends T>>onErrorResumeWith(io.reactivex.rxjava3.core.MaybeSource)toSingletoSingle()MaybeConverter<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeConverter.classMaybeConverterto(io.reactivex.rxjava3.core.MaybeConverter)MaybeConverter<T,? extends R>MaybeOperator<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeOperator.classMaybeOperatorlift(io.reactivex.rxjava3.core.MaybeOperator)MaybeOperator<? extends R,? super T>? extends MaybeSource<? extends U>Function<? super T,? extends MaybeSource<? extends U>>Function<? super Throwable,? extends MaybeSource<? extends R>>Supplier<? extends MaybeSource<? extends R>>delay(org.reactivestreams.Publisher)MaybeTransformer<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeTransformer.classMaybeTransformercompose(io.reactivex.rxjava3.core.MaybeTransformer)MaybeTransformer<? super T,? extends R>blockingSubscribe(io.reactivex.rxjava3.core.MaybeObserver)blockingGet(java.lang.Object)ambWith(io.reactivex.rxjava3.core.MaybeSource)MaybeSource[]MaybeSource<>[]zipArray(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.core.MaybeSource[])MaybeSource<? extends T>[]zip(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function9)MaybeSource<? extends T1>MaybeSource<? extends T2>MaybeSource<? extends T3>MaybeSource<? extends T4>MaybeSource<? extends T5>MaybeSource<? extends T6>MaybeSource<? extends T7>MaybeSource<? extends T8>MaybeSource<? extends T9>zip(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function8)zip(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function7)zip(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function6)zip(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function5)zip(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function4)zip(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function3)zip(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.BiFunction)Iterable<? extends MaybeSource<? extends T>>wrap(io.reactivex.rxjava3.core.MaybeSource)Function<? super D,? extends MaybeSource<? extends T>>unsafeCreate(io.reactivex.rxjava3.core.MaybeSource)Maybe<Long>MaybeSource<Long>Publisher<? extends MaybeSource<? extends T>>sequenceEqual(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.BiPredicate)sequenceEqual(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)mergeDelayError(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)mergeDelayError(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)mergeDelayError(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)mergeArrayDelayError(io.reactivex.rxjava3.core.MaybeSource[])mergeArray(io.reactivex.rxjava3.core.MaybeSource[])merge(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)merge(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)merge(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)merge(io.reactivex.rxjava3.core.MaybeSource)MaybeSource<? extends MaybeSource<? extends T>>Supplier<? extends MaybeSource<? extends T>>MaybeOnSubscribe<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeOnSubscribe.classMaybeOnSubscribecreate(io.reactivex.rxjava3.core.MaybeOnSubscribe)MaybeOnSubscribe<T>concatArrayEagerDelayError(io.reactivex.rxjava3.core.MaybeSource[])concatArrayEager(io.reactivex.rxjava3.core.MaybeSource[])concatArrayDelayError(io.reactivex.rxjava3.core.MaybeSource[])concatArray(io.reactivex.rxjava3.core.MaybeSource[])concat(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)concat(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)concat(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)ambArray(io.reactivex.rxjava3.core.MaybeSource[])Maybe()Maybe<T>()MaybeDelayWithCompletable(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.CompletableSource)BlockingMultiObserver<Void>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/BlockingMultiObserver.classBlockingMultiObserverC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observersSingleObserver<Void>MaybeObserver<Void>observerBlockingMultiObserver<Void>()onErroronError(java.lang.Throwable)onSuccessonSuccess(java.lang.Object)onSuccess(java.lang.Void)onSubscribe(io.reactivex.rxjava3.disposables.Disposable)onCompleteonComplete()blockingConsumeblockingConsume(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)? super VoidConsumer<? super Void>blockingAwaitblockingAwait(long,java.util.concurrent.TimeUnit)blockingGet(java.lang.Void)disposedispose()BlockingMultiObserver()cancelledvolatileupstreamvalueConsumer<Throwable>"onComplete is null"onComplete is null"onError is null"onError is nullConsumer<Void>BlockingDisposableMultiObserver<Void>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/BlockingDisposableMultiObserver.classBlockingDisposableMultiObserverblockingObserverBlockingDisposableMultiObserver<Void>()blockingConsume(io.reactivex.rxjava3.core.MaybeObserver)MaybeObserver<? super Void>blockingConsume(io.reactivex.rxjava3.core.SingleObserver)SingleObserver<? super Void>blockingConsume(io.reactivex.rxjava3.core.CompletableObserver)isDisposedisDisposed()BlockingDisposableMultiObserver()"observer is null"observer is nulltransformer"transformer is null"transformer is nulltimedelayErrorConsumer<Disposable>onDisposeonEvent"onEvent is null"onEvent is nullonTerminateonAfterTerminate"onTerminate is null"onTerminate is null"onAfterTerminate is null"onAfterTerminate is null"onDispose is null"onDispose is nullonFinally"onFinally is null"onFinally is nullonLift"onLift is null"onLift is nullCompletableMaterialize<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableMaterialize.classCompletableMaterializeCompletableMaterialize<T>(io.reactivex.rxjava3.core.Completable)SingleObserver<? super Notification<T>>Function<? super Notification<T>,? extends Stream<? extends R>>CompletionStage<Notification<T>>Function<? super Notification<T>,Optional<? extends R>>TestObserver<Notification<T>>BaseTestConsumer<Notification<T>,TestObserver<Notification<T>>>Observer<Notification<T>>MaybeObserver<Notification<T>>SingleObserver<Notification<T>>BiFunction<? super Notification<T>,? super U,? extends R>Maybe<Notification<T>>MaybeSource<Notification<T>>Future<Notification<T>>SingleConverter<Notification<T>,? extends R>? extends Notification<T>SingleSource<? extends Notification<T>>Timed<Notification<T>>Single<Timed<Notification<T>>>SingleSource<Timed<Notification<T>>>BiConsumer<? super Notification<T>,? super Throwable>? extends SingleSource<? extends Notification<T>>Function<? super Throwable,? extends SingleSource<? extends Notification<T>>>onErrorReturnItem(io.reactivex.rxjava3.core.Notification)Function<Throwable,? extends Notification<T>>Notification<Notification<T>>Single<Notification<Notification<T>>>SingleSource<Notification<Notification<T>>>Function<? super Notification<T>,? extends R>SingleOperator<? extends R,? super Notification<T>>Notification<>Function<? super Notification<T>,? extends CompletableSource>Function<? super Notification<T>,? extends ObservableSource<? extends R>>Function<? super Notification<T>,? extends Iterable<? extends U>>Function<? super Notification<T>,? extends Publisher<? extends R>>Function<? super Notification<T>,? extends MaybeSource<? extends R>>Function<? super Notification<T>,? extends SingleSource<? extends R>>Function<? super Notification<T>,? extends SingleSource<? extends U>>Predicate<? super Notification<T>>Function<? super Notification<T>,Notification<R>>SingleTransformer<? super Notification<T>,? extends R>Single<Notification<T>>()CompletableMaterialize(io.reactivex.rxjava3.core.Completable)Predicate<Throwable>predicate"predicate is null"predicate is nullfallbackSupplier"fallbackSupplier is null"fallbackSupplier is nullfallback"fallback is null"fallback is nullFunction<Throwable,CompletableSource>itemSupplier"itemSupplier is null"itemSupplier is nullCompletableOnErrorReturn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableOnErrorReturn.classCompletableOnErrorReturnCompletableOnErrorReturn<T>(io.reactivex.rxjava3.core.CompletableSource,io.reactivex.rxjava3.functions.Function)CompletableOnErrorReturn(io.reactivex.rxjava3.core.CompletableSource,io.reactivex.rxjava3.functions.Function)valueSupplieritem"item is null"item is nullFunction<Throwable,T>? super ObjectSubscriber<? super Object>Function<? super Object,? extends Stream<? extends R>>Stream<Object>BaseStream<Object,Stream<Object>>CompletionStage<Object>Collector<? super Object,A,R>Function<? super Object,Optional<? extends R>>TestSubscriber<Object>BaseTestConsumer<Object,TestSubscriber<Object>>FlowableSubscriber<Object>Subscriber<Object>BiFunction<? super Object,? super U,? extends R>Function5<? super Object,? super T1,? super T2,? super T3,? super T4,R>Function4<? super Object,? super T1,? super T2,? super T3,R>Function3<? super Object,? super T1,? super T2,R>Flowable<Flowable<Object>>Publisher<Flowable<Object>>List<Object>Collection<Object>Iterable<Object>Single<List<Object>>SingleSource<List<Object>>Comparator<? super Object>Function<? super Object,? extends K>Function<? super Object,? extends V>Map<K,Collection<Object>>Single<Map<K,Collection<Object>>>SingleSource<Map<K,Collection<Object>>>Single<Map<K,Object>>SingleSource<Map<K,Object>>FlowableConverter<Object,? extends R>Timed<Object>Flowable<Timed<Object>>Publisher<Timed<Object>>Function<? super Object,? extends Publisher<V>>? extends ObjectPublisher<? extends Object>Predicate<? super Object>Function<? super Object,? extends SingleSource<? extends R>>Function<? super Object,? extends MaybeSource<? extends R>>Function<? super Object,? extends Publisher<? extends R>>Function<? super Object,? extends CompletableSource>FlowableSubscriber<? super Object>Consumer<? super Object>MaybeSource<Object>SingleSource<Object>Iterable<? extends Object>Single<Object>Maybe<Object>BiFunction<R,? super Object,R>BiFunction<Object,Object,Object>ConnectableFlowable<Object>Function<? super Flowable<Object>,? extends Publisher<R>>Function<? super Flowable<Object>,? extends Publisher<? extends R>>ParallelFlowable<Object>Function<? super Throwable,? extends Object>? extends Publisher<? extends Object>Function<? super Throwable,? extends Publisher<? extends Object>>MaybeSource<? extends Object>SingleSource<? extends Object>Notification<Object>Flowable<Notification<Object>>Publisher<Notification<Object>>Function<? super Object,? extends R>FlowableOperator<? extends R,? super Object>Function<? super Object,? extends Publisher<TLeftEnd>>BiFunction<? super Object,? super TRight,? extends R>BiFunction<? super Object,? super Flowable<TRight>,? extends R>GroupedFlowable<K,Object>Flowable<GroupedFlowable<K,Object>>Publisher<GroupedFlowable<K,Object>>Function<? super Object,? extends Iterable<? extends U>>BiFunction<? super Object,? super U,? extends V>Function<? super Object,? extends Publisher<? extends U>>? super Notification<Object>Consumer<? super Notification<Object>>BiPredicate<? super Object,? super Object>Function<? super Object,K>Function<? super Object,Notification<R>>Function<? super Object,? extends Publisher<U>>FlowableTransformer<? super Object,? extends R>BiConsumer<? super U,? super Object>Flowable<List<Object>>Publisher<List<Object>>Future<Object>Flowable<Object>()timesstophandler"stop is null"stop is nullMaybe<>()Observable<Observable<T>>ObservableSource<Observable<T>>? super Observable<T>Function<? super Observable<T>,? extends ObservableSource<R>>Observable<T>()Observable<>()Flowable<Flowable<T>>Publisher<Flowable<T>>? super Flowable<T>Function<? super Flowable<T>,? extends Publisher<R>>Function<? super Flowable<T>,? extends Publisher<? extends R>>Flowable<T>()"The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/PluginsCompletableConverter<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/CompletableConverter.classCompletableConverterCompletableConverter<? extends R>converterapplyapply(io.reactivex.rxjava3.core.Completable)"converter is null"converter is nullString[]"unchecked"uncheckedFuseToFlowable<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToFlowable.classFuseToFlowableFuseToFlowable<T>fuseToFlowablefuseToFlowable()CompletableToFlowable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToFlowable.classCompletableToFlowableCompletableToFlowable<T>(io.reactivex.rxjava3.core.CompletableSource)CompletableToFlowable(io.reactivex.rxjava3.core.CompletableSource)Future<Void>FutureMultiObserver<Void>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/FutureMultiObserver.classFutureMultiObserverFutureMultiObserver<T>FutureMultiObserver<T>()getget(long,java.util.concurrent.TimeUnit)get()isDoneisDone()isCancelledisCancelled()cancelcancel(boolean)FutureMultiObserver()java.util.concurrent.atomicAtomicReference<Disposable>C:/modules/java.base/java/util/concurrent/atomic/AtomicReference.classAtomicReferenceC:/modules/java.base/java/util/concurrent/atomicatomicFuseToMaybe<>MaybeFromCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromCompletable.classMaybeFromCompletableMaybeFromCompletable<T>(io.reactivex.rxjava3.core.CompletableSource)source()MaybeFromCompletable(io.reactivex.rxjava3.core.CompletableSource)FuseToObservable<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseable/FuseToObservable.classFuseToObservableFuseToObservable<T>fuseToObservablefuseToObservable()CompletableToObservable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToObservable.classCompletableToObservableCompletableToObservable<T>(io.reactivex.rxjava3.core.CompletableSource)CompletableToObservable(io.reactivex.rxjava3.core.CompletableSource)completionValueSupplier"completionValueSupplier is null"completionValueSupplier is nullCompletableToSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/completable/CompletableToSingle.classCompletableToSingleCompletableToSingle<T>(io.reactivex.rxjava3.core.CompletableSource,io.reactivex.rxjava3.functions.Supplier,java.lang.Object)CompletableToSingle(io.reactivex.rxjava3.core.CompletableSource,io.reactivex.rxjava3.functions.Supplier,java.lang.Object)completionValue"completionValue is null"completionValue is nullTestObserver<Void>BaseTestConsumer<Void,TestObserver<Void>>Observer<Void>TestObserver<Void>()awaitCountawaitCount(int)withTagwithTag(java.lang.CharSequence)assertEmptyassertEmpty()awaitDoneawaitDone(long,java.util.concurrent.TimeUnit)Class<? extends Throwable>assertFailureassertFailure(java.lang.Class,java.lang.Object[])Void[]assertFailure(java.lang.Class,java.lang.Void[])assertResultassertResult(java.lang.Object[])assertResult(java.lang.Void[])assertSubscribedassertSubscribed()assertValueSequenceassertValueSequence(java.lang.Iterable)? extends VoidIterable<? extends Void>assertValuesOnlyassertValuesOnly(java.lang.Object[])assertValuesOnly(java.lang.Void[])assertValuesassertValues(java.lang.Object[])assertValues(java.lang.Void[])assertNoValuesassertNoValues()assertValueCountassertValueCount(int)valueAndClassvalueAndClass(java.lang.Object)Predicate<T>assertValueAtassertValueAt(int,io.reactivex.rxjava3.functions.Predicate)Predicate<Void>assertValueAt(int,java.lang.Object)assertValueAt(int,java.lang.Void)assertValueassertValue(io.reactivex.rxjava3.functions.Predicate)assertValue(java.lang.Object)assertValue(java.lang.Void)assertErrorassertError(io.reactivex.rxjava3.functions.Predicate)assertError(java.lang.Class)assertError(java.lang.Throwable)assertNoErrorsassertNoErrors()assertNotCompleteassertNotComplete()assertCompleteassertComplete()awaitawait(long,java.util.concurrent.TimeUnit)await()failfail(java.lang.String)List<>Collection<>valuesvalues()List<Void>Collection<Void>Iterable<Void>BaseTestConsumer()BaseTestConsumer<Void,TestObserver<Void>>()tagcheckSubscriptionOncelastThreadcompletionsList<Throwable>Collection<Throwable>Iterable<Throwable>errorsdoneonNextonNext(java.lang.Object)onNext(java.lang.Void)hasSubscriptionhasSubscription()TestObserver(io.reactivex.rxjava3.core.Observer)Observer<? super Void>TestObserver<Void>(io.reactivex.rxjava3.core.Observer)TestObserver()create(io.reactivex.rxjava3.core.Observer)create()CompletionStage<?>stage"stage is null"stage is nullCompletableFromCompletionStage<?>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/CompletableFromCompletionStage.classCompletableFromCompletionStageC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8jdk8CompletableFromCompletionStage<?>(java.util.concurrent.CompletionStage)CompletableFromCompletionStage(java.util.concurrent.CompletionStage)defaultItemCompletionStageConsumer<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/CompletionStageConsumer.classCompletionStageConsumerCompletableFuture<T>C:/modules/java.base/java/util/concurrent/CompletableFuture.classCompletableFutureCompletionStageConsumer<T>(boolean,java.lang.Object)CompletableFuture<>toCompletableFuturetoCompletableFuture()? extends CompletionStagejava.util.functionFunction<Throwable,? extends CompletionStage>C:/modules/java.base/java/util/function/Function.classC:/modules/java.base/java/util/functionfunctionexceptionallyComposeAsyncexceptionallyComposeAsync(java.util.function.Function,java.util.concurrent.Executor)default? extends CompletionStage<T>Function<Throwable,? extends CompletionStage<T>>exceptionallyComposeAsync(java.util.function.Function)exceptionallyComposeexceptionallyCompose(java.util.function.Function)exceptionallyAsyncexceptionallyAsync(java.util.function.Function,java.util.concurrent.Executor)exceptionallyAsync(java.util.function.Function)exceptionallyexceptionally(java.util.function.Function)C:/modules/java.base/java/util/function/BiConsumer.classwhenCompleteAsyncwhenCompleteAsync(java.util.function.BiConsumer,java.util.concurrent.Executor)whenCompleteAsync(java.util.function.BiConsumer)whenCompletewhenComplete(java.util.function.BiConsumer)C:/modules/java.base/java/util/function/BiFunction.classCompletionStage<U>handleAsynchandleAsync(java.util.function.BiFunction,java.util.concurrent.Executor)BiFunction<? super T,Throwable,? extends U>handleAsync(java.util.function.BiFunction)handlehandle(java.util.function.BiFunction)thenComposeAsyncthenComposeAsync(java.util.function.Function,java.util.concurrent.Executor)? extends CompletionStage<U>Function<? super T,? extends CompletionStage<U>>thenComposeAsync(java.util.function.Function)thenComposethenCompose(java.util.function.Function)CompletionStage<Void>runAfterEitherAsyncrunAfterEitherAsync(java.util.concurrent.CompletionStage,java.lang.Runnable,java.util.concurrent.Executor)runAfterEitherAsync(java.util.concurrent.CompletionStage,java.lang.Runnable)runAfterEitherrunAfterEither(java.util.concurrent.CompletionStage,java.lang.Runnable)CompletionStage<? extends T>C:/modules/java.base/java/util/function/Consumer.classacceptEitherAsyncacceptEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Consumer,java.util.concurrent.Executor)acceptEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Consumer)acceptEitheracceptEither(java.util.concurrent.CompletionStage,java.util.function.Consumer)applyToEitherAsyncapplyToEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Function,java.util.concurrent.Executor)Function<? super T,U>applyToEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Function)applyToEitherapplyToEither(java.util.concurrent.CompletionStage,java.util.function.Function)runAfterBothAsyncrunAfterBothAsync(java.util.concurrent.CompletionStage,java.lang.Runnable,java.util.concurrent.Executor)runAfterBothAsync(java.util.concurrent.CompletionStage,java.lang.Runnable)runAfterBothrunAfterBoth(java.util.concurrent.CompletionStage,java.lang.Runnable)thenAcceptBothAsyncthenAcceptBothAsync(java.util.concurrent.CompletionStage,java.util.function.BiConsumer,java.util.concurrent.Executor)CompletionStage<? extends U>BiConsumer<? super T,? super U>thenAcceptBothAsync(java.util.concurrent.CompletionStage,java.util.function.BiConsumer)thenAcceptBoththenAcceptBoth(java.util.concurrent.CompletionStage,java.util.function.BiConsumer)CompletionStage<V>thenCombineAsyncthenCombineAsync(java.util.concurrent.CompletionStage,java.util.function.BiFunction,java.util.concurrent.Executor)thenCombineAsync(java.util.concurrent.CompletionStage,java.util.function.BiFunction)thenCombinethenCombine(java.util.concurrent.CompletionStage,java.util.function.BiFunction)thenRunAsyncthenRunAsync(java.lang.Runnable,java.util.concurrent.Executor)thenRunAsync(java.lang.Runnable)thenRunthenRun(java.lang.Runnable)thenAcceptAsyncthenAcceptAsync(java.util.function.Consumer,java.util.concurrent.Executor)thenAcceptAsync(java.util.function.Consumer)thenAcceptthenAccept(java.util.function.Consumer)thenApplyAsyncthenApplyAsync(java.util.function.Function,java.util.concurrent.Executor)Function<? super T,? extends U>thenApplyAsync(java.util.function.Function)thenApplythenApply(java.util.function.Function)failedStagefailedStage(java.lang.Throwable)CompletableFuture<U>Future<U>failedFuturefailedFuture(java.lang.Throwable)completedStagecompletedStage(java.lang.Object)delayedExecutordelayedExecutor(long,java.util.concurrent.TimeUnit)delayedExecutor(long,java.util.concurrent.TimeUnit,java.util.concurrent.Executor)completeOnTimeoutcompleteOnTimeout(java.lang.Object,long,java.util.concurrent.TimeUnit)orTimeoutorTimeout(long,java.util.concurrent.TimeUnit)C:/modules/java.base/java/util/function/Supplier.classcompleteAsynccompleteAsync(java.util.function.Supplier)completeAsync(java.util.function.Supplier,java.util.concurrent.Executor)minimalCompletionStageminimalCompletionStage()copycopy()defaultExecutordefaultExecutor()newIncompleteFuturenewIncompleteFuture()toStringtoString()getNumberOfDependentsgetNumberOfDependents()obtrudeExceptionobtrudeException(java.lang.Throwable)obtrudeValueobtrudeValue(java.lang.Object)isCompletedExceptionallyisCompletedExceptionally()CompletableFuture[]CompletableFuture<?>CompletableFuture<?>[]CompletableFuture<Object>anyOfanyOf(java.util.concurrent.CompletableFuture[])CompletableFuture<Void>allOfallOf(java.util.concurrent.CompletableFuture[])CompletableFuture<V>Future<V>completeExceptionallycompleteExceptionally(java.lang.Throwable)completecomplete(java.lang.Object)getNowgetNow(java.lang.Object)join()completedFuturecompletedFuture(java.lang.Object)runAsyncrunAsync(java.lang.Runnable,java.util.concurrent.Executor)runAsync(java.lang.Runnable)supplyAsyncsupplyAsync(java.util.function.Supplier,java.util.concurrent.Executor)supplyAsync(java.util.function.Supplier)CompletableFuture(java.lang.Object)CompletableFuture<T>(java.lang.Object)CompletableFuture()CompletableFuture<T>()asyncRunStageasyncRunStage(java.util.concurrent.Executor,java.lang.Runnable)asyncSupplyStageasyncSupplyStage(java.util.concurrent.Executor,java.util.function.Supplier)BiCompletion<?,?,?>C:/modules/java.base/java/util/concurrent/CompletableFuture$BiCompletion.classCompletableFuture$BiCompletionUniCompletion<?,?>C:/modules/java.base/java/util/concurrent/CompletableFuture$UniCompletion.classCompletableFuture$UniCompletionorpushorpush(java.util.concurrent.CompletableFuture,java.util.concurrent.CompletableFuture.BiCompletion)andTreeandTree(java.util.concurrent.CompletableFuture[],int,int)BiRun<?,?>C:/modules/java.base/java/util/concurrent/CompletableFuture$BiRun.classCompletableFuture$BiRunBiCompletion<?,?,Void>UniCompletion<?,Void>biRunbiRun(java.lang.Object,java.lang.Object,java.lang.Runnable,java.util.concurrent.CompletableFuture.BiRun)BiAccept<>C:/modules/java.base/java/util/concurrent/CompletableFuture$BiAccept.classCompletableFuture$BiAcceptBiCompletion<>UniCompletion<>biAcceptbiAccept(java.lang.Object,java.lang.Object,java.util.function.BiConsumer,java.util.concurrent.CompletableFuture.BiAccept)BiConsumer<? super R,? super S>BiAccept<R,S>BiCompletion<R,S,Void>UniCompletion<R,Void>BiApply<>C:/modules/java.base/java/util/concurrent/CompletableFuture$BiApply.classCompletableFuture$BiApplybiApplybiApply(java.lang.Object,java.lang.Object,java.util.function.BiFunction,java.util.concurrent.CompletableFuture.BiApply)BiFunction<? super R,? super S,? extends T>BiApply<R,S,T>BiCompletion<R,S,T>UniCompletion<R,T>postFirepostFire(java.util.concurrent.CompletableFuture,java.util.concurrent.CompletableFuture,int)bipushbipush(java.util.concurrent.CompletableFuture,java.util.concurrent.CompletableFuture.BiCompletion)UniExceptionally<T>C:/modules/java.base/java/util/concurrent/CompletableFuture$UniExceptionally.classCompletableFuture$UniExceptionallyUniCompletion<T,T>uniExceptionallyuniExceptionally(java.lang.Object,java.util.function.Function,java.util.concurrent.CompletableFuture.UniExceptionally)UniHandle<>C:/modules/java.base/java/util/concurrent/CompletableFuture$UniHandle.classCompletableFuture$UniHandleuniHandleuniHandle(java.lang.Object,java.util.function.BiFunction,java.util.concurrent.CompletableFuture.UniHandle)BiFunction<? super S,Throwable,? extends T>UniHandle<S,T>UniCompletion<S,T>UniWhenComplete<T>C:/modules/java.base/java/util/concurrent/CompletableFuture$UniWhenComplete.classCompletableFuture$UniWhenCompleteuniWhenCompleteuniWhenComplete(java.lang.Object,java.util.function.BiConsumer,java.util.concurrent.CompletableFuture.UniWhenComplete)postFire(java.util.concurrent.CompletableFuture,int)unipushunipush(java.util.concurrent.CompletableFuture.Completion)cleanStackcleanStack()postCompletepostComplete()screenExecutorscreenExecutor(java.util.concurrent.Executor)completeRelaycompleteRelay(java.lang.Object)encodeRelayencodeRelay(java.lang.Object)encodeOutcomeencodeOutcome(java.lang.Object,java.lang.Throwable)completeThrowablecompleteThrowable(java.lang.Throwable,java.lang.Object)encodeThrowableencodeThrowable(java.lang.Throwable,java.lang.Object)completeThrowable(java.lang.Throwable)encodeThrowable(java.lang.Throwable)completeValuecompleteValue(java.lang.Object)encodeValueencodeValue(java.lang.Object)completeNullcompleteNull()pushStackpushStack(java.util.concurrent.CompletableFuture.Completion)tryPushStacktryPushStack(java.util.concurrent.CompletableFuture.Completion)internalCompleteinternalComplete(java.lang.Object)NESTEDASYNCSYNCNILstackresultclearclear()cancelUpstreamcancelUpstream()CompletionStageConsumer(boolean,java.lang.Object)hasDefaultThe {@code Completable} class represents a deferred computation without any value butonly indication for completion or exception.{@code Completable} behaves similarly to {@link Observable} except that it can only emit eithera completion or error signal (there is no {@code onNext} or {@code onSuccess} as with the otherreactive types).The {@code Completable} class implements the {@link CompletableSource} base interface and the default consumertype it interacts with is the {@link CompletableObserver} via the {@link #subscribe(CompletableObserver)} method.The {@code Completable} operates with the following sequential protocol:<pre><code>onSubscribe (onError | onComplete)?</code></pre>Note that as with the {@code Observable} protocol, {@code onError} and {@code onComplete} are mutually exclusive events.Like {@code Observable}, a running {@code Completable} can be stopped through the {@link Disposable} instanceprovided to consumers through {@link SingleObserver#onSubscribe}.Like an {@code Observable}, a {@code Completable} is lazy, can be either "hot" or "cold", synchronous orasynchronous. {@code Completable} instances returned by the methods of this class are <em>cold</em>and there is a standard <em>hot</em> implementation in the form of a subject:{@link io.reactivex.rxjava3.subjects.CompletableSubject CompletableSubject}.The documentation for this class makes use of marble diagrams. The following legend explains these diagrams:<img width="640" height="577" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.png" alt="">See {@link Flowable} or {@code Observable} for theimplementation of the Reactive Pattern for a stream or vector of values.Example:Disposable d = Completable.complete().delay(10, TimeUnit.SECONDS, Schedulers.io()).subscribeWith(new DisposableCompletableObserver() {&#64;Overridepublic void onStart() {System.out.println("Started");}public void onError(Throwable error) {error.printStackTrace();public void onComplete() {System.out.println("Done!");});Thread.sleep(5000);d.dispose();Note that by design, subscriptions via {@link #subscribe(CompletableObserver)} can't be disposedfrom the outside (hence the{@code void} return of the {@link #subscribe(CompletableObserver)} method) and it is theresponsibility of the implementor of the {@code CompletableObserver} to allow this to happen.RxJava supports such usage with the standard{@link io.reactivex.rxjava3.observers.DisposableCompletableObserver DisposableCompletableObserver} instance.For convenience, the {@link #subscribeWith(CompletableObserver)} method is provided as well toallow working with a {@code CompletableObserver} (or subclass) instance to be applied with ina fluent manner (such as in the example above).@seeio.reactivex.rxjava3.observers.DisposableCompletableObserverReturns a {@code Completable} which terminates as soon as one of the source {@code Completable}sterminates (normally or with an error) and disposes all other {@code Completable}s.<img width="640" height="518" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambArray.png" alt=""><dl><dt><b>Scheduler:</b></dt><dd>{@code ambArray} does not operate by default on a particular {@link Scheduler}.</dd></dl>@paramthe array of source {@code Completable}s. A subscription to each source willoccur in the same order as in this array.the new {@code Completable} instance@throwsNullPointerExceptionif {@code sources} is {@code null}Returns a {@code Completable} which terminates as soon as one of the source {@code Completable}s in the {@link Iterable} sequence<img width="640" height="518" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.amb.png" alt=""><dd>{@code amb} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Iterable} of source {@code Completable}s. A subscription to each source willoccur in the same order as in this {@code Iterable}.Returns a {@code Completable} instance that completes immediately when subscribed to.<img width="640" height="472" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.complete.png" alt=""><dd>{@code complete} does not operate by default on a particular {@link Scheduler}.</dd>the shared {@code Completable} instanceReturns a {@code Completable} which completes only when all sources complete, one after another.<img width="640" height="284" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArray.png" alt=""><dd>{@code concatArray} does not operate by default on a particular {@link Scheduler}.</dd>the sources to concatenate<img width="640" height="324" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArrayDelayError.png" alt=""><dd>{@code concatArrayDelayError} does not operate by default on a particular {@link Scheduler}.</dd>3.0.0<img width="640" height="303" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.png" alt=""><dd>{@code concat} does not operate by default on a particular {@link Scheduler}.</dd><img width="640" height="238" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.p.png" alt=""><dt><b>Backpressure:</b></dt><dd>The returned {@code Completable} honors the backpressure of the downstream consumerand expects the other {@link Publisher} to honor it as well.</dd><img width="640" height="238" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.pn.png" alt="">the number of sources to prefetch from the sourcesIllegalArgumentExceptionif {@code prefetch} is non-positive<img width="640" height="361" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatDelayError.i.png" alt=""><dd>{@code concatDelayError} does not operate by default on a particular {@link Scheduler}.</dd><img width="640" height="396" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatDelayError.p.png" alt=""><img width="640" height="359" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatDelayError.pn.png" alt="">Provides an API (via a cold {@code Completable}) that bridges the reactive world with the callback-style world.<img width="640" height="442" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.create.png" alt="">Completable.create(emitter -&gt; {Callback listener = new Callback() {public void onEvent(Event e) {emitter.onComplete();public void onFailure(Exception e) {emitter.onError(e);};AutoCloseable c = api.someMethod(listener);emitter.setCancellable(c::close);Whenever a {@link CompletableObserver} subscribes to the returned {@code Completable}, the provided{@link CompletableOnSubscribe} callback is invoked with a fresh instance of a {@link CompletableEmitter}that will interact only with that specific {@code CompletableObserver}. If this {@code CompletableObserver}disposes the flow (making {@link CompletableEmitter#isDisposed} return {@code true}),other observers subscribed to the same returned {@code Completable} are not affected.<dd>{@code create} does not operate by default on a particular {@link Scheduler}.</dd>the emitter that is called when a {@code CompletableObserver} subscribes to the returned {@code Completable}if {@code source} is {@code null}CompletableOnSubscribeCancellableCompares two {@link CompletableSource}s and emits {@code true} via a {@link Single} if both complete.<img width="640" height="187" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.sequenceEqual.png" alt=""><dd>{@code sequenceEqual} does not operate by default on a particular {@link Scheduler}.</dd>the first {@code CompletableSource} instancethe second {@code CompletableSource} instancethe new {@code Single} instanceif {@code source1} or {@code source2} is {@code null} NOPMDConstructs a {@code Completable} instance by wrapping the given source callback<strong>without any safeguards; you should manage the lifecycle and responseto downstream disposal</strong>.<img width="640" height="260" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsafeCreate.png" alt=""><dd>{@code unsafeCreate} does not operate by default on a particular {@link Scheduler}.</dd>the callback which will receive the {@link CompletableObserver} instanceswhen the {@code Completable} is subscribed to.if {@code onSubscribe} is {@code null}if {@code source} is a {@code Completable}Defers the subscription to a {@code Completable} instance returned by a supplier.<img width="640" height="298" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.defer.png" alt=""><dd>{@code defer} does not operate by default on a particular {@link Scheduler}.</dd>the supplier that returns the {@code Completable} that will be subscribed to.if {@code supplier} is {@code null}Creates a {@code Completable} which calls the given error supplier for each subscriberand emits its returned {@link Throwable}.<img width="640" height="462" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.f.png" alt="">If the {@code errorSupplier} returns {@code null}, the downstream {@link CompletableObserver}s will receive a{@link NullPointerException}.<dd>{@code error} does not operate by default on a particular {@link Scheduler}.</dd>the error supplier, not {@code null}Creates a {@code Completable} instance that emits the given {@link Throwable} exception to subscribers.<img width="640" height="462" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.png" alt="">the {@code Throwable} instance to emit, not {@code null}if {@code throwable} is {@code null}Returns a {@code Completable} instance that runs the given {@link Action} for each {@link CompletableObserver} andemits either an exception or simply completes.<img width="640" height="297" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromAction.png" alt=""><dd>{@code fromAction} does not operate by default on a particular {@link Scheduler}.</dd><dt><b>Error handling:</b></dt><dd> If the {@code Action} throws an exception, the respective {@link Throwable} isdelivered to the downstream via {@link CompletableObserver#onError(Throwable)},except when the downstream has disposed this {@code Completable} source.In this latter case, the {@code Throwable} is delivered to the global error handler via{@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.rxjava3.exceptions.UndeliverableException UndeliverableException}.</dd>the {@code Action} to run for each subscribing {@code CompletableObserver}if {@code action} is {@code null}Returns a {@code Completable} which when subscribed, executes the {@link Callable} function, ignores itsnormal result and emits {@code onError} or {@code onComplete} only.<img width="640" height="286" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromCallable.png" alt=""><dd>{@code fromCallable} does not operate by default on a particular {@link Scheduler}.</dd><dd> If the {@code Callable} throws an exception, the respective {@link Throwable} isthe {@code Callable} instance to execute for each subscribing {@link CompletableObserver}if {@code callable} is {@code null}#defer(Supplier)#fromSupplier(Supplier)Returns a {@code Completable} instance that reacts to the termination of the given {@link Future} in a blocking fashion.<img width="640" height="628" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromFuture.png" alt="">Note that disposing the {@code Completable} won't cancel the {@code Future}.Use {@link #doOnDispose(Action)} and call {@link Future#cancel(boolean)} in the{@link Action}.<dd>{@code fromFuture} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Future} to react toif {@code future} is {@code null}Returns a {@code Completable} instance that when subscribed to, subscribes to the {@link MaybeSource} instance andemits an {@code onComplete} event if the maybe emits {@code onSuccess}/{@code onComplete} or forwards any{@code onError} events.<img width="640" height="235" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromMaybe.png" alt=""><dd>{@code fromMaybe} does not operate by default on a particular {@link Scheduler}.</dd><p>History: 2.1.17 - beta<T>the value type of the {@code MaybeSource} elementthe {@code MaybeSource} instance to subscribe to, not {@code null}if {@code maybe} is {@code null}Returns a {@code Completable} instance that runs the given {@link Runnable} for each {@link CompletableObserver} andemits either its unchecked exception or simply completes.<img width="640" height="297" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromRunnable.png" alt="">If the code to be wrapped needs to throw a checked or more broader {@link Throwable} exception, thatexception has to be converted to an unchecked exception by the wrapped code itself. Alternatively,use the {@link #fromAction(Action)} method which allows the wrapped code to throw any {@code Throwable}exception and will signal it to observers as-is.<dd>{@code fromRunnable} does not operate by default on a particular {@link Scheduler}.</dd><dd> If the {@code Runnable} throws an exception, the respective {@code Throwable} isthe {@code Runnable} to run for each {@code CompletableObserver}if {@code run} is {@code null}#fromAction(Action)Returns a {@code Completable} instance that subscribes to the given {@link ObservableSource}, ignores all values andemits only the terminal event.<img width="640" height="414" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromObservable.png" alt=""><dd>{@code fromObservable} does not operate by default on a particular {@link Scheduler}.</dd>the type of the {@code ObservableSource}the {@code ObservableSource} instance to subscribe to, not {@code null}if {@code observable} is {@code null}Returns a {@code Completable} instance that subscribes to the given {@link Publisher}, ignores all values and<img width="640" height="422" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromPublisher.png" alt="">The {@code Publisher} must follow the<a href="https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams">Reactive-Streams specification</a>.Violating the specification may result in undefined behavior.If possible, use {@link #create(CompletableOnSubscribe)} to create asource-like {@code Completable} instead.Note that even though {@code Publisher} appears to be a functional interface, itis not recommended to implement it through a lambda as the specification requiresstate management that is not achievable with a stateless lambda.and expects the other {@code Publisher} to honor it as well.</dd><dd>{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.</dd>the type of the {@code Publisher}the {@code Publisher} instance to subscribe to, not {@code null}if {@code publisher} is {@code null}#create(CompletableOnSubscribe)Returns a {@code Completable} instance that when subscribed to, subscribes to the {@link SingleSource} instance andemits a completion event if the single emits {@code onSuccess} or forwards any {@code onError} events.<img width="640" height="356" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromSingle.png" alt=""><dd>{@code fromSingle} does not operate by default on a particular {@link Scheduler}.</dd>the value type of the {@code SingleSource}the {@code SingleSource} instance to subscribe to, not {@code null}if {@code single} is {@code null}Returns a {@code Completable} which when subscribed, executes the {@link Supplier} function, ignores its<img width="640" height="286" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromSupplier.png" alt=""><dd>{@code fromSupplier} does not operate by default on a particular {@link Scheduler}.</dd><dd> If the {@code Supplier} throws an exception, the respective {@link Throwable} isthe {@code Supplier} instance to execute for each {@link CompletableObserver}#fromCallable(Callable)Returns a {@code Completable} instance that subscribes to all sources at once andcompletes only when all source {@link CompletableSource}s complete or one of them emits an error.<img width="640" height="270" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeArray.png" alt=""><dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.</dd><dd>If any of the source {@code CompletableSource}s signal a {@link Throwable} via {@code onError}, the resulting{@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are disposed.If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with thefirst one's error or, depending on the concurrency of the sources, may terminate with a{@link CompositeException} containing two or more of the various error signals.{@code Throwable}s that didn't make into the composite will be sent (individually) to the global error handler via{@link RxJavaPlugins#onError(Throwable)} method as {@link UndeliverableException} errors. Similarly, {@code Throwable}ssignaled by source(s) after the returned {@code Completable} has been disposed or terminated with a(composite) error will be sent to the same global error handler.Use {@link #mergeArrayDelayError(CompletableSource...)} to merge sources and terminate only when all source {@code CompletableSource}shave completed or failed with an error.the array of {@code CompletableSource}s.#mergeArrayDelayError(CompletableSource...)<img width="640" height="311" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.png" alt=""><dd>{@code merge} does not operate by default on a particular {@link Scheduler}.</dd>Use {@link #mergeDelayError(Iterable)} to merge sources and terminate only when all source {@code CompletableSource}sthe {@link Iterable} sequence of {@code CompletableSource}s.#mergeDelayError(Iterable)<img width="640" height="336" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.p.png" alt=""><dd>The operator consumes the given {@link Publisher} in an unbounded manner(requesting {@link Long#MAX_VALUE} upfront).</dd>Use {@link #mergeDelayError(Publisher)} to merge sources and terminate only when all source {@code CompletableSource}sthe {@code Publisher} sequence of {@code CompletableSource}s.#mergeDelayError(Publisher)Returns a {@code Completable} instance that keeps subscriptions to a limited number of sources at once and<img width="640" height="269" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.merge.pn.png" alt=""><dd>The operator consumes the given {@link Publisher} in a bounded manner,requesting {@code maxConcurrency} items first, then keeps requesting asmany more as the inner {@code CompletableSource}s terminate.</dd>Use {@link #mergeDelayError(Publisher, int)} to merge sources and terminate only when all source {@code CompletableSource}sthe maximum number of concurrent subscriptionsif {@code maxConcurrency} is less than 1#mergeDelayError(Publisher, int)Returns a {@code Completable} instance that keeps subscriptions to a limited number of {@link CompletableSource}s at once andcompletes only when all source {@code CompletableSource}s terminate in one way or another, combining any exceptionssignaled by either the source {@link Publisher} or the inner {@code CompletableSource} instances.<dd>The operator consumes the given {@code Publisher} in a bounded manner,<dd>{@code merge0} does not operate by default on a particular {@link Scheduler}.</dd>delay all errors from the main source and from the inner {@code CompletableSource}s?Returns a {@code Completable} that subscribes to all {@link CompletableSource}s in the source array and delaysany error emitted by any of the inner {@code CompletableSource}s until all ofthem terminate in a way or another.<img width="640" height="430" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeArrayDelayError.png" alt=""><dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.</dd>the array of {@code CompletableSource}sReturns a {@code Completable} that subscribes to all {@link CompletableSource}s in the source sequence and delays<img width="640" height="476" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.png" alt=""><dd>{@code mergeDelayError} does not operate by default on a particular {@link Scheduler}.</dd>the sequence of {@code CompletableSource}sany error emitted by either the sources {@link Publisher} or any of the inner {@code CompletableSource}s until all of<img width="640" height="466" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.p.png" alt=""><dd>The operator consumes the {@code Publisher} in an unbounded manner(requesting {@link Long#MAX_VALUE} from it).</dd>Returns a {@code Completable} that subscribes to a limited number of inner {@link CompletableSource}s at once inthe source sequence and delays any error emitted by either the sources{@link Publisher} or any of the inner {@code CompletableSource}s until all of<img width="640" height="440" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeDelayError.pn.png" alt=""><dd>The operator requests {@code maxConcurrency} items from the {@code Publisher}upfront and keeps requesting as many more as many inner {@code CompletableSource}s terminate.</dd>the maximum number of concurrent subscriptions to haveat a time to the inner {@code CompletableSource}sif {@code maxConcurrency} is non-positiveReturns a {@code Completable} that never calls {@code onError} or {@code onComplete}.<img width="640" height="512" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.never.png" alt=""><dd>{@code never} does not operate by default on a particular {@link Scheduler}.</dd>the singleton instance that never calls {@code onError} or {@code onComplete}Returns a {@code Completable} instance that fires its {@code onComplete} event after the given delay elapsed.<img width="640" height="413" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timer.png" alt=""><dd>{@code timer} does operate by default on the {@code computation} {@link Scheduler}.</dd>the delay timethe delay unitif {@code unit} is {@code null}Returns a {@code Completable} instance that fires its {@code onComplete} event after the given delay elapsedby using the supplied {@link Scheduler}.<img width="640" height="413" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timer.s.png" alt=""><dd>{@code timer} operates on the {@code Scheduler} you specify.</dd>the {@code Scheduler} where to emit the {@code onComplete} eventif {@code unit} or {@code scheduler} is {@code null}Creates a {@link NullPointerException} instance and sets the given {@link Throwable} as its initial cause.the {@code Throwable} instance to use as cause, not {@code null} (not verified)the new {@code NullPointerException}Switches between {@link CompletableSource}s emitted by the source {@link Publisher} whenevera new {@code CompletableSource} is emitted, disposing the previously running {@code CompletableSource},exposing the setup as a {@code Completable} sequence.<img width="640" height="518" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.switchOnNext.png" alt=""><dd>The {@code sources} {@code Publisher} is consumed in an unbounded manner (requesting {@link Long#MAX_VALUE}).</dd><dd>{@code switchOnNext} does not operate by default on a particular {@link Scheduler}.</dd><dd>The returned sequence fails with the first error signaled by the {@code sources} {@code Publisher}or the currently running {@code CompletableSource}, disposing the rest. Late errors areforwarded to the global error handler via {@link RxJavaPlugins#onError(Throwable)}.</dd>the {@code Publisher} sequence of inner {@code CompletableSource}s to switch between#switchOnNextDelayError(Publisher)<a href="http://reactivex.io/documentation/operators/switch.html">ReactiveX operators documentation: Switch</a>exposing the setup as a {@code Completable} sequence and delaying all errors fromall of them until all terminate.<img width="640" height="415" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.switchOnNextDelayError.png" alt=""><dd>{@code switchOnNextDelayError} does not operate by default on a particular {@link Scheduler}.</dd><dd>The returned {@code Completable} collects all errors emitted by either the {@code sources}{@code Publisher} or any inner {@code CompletableSource} and emits them as a {@link CompositeException}when all sources terminate. If only one source ever failed, its error is emitted as-is at the end.</dd>#switchOnNext(Publisher)Returns a {@code Completable} instance which manages a resource alongwith a custom {@link CompletableSource} instance while the subscription is active.<img width="640" height="389" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.png" alt="">This overload disposes eagerly before the terminal event is emitted.<dd>{@code using} does not operate by default on a particular {@link Scheduler}.</dd><R>the resource typethe {@link Supplier} that returns a resource to be managed.the {@link Function} that given a resource returns a {@code CompletableSource} instance that will be subscribed tothe {@link Consumer} that disposes the resource created by the resource supplierif {@code resourceSupplier}, {@code sourceSupplier}or {@code resourceCleanup} is {@code null}with a custom {@link CompletableSource} instance while the subscription is active and performs eager or lazyresource disposition.<img width="640" height="332" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.b.png" alt="">If this overload performs a lazy disposal after the terminal event is emitted.The exceptions thrown at this time will be delivered to the global {@link RxJavaPlugins#onError(Throwable)} handler only.the {@link Supplier} that returns a resource to be managedthe {@link Function} that given a resource returns a non-{@code null}{@code CompletableSource} instance that will be subscribed toIf {@code true} then resource disposal will happen either on a {@code dispose()} call before the upstream is disposedor just before the emission of a terminal event ({@code onComplete} or {@code onError}).If {@code false} the resource disposal will happen either on a {@code dispose()} call after the upstream is disposedor just after the emission of a terminal event ({@code onComplete} or {@code onError}).Wraps the given {@link CompletableSource} into a {@code Completable}if not already {@code Completable}.<img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.wrap.png" alt=""><dd>{@code wrap} does not operate by default on a particular {@link Scheduler}.</dd>the source to wrapthe new wrapped or cast {@code Completable} instanceReturns a {@code Completable} that emits the a terminated event of either this {@code Completable}or the other {@link CompletableSource}, whichever fires first.<img width="640" height="485" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambWith.png" alt=""><dd>{@code ambWith} does not operate by default on a particular {@link Scheduler}.</dd>the other {@code CompletableSource}, not {@code null}. A subscription to this provided source will occur after subscribingto the current source.if {@code other} is {@code null}Returns an {@link Observable} which will subscribe to this {@code Completable} and once that is completed thenwill subscribe to the {@code next} {@link ObservableSource}. An error event from this {@code Completable} will bepropagated to the downstream observer and will result in skipping the subscription to thenext {@code ObservableSource}.<img width="640" height="278" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.o.png" alt=""><dd>{@code andThen} does not operate by default on a particular {@link Scheduler}.</dd>the value type of the next {@code ObservableSource}the {@code ObservableSource} to subscribe after this {@code Completable} is completed, not {@code null}the new {@code Observable} that composes this {@code Completable} and the next {@code ObservableSource}if {@code next} is {@code null}Returns a {@link Flowable} which will subscribe to this {@code Completable} and once that is completed thenwill subscribe to the {@code next} {@link Publisher}. An error event from this {@code Completable} will bepropagated to the downstream subscriber and will result in skipping the subscription to the next{@code Publisher}.<img width="640" height="249" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.p.png" alt=""><dd>The returned {@code Flowable} honors the backpressure of the downstream consumerthe value type of the next {@code Publisher}the {@code Publisher} to subscribe after this {@code Completable} is completed, not {@code null}the new {@code Flowable} that composes this {@code Completable} and the next {@code Publisher}Returns a {@link Single} which will subscribe to this {@code Completable} and once that is completed thenwill subscribe to the {@code next} {@link SingleSource}. An error event from this {@code Completable} will bepropagated to the downstream observer and will result in skipping the subscription to the next{@code SingleSource}.<img width="640" height="437" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.s.png" alt="">the value type of the next {@code SingleSource}the {@code SingleSource} to subscribe after this {@code Completable} is completed, not {@code null}the new {@code Single} that composes this {@code Completable} and the next {@code SingleSource}Returns a {@link Maybe} which will subscribe to this {@code Completable} and once that is completed thenwill subscribe to the {@code next} {@link MaybeSource}. An error event from this {@code Completable} will be{@code MaybeSource}.<img width="640" height="281" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.m.png" alt="">the value type of the next {@code MaybeSource}the {@code MaybeSource} to subscribe after this {@code Completable} is completed, not {@code null}the new {@code Maybe} that composes this {@code Completable} and the next {@code MaybeSource}Returns a {@code Completable} that first runs this {@code Completable}and then the other {@link CompletableSource}. An error event from this {@code Completable} will be{@code CompletableSource}.<img width="640" height="437" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.c.png" alt="">This is an alias for {@link #concatWith(CompletableSource)}.the other {@code CompletableSource}, not {@code null}Subscribes to and awaits the termination of this {@code Completable} instance in a blocking manner andrethrows any exception emitted.<img width="640" height="433" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingAwait.png" alt=""><dd>{@code blockingAwait} does not operate by default on a particular {@link Scheduler}.</dd><dd>If the source signals an error, the operator wraps a checked {@link Exception}into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and{@link Error}s are rethrown as they are.</dd>RuntimeExceptionwrapping an {@link InterruptedException} if the current thread is interruptedSubscribes to and awaits the termination of this {@code Completable} instance in a blocking mannerwith a specific timeout and rethrows any exception emitted within the timeout window.<img width="640" height="348" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingAwait.t.png" alt="">the timeout valuethe timeout unit{@code true} if the this {@code Completable} instance completed normally within the time limit,{@code false} if the timeout elapsed before this {@code Completable} terminated.Subscribes to the current {@code Completable} and <em>blocks the current thread</em> until it terminates.<img width="640" height="346" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingSubscribe.png" alt=""><dd>{@code blockingSubscribe} does not operate by default on a particular {@link Scheduler}.</dd><dd>If the current {@code Completable} signals an error,the {@link Throwable} is routed to the global error handler via {@link RxJavaPlugins#onError(Throwable)}.If the current thread is interrupted, an {@link InterruptedException} is routed to the same global error handler.#blockingSubscribe(Action)#blockingSubscribe(Action, Consumer)Subscribes to the current {@code Completable} and calls given {@code onComplete} callback on the <em>current thread</em>when it completes normally.<img width="640" height="351" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingSubscribe.a.png" alt=""><dd>If either the current {@code Completable} signals an error or {@code onComplete} throws,the respective {@link Throwable} is routed to the global error handler via {@link RxJavaPlugins#onError(Throwable)}.the {@link Action} to call if the current {@code Completable} completes normallyif {@code onComplete} is {@code null}Subscribes to the current {@code Completable} and calls the appropriate callback on the <em>current thread</em>when it terminates.<img width="640" height="352" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingSubscribe.ac.png" alt=""><dd>If either {@code onComplete} or {@code onError} throw, the {@link Throwable} is routed to theglobal error handler via {@link RxJavaPlugins#onError(Throwable)}.If the current thread is interrupted, the {@code onError} consumer is called with an {@link InterruptedException}.the {@link Consumer} to call if the current {@code Completable} signals an errorif {@code onComplete} or {@code onError} is {@code null}Subscribes to the current {@code Completable} and calls the appropriate {@link CompletableObserver} method on the <em>current thread</em>.<img width="640" height="468" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.blockingSubscribe.o.png" alt=""><dd>An {@code onError} signal is delivered to the {@link CompletableObserver#onError(Throwable)} method.If any of the {@code CompletableObserver}'s methods throw, the {@link RuntimeException} is propagated to the caller of this method.If the current thread is interrupted, an {@link InterruptedException} is delivered to {@code observer.onError}.the {@code CompletableObserver} to call methods on the current threadif {@code observer} is {@code null}Subscribes to this {@code Completable} only once, when the first {@link CompletableObserver}subscribes to the result {@code Completable}, caches its terminal eventand relays/replays it to observers.<img width="640" height="375" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.cache.png" alt="">Note that this operator doesn't allow disposing the connectionof the upstream source.<dd>{@code cache} does not operate by default on a particular {@link Scheduler}.</dd><p>History: 2.0.4 - experimentalCalls the given transformer function with this instance and returns the function's resulting{@link CompletableSource} wrapped with {@link #wrap(CompletableSource)}.<img width="640" height="625" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.compose.png" alt=""><dd>{@code compose} does not operate by default on a particular {@link Scheduler}.</dd>the transformer function, not {@code null}if {@code transformer} is {@code null}Concatenates this {@code Completable} with another {@link CompletableSource}.An error event from this {@code Completable} will be<img width="640" height="317" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatWith.png" alt=""><dd>{@code concatWith} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code Completable} which subscribes to this and then the other {@code CompletableSource}#andThen(CompletableSource)#andThen(MaybeSource)#andThen(ObservableSource)#andThen(SingleSource)#andThen(Publisher)Returns a {@code Completable} which delays the emission of the completion event by the given time.<img width="640" height="344" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.png" alt=""><dd>{@code delay} does operate by default on the {@code computation} {@link Scheduler}.</dd>Returns a {@code Completable} which delays the emission of the completion event by the given time whilerunning on the specified {@link Scheduler}.<img width="640" height="313" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.s.png" alt=""><dd>{@code delay} operates on the {@code Scheduler} you specify.</dd>the {@code Scheduler} to run the delayed completion onReturns a {@code Completable} which delays the emission of the completion event, and optionally the error as well, by the given time while<img width="640" height="253" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.sb.png" alt="">delay the error emission as well?Returns a {@code Completable} that delays the subscription to the upstream by a given amount of time.<img width="640" height="475" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.t.png" alt=""><dd>This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.</dd><p>History: 2.2.3 - experimentalthe time to delay the subscriptionthe time unit of {@code delay}<a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX operators documentation: Delay</a>Returns a {@code Completable} that delays the subscription to the upstream by a given amount of time,both waiting and subscribing on a given {@link Scheduler}.<img width="640" height="420" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.ts.png" alt=""><dd>You specify which {@code Scheduler} this operator will use.</dd>the {@code Scheduler} on which the waiting and subscription will happenReturns a {@code Completable} which calls the given {@code onComplete} {@link Action} if this {@code Completable} completes.<img width="640" height="304" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnComplete.png" alt=""><dd>{@code doOnComplete} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Action} to call when this emits an {@code onComplete} event#doFinally(Action)Calls the shared {@link Action} if a {@link CompletableObserver} subscribed to the current{@code Completable} disposes the common {@link Disposable} it received via {@code onSubscribe}.<img width="640" height="589" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnDispose.png" alt=""><dd>{@code doOnDispose} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Action} to call when the downstream observer disposes the subscriptionif {@code onDispose} is {@code null}Returns a {@code Completable} which calls the given {@code onError} {@link Consumer} if this {@code Completable} emits an error.<img width="640" height="304" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnError.png" alt=""><dd>{@code doOnError} does not operate by default on a particular {@link Scheduler}.</dd>the error {@code Consumer} receiving the upstream {@link Throwable} if the upstream signals it via {@code onError}if {@code onError} is {@code null}Returns a {@code Completable} which calls the given {@code onEvent} {@link Consumer} with the {@link Throwable} for an {@code onError}or {@code null} for an {@code onComplete} signal from this {@code Completable} before delivering the signal to the downstream.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnEvent.png" alt=""><dd>{@code doOnEvent} does not operate by default on a particular {@link Scheduler}.</dd>the event {@code Consumer} that receives {@code null} for upstreamcompletion or a {@code Throwable} if the upstream signaled an errorif {@code onEvent} is {@code null}Calls the appropriate {@code onXXX} method (shared between all {@link CompletableObserver}s) for the lifecycle events ofthe sequence (subscription, disposal).<img width="640" height="257" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnLifecycle.png" alt=""><dd>{@code doOnLifecycle} does not operate by default on a particular {@link Scheduler}.</dd>a {@link Consumer} called with the {@link Disposable} sent via {@link CompletableObserver#onSubscribe(Disposable)}called when the downstream disposes the {@code Disposable} via {@code dispose()}if {@code onSubscribe} or {@code onDispose} is {@code null}<a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operators documentation: Do</a>Returns a {@code Completable} instance that calls the various callbacks upon the specificlifecycle events.the consumer called when a {@link CompletableObserver} subscribes.the consumer called when this emits an {@code onError} eventthe runnable called just before when the current {@code Completable} completes normallythe runnable called after this {@code Completable} completes normallythe {@link Runnable} called when the downstream disposes the subscriptionif {@code onSubscribe}, {@code onError}, {@code onComplete}{@code onTerminate}, {@code onAfterTerminate} or {@code onDispose} is {@code null}Returns a {@code Completable} instance that calls the given {@code onSubscribe} callback with the disposablethat the downstream {@link CompletableObserver}s receive upon subscription.<img width="640" height="304" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnSubscribe.png" alt=""><dd>{@code doOnSubscribe} does not operate by default on a particular {@link Scheduler}.</dd>the {@link Consumer} called when a downstream {@code CompletableObserver} subscribesReturns a {@code Completable} instance that calls the given {@code onTerminate} {@link Action} just before this {@code Completable}completes normally or with an exception.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnTerminate.png" alt=""><dd>{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Action} to call just before this {@code Completable} terminatesif {@code onTerminate} is {@code null}Returns a {@code Completable} instance that calls the given {@code onAfterTerminate}  {@link Action} after this {@code Completable}<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doAfterTerminate.png" alt=""><dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Action} to call after this {@code Completable} terminatesif {@code onAfterTerminate} is {@code null}Calls the specified {@link Action} after this {@code Completable} signals {@code onError} or {@code onComplete} or gets disposed bythe downstream.<img width="640" height="331" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doFinally.png" alt="">In case of a race between a terminal event and a dispose call, the provided {@code onFinally} actionis executed once per subscription.Note that the {@code onFinally} action is shared between subscriptions and as suchshould be thread-safe.<dd>{@code doFinally} does not operate by default on a particular {@link Scheduler}.</dd><p>History: 2.0.1 - experimentalthe {@code Action} called when this {@code Completable} terminates or gets disposedif {@code onFinally} is {@code null}<strong>This method requires advanced knowledge about building operators, please considerother standard composition methods first;</strong>Returns a {@code Completable} which, when subscribed to, invokes the {@link CompletableOperator#apply(CompletableObserver) apply(CompletableObserver)} methodof the provided {@link CompletableOperator} for each individual downstream {@link Completable} and allows theinsertion of a custom operator by accessing the downstream's {@link CompletableObserver} during this subscription phaseand providing a new {@code CompletableObserver}, containing the custom operator's intended business logic, that will beused in the subscription process going further upstream.<img width="640" height="313" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.lift.png" alt="">Generally, such a new {@code CompletableObserver} will wrap the downstream's {@code CompletableObserver} and forwards the{@code onError} and {@code onComplete} events from the upstream directly or according to theemission pattern the custom operator's business logic requires. In addition, such operator can intercept theflow control calls of {@code dispose} and {@code isDisposed} that would have traveled upstream and performadditional actions depending on the same business logic requirements.// Step 1: Create the consumer type that will be returned by the CompletableOperator.apply():public final class CustomCompletableObserver implements CompletableObserver, Disposable {// The downstream's CompletableObserver that will receive the onXXX eventsfinal CompletableObserver downstream;// The connection to the upstream source that will call this class' onXXX methodsDisposable upstream;// The constructor takes the downstream subscriber and usually any other parameterspublic CustomCompletableObserver(CompletableObserver downstream) {this.downstream = downstream;// In the subscription phase, the upstream sends a Disposable to this class// and subsequently this class has to send a Disposable to the downstream.// Note that relaying the upstream's Disposable directly is not allowed in RxJavapublic void onSubscribe(Disposable d) {if (upstream != null) {} else {upstream = d;downstream.onSubscribe(this);// Some operators may handle the upstream's error while others// could just forward it to the downstream.public void onError(Throwable throwable) {downstream.onError(throwable);// When the upstream completes, usually the downstream should complete as well.// In completable, this could also mean doing some side-effectsSystem.out.println("Sequence completed");downstream.onComplete();// Some operators may use their own resources which should be cleaned up if// the downstream disposes the flow before it completed. Operators without// resources can simply forward the dispose to the upstream.// In some cases, a disposed flag may be set by this method so that other parts// of this class may detect the dispose and stop sending events// to the downstream.public void dispose() {upstream.dispose();// Some operators may simply forward the call to the upstream while others// can return the disposed flag set in dispose().public boolean isDisposed() {return upstream.isDisposed();// Step 2: Create a class that implements the CompletableOperator interface and//         returns the custom consumer type from above in its apply() method.//         Such class may define additional parameters to be submitted to//         the custom consumer type.final class CustomCompletableOperator implements CompletableOperator {public CompletableObserver apply(CompletableObserver upstream) {return new CustomCompletableObserver(upstream);// Step 3: Apply the custom operator via lift() in a flow by creating an instance of it//         or reusing an existing one.Completable.complete().lift(new CustomCompletableOperator()).test().assertResult();Creating custom operators can be complicated and it is recommended one consults the<a href="https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0">RxJava wiki: Writing operators</a> page aboutthe tools, requirements, rules, considerations and pitfalls of implementing them.Note that implementing custom operators via this {@code lift()} method adds slightly more overhead by requiringan additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Completable}class and creating a {@link CompletableTransformer} with it is recommended.Note also that it is not possible to stop the subscription phase in {@code lift()} as the {@code apply()} methodrequires a non-{@code null} {@code CompletableObserver} instance to be returned, which is then unconditionally subscribed tothe current {@code Completable}. For example, if the operator decided there is no reason to subscribe to theupstream source because of some optimization possibility or a failure to prepare the operator, it still has toreturn a {@code CompletableObserver} that should immediately dispose the upstream's {@link Disposable} in its{@code onSubscribe} method. Again, using a {@code CompletableTransformer} and extending the {@code Completable} isa better option as {@link #subscribeActual} can decide to not subscribe to its upstream after all.<dd>{@code lift} does not operate by default on a particular {@link Scheduler}, however, the{@code CompletableOperator} may use a {@code Scheduler} to support its own asynchronous behavior.</dd>the {@code CompletableOperator} that receives the downstream's {@code CompletableObserver} and should returna {@code CompletableObserver} with custom behavior to be used as the consumer for the current{@code Completable}.if {@code onLift} is {@code null}<a href="https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0">RxJava wiki: Writing operators</a>#compose(CompletableTransformer)Maps the signal types of this {@code Completable} into a {@link Notification} of the same kindand emits it as a single success value to downstream.<img width="640" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.v3.png" alt=""><dd>{@code materialize} does not operate by default on a particular {@link Scheduler}.</dd><p>History: 2.2.4 - experimentalthe intended target element type of the {@code Notification}the new {@link Single} instanceSingle#dematerialize(Function)Returns a {@code Completable} which subscribes to this and the other {@link CompletableSource} and completeswhen both of them complete or one emits an error.<img width="640" height="442" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.mergeWith.png" alt=""><dd>{@code mergeWith} does not operate by default on a particular {@link Scheduler}.</dd>the other {@code CompletableSource} instanceReturns a {@code Completable} which emits the terminal events from the thread of the specified {@link Scheduler}.<img width="640" height="523" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.observeOn.png" alt=""><dd>{@code observeOn} operates on a {@code Scheduler} you specify.</dd>the {@code Scheduler} to emit terminal events onif {@code scheduler} is {@code null}Returns a {@code Completable} instance that if this {@code Completable} emits an error, it will emit an {@code onComplete}and swallow the upstream {@link Throwable}.<img width="640" height="585" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorComplete.png" alt=""><dd>{@code onErrorComplete} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@code Completable} instance that if this {@code Completable} emits an error and the {@link Predicate} returns{@code true}, it will emit an {@code onComplete} and swallow the {@link Throwable}.<img width="640" height="283" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorComplete.f.png" alt="">the {@code Predicate} to call when a {@code Throwable} is emitted which should return {@code true}if the {@code Throwable} should be swallowed and replaced with an {@code onComplete}.if {@code predicate} is {@code null}Returns a {@code Completable} instance that when encounters an error from this {@code Completable}, calls thespecified {@code mapper} {@link Function} that returns a {@link CompletableSource} instance for it and resumes theexecution with it.<img width="640" height="426" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorResumeNext.png" alt=""><dd>{@code onErrorResumeNext} does not operate by default on a particular {@link Scheduler}.</dd>the {@code mapper} {@code Function} that takes the error and should return a {@code CompletableSource} ascontinuation.if {@code fallbackSupplier} is {@code null}Resumes the flow with the given {@link CompletableSource} when the current {@code Completable} fails instead ofsignaling the error via {@code onError}.<img width="640" height="409" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorResumeWith.png" alt="">You can use this to prevent errors from propagating or to supply fallback data should errors beencountered.<dd>{@code onErrorResumeWith} does not operate by default on a particular {@link Scheduler}.</dd>the next {@code CompletableSource} that will take over if the current {@code Completable} encountersan errorif {@code fallback} is {@code null}<a href="http://reactivex.io/documentation/operators/catch.html">ReactiveX operators documentation: Catch</a>Ends the flow with a success item returned by a function for the {@link Throwable} error signaled by the current{@code Completable} instead of signaling the error via {@code onError}.<img width="640" height="567" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorReturn.png" alt=""><dd>{@code onErrorReturn} does not operate by default on a particular {@link Scheduler}.</dd>the item type to return on errora function that returns a single value that will be emitted as success valuethe current {@code Completable} signals an {@code onError} eventthe new {@link Maybe} instanceif {@code itemSupplier} is {@code null}Ends the flow with the given success item when the current {@code Completable}fails instead of signaling the error via {@code onError}.<img width="640" height="567" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onErrorReturnItem.png" alt=""><dd>{@code onErrorReturnItem} does not operate by default on a particular {@link Scheduler}.</dd>the value that is emitted as {@code onSuccess} in case the current {@code Completable} signals an {@code onError}if {@code item} is {@code null}Nulls out references to the upstream producer and downstream {@link CompletableObserver} ifthe sequence is terminated or downstream calls {@code dispose()}.<img width="640" height="326" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.onTerminateDetach.png" alt=""><dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.</dd><p>History: 2.1.5 - experimentalReturns a {@code Completable} that repeatedly subscribes to this {@code Completable} until disposed.<img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.png" alt=""><dd>{@code repeat} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@code Completable} that subscribes repeatedly at most the given number of times to this {@code Completable}.<img width="640" height="408" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.n.png" alt="">the number of times the re-subscription should happenif {@code times} is negativeReturns a {@code Completable} that repeatedly subscribes to this {@code Completable} so long as the givenstop {@link BooleanSupplier} returns {@code false}.<img width="640" height="381" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatUntil.png" alt=""><dd>{@code repeatUntil} does not operate by default on a particular {@link Scheduler}.</dd>the {@code BooleanSupplier} that should return {@code true} to stop resubscribing.if {@code stop} is {@code null}Returns a {@code Completable} instance that repeats when the {@link Publisher} returned by the handler {@link Function}emits an item or completes when this {@code Publisher} emits an {@code onComplete} event.<img width="640" height="586" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatWhen.png" alt=""><dd>{@code repeatWhen} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Function} that transforms the stream of values indicating the completion ofthis {@code Completable} and returns a {@code Publisher} that emits items for repeating or completes to indicate therepetition should stopif {@code handler} is {@code null}Returns a {@code Completable} that retries this {@code Completable} as long as it emits an {@code onError} event.<img width="640" height="368" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.png" alt=""><dd>{@code retry} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@code Completable} that retries this {@code Completable} in case of an error as long as the {@code predicate}returns {@code true}.<img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.ff.png" alt="">the {@link Predicate} called when this {@code Completable} emits an error with the repeat count and the latest {@link Throwable}and should return {@code true} to retry.Returns a {@code Completable} that when this {@code Completable} emits an error, retries at most the givennumber of times before giving up and emitting the last error.<img width="640" height="451" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.n.png" alt="">the number of times to resubscribe if the current {@code Completable} failsReturns a {@code Completable} that when this {@code Completable} emits an error, retries at most timesor until the predicate returns {@code false}, whichever happens first and emitting the last error.<img width="640" height="361" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.nf.png" alt=""><p>History: 2.1.8 - experimentalthe {@link Predicate} that is called with the latest {@link Throwable} and should return{@code true} to indicate the returned {@code Completable} should resubscribe to this {@code Completable}.Returns a {@code Completable} that when this {@code Completable} emits an error, calls the given predicate withthe latest {@link Throwable} to decide whether to resubscribe to the upstream or not.<img width="640" height="336" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.f.png" alt="">the {@link Predicate} that is called with the latest {@code Throwable} and should returnRetries until the given stop function returns {@code true}.<img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retryUntil.png" alt=""><dd>{@code retryUntil} does not operate by default on a particular {@link Scheduler}.</dd>the function that should return {@code true} to stop retryingReturns a {@code Completable} which given a {@link Publisher} and when this {@code Completable} emits an error, deliversthat error through a {@link Flowable} and the {@code Publisher} should signal a value indicating a retry in responseor a terminal event indicating a termination.<img width="640" height="586" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retryWhen.png" alt="">Note that the inner {@code Publisher} returned by the handler function should signaleither {@code onNext}, {@code onError} or {@code onComplete} in response to the received{@link Throwable} to indicate the operator should retry or terminate. If the upstream tothe operator is asynchronous, signaling {@code onNext} followed by {@code onComplete} immediately mayresult in the sequence to be completed immediately. Similarly, if this inner{@code Publisher} signals {@code onError} or {@code onComplete} while the upstream isactive, the sequence is terminated with the same signal immediately.The following example demonstrates how to retry an asynchronous source with a delay:Completable.timer(1, TimeUnit.SECONDS).doOnSubscribe(s -&gt; System.out.println("subscribing")).doOnComplete(() -&gt; { throw new RuntimeException(); }).retryWhen(errors -&gt; {AtomicInteger counter = new AtomicInteger();return errors.takeWhile(e -&gt; counter.getAndIncrement() != 3).flatMap(e -&gt; {System.out.println("delay retry by " + counter.get() + " second(s)");return Flowable.timer(counter.get(), TimeUnit.SECONDS);}).blockingAwait();<dd>{@code retryWhen} does not operate by default on a particular {@link Scheduler}.</dd>the {@link Function} that receives a {@code Flowable} delivering {@code Throwable}s and should return a {@code Publisher} thatemits items to indicate retries or emits terminal events to indicate termination.Wraps the given {@link CompletableObserver}, catches any {@link RuntimeException}s thrown by its{@link CompletableObserver#onSubscribe(Disposable)}, {@link CompletableObserver#onError(Throwable)}or {@link CompletableObserver#onComplete()} methods and routes those to the globalerror handler via {@link RxJavaPlugins#onError(Throwable)}.By default, the {@code Completable} protocol forbids the {@code onXXX} methods to throw, but some{@code CompletableObserver} implementation may do it anyway, causing undefined behavior in theupstream. This method and the underlying safe wrapper ensures such misbehaving consumers don'tdisrupt the protocol.<dd>{@code safeSubscribe} does not operate by default on a particular {@link Scheduler}.</dd>the potentially misbehaving {@code CompletableObserver}#subscribe(Action, Consumer)Returns a {@code Completable} which first runs the other {@link CompletableSource}then the current {@code Completable} if the other completed normally.<img width="640" height="437" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.c.png" alt=""><dd>{@code startWith} does not operate by default on a particular {@link Scheduler}.</dd>the other {@code CompletableSource} to run firstReturns a {@link Flowable} which first runs the other {@link SingleSource}then the current {@code Completable} if the other succeeded normally.<img width="640" height="388" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.s.png" alt=""><dd>The returned {@code Flowable} honors the backpressure of the downstream consumer.</dd>the element type of the {@code other} {@code SingleSource}.the other {@code SingleSource} to run firstthe new {@code Flowable} instanceReturns a {@link Flowable} which first runs the other {@link MaybeSource}then the current {@code Completable} if the other succeeded or completed normally.<img width="640" height="266" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.m.png" alt="">the element type of the {@code other} {@code MaybeSource}.the other {@code MaybeSource} to run firstReturns an {@link Observable} which first delivers the eventsof the other {@link ObservableSource} then runs the current {@code Completable}.<img width="640" height="289" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.o.png" alt="">the value typethe other {@code ObservableSource} to run firstthe new {@code Observable} instanceReturns a {@link Flowable} which first delivers the eventsof the other {@link Publisher} then runs the current {@code Completable}.<img width="640" height="250" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.startWith.p.png" alt="">the other {@code Publisher} to run firstHides the identity of this {@code Completable} and its {@link Disposable}.<img width="640" height="432" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.hide.png" alt="">Allows preventing certain identity-based optimizations (fusion).<dd>{@code hide} does not operate by default on a particular {@link Scheduler}.</dd><p>History: 2.0.5 - experimentalSubscribes to this {@code Completable} and returns a {@link Disposable} which can be used to disposethe subscription.<img width="640" height="352" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.png" alt=""><dd>{@code subscribe} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code Disposable} that can be used for disposing the subscription at any timeImplement this method to handle the incoming {@link CompletableObserver}s andperform the business logic in your operator.<p>There is no need to call any of the plugin hooks on the current {@code Completable} instance orthe {@code CompletableObserver}; all hooks and basic safeguards have beenapplied by {@link #subscribe(CompletableObserver)} before this method gets called.the {@code CompletableObserver} instance, never {@code null}Subscribes a given {@link CompletableObserver} (subclass) to this {@code Completable} and returns the given{@code CompletableObserver} as is.<img width="640" height="349" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeWith.png" alt=""><p>Usage example:Completable source = Completable.complete().delay(1, TimeUnit.SECONDS);CompositeDisposable composite = new CompositeDisposable();DisposableCompletableObserver ds = new DisposableCompletableObserver() {// ...composite.add(source.subscribeWith(ds));<dd>{@code subscribeWith} does not operate by default on a particular {@link Scheduler}.</dd><E>the type of the {@code CompletableObserver} to use and returnthe {@code CompletableObserver} (subclass) to use and return, not {@code null}the input {@code observer}Subscribes to this {@code Completable} and calls back either the {@code onError} or {@code onComplete} functions.<img width="640" height="352" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.ff.png" alt="">the {@link Action} that is called if the {@code Completable} completes normallythe {@link Consumer} that is called if this {@code Completable} emits an errorthe new {@link Disposable} that can be used for disposing the subscription at any timeSubscribes to this {@code Completable} and calls the given {@link Action} when this {@code Completable}completes normally.<img width="640" height="352" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribe.f.png" alt="">If the {@code Completable} emits an error, it is wrapped into an{@link OnErrorNotImplementedException}and routed to the global {@link RxJavaPlugins#onError(Throwable)} handler.the {@code Action} called when this {@code Completable} completes normallyReturns a {@code Completable} which subscribes the downstream subscriber on the specified scheduler, makingsure the subscription side-effects happen on that specific thread of the {@link Scheduler}.<img width="640" height="686" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeOn.png" alt=""><dd>{@code subscribeOn} operates on a {@code Scheduler} you specify.</dd>the {@code Scheduler} to subscribe onTerminates the downstream if this or the other {@code Completable}terminates (wins the termination race) while disposing the connection to the losing source.<img width="640" height="468" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.takeuntil.c.png" alt=""><dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.</dd><dd>If both this and the other sources signal an error, only one of the errorsis signaled to the downstream and the other error is signaled to the globalerror handler via {@link RxJavaPlugins#onError(Throwable)}.</dd><p>History: 2.1.17 - experimentalthe other completable source to observe for the terminal signalsReturns a {@code Completabl}e that runs this {@code Completable} and emits a {@link TimeoutException} in casethis {@code Completable} doesn't complete within the given time.<img width="640" height="348" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.png" alt=""><dd>{@code timeout} signals the {@code TimeoutException} on the {@code computation} {@link Scheduler}.</dd>the unit of {@code timeout}Returns a {@code Completable} that runs this {@code Completable} and switches to the other {@link CompletableSource}in case this {@code Completable} doesn't complete within the given time.<img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.c.png" alt=""><dd>{@code timeout} subscribes to the other {@code CompletableSource} onthe {@code computation} {@link Scheduler}.</dd>the other {@code CompletableSource} instance to switch to in case of a timeoutif {@code unit} or {@code fallback} is {@code null}Returns a {@code Completable} that runs this {@code Completable} and emits a {@link TimeoutException} in casethis {@code Completable} doesn't complete within the given time while "waiting" on the specified{@link Scheduler}.<img width="640" height="348" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.s.png" alt=""><dd>{@code timeout} signals the {@code TimeoutException} on the {@code Scheduler} you specify.</dd>the {@code Scheduler} to use to wait for completion and signal {@code TimeoutException}in case this {@code Completable} doesn't complete within the given time while "waiting" onthe specified {@link Scheduler}.<img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.timeout.sc.png" alt="">the {@code Scheduler} you specify.</dd>the {@code Scheduler} to use to wait for completionthe other {@code Completable} instance to switch to in case of a timeoutif {@code unit}, {@code scheduler} or {@code fallback} is {@code null}Returns a {@code Completable} that runs this {@code Completable} and optionally switches to the other {@link CompletableSource}<dd>You specify the {@code Scheduler} this operator runs on.</dd>the other {@code Completable} instance to switch to in case of a timeout,if {@code null} a {@link TimeoutException} is emitted insteadCalls the specified {@link CompletableConverter} function during assembly time and returns its resulting value.<img width="640" height="751" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.to.png" alt="">This allows fluent conversion to any other type.<dd>{@code to} does not operate by default on a particular {@link Scheduler}.</dd><p>History: 2.1.7 - experimentalthe resulting object typethe {@code CompletableConverter} that receives the current {@code Completable} instance and returns a value to be the result of {@code to()}the converted valueif {@code converter} is {@code null}Returns a {@link Flowable} which when subscribed to subscribes to this {@code Completable} andrelays the terminal events to the downstream {@link Subscriber}.<img width="640" height="585" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toFlowable.png" alt=""><dd>{@code toFlowable} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@link Future} representing the termination of the current {@code Completable}via a {@code null} value.<img width="640" height="433" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Completable.toFuture.png" alt="">Cancelling the {@code Future} will cancel the subscription to the current {@code Completable}.<dd>{@code toFuture} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code Future} instance<a href="http://reactivex.io/documentation/operators/to.html">ReactiveX documentation: To</a>Converts this {@code Completable} into a {@link Maybe}.<img width="640" height="585" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toMaybe.png" alt=""><dd>{@code toMaybe} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code Maybe} instanceReturns an {@link Observable} which when subscribed to subscribes to this {@code Completable} andrelays the terminal events to the downstream {@link Observer}.<img width="640" height="293" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png" alt=""><dd>{@code toObservable} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code Observable} createdConverts this {@code Completable} into a {@link Single} which when this {@code Completable} completes normally,calls the given {@link Supplier} and emits its returned value through {@code onSuccess}.<img width="640" height="583" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingle.png" alt=""><dd>{@code toSingle} does not operate by default on a particular {@link Scheduler}.</dd>the value supplier called when this {@code Completable} completes normallyif {@code completionValueSupplier} is {@code null}emits the given value through {@code onSuccess}.<img width="640" height="583" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingleDefault.png" alt=""><dd>{@code toSingleDefault} does not operate by default on a particular {@link Scheduler}.</dd>the value to emit when this {@code Completable} completes normallyif {@code completionValue} is {@code null}Returns a {@code Completable} which makes sure when an observer disposes the subscription, the{@code dispose()} method is called on the specified {@link Scheduler}.<img width="640" height="716" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsubscribeOn.png" alt=""><dd>{@code unsubscribeOn} calls {@code dispose()} of the upstream on the {@code Scheduler} you specify.</dd>the target {@code Scheduler} where to execute the disposing ------------------------------------------------------------------------- Fluent test support, super handy and reduces test preparation boilerplateCreates a {@link TestObserver} and subscribesit to this {@code Completable}.<img width="640" height="458" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.test.png" alt=""><dd>{@code test} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code TestObserver} instanceCreates a {@link TestObserver} optionally in cancelled state, then subscribes it to this {@code Completable}.if {@code true}, the {@code TestObserver} will be cancelled before subscribing to this<img width="640" height="499" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.test.b.png" alt=""> JDK 8 SupportSignals completion (or error) when the {@link CompletionStage} terminates.<img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.c.png" alt="">Note that the operator takes an already instantiated, running or terminated {@code CompletionStage}.If the optional is to be created per consumer upon subscription, use {@link #defer(Supplier)}around {@code fromCompletionStage}:Maybe.defer(() -&gt; Completable.fromCompletionStage(createCompletionStage()));Canceling the flow can't cancel the execution of the {@code CompletionStage} because {@code CompletionStage}itself doesn't support cancellation. Instead, the operator detaches from the {@code CompletionStage}.<dd>{@code fromCompletionStage} does not operate by default on a particular {@link Scheduler}.</dd>the {@code CompletionStage} to convert to a {@code Completable} andsignal {@code onComplete} or {@code onError} when the {@code CompletionStage} terminates normally or with a failureif {@code stage} is {@code null}Signals the given default item when the upstream completes or signals the upstream error viaa {@link CompletionStage}.<img width="640" height="323" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toCompletionStage.c.png" alt="">The upstream can be canceled by converting the resulting {@code CompletionStage} into{@link CompletableFuture} via {@link CompletionStage#toCompletableFuture()} andcalling {@link CompletableFuture#cancel(boolean)} on it.The upstream will be also cancelled if the resulting {@code CompletionStage} is converted to andcompleted manually by {@link CompletableFuture#complete(Object)} or {@link CompletableFuture#completeExceptionally(Throwable)}.{@code CompletionStage}s don't have a notion of emptiness and allow {@code null}s, therefore, one can either usea {@code defaultItem} of {@code null} or turn the flow into a sequence of {@link Optional}s and default to {@link Optional#empty()}:CompletionStage&lt;Optional&lt;T&gt;&gt; stage = source.map(Optional::of).toCompletionStage(Optional.empty());<dd>{@code toCompletionStage} does not operate by default on a particular {@link Scheduler}.</dd>the type of the default item to signal upon completionthe item to signal upon completionthe new {@code CompletionStage} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/CompletableConverter.javaConvenience interface and callback used by the {@link Completable#to} operator to turn a Completable into anothervalue fluently.the output typeApplies a function to the upstream Completable and returns a converted value of type {@code R}.the upstream Completable instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/CompletableEmitter.javaCompletableEmittertdcAbstraction over an RxJava {@link CompletableObserver} that allows associatinga resource with it.All methods are safe to call from multiple threads, but note that there is no guaranteewhose terminal event will win and get delivered to the downstream.Calling {@link #onComplete()} multiple times has no effect.Calling {@link #onError(Throwable)} multiple times or after {@code onComplete} will route theexception into the global error handler via {@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable)}.The emitter allows the registration of a single resource, in the form of a {@link Disposable}or {@link Cancellable} via {@link #setDisposable(Disposable)} or {@link #setCancellable(Cancellable)}respectively. The emitter implementations will dispose/cancel this instance when thedownstream cancels the flow or after the event generator logic calls{@link #onError(Throwable)}, {@link #onComplete()} or when {@link #tryOnError(Throwable)} succeeds.Only one {@code Disposable} or {@code Cancellable} object can be associated with the emitter ata time. Calling either {@code set} method will dispose/cancel any previous object. If thereis a need for handling multiple resources, one can create a {@link io.reactivex.rxjava3.disposables.CompositeDisposable}and associate that with the emitter instead.The {@link Cancellable} is logically equivalent to {@code Disposable} but allows using cleanup logic that canthrow a checked exception (such as many {@code close()} methods on Java IO components). Sincethe release of resources happens after the terminal events have been delivered or the sequence getscancelled, exceptions throw within {@code Cancellable} are routed to the global error handler via{@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable)}.Signal the completion.Signal an exception.the exception, not nullSets a Disposable on this emitter; any previous {@link Disposable}or {@link Cancellable} will be disposed/cancelled.the disposable, null is allowedSets a Cancellable on this emitter; any previous {@link Disposable}the cancellable resource, null is allowedReturns true if the downstream disposed the sequence or theemitter was terminated via {@link #onError(Throwable)},{@link #onComplete} or a successful {@link #tryOnError(Throwable)}.<p>This method is thread-safe.true if the downstream disposed the sequence or the emitter was terminatedAttempts to emit the specified {@link Throwable} error if the downstreamhasn't cancelled the sequence or is otherwise terminated, returning falseif the emission is not allowed to happen due to lifecycle restrictions.Unlike {@link #onError(Throwable)}, the {@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable) RxjavaPlugins.onError}is not called if the error could not be delivered.<p>History: 2.1.1 - experimentalthe throwable error to signal if possibletrue if successful, false if the downstream is not able to accept furthereventsC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/CompletableObserver.javaCompletableObservereProvides a mechanism for receiving push-based notification of a valueless completion or an error.When a {@code CompletableObserver} is subscribed to a {@link CompletableSource} through the {@link CompletableSource#subscribe(CompletableObserver)} method,the {@code CompletableSource} calls {@link #onSubscribe(Disposable)}  with a {@link Disposable} that allowsdisposing the sequence at any time. A well-behaved{@code CompletableSource} will call a {@code CompletableObserver}'s {@link #onError(Throwable)}or {@link #onComplete()} method exactly once as they are considered mutually exclusive <strong>terminal signals</strong>.Calling the {@code CompletableObserver}'s method must happen in a serialized fashion, that is, they must notbe invoked concurrently by multiple threads in an overlapping fashion and the invocation pattern mustadhere to the following protocol:<pre><code>    onSubscribe (onError | onComplete)?</code></pre>Subscribing a {@code CompletableObserver} to multiple {@code CompletableSource}s is not recommended. If such reusehappens, it is the duty of the {@code CompletableObserver} implementation to be ready to receive multiple calls toits methods and ensure proper concurrent behavior of its business logic.Calling {@link #onSubscribe(Disposable)} or {@link #onError(Throwable)} with a{@code null} argument is forbidden.The implementations of the {@code onXXX} methods should avoid throwing runtime exceptions other than the following cases:<ul><li>If the argument is {@code null}, the methods can throw a {@code NullPointerException}.Note though that RxJava prevents {@code null}s to enter into the flow and thus there is generally noneed to check for nulls in flows assembled from standard sources and intermediate operators.</li><li>If there is a fatal error (such as {@code VirtualMachineError}).</li></ul>Called once by the {@link Completable} to set a {@link Disposable} on this instance whichthen can be used to cancel the subscription at any time.the {@code Disposable} instance to call dispose on for cancellation, not nullCalled once the deferred computation completes normally.Called once if the deferred computation 'throws' an exception.the exception, not {@code null}.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/CompletableOnSubscribe.javaemitterA functional interface that has a {@code subscribe()} method that receivesan instance of a {@link CompletableEmitter} instance that allows pushingan event in a cancellation-safe manner.Called for each {@link CompletableObserver} that subscribes.the safe emitter instance, never {@code null}Throwableon errorC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/CompletableOperator.javaCompletableOperatorInterface to map/wrap a downstream observer to an upstream observer.Applies a function to the child {@link CompletableObserver} and returns a new parent {@code CompletableObserver}.the child {@code CompletableObserver} instancethe parent {@code CompletableObserver} instanceon failureC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/CompletableSource.javaCompletableSourceRepresents a basic {@link Completable} source base interface,consumable via an {@link CompletableObserver}.Subscribes the given {@link CompletableObserver} to this {@code CompletableSource} instance.the {@code CompletableObserver}, not {@code null}C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/CompletableTransformer.javaCompletableTransformerConvenience interface and callback used by the compose operator to turn a {@link Completable} into another{@code Completable} fluently.Applies a function to the upstream {@link Completable} and returns a {@link CompletableSource}.the upstream {@code Completable} instancethe transformed {@code CompletableSource} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Emitter.javaBase interface for emitting signals in a push-fashion in various generator-like sourceoperators (create, generate).Note that the {@link Emitter#onNext}, {@link Emitter#onError} and{@link Emitter#onComplete} methods provided to the function via the {@link Emitter} instance should be called synchronously,never concurrently. Calling them from multiple threads is not supported and leads to anundefined behavior.the value type emittedSignal a normal value.the value to signal, not {@code null}Signal a {@link Throwable} exception.the {@code Throwable} to signal, not {@code null}Signal a completion.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Flowable.javaio.reactivex.rxjava3.internal.operators.flowableio.reactivex.rxjava3.internal.subscribersio.reactivex.rxjava3.internal.utiltimeout0(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,org.reactivestreams.Publisher)timeout0(long,java.util.concurrent.TimeUnit,org.reactivestreams.Publisher,io.reactivex.rxjava3.core.Scheduler)doOnEach(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action)"rx3.buffer-size"rx3.buffer-size128FlowableAmb<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAmb.classFlowableAmbC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowableFlowableAmb<T>(org.reactivestreams.Publisher[],java.lang.Iterable)FlowableAmb(org.reactivestreams.Publisher[],java.lang.Iterable)sourcesIterablelencombiner"combiner is null"combiner is null"bufferSize"FlowableCombineLatest<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCombineLatest.classFlowableCombineLatestFlowableCombineLatest<T,R>(org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function,int,boolean)FlowableCombineLatest(java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int,boolean)FlowableCombineLatest<T,R>(java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int,boolean)FlowableCombineLatest(org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function,int,boolean)iterablearrayFunction<Object[],? extends R>source3"source3 is null"source3 is nullsource4"source4 is null"source4 is nullsource5"source5 is null"source5 is nullsource6"source6 is null"source6 is nullsource7"source7 is null"source7 is nullsource8"source8 is null"source8 is nullsource9"source9 is null"source9 is null"rawtypes"rawtypesFlowable<? extends Publisher<? extends T>>? super ? extends Publisher<? extends T>Function<? super ? extends Publisher<? extends T>,? extends Publisher<? extends R>>Subscriber<? super ? extends Publisher<? extends T>>Function<? super ? extends Publisher<? extends T>,? extends Stream<? extends R>>Stream<? extends Publisher<? extends T>>BaseStream<? extends Publisher<? extends T>,Stream<? extends Publisher<? extends T>>>CompletionStage<? extends Publisher<? extends T>>lastStage(org.reactivestreams.Publisher)singleStage(org.reactivestreams.Publisher)firstStage(org.reactivestreams.Publisher)Collector<? super ? extends Publisher<? extends T>,A,R>Function<? super ? extends Publisher<? extends T>,Optional<? extends R>>TestSubscriber<? extends Publisher<? extends T>>BaseTestConsumer<? extends Publisher<? extends T>,TestSubscriber<? extends Publisher<? extends T>>>FlowableSubscriber<? extends Publisher<? extends T>>Subscriber<? extends Publisher<? extends T>>BiFunction<? super ? extends Publisher<? extends T>,? super U,? extends R>Function5<? super ? extends Publisher<? extends T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super ? extends Publisher<? extends T>,? super T1,? super T2,? super T3,R>Function3<? super ? extends Publisher<? extends T>,? super T1,? super T2,R>Flowable<Flowable<? extends Publisher<? extends T>>>Publisher<Flowable<? extends Publisher<? extends T>>>List<? extends Publisher<? extends T>>Collection<? extends Publisher<? extends T>>Single<List<? extends Publisher<? extends T>>>SingleSource<List<? extends Publisher<? extends T>>>Comparator<? super ? extends Publisher<? extends T>>Observable<? extends Publisher<? extends T>>ObservableSource<? extends Publisher<? extends T>>Function<? super ? extends Publisher<? extends T>,? extends K>Function<? super ? extends Publisher<? extends T>,? extends V>Map<K,Collection<? extends Publisher<? extends T>>>Single<Map<K,Collection<? extends Publisher<? extends T>>>>SingleSource<Map<K,Collection<? extends Publisher<? extends T>>>>Map<K,? extends Publisher<? extends T>>Single<Map<K,? extends Publisher<? extends T>>>SingleSource<Map<K,? extends Publisher<? extends T>>>FlowableConverter<? extends Publisher<? extends T>,? extends R>Timed<? extends Publisher<? extends T>>Flowable<Timed<? extends Publisher<? extends T>>>Publisher<Timed<? extends Publisher<? extends T>>>Function<? super ? extends Publisher<? extends T>,? extends Publisher<V>>? extends ? extends Publisher<? extends T>Publisher<? extends ? extends Publisher<? extends T>>Predicate<? super ? extends Publisher<? extends T>>Function<? super ? extends Publisher<? extends T>,? extends SingleSource<? extends R>>Function<? super ? extends Publisher<? extends T>,? extends MaybeSource<? extends R>>Function<? super ? extends Publisher<? extends T>,? extends CompletableSource>FlowableSubscriber<? super ? extends Publisher<? extends T>>Consumer<? super ? extends Publisher<? extends T>>? extends Publisher<? extends T>[]startWithArray(org.reactivestreams.Publisher[])startWithItem(org.reactivestreams.Publisher)MaybeSource<? extends Publisher<? extends T>>SingleSource<? extends Publisher<? extends T>>Iterable<? extends ? extends Publisher<? extends T>>Single<? extends Publisher<? extends T>>single(org.reactivestreams.Publisher)Maybe<? extends Publisher<? extends T>>BiFunction<R,? super ? extends Publisher<? extends T>,R>BiFunction<? extends Publisher<? extends T>,? extends Publisher<? extends T>,? extends Publisher<? extends T>>ConnectableFlowable<? extends Publisher<? extends T>>? super Flowable<? extends Publisher<? extends T>>Function<? super Flowable<? extends Publisher<? extends T>>,? extends Publisher<R>>Function<? super Flowable<? extends Publisher<? extends T>>,? extends Publisher<? extends R>>ParallelFlowable<? extends Publisher<? extends T>>onErrorReturnItem(org.reactivestreams.Publisher)Function<? super Throwable,? extends ? extends Publisher<? extends T>>? extends Publisher<? extends ? extends Publisher<? extends T>>Function<? super Throwable,? extends Publisher<? extends ? extends Publisher<? extends T>>>MaybeSource<? extends ? extends Publisher<? extends T>>SingleSource<? extends ? extends Publisher<? extends T>>Notification<? extends Publisher<? extends T>>Flowable<Notification<? extends Publisher<? extends T>>>Publisher<Notification<? extends Publisher<? extends T>>>Function<? super ? extends Publisher<? extends T>,? extends R>FlowableOperator<? extends R,? super ? extends Publisher<? extends T>>last(org.reactivestreams.Publisher)Function<? super ? extends Publisher<? extends T>,? extends Publisher<TLeftEnd>>BiFunction<? super ? extends Publisher<? extends T>,? super TRight,? extends R>BiFunction<? super ? extends Publisher<? extends T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,? extends Publisher<? extends T>>Flowable<GroupedFlowable<K,? extends Publisher<? extends T>>>Publisher<GroupedFlowable<K,? extends Publisher<? extends T>>>Function<? super ? extends Publisher<? extends T>,? extends Iterable<? extends U>>BiFunction<? super ? extends Publisher<? extends T>,? super U,? extends V>Function<? super ? extends Publisher<? extends T>,? extends Publisher<? extends U>>first(org.reactivestreams.Publisher)elementAt(long,org.reactivestreams.Publisher)? super Notification<? extends Publisher<? extends T>>Consumer<? super Notification<? extends Publisher<? extends T>>>BiPredicate<? super ? extends Publisher<? extends T>,? super ? extends Publisher<? extends T>>Function<? super ? extends Publisher<? extends T>,K>Function<? super ? extends Publisher<? extends T>,Notification<R>>Function<? super ? extends Publisher<? extends T>,? extends Publisher<U>>defaultIfEmpty(org.reactivestreams.Publisher)FlowableTransformer<? super ? extends Publisher<? extends T>,? extends R>BiConsumer<? super U,? super ? extends Publisher<? extends T>>Flowable<List<? extends Publisher<? extends T>>>Publisher<List<? extends Publisher<? extends T>>>Future<? extends Publisher<? extends T>>blockingSingle(org.reactivestreams.Publisher)blockingMostRecent(org.reactivestreams.Publisher)blockingLast(org.reactivestreams.Publisher)blockingFirst(org.reactivestreams.Publisher)Flowable<? extends Publisher<? extends T>>()Function<Object,Object>FlowableConcatArray<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatArray.classFlowableConcatArrayFlowableConcatArray<T>(org.reactivestreams.Publisher[],boolean)FlowableConcatArray(org.reactivestreams.Publisher[],boolean)FlowableConcatMapEager<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapEager.classFlowableConcatMapEagerAbstractFlowableWithUpstream<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/AbstractFlowableWithUpstream.classAbstractFlowableWithUpstreamHasUpstreamPublisher<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamPublisher.classHasUpstreamPublisherFlowableFromArray<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromArray.classFlowableFromArrayFlowableConcatMapEager<>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,int,io.reactivex.rxjava3.internal.util.ErrorMode)AbstractFlowableWithUpstream(io.reactivex.rxjava3.core.Flowable)AbstractFlowableWithUpstream<>(io.reactivex.rxjava3.core.Flowable)FlowableConcatMapEager(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,int,io.reactivex.rxjava3.internal.util.ErrorMode)errorModeFlowableFromArray<>(java.lang.Object[])FlowableFromArray(java.lang.Object[])Flowable<Publisher<? extends T>>Publisher<Publisher<? extends T>>? super Publisher<? extends T>Function<? super Publisher<? extends T>,? extends Publisher<? extends R>>Subscriber<? super Publisher<? extends T>>Function<? super Publisher<? extends T>,? extends Stream<? extends R>>Stream<Publisher<? extends T>>BaseStream<Publisher<? extends T>,Stream<Publisher<? extends T>>>CompletionStage<Publisher<? extends T>>Collector<? super Publisher<? extends T>,A,R>Function<? super Publisher<? extends T>,Optional<? extends R>>TestSubscriber<Publisher<? extends T>>BaseTestConsumer<Publisher<? extends T>,TestSubscriber<Publisher<? extends T>>>FlowableSubscriber<Publisher<? extends T>>Subscriber<Publisher<? extends T>>BiFunction<? super Publisher<? extends T>,? super U,? extends R>Function5<? super Publisher<? extends T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super Publisher<? extends T>,? super T1,? super T2,? super T3,R>Function3<? super Publisher<? extends T>,? super T1,? super T2,R>Flowable<Flowable<Publisher<? extends T>>>Publisher<Flowable<Publisher<? extends T>>>List<Publisher<? extends T>>Collection<Publisher<? extends T>>Iterable<Publisher<? extends T>>Single<List<Publisher<? extends T>>>SingleSource<List<Publisher<? extends T>>>Comparator<? super Publisher<? extends T>>Observable<Publisher<? extends T>>ObservableSource<Publisher<? extends T>>Function<? super Publisher<? extends T>,? extends K>Function<? super Publisher<? extends T>,? extends V>Map<K,Collection<Publisher<? extends T>>>Single<Map<K,Collection<Publisher<? extends T>>>>SingleSource<Map<K,Collection<Publisher<? extends T>>>>Map<K,Publisher<? extends T>>Single<Map<K,Publisher<? extends T>>>SingleSource<Map<K,Publisher<? extends T>>>FlowableConverter<Publisher<? extends T>,? extends R>Timed<Publisher<? extends T>>Flowable<Timed<Publisher<? extends T>>>Publisher<Timed<Publisher<? extends T>>>Function<? super Publisher<? extends T>,? extends Publisher<V>>Predicate<? super Publisher<? extends T>>Function<? super Publisher<? extends T>,? extends SingleSource<? extends R>>Function<? super Publisher<? extends T>,? extends MaybeSource<? extends R>>Function<? super Publisher<? extends T>,? extends CompletableSource>FlowableSubscriber<? super Publisher<? extends T>>Consumer<? super Publisher<? extends T>>MaybeSource<Publisher<? extends T>>SingleSource<Publisher<? extends T>>Single<Publisher<? extends T>>Maybe<Publisher<? extends T>>BiFunction<R,? super Publisher<? extends T>,R>BiFunction<Publisher<? extends T>,Publisher<? extends T>,Publisher<? extends T>>ConnectableFlowable<Publisher<? extends T>>? super Flowable<Publisher<? extends T>>Function<? super Flowable<Publisher<? extends T>>,? extends Publisher<R>>Function<? super Flowable<Publisher<? extends T>>,? extends Publisher<? extends R>>ParallelFlowable<Publisher<? extends T>>? extends Publisher<? extends Publisher<? extends T>>Function<? super Throwable,? extends Publisher<? extends Publisher<? extends T>>>Notification<Publisher<? extends T>>Flowable<Notification<Publisher<? extends T>>>Publisher<Notification<Publisher<? extends T>>>Function<? super Publisher<? extends T>,? extends R>FlowableOperator<? extends R,? super Publisher<? extends T>>Function<? super Publisher<? extends T>,? extends Publisher<TLeftEnd>>BiFunction<? super Publisher<? extends T>,? super TRight,? extends R>BiFunction<? super Publisher<? extends T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,Publisher<? extends T>>Flowable<GroupedFlowable<K,Publisher<? extends T>>>Publisher<GroupedFlowable<K,Publisher<? extends T>>>Function<? super Publisher<? extends T>,? extends Iterable<? extends U>>BiFunction<? super Publisher<? extends T>,? super U,? extends V>Function<? super Publisher<? extends T>,? extends Publisher<? extends U>>? super Notification<Publisher<? extends T>>Consumer<? super Notification<Publisher<? extends T>>>BiPredicate<? super Publisher<? extends T>,? super Publisher<? extends T>>Function<? super Publisher<? extends T>,K>Function<? super Publisher<? extends T>,Notification<R>>Function<? super Publisher<? extends T>,? extends Publisher<U>>FlowableTransformer<? super Publisher<? extends T>,? extends R>BiConsumer<? super U,? super Publisher<? extends T>>Flowable<List<Publisher<? extends T>>>Publisher<List<Publisher<? extends T>>>Future<Publisher<? extends T>>Flowable<Publisher<? extends T>>()tillTheEndFlowableFromIterable<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromIterable.classFlowableFromIterableFlowableFromIterable<>(java.lang.Iterable)Iterator<>C:/modules/java.base/java/util/Iterator.classIteratorsubscribe(org.reactivestreams.Subscriber,java.util.Iterator)Iterator<? extends T>FlowableFromIterable(java.lang.Iterable)FlowableConcatMapEagerPublisher<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapEagerPublisher.classFlowableConcatMapEagerPublisherFlowableConcatMapEagerPublisher<>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,int,int,io.reactivex.rxjava3.internal.util.ErrorMode)FlowableConcatMapEagerPublisher(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,int,int,io.reactivex.rxjava3.internal.util.ErrorMode)mode"mode is null"mode is nullFlowableCreate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCreate.classFlowableCreateFlowableCreate<T>(io.reactivex.rxjava3.core.FlowableOnSubscribe,io.reactivex.rxjava3.core.BackpressureStrategy)FlowableCreate(io.reactivex.rxjava3.core.FlowableOnSubscribe,io.reactivex.rxjava3.core.BackpressureStrategy)backpressureFlowableDefer<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDefer.classFlowableDeferFlowableDefer<T>(io.reactivex.rxjava3.functions.Supplier)FlowableDefer(io.reactivex.rxjava3.functions.Supplier)FlowableError<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableError.classFlowableErrorFlowableError<T>(io.reactivex.rxjava3.functions.Supplier)FlowableError(io.reactivex.rxjava3.functions.Supplier)errorSupplierSupplier<Throwable>FlowableFromAction<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromAction.classFlowableFromActionSupplier<T>FlowableFromAction<T>(io.reactivex.rxjava3.functions.Action)FlowableFromAction(io.reactivex.rxjava3.functions.Action)items"items is null"items is nullFlowableFromArray<T>FlowableFromArray<T>(java.lang.Object[])FlowableFromCallable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromCallable.classFlowableFromCallableFlowableFromCallable<T>(java.util.concurrent.Callable)FlowableFromCallable(java.util.concurrent.Callable)completableSource"completableSource is null"completableSource is nullFlowableFromCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromCompletable.classFlowableFromCompletableFlowableFromCompletable<T>(io.reactivex.rxjava3.core.CompletableSource)FlowableFromCompletable(io.reactivex.rxjava3.core.CompletableSource)FlowableFromFuture<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromFuture.classFlowableFromFutureFlowableFromFuture<T>(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit)FlowableFromFuture(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit)0LFlowableFromIterable<T>FlowableFromIterable<T>(java.lang.Iterable)MaybeToFlowable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeToFlowable.classMaybeToFlowableHasUpstreamMaybeSource<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamMaybeSource.classHasUpstreamMaybeSourceMaybeToFlowable<T>(io.reactivex.rxjava3.core.MaybeSource)MaybeToFlowable(io.reactivex.rxjava3.core.MaybeSource)strategyfFlowableFromObservable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromObservable.classFlowableFromObservableFlowableFromObservable<T>(io.reactivex.rxjava3.core.ObservableSource)FlowableFromObservable(io.reactivex.rxjava3.core.ObservableSource)"strategy is null"strategy is nullFlowableOnBackpressureError<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureError.classFlowableOnBackpressureErrorAbstractFlowableWithUpstream<T,T>HasUpstreamPublisher<T>FlowableOnBackpressureError<T>(io.reactivex.rxjava3.core.Flowable)AbstractFlowableWithUpstream<T,T>(io.reactivex.rxjava3.core.Flowable)FlowableOnBackpressureError(io.reactivex.rxjava3.core.Flowable)FlowableFromPublisher<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromPublisher.classFlowableFromPublisherFlowableFromPublisher<T>(org.reactivestreams.Publisher)FlowableFromPublisher(org.reactivestreams.Publisher)FlowableFromRunnable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromRunnable.classFlowableFromRunnableFlowableFromRunnable<T>(java.lang.Runnable)FlowableFromRunnable(java.lang.Runnable)SingleToFlowable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleToFlowable.classSingleToFlowableSingleToFlowable<T>(io.reactivex.rxjava3.core.SingleSource)SingleToFlowable(io.reactivex.rxjava3.core.SingleSource)FlowableFromSupplier<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFromSupplier.classFlowableFromSupplierFlowableFromSupplier<T>(io.reactivex.rxjava3.functions.Supplier)FlowableFromSupplier(io.reactivex.rxjava3.functions.Supplier)generator"generator is null"generator is nullSupplier<Object>BiFunction<Object,Emitter<T>,Object>initialStateConsumer<S>disposeState"initialState is null"initialState is null"disposeState is null"disposeState is nullFlowableGenerate<T,S>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGenerate.classFlowableGenerateFlowableGenerate<T,S>(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction,io.reactivex.rxjava3.functions.Consumer)FlowableGenerate(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction,io.reactivex.rxjava3.functions.Consumer)stateSupplierinitialDelayperiodstartend"count >= 0 required but it was "count >= 0 required but it was ? super LongSubscriber<? super Long>Function<? super Long,? extends Stream<? extends R>>Stream<Long>BaseStream<Long,Stream<Long>>CompletionStage<Long>lastStage(java.lang.Long)singleStage(java.lang.Long)firstStage(java.lang.Long)Collector<? super Long,A,R>Function<? super Long,Optional<? extends R>>TestSubscriber<Long>BaseTestConsumer<Long,TestSubscriber<Long>>FlowableSubscriber<Long>Subscriber<Long>BiFunction<? super Long,? super U,? extends R>Function5<? super Long,? super T1,? super T2,? super T3,? super T4,R>Function4<? super Long,? super T1,? super T2,? super T3,R>Function3<? super Long,? super T1,? super T2,R>Flowable<Flowable<Long>>Publisher<Flowable<Long>>List<Long>Collection<Long>Iterable<Long>Single<List<Long>>SingleSource<List<Long>>Comparator<? super Long>Function<? super Long,? extends K>Function<? super Long,? extends V>Map<K,Collection<Long>>Single<Map<K,Collection<Long>>>SingleSource<Map<K,Collection<Long>>>Map<K,Long>Single<Map<K,Long>>SingleSource<Map<K,Long>>FlowableConverter<Long,? extends R>Timed<Long>Flowable<Timed<Long>>Publisher<Timed<Long>>Function<? super Long,? extends Publisher<V>>? extends LongPublisher<? extends Long>Predicate<? super Long>Function<? super Long,? extends SingleSource<? extends R>>Function<? super Long,? extends MaybeSource<? extends R>>Function<? super Long,? extends Publisher<? extends R>>Function<? super Long,? extends CompletableSource>FlowableSubscriber<? super Long>Consumer<? super Long>Long[]startWithArray(java.lang.Long[])startWithItem(java.lang.Long)Iterable<? extends Long>single(java.lang.Long)BiFunction<R,? super Long,R>BiFunction<Long,Long,Long>ConnectableFlowable<Long>? super Flowable<Long>Function<? super Flowable<Long>,? extends Publisher<R>>Function<? super Flowable<Long>,? extends Publisher<? extends R>>ParallelFlowable<Long>onErrorReturnItem(java.lang.Long)Function<? super Throwable,? extends Long>? extends Publisher<? extends Long>Function<? super Throwable,? extends Publisher<? extends Long>>MaybeSource<? extends Long>SingleSource<? extends Long>Notification<Long>Flowable<Notification<Long>>Publisher<Notification<Long>>Function<? super Long,? extends R>FlowableOperator<? extends R,? super Long>last(java.lang.Long)Function<? super Long,? extends Publisher<TLeftEnd>>BiFunction<? super Long,? super TRight,? extends R>BiFunction<? super Long,? super Flowable<TRight>,? extends R>GroupedFlowable<K,Long>Flowable<GroupedFlowable<K,Long>>Publisher<GroupedFlowable<K,Long>>Function<? super Long,? extends Iterable<? extends U>>BiFunction<? super Long,? super U,? extends V>Function<? super Long,? extends Publisher<? extends U>>first(java.lang.Long)elementAt(long,java.lang.Long)? super Notification<Long>Consumer<? super Notification<Long>>BiPredicate<? super Long,? super Long>Function<? super Long,K>Function<? super Long,Notification<R>>Function<? super Long,? extends Publisher<U>>defaultIfEmpty(java.lang.Long)FlowableTransformer<? super Long,? extends R>BiConsumer<? super U,? super Long>Flowable<List<Long>>Publisher<List<Long>>Future<Long>blockingSingle(java.lang.Long)blockingMostRecent(java.lang.Long)blockingLast(java.lang.Long)blockingFirst(java.lang.Long)Flowable<Long>()"Overflow! start + count is bigger than Long.MAX_VALUE"Overflow! start + count is bigger than Long.MAX_VALUEFlowableJust<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJust.classFlowableJustScalarSupplier<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseable/ScalarSupplier.classScalarSupplierFlowableJust<T>(java.lang.Object)FlowableJust(java.lang.Object)item1item2"item1 is null"item1 is null"item2 is null"item2 is nullitem3"item3 is null"item3 is nullitem4"item4 is null"item4 is nullitem5"item5 is null"item5 is nullitem6"item6 is null"item6 is nullitem7"item7 is null"item7 is nullitem8"item8 is null"item8 is nullitem9"item9 is null"item9 is nullitem10"item10 is null"item10 is null34"Integer overflow"Integer overflowBiPredicate<T,T>isEqual"isEqual is null"isEqual is nullFlowableSequenceEqualSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSequenceEqualSingle.classFlowableSequenceEqualSingleFuseToFlowable<Boolean>FlowableSequenceEqualSingle<T>(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiPredicate,int)? super BooleanSingleObserver<? super Boolean>Function<? super Boolean,? extends Stream<? extends R>>CompletionStage<Boolean>Function<? super Boolean,Optional<? extends R>>TestObserver<Boolean>BaseTestConsumer<Boolean,TestObserver<Boolean>>Observer<Boolean>MaybeObserver<Boolean>SingleObserver<Boolean>BiFunction<? super Boolean,? super U,? extends R>Observable<Boolean>ObservableSource<Boolean>Maybe<Boolean>MaybeSource<Boolean>Future<Boolean>Flowable<Boolean>Publisher<Boolean>SingleConverter<Boolean,? extends R>? extends BooleanSingleSource<? extends Boolean>Timed<Boolean>Single<Timed<Boolean>>SingleSource<Timed<Boolean>>Consumer<? super Boolean>BiConsumer<? super Boolean,? super Throwable>? extends SingleSource<? extends Boolean>Function<? super Throwable,? extends SingleSource<? extends Boolean>>onErrorReturnItem(java.lang.Boolean)Function<Throwable,? extends Boolean>Notification<Boolean>Single<Notification<Boolean>>SingleSource<Notification<Boolean>>Function<? super Boolean,? extends R>SingleOperator<? extends R,? super Boolean>Function<? super Boolean,? extends CompletableSource>Function<? super Boolean,? extends ObservableSource<? extends R>>Function<? super Boolean,? extends Iterable<? extends U>>Function<? super Boolean,? extends Publisher<? extends R>>Function<? super Boolean,? extends MaybeSource<? extends R>>Function<? super Boolean,? extends SingleSource<? extends R>>Function<? super Boolean,? extends SingleSource<? extends U>>Predicate<? super Boolean>Function<? super Boolean,Notification<R>>SingleTransformer<? super Boolean,? extends R>Single<Boolean>()FlowableSequenceEqualSingle(org.reactivestreams.Publisher,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.BiPredicate,int)comparersecondFunction<Publisher<? extends T>,Publisher<? extends T>>"unsafeCreate(Flowable) should be upgraded"unsafeCreate(Flowable) should be upgradedFlowableUsing<T,D>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableUsing.classFlowableUsingFlowableUsing<T,D>(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)FlowableUsing(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)zipper"zipper is null"zipper is nullFlowableZip<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableZip.classFlowableZipFlowableZip<T,R>(org.reactivestreams.Publisher[],java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int,boolean)FlowableZip(org.reactivestreams.Publisher[],java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int,boolean)FlowableAllSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAllSingle.classFlowableAllSingleFlowableAllSingle<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableAllSingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableAnySingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableAnySingle.classFlowableAnySingleFlowableAnySingle<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableAnySingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)BlockingFirstSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/subscribers/BlockingFirstSubscriber.classBlockingFirstSubscriberC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/subscribersBlockingBaseSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/subscribers/BlockingBaseSubscriber.classBlockingBaseSubscribersBlockingFirstSubscriber<T>()onSubscribe(org.reactivestreams.Subscription)BlockingBaseSubscriber()BlockingBaseSubscriber<T>()BlockingFirstSubscriber()v"defaultItem is null"defaultItem is nullIterator<T>ititeratoriterator()Spliterator<>C:/modules/java.base/java/util/Spliterator.classSpliteratorSpliterator<T>spliteratorspliterator()forEach(java.util.function.Consumer)"onNext is null"onNext is nullhasNexthasNext()? super EConsumer<? super E>forEachRemainingforEachRemaining(java.util.function.Consumer)removeremove()next()acceptaccept(java.lang.Object)BlockingFlowableIterable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableIterable.classBlockingFlowableIterableBlockingFlowableIterable<T>(io.reactivex.rxjava3.core.Flowable,int)BlockingFlowableIterable(io.reactivex.rxjava3.core.Flowable,int)BlockingLastSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/subscribers/BlockingLastSubscriber.classBlockingLastSubscriberBlockingLastSubscriber<T>()BlockingLastSubscriber()BlockingFlowableLatest<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableLatest.classBlockingFlowableLatestBlockingFlowableLatest<T>(org.reactivestreams.Publisher)BlockingFlowableLatest(org.reactivestreams.Publisher)initialItem"initialItem is null"initialItem is nullBlockingFlowableMostRecent<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableMostRecent.classBlockingFlowableMostRecentBlockingFlowableMostRecent<T>(io.reactivex.rxjava3.core.Flowable,java.lang.Object)BlockingFlowableMostRecent(io.reactivex.rxjava3.core.Flowable,java.lang.Object)initialValueBlockingFlowableNext<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/BlockingFlowableNext.classBlockingFlowableNextBlockingFlowableNext<T>(org.reactivestreams.Publisher)BlockingFlowableNext(org.reactivestreams.Publisher)FutureSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/subscribers/FutureSubscriber.classFutureSubscriberFutureSubscriber<T>()requestrequest(long)cancel()FutureSubscriber()AtomicReference<Subscription>subscriber"subscriber is null"subscriber is nullSupplier<List<T>>bufferSupplier"count""skip""bufferSupplier is null"bufferSupplier is nullFlowableBuffer<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBuffer.classFlowableBufferAbstractFlowableWithUpstream<T,U>FlowableBuffer<T,C>AbstractFlowableWithUpstream<T,C>Flowable<C>Publisher<C>Supplier<C>FlowableBuffer<T,C>(io.reactivex.rxjava3.core.Flowable,int,int,io.reactivex.rxjava3.functions.Supplier)? super CSubscriber<? super C>Function<? super C,? extends Stream<? extends R>>Stream<C>BaseStream<C,Stream<C>>CompletionStage<C>lastStage(java.util.Collection)singleStage(java.util.Collection)firstStage(java.util.Collection)Collector<? super C,A,R>Function<? super C,Optional<? extends R>>TestSubscriber<C>BaseTestConsumer<C,TestSubscriber<C>>FlowableSubscriber<C>Subscriber<C>BiFunction<? super C,? super U,? extends R>Function5<? super C,? super T1,? super T2,? super T3,? super T4,R>Function4<? super C,? super T1,? super T2,? super T3,R>Function3<? super C,? super T1,? super T2,R>Flowable<Flowable<C>>Publisher<Flowable<C>>List<C>Collection<C>Iterable<C>Single<List<C>>SingleSource<List<C>>Comparator<? super C>Observable<C>ObservableSource<C>Function<? super C,? extends K>Function<? super C,? extends V>Map<K,Collection<C>>Single<Map<K,Collection<C>>>SingleSource<Map<K,Collection<C>>>Map<K,C>Single<Map<K,C>>SingleSource<Map<K,C>>FlowableConverter<C,? extends R>Timed<C>Flowable<Timed<C>>Publisher<Timed<C>>Function<? super C,? extends Publisher<V>>? extends CPublisher<? extends C>Predicate<? super C>Function<? super C,? extends SingleSource<? extends R>>Function<? super C,? extends MaybeSource<? extends R>>Function<? super C,? extends Publisher<? extends R>>Function<? super C,? extends CompletableSource>FlowableSubscriber<? super C>Consumer<? super C>Collection[]Collection<? super T>[]C[]startWithArray(java.util.Collection[])startWithItem(java.util.Collection)MaybeSource<C>SingleSource<C>Iterable<? extends C>Single<C>single(java.util.Collection)Maybe<C>BiFunction<R,? super C,R>BiFunction<C,C,C>ConnectableFlowable<C>? super Flowable<C>Function<? super Flowable<C>,? extends Publisher<R>>Function<? super Flowable<C>,? extends Publisher<? extends R>>ParallelFlowable<C>onErrorReturnItem(java.util.Collection)Function<? super Throwable,? extends C>? extends Publisher<? extends C>Function<? super Throwable,? extends Publisher<? extends C>>MaybeSource<? extends C>SingleSource<? extends C>Notification<C>Flowable<Notification<C>>Publisher<Notification<C>>Function<? super C,? extends R>FlowableOperator<? extends R,? super C>last(java.util.Collection)Function<? super C,? extends Publisher<TLeftEnd>>BiFunction<? super C,? super TRight,? extends R>BiFunction<? super C,? super Flowable<TRight>,? extends R>GroupedFlowable<K,C>Flowable<GroupedFlowable<K,C>>Publisher<GroupedFlowable<K,C>>Function<? super C,? extends Iterable<? extends U>>BiFunction<? super C,? super U,? extends V>Function<? super C,? extends Publisher<? extends U>>first(java.util.Collection)elementAt(long,java.util.Collection)? super Notification<C>Consumer<? super Notification<C>>BiPredicate<? super C,? super C>Function<? super C,K>Function<? super C,Notification<R>>Function<? super C,? extends Publisher<U>>defaultIfEmpty(java.util.Collection)FlowableTransformer<? super C,? extends R>BiConsumer<? super U,? super C>Flowable<List<C>>Publisher<List<C>>Future<C>blockingSingle(java.util.Collection)blockingMostRecent(java.util.Collection)blockingLast(java.util.Collection)blockingFirst(java.util.Collection)Flowable<C>()AbstractFlowableWithUpstream<T,C>(io.reactivex.rxjava3.core.Flowable)FlowableBuffer(io.reactivex.rxjava3.core.Flowable,int,int,io.reactivex.rxjava3.functions.Supplier)sizetimespantimeskipFlowableBufferTimed<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferTimed.classFlowableBufferTimedFlowableBufferTimed<T,U>(io.reactivex.rxjava3.core.Flowable,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.functions.Supplier,int,boolean)Subscriber<? super U>Function<? super U,? extends Stream<? extends R>>Stream<U>BaseStream<U,Stream<U>>Collector<? super U,A,R>Function<? super U,Optional<? extends R>>TestSubscriber<U>BaseTestConsumer<U,TestSubscriber<U>>FlowableSubscriber<U>Subscriber<U>BiFunction<? super U,? super U,? extends R>Function5<? super U,? super T1,? super T2,? super T3,? super T4,R>Function4<? super U,? super T1,? super T2,? super T3,R>Function3<? super U,? super T1,? super T2,R>Flowable<Flowable<U>>Publisher<Flowable<U>>List<U>Collection<U>Single<List<U>>SingleSource<List<U>>Comparator<? super U>Function<? super U,? extends K>Function<? super U,? extends V>Map<K,Collection<U>>Single<Map<K,Collection<U>>>SingleSource<Map<K,Collection<U>>>Map<K,U>Single<Map<K,U>>SingleSource<Map<K,U>>FlowableConverter<U,? extends R>Timed<U>Flowable<Timed<U>>Publisher<Timed<U>>Predicate<? super U>Function<? super U,? extends SingleSource<? extends R>>Function<? super U,? extends MaybeSource<? extends R>>Function<? super U,? extends Publisher<? extends R>>Function<? super U,? extends CompletableSource>FlowableSubscriber<? super U>U[]BiFunction<R,? super U,R>BiFunction<U,U,U>ConnectableFlowable<U>? super Flowable<U>Function<? super Flowable<U>,? extends Publisher<R>>Function<? super Flowable<U>,? extends Publisher<? extends R>>ParallelFlowable<U>Function<? super Throwable,? extends U>Function<? super Throwable,? extends Publisher<? extends U>>Notification<U>Flowable<Notification<U>>Publisher<Notification<U>>Function<? super U,? extends R>FlowableOperator<? extends R,? super U>Function<? super U,? extends Publisher<TLeftEnd>>BiFunction<? super U,? super TRight,? extends R>BiFunction<? super U,? super Flowable<TRight>,? extends R>GroupedFlowable<K,U>Flowable<GroupedFlowable<K,U>>Publisher<GroupedFlowable<K,U>>Function<? super U,? extends Iterable<? extends U>>BiFunction<? super U,? super U,? extends V>Function<? super U,? extends Publisher<? extends U>>? super Notification<U>Consumer<? super Notification<U>>BiPredicate<? super U,? super U>Function<? super U,K>Function<? super U,Notification<R>>Function<? super U,? extends Publisher<U>>FlowableTransformer<? super U,? extends R>BiConsumer<? super U,? super U>Flowable<List<U>>Publisher<List<U>>Flowable<U>()AbstractFlowableWithUpstream<T,U>(io.reactivex.rxjava3.core.Flowable)FlowableBufferTimed(io.reactivex.rxjava3.core.Flowable,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.functions.Supplier,int,boolean)restartTimerOnMaxSizemaxSizeopeningIndicatorclosingIndicator"openingIndicator is null"openingIndicator is null"closingIndicator is null"closingIndicator is nullFlowableBufferBoundary<T,U,TOpening,TClosing>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferBoundary.classFlowableBufferBoundary? extends OpenPublisher<? extends Open>? super Open? extends ClosePublisher<? extends Close>? extends Publisher<? extends Close>Function<? super Open,? extends Publisher<? extends Close>>FlowableBufferBoundary<T,U,TOpening,TClosing>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)FlowableBufferBoundary(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)bufferClosebufferOpenboundaryIndicatorinitialCapacity"initialCapacity""boundaryIndicator is null"boundaryIndicator is nullFlowableBufferExactBoundary<T,U,B>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferExactBoundary.classFlowableBufferExactBoundaryFlowableBufferExactBoundary<T,U,B>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Supplier)FlowableBufferExactBoundary(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Supplier)boundary16FlowableCache<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCache.classFlowableCacheFlowableCache<T>(io.reactivex.rxjava3.core.Flowable,int)CacheSubscription<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCache$CacheSubscription.classFlowableCache$CacheSubscriptionFlowableCache<>replay(io.reactivex.rxjava3.internal.operators.flowable.FlowableCache.CacheSubscription)remove(io.reactivex.rxjava3.internal.operators.flowable.FlowableCache.CacheSubscription)addadd(io.reactivex.rxjava3.internal.operators.flowable.FlowableCache.CacheSubscription)cachedEventCountcachedEventCount()hasSubscribershasSubscribers()isConnectedisConnected()FlowableCache(io.reactivex.rxjava3.core.Flowable,int)tailOffsetNode<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCache$Node.classFlowableCache$NodetailheadCacheSubscription[]CacheSubscription<>CacheSubscription<>[]TERMINATEDEMPTYCacheSubscription<T>[]AtomicReference<CacheSubscription<T>[]>capacityHintonceclazz"clazz is null"clazz is nullFunction<T,U>initialItemSuppliercollector"initialItemSupplier is null"initialItemSupplier is null"collector is null"collector is nullFlowableCollectSingle<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCollectSingle.classFlowableCollectSingleFuseToFlowable<U>FlowableCollectSingle<T,U>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiConsumer)SingleObserver<? super U>TestObserver<U>BaseTestConsumer<U,TestObserver<U>>Observer<U>MaybeObserver<U>SingleObserver<U>SingleConverter<U,? extends R>Single<Timed<U>>SingleSource<Timed<U>>BiConsumer<? super U,? super Throwable>Function<? super Throwable,? extends SingleSource<? extends U>>Function<Throwable,? extends U>Single<Notification<U>>SingleSource<Notification<U>>SingleOperator<? extends R,? super U>Function<? super U,? extends ObservableSource<? extends R>>Function<? super U,? extends SingleSource<? extends U>>SingleTransformer<? super U,? extends R>Single<U>()FlowableCollectSingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiConsumer)initialSuppliercomposerFlowableTransformer<T,R>Flowable<Upstream>Publisher<Upstream>apply(io.reactivex.rxjava3.core.Flowable)Publisher<Downstream>"composer is null"composer is null"mapper is null"mapper is nullScalarSupplier<>FlowableConcatMap<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMap.classFlowableConcatMapAbstractFlowableWithUpstream<T,R>FlowableConcatMap<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode)AbstractFlowableWithUpstream<T,R>(io.reactivex.rxjava3.core.Flowable)subscribe(org.reactivestreams.Subscriber,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode)FlowableConcatMap(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode)FlowableConcatMapScheduler<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatMapScheduler.classFlowableConcatMapSchedulerFlowableConcatMapScheduler<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode,io.reactivex.rxjava3.core.Scheduler)FlowableConcatMapScheduler(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode,io.reactivex.rxjava3.core.Scheduler)FlowableConcatMapCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapCompletable.classFlowableConcatMapCompletableFlowableConcatMapCompletable<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)FlowableConcatMapCompletable(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)FlowableConcatMapEager<T,R>FlowableConcatMapEager<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,int,io.reactivex.rxjava3.internal.util.ErrorMode)FlowableFlattenIterable<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlattenIterable.classFlowableFlattenIterableFlowableFlattenIterable<T,R>? extends Iterable<? extends R>Function<? super T,? extends Iterable<? extends R>>FlowableFlattenIterable<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int)subscribe(org.reactivestreams.Subscriber,io.reactivex.rxjava3.functions.Function,int)FlowableFlattenIterable(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int)FlowableConcatMapMaybe<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapMaybe.classFlowableConcatMapMaybeFlowableConcatMapMaybe<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)FlowableConcatMapMaybe(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)FlowableConcatMapSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapSingle.classFlowableConcatMapSingleFlowableConcatMapSingle<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)FlowableConcatMapSingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)FlowableConcatWithSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatWithSingle.classFlowableConcatWithSingleFlowableConcatWithSingle<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.SingleSource)FlowableConcatWithSingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.SingleSource)FlowableConcatWithMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatWithMaybe.classFlowableConcatWithMaybeFlowableConcatWithMaybe<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.MaybeSource)FlowableConcatWithMaybe(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.MaybeSource)FlowableConcatWithCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableConcatWithCompletable.classFlowableConcatWithCompletableFlowableConcatWithCompletable<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.CompletableSource)FlowableConcatWithCompletable(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.CompletableSource)Predicate<Object>FlowableCountSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCountSingle.classFlowableCountSingleFuseToFlowable<Long>FlowableCountSingle<T>(io.reactivex.rxjava3.core.Flowable)SingleObserver<? super Long>TestObserver<Long>BaseTestConsumer<Long,TestObserver<Long>>Observer<Long>MaybeObserver<Long>SingleObserver<Long>SingleConverter<Long,? extends R>Single<Timed<Long>>SingleSource<Timed<Long>>BiConsumer<? super Long,? super Throwable>? extends SingleSource<? extends Long>Function<? super Throwable,? extends SingleSource<? extends Long>>Function<Throwable,? extends Long>Single<Notification<Long>>SingleSource<Notification<Long>>SingleOperator<? extends R,? super Long>Function<? super Long,? extends ObservableSource<? extends R>>Function<? super Long,? extends SingleSource<? extends U>>SingleTransformer<? super Long,? extends R>Single<Long>()FlowableCountSingle(io.reactivex.rxjava3.core.Flowable)debounceIndicator"debounceIndicator is null"debounceIndicator is nullFlowableDebounce<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDebounce.classFlowableDebounceFlowableDebounce<T,U>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableDebounce(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)debounceSelectorFlowableDebounceTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDebounceTimed.classFlowableDebounceTimedFlowableDebounceTimed<T>(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)FlowableDebounceTimed(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)itemDelayIndicator"itemDelayIndicator is null"itemDelayIndicator is nullFunction<T,Publisher<T>>FlowableDelay<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelay.classFlowableDelayFlowableDelay<T>(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)FlowableDelay(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)subscriptionIndicator"subscriptionIndicator is null"subscriptionIndicator is nullFlowableDelaySubscriptionOther<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDelaySubscriptionOther.classFlowableDelaySubscriptionOtherFlowableDelaySubscriptionOther<T,U>(org.reactivestreams.Publisher,org.reactivestreams.Publisher)FlowableDelaySubscriptionOther(org.reactivestreams.Publisher,org.reactivestreams.Publisher)selector"selector is null"selector is nullFlowableDematerialize<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDematerialize.classFlowableDematerialize? extends Notification<R>Function<? super T,? extends Notification<R>>FlowableDematerialize<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableDematerialize(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)Set<T>C:/modules/java.base/java/util/Set.classSetSupplier<Set<T>>keySelectorSet<K>Collection<K>Iterable<K>Supplier<Set<K>>collectionSupplier"keySelector is null"keySelector is null"collectionSupplier is null"collectionSupplier is nullFlowableDistinct<T,K>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDistinct.classFlowableDistinctFlowableDistinct<T,K>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)FlowableDistinct(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)Function<T,T>FlowableDistinctUntilChanged<T,K>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDistinctUntilChanged.classFlowableDistinctUntilChangedBiPredicate<K,K>BiPredicate<? super K,? super K>FlowableDistinctUntilChanged<T,K>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiPredicate)FlowableDistinctUntilChanged(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiPredicate)"comparer is null"comparer is nullFlowableDistinctUntilChanged<T,T>FlowableDoFinally<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDoFinally.classFlowableDoFinallyFlowableDoFinally<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Action)FlowableDoFinally(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Action)onAfterNext"onAfterNext is null"onAfterNext is nullFlowableDoAfterNext<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDoAfterNext.classFlowableDoAfterNextFlowableDoAfterNext<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Consumer)FlowableDoAfterNext(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Consumer)Consumer<T>onCancelConsumer<Subscription>FlowableDoOnEach<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDoOnEach.classFlowableDoOnEachFlowableDoOnEach<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action)FlowableDoOnEach(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action)onNotification"onNotification is null"onNotification is nullonRequest"onRequest is null"onRequest is null"onCancel is null"onCancel is nullFlowableDoOnLifecycle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDoOnLifecycle.classFlowableDoOnLifecycleFlowableDoOnLifecycle<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.LongConsumer,io.reactivex.rxjava3.functions.Action)FlowableDoOnLifecycle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.LongConsumer,io.reactivex.rxjava3.functions.Action)index"index >= 0 required but it was "index >= 0 required but it was FlowableElementAtMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableElementAtMaybe.classFlowableElementAtMaybeFlowableElementAtMaybe<T>(io.reactivex.rxjava3.core.Flowable,long)FlowableElementAtMaybe(io.reactivex.rxjava3.core.Flowable,long)FlowableElementAtSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableElementAtSingle.classFlowableElementAtSingleFlowableElementAtSingle<T>(io.reactivex.rxjava3.core.Flowable,long,java.lang.Object)FlowableElementAtSingle(io.reactivex.rxjava3.core.Flowable,long,java.lang.Object)defaultValueFlowableFilter<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFilter.classFlowableFilterFlowableFilter<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableFilter(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableFlatMap<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMap.classFlowableFlatMapFlowableFlatMap<T,U>FlowableFlatMap<T,U>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean,int,int)subscribe(org.reactivestreams.Subscriber,io.reactivex.rxjava3.functions.Function,boolean,int,int)FlowableFlatMap(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean,int,int)onNextMapperonErrorMapperonCompleteSupplier"onNextMapper is null"onNextMapper is null"onErrorMapper is null"onErrorMapper is null"onCompleteSupplier is null"onCompleteSupplier is nullFlowableMapNotification<T,Publisher<? extends R>>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMapNotification.classFlowableMapNotificationAbstractFlowableWithUpstream<T,Publisher<? extends R>>Flowable<Publisher<? extends R>>Publisher<Publisher<? extends R>>FlowableMapNotification<T,R>Supplier<? extends R>FlowableMapNotification<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)FlowableMapNotification(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)Function<T,Publisher<? extends R>>FlowableFlatMapCompletableCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapCompletableCompletable.classFlowableFlatMapCompletableCompletableFlowableFlatMapCompletableCompletable<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean,int)FlowableFlatMapCompletableCompletable(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean,int)Function<T,Publisher<U>>FlowableFlatMapMaybe<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapMaybe.classFlowableFlatMapMaybeFlowableFlatMapMaybe<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean,int)FlowableFlatMapMaybe(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean,int)FlowableFlatMapSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapSingle.classFlowableFlatMapSingleFlowableFlatMapSingle<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean,int)FlowableFlatMapSingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean,int)ForEachWhileSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/subscribers/ForEachWhileSubscriber.classForEachWhileSubscriberForEachWhileSubscriber<T>(io.reactivex.rxjava3.functions.Predicate,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)weakCompareAndSetReleaseweakCompareAndSetRelease(java.lang.Object,java.lang.Object)weakCompareAndSetRelease(org.reactivestreams.Subscription,org.reactivestreams.Subscription)weakCompareAndSetAcquireweakCompareAndSetAcquire(java.lang.Object,java.lang.Object)weakCompareAndSetAcquire(org.reactivestreams.Subscription,org.reactivestreams.Subscription)weakCompareAndSetVolatileweakCompareAndSetVolatile(java.lang.Object,java.lang.Object)weakCompareAndSetVolatile(org.reactivestreams.Subscription,org.reactivestreams.Subscription)compareAndExchangeReleasecompareAndExchangeRelease(java.lang.Object,java.lang.Object)compareAndExchangeRelease(org.reactivestreams.Subscription,org.reactivestreams.Subscription)compareAndExchangeAcquirecompareAndExchangeAcquire(java.lang.Object,java.lang.Object)compareAndExchangeAcquire(org.reactivestreams.Subscription,org.reactivestreams.Subscription)compareAndExchangecompareAndExchange(java.lang.Object,java.lang.Object)compareAndExchange(org.reactivestreams.Subscription,org.reactivestreams.Subscription)setReleasesetRelease(java.lang.Object)setRelease(org.reactivestreams.Subscription)getAcquiregetAcquire()setOpaquesetOpaque(java.lang.Object)setOpaque(org.reactivestreams.Subscription)getOpaquegetOpaque()setPlainsetPlain(java.lang.Object)setPlain(org.reactivestreams.Subscription)getPlaingetPlain()BinaryOperator<V>C:/modules/java.base/java/util/function/BinaryOperator.classBinaryOperatorBiFunction<V,V,V>accumulateAndGetaccumulateAndGet(java.lang.Object,java.util.function.BinaryOperator)BinaryOperator<Subscription>BiFunction<Subscription,Subscription,Subscription>accumulateAndGet(org.reactivestreams.Subscription,java.util.function.BinaryOperator)getAndAccumulategetAndAccumulate(java.lang.Object,java.util.function.BinaryOperator)getAndAccumulate(org.reactivestreams.Subscription,java.util.function.BinaryOperator)UnaryOperator<V>C:/modules/java.base/java/util/function/UnaryOperator.classUnaryOperatorFunction<V,V>updateAndGetupdateAndGet(java.util.function.UnaryOperator)UnaryOperator<Subscription>Function<Subscription,Subscription>getAndUpdategetAndUpdate(java.util.function.UnaryOperator)getAndSetgetAndSet(java.lang.Object)getAndSet(org.reactivestreams.Subscription)weakCompareAndSetPlainweakCompareAndSetPlain(java.lang.Object,java.lang.Object)weakCompareAndSetPlain(org.reactivestreams.Subscription,org.reactivestreams.Subscription)weakCompareAndSetweakCompareAndSet(java.lang.Object,java.lang.Object)weakCompareAndSet(org.reactivestreams.Subscription,org.reactivestreams.Subscription)compareAndSetcompareAndSet(java.lang.Object,java.lang.Object)compareAndSet(org.reactivestreams.Subscription,org.reactivestreams.Subscription)lazySetlazySet(java.lang.Object)lazySet(org.reactivestreams.Subscription)setset(java.lang.Object)set(org.reactivestreams.Subscription)AtomicReference()AtomicReference<Subscription>()AtomicReference(java.lang.Object)AtomicReference<Subscription>(org.reactivestreams.Subscription)ForEachWhileSubscriber(io.reactivex.rxjava3.functions.Predicate,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)valueSelector"valueSelector is null"valueSelector is nullFlowableGroupBy<T,K,V>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupBy.classFlowableGroupByAbstractFlowableWithUpstream<T,GroupedFlowable<K,V>>FlowableGroupBy<T,K,V>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,int,boolean,io.reactivex.rxjava3.functions.Function)? super GroupedFlowable<K,V>Subscriber<? super GroupedFlowable<K,V>>Function<? super GroupedFlowable<K,V>,? extends Stream<? extends R>>Stream<GroupedFlowable<K,V>>BaseStream<GroupedFlowable<K,V>,Stream<GroupedFlowable<K,V>>>CompletionStage<GroupedFlowable<K,V>>lastStage(io.reactivex.rxjava3.flowables.GroupedFlowable)singleStage(io.reactivex.rxjava3.flowables.GroupedFlowable)firstStage(io.reactivex.rxjava3.flowables.GroupedFlowable)Collector<? super GroupedFlowable<K,V>,A,R>Function<? super GroupedFlowable<K,V>,Optional<? extends R>>TestSubscriber<GroupedFlowable<K,V>>BaseTestConsumer<GroupedFlowable<K,V>,TestSubscriber<GroupedFlowable<K,V>>>FlowableSubscriber<GroupedFlowable<K,V>>Subscriber<GroupedFlowable<K,V>>BiFunction<? super GroupedFlowable<K,V>,? super U,? extends R>Function5<? super GroupedFlowable<K,V>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super GroupedFlowable<K,V>,? super T1,? super T2,? super T3,R>Function3<? super GroupedFlowable<K,V>,? super T1,? super T2,R>Flowable<Flowable<GroupedFlowable<K,V>>>Publisher<Flowable<GroupedFlowable<K,V>>>List<GroupedFlowable<K,V>>Collection<GroupedFlowable<K,V>>Iterable<GroupedFlowable<K,V>>Single<List<GroupedFlowable<K,V>>>SingleSource<List<GroupedFlowable<K,V>>>Comparator<? super GroupedFlowable<K,V>>Observable<GroupedFlowable<K,V>>ObservableSource<GroupedFlowable<K,V>>Function<? super GroupedFlowable<K,V>,? extends K>Function<? super GroupedFlowable<K,V>,? extends V>Map<K,Collection<GroupedFlowable<K,V>>>Single<Map<K,Collection<GroupedFlowable<K,V>>>>SingleSource<Map<K,Collection<GroupedFlowable<K,V>>>>Map<K,GroupedFlowable<K,V>>Single<Map<K,GroupedFlowable<K,V>>>SingleSource<Map<K,GroupedFlowable<K,V>>>FlowableConverter<GroupedFlowable<K,V>,? extends R>Timed<GroupedFlowable<K,V>>Flowable<Timed<GroupedFlowable<K,V>>>Publisher<Timed<GroupedFlowable<K,V>>>Function<? super GroupedFlowable<K,V>,? extends Publisher<V>>? extends GroupedFlowable<K,V>Publisher<? extends GroupedFlowable<K,V>>Predicate<? super GroupedFlowable<K,V>>Function<? super GroupedFlowable<K,V>,? extends SingleSource<? extends R>>Function<? super GroupedFlowable<K,V>,? extends MaybeSource<? extends R>>Function<? super GroupedFlowable<K,V>,? extends Publisher<? extends R>>Function<? super GroupedFlowable<K,V>,? extends CompletableSource>FlowableSubscriber<? super GroupedFlowable<K,V>>Consumer<? super GroupedFlowable<K,V>>GroupedFlowable[]GroupedFlowable<K,V>[]startWithArray(io.reactivex.rxjava3.flowables.GroupedFlowable[])startWithItem(io.reactivex.rxjava3.flowables.GroupedFlowable)MaybeSource<GroupedFlowable<K,V>>SingleSource<GroupedFlowable<K,V>>Iterable<? extends GroupedFlowable<K,V>>Single<GroupedFlowable<K,V>>single(io.reactivex.rxjava3.flowables.GroupedFlowable)Maybe<GroupedFlowable<K,V>>BiFunction<R,? super GroupedFlowable<K,V>,R>BiFunction<GroupedFlowable<K,V>,GroupedFlowable<K,V>,GroupedFlowable<K,V>>ConnectableFlowable<GroupedFlowable<K,V>>? super Flowable<GroupedFlowable<K,V>>Function<? super Flowable<GroupedFlowable<K,V>>,? extends Publisher<R>>Function<? super Flowable<GroupedFlowable<K,V>>,? extends Publisher<? extends R>>ParallelFlowable<GroupedFlowable<K,V>>onErrorReturnItem(io.reactivex.rxjava3.flowables.GroupedFlowable)Function<? super Throwable,? extends GroupedFlowable<K,V>>? extends Publisher<? extends GroupedFlowable<K,V>>Function<? super Throwable,? extends Publisher<? extends GroupedFlowable<K,V>>>MaybeSource<? extends GroupedFlowable<K,V>>SingleSource<? extends GroupedFlowable<K,V>>Notification<GroupedFlowable<K,V>>Flowable<Notification<GroupedFlowable<K,V>>>Publisher<Notification<GroupedFlowable<K,V>>>Function<? super GroupedFlowable<K,V>,? extends R>FlowableOperator<? extends R,? super GroupedFlowable<K,V>>last(io.reactivex.rxjava3.flowables.GroupedFlowable)Function<? super GroupedFlowable<K,V>,? extends Publisher<TLeftEnd>>BiFunction<? super GroupedFlowable<K,V>,? super TRight,? extends R>BiFunction<? super GroupedFlowable<K,V>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,GroupedFlowable<K,V>>Flowable<GroupedFlowable<K,GroupedFlowable<K,V>>>Publisher<GroupedFlowable<K,GroupedFlowable<K,V>>>Function<? super GroupedFlowable<K,V>,? extends Iterable<? extends U>>BiFunction<? super GroupedFlowable<K,V>,? super U,? extends V>Function<? super GroupedFlowable<K,V>,? extends Publisher<? extends U>>first(io.reactivex.rxjava3.flowables.GroupedFlowable)elementAt(long,io.reactivex.rxjava3.flowables.GroupedFlowable)? super Notification<GroupedFlowable<K,V>>Consumer<? super Notification<GroupedFlowable<K,V>>>BiPredicate<? super GroupedFlowable<K,V>,? super GroupedFlowable<K,V>>Function<? super GroupedFlowable<K,V>,K>Function<? super GroupedFlowable<K,V>,Notification<R>>Function<? super GroupedFlowable<K,V>,? extends Publisher<U>>defaultIfEmpty(io.reactivex.rxjava3.flowables.GroupedFlowable)FlowableTransformer<? super GroupedFlowable<K,V>,? extends R>BiConsumer<? super U,? super GroupedFlowable<K,V>>Flowable<List<GroupedFlowable<K,V>>>Publisher<List<GroupedFlowable<K,V>>>Future<GroupedFlowable<K,V>>GroupedFlowable<>blockingSingle(io.reactivex.rxjava3.flowables.GroupedFlowable)blockingMostRecent(io.reactivex.rxjava3.flowables.GroupedFlowable)blockingLast(io.reactivex.rxjava3.flowables.GroupedFlowable)blockingFirst(io.reactivex.rxjava3.flowables.GroupedFlowable)Flowable<GroupedFlowable<K,V>>()AbstractFlowableWithUpstream<T,GroupedFlowable<K,V>>(io.reactivex.rxjava3.core.Flowable)FlowableGroupBy(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,int,boolean,io.reactivex.rxjava3.functions.Function)mapFactoryevictingMapFactory"evictingMapFactory is null"evictingMapFactory is nullleftEndrightEndresultSelector"leftEnd is null"leftEnd is null"rightEnd is null"rightEnd is null"resultSelector is null"resultSelector is nullFlowableGroupJoin<T,TRight,TLeftEnd,TRightEnd,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoin.classFlowableGroupJoinFlowableGroupJoin<TLeft,TRight,TLeftEnd,TRightEnd,R>AbstractFlowableWithUpstream<TLeft,R>HasUpstreamPublisher<TLeft>Flowable<TLeft>Publisher<TLeft>? super TLeftFunction<? super TLeft,? extends Publisher<TLeftEnd>>BiFunction<? super TLeft,? super Flowable<TRight>,? extends R>FlowableGroupJoin<TLeft,TRight,TLeftEnd,TRightEnd,R>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)AbstractFlowableWithUpstream<TLeft,R>(io.reactivex.rxjava3.core.Flowable)FlowableGroupJoin(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)FlowableHide<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableHide.classFlowableHideFlowableHide<T>(io.reactivex.rxjava3.core.Flowable)FlowableHide(io.reactivex.rxjava3.core.Flowable)FlowableIgnoreElementsCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableIgnoreElementsCompletable.classFlowableIgnoreElementsCompletableFlowableIgnoreElementsCompletable<T>(io.reactivex.rxjava3.core.Flowable)FlowableIgnoreElementsCompletable(io.reactivex.rxjava3.core.Flowable)FlowableJoin<T,TRight,TLeftEnd,TRightEnd,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableJoin.classFlowableJoinBiFunction<? super TLeft,? super TRight,? extends R>FlowableJoin<T,TRight,TLeftEnd,TRightEnd,R>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)FlowableJoin(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)FlowableLastMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableLastMaybe.classFlowableLastMaybeFlowableLastMaybe<T>(org.reactivestreams.Publisher)FlowableLastMaybe(org.reactivestreams.Publisher)FlowableLastSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableLastSingle.classFlowableLastSingleFlowableLastSingle<T>(org.reactivestreams.Publisher,java.lang.Object)FlowableLastSingle(org.reactivestreams.Publisher,java.lang.Object)lifter"lifter is null"lifter is nullFlowableLift<R,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableLift.classFlowableLiftFlowableLift<R,T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.FlowableOperator)FlowableLift(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.FlowableOperator)operatorFlowableMap<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMap.classFlowableMapFlowableMap<T,U>FlowableMap<T,U>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableMap(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableMaterialize<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMaterialize.classFlowableMaterializeAbstractFlowableWithUpstream<T,Notification<T>>FlowableMaterialize<T>(io.reactivex.rxjava3.core.Flowable)Subscriber<? super Notification<T>>Stream<Notification<T>>BaseStream<Notification<T>,Stream<Notification<T>>>lastStage(io.reactivex.rxjava3.core.Notification)singleStage(io.reactivex.rxjava3.core.Notification)firstStage(io.reactivex.rxjava3.core.Notification)Collector<? super Notification<T>,A,R>TestSubscriber<Notification<T>>BaseTestConsumer<Notification<T>,TestSubscriber<Notification<T>>>FlowableSubscriber<Notification<T>>Subscriber<Notification<T>>Function5<? super Notification<T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super Notification<T>,? super T1,? super T2,? super T3,R>Function3<? super Notification<T>,? super T1,? super T2,R>Flowable<Flowable<Notification<T>>>Publisher<Flowable<Notification<T>>>List<Notification<T>>Collection<Notification<T>>Iterable<Notification<T>>Single<List<Notification<T>>>SingleSource<List<Notification<T>>>Comparator<? super Notification<T>>Function<? super Notification<T>,? extends K>Function<? super Notification<T>,? extends V>Map<K,Collection<Notification<T>>>Single<Map<K,Collection<Notification<T>>>>SingleSource<Map<K,Collection<Notification<T>>>>Map<K,Notification<T>>Single<Map<K,Notification<T>>>SingleSource<Map<K,Notification<T>>>FlowableConverter<Notification<T>,? extends R>Flowable<Timed<Notification<T>>>Publisher<Timed<Notification<T>>>Function<? super Notification<T>,? extends Publisher<V>>Publisher<? extends Notification<T>>FlowableSubscriber<? super Notification<T>>Notification[]Notification<T>[]startWithArray(io.reactivex.rxjava3.core.Notification[])startWithItem(io.reactivex.rxjava3.core.Notification)Iterable<? extends Notification<T>>single(io.reactivex.rxjava3.core.Notification)BiFunction<R,? super Notification<T>,R>BiFunction<Notification<T>,Notification<T>,Notification<T>>ConnectableFlowable<Notification<T>>? super Flowable<Notification<T>>Function<? super Flowable<Notification<T>>,? extends Publisher<R>>Function<? super Flowable<Notification<T>>,? extends Publisher<? extends R>>ParallelFlowable<Notification<T>>Function<? super Throwable,? extends Notification<T>>? extends Publisher<? extends Notification<T>>Function<? super Throwable,? extends Publisher<? extends Notification<T>>>MaybeSource<? extends Notification<T>>Flowable<Notification<Notification<T>>>Publisher<Notification<Notification<T>>>FlowableOperator<? extends R,? super Notification<T>>last(io.reactivex.rxjava3.core.Notification)Function<? super Notification<T>,? extends Publisher<TLeftEnd>>BiFunction<? super Notification<T>,? super TRight,? extends R>BiFunction<? super Notification<T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,Notification<T>>Flowable<GroupedFlowable<K,Notification<T>>>Publisher<GroupedFlowable<K,Notification<T>>>BiFunction<? super Notification<T>,? super U,? extends V>Function<? super Notification<T>,? extends Publisher<? extends U>>first(io.reactivex.rxjava3.core.Notification)elementAt(long,io.reactivex.rxjava3.core.Notification)? super Notification<Notification<T>>Consumer<? super Notification<Notification<T>>>BiPredicate<? super Notification<T>,? super Notification<T>>Function<? super Notification<T>,K>Function<? super Notification<T>,? extends Publisher<U>>defaultIfEmpty(io.reactivex.rxjava3.core.Notification)FlowableTransformer<? super Notification<T>,? extends R>BiConsumer<? super U,? super Notification<T>>Flowable<List<Notification<T>>>Publisher<List<Notification<T>>>blockingSingle(io.reactivex.rxjava3.core.Notification)blockingMostRecent(io.reactivex.rxjava3.core.Notification)blockingLast(io.reactivex.rxjava3.core.Notification)blockingFirst(io.reactivex.rxjava3.core.Notification)Flowable<Notification<T>>()AbstractFlowableWithUpstream<T,Notification<T>>(io.reactivex.rxjava3.core.Flowable)FlowableMaterialize(io.reactivex.rxjava3.core.Flowable)FlowableMergeWithSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMergeWithSingle.classFlowableMergeWithSingleFlowableMergeWithSingle<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.SingleSource)FlowableMergeWithSingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.SingleSource)FlowableMergeWithMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMergeWithMaybe.classFlowableMergeWithMaybeFlowableMergeWithMaybe<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.MaybeSource)FlowableMergeWithMaybe(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.MaybeSource)FlowableMergeWithCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableMergeWithCompletable.classFlowableMergeWithCompletableFlowableMergeWithCompletable<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.CompletableSource)FlowableMergeWithCompletable(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.CompletableSource)FlowableObserveOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableObserveOn.classFlowableObserveOnFlowableObserveOn<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.Scheduler,boolean,int)FlowableObserveOn(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.Scheduler,boolean,int)capacityunbounded"capacity"FlowableOnBackpressureBuffer<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureBuffer.classFlowableOnBackpressureBufferFlowableOnBackpressureBuffer<T>(io.reactivex.rxjava3.core.Flowable,int,boolean,boolean,io.reactivex.rxjava3.functions.Action)FlowableOnBackpressureBuffer(io.reactivex.rxjava3.core.Flowable,int,boolean,boolean,io.reactivex.rxjava3.functions.Action)onOverflow"onOverflow is null"onOverflow is nulloverflowStrategy"overflowStrategy is null"overflowStrategy is nullFlowableOnBackpressureBufferStrategy<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.classFlowableOnBackpressureBufferStrategyFlowableOnBackpressureBufferStrategy<T>(io.reactivex.rxjava3.core.Flowable,long,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.core.BackpressureOverflowStrategy)FlowableOnBackpressureBufferStrategy(io.reactivex.rxjava3.core.Flowable,long,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.core.BackpressureOverflowStrategy)FlowableOnBackpressureDrop<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureDrop.classFlowableOnBackpressureDropFlowableOnBackpressureDrop<T>(io.reactivex.rxjava3.core.Flowable)FlowableOnBackpressureDrop(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Consumer)FlowableOnBackpressureDrop<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Consumer)FlowableOnBackpressureDrop(io.reactivex.rxjava3.core.Flowable)onDrop"onDrop is null"onDrop is nullFlowableOnBackpressureLatest<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureLatest.classFlowableOnBackpressureLatestFlowableOnBackpressureLatest<T>(io.reactivex.rxjava3.core.Flowable)FlowableOnBackpressureLatest(io.reactivex.rxjava3.core.Flowable)reducer"reducer is null"reducer is nullFlowableOnBackpressureReduce<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureReduce.classFlowableOnBackpressureReduceFlowableOnBackpressureReduce<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiFunction)FlowableOnBackpressureReduce(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiFunction)FlowableOnBackpressureReduceWith<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnBackpressureReduceWith.classFlowableOnBackpressureReduceWithFlowableOnBackpressureReduceWith<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)FlowableOnBackpressureReduceWith(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)FlowableOnErrorComplete<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnErrorComplete.classFlowableOnErrorCompleteFlowableOnErrorComplete<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableOnErrorComplete(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableOnErrorNext<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnErrorNext.classFlowableOnErrorNextFlowableOnErrorNext<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableOnErrorNext(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)nextSupplierFunction<Throwable,Publisher<? extends T>>FlowableOnErrorReturn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableOnErrorReturn.classFlowableOnErrorReturnFlowableOnErrorReturn<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableOnErrorReturn(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableDetach<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableDetach.classFlowableDetachFlowableDetach<T>(io.reactivex.rxjava3.core.Flowable)FlowableDetach(io.reactivex.rxjava3.core.Flowable)fromfrom(org.reactivestreams.Publisher)Collector<T,A,R>mapOptional(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)BiFunction<? super Long,? super Throwable,ParallelFailureHandling>mapOptional(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.parallel.ParallelFailureHandling)concatMapDelayError(io.reactivex.rxjava3.functions.Function,int,boolean)concatMapDelayError(io.reactivex.rxjava3.functions.Function,boolean)ParallelTransformer<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/parallel/ParallelTransformer.classParallelTransformercompose(io.reactivex.rxjava3.parallel.ParallelTransformer)ParallelTransformer<T,U>ParallelFlowableConverter<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/parallel/ParallelFlowableConverter.classParallelFlowableConverterto(io.reactivex.rxjava3.parallel.ParallelFlowableConverter)ParallelFlowableConverter<T,R>fromArray(org.reactivestreams.Publisher[])Publisher<T>[]CSupplier<? extends C>BiConsumer<? super C,? super T>doAfterTerminateddoAfterTerminated(io.reactivex.rxjava3.functions.Action)doOnNext(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.BiFunction)doOnNext(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.parallel.ParallelFailureHandling)sorted(java.util.Comparator,int)sequentialDelayErrorsequentialDelayError(int)sequentialDelayError()sequentialsequential(int)sequential()reduce(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)runOnrunOn(io.reactivex.rxjava3.core.Scheduler,int)runOn(io.reactivex.rxjava3.core.Scheduler)filter(io.reactivex.rxjava3.functions.Predicate,io.reactivex.rxjava3.functions.BiFunction)filter(io.reactivex.rxjava3.functions.Predicate,io.reactivex.rxjava3.parallel.ParallelFailureHandling)map(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)map(io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.parallel.ParallelFailureHandling)from(org.reactivestreams.Publisher,int,int)from(org.reactivestreams.Publisher,int)Subscriber[]Subscriber<?>Subscriber<?>[]validatevalidate(org.reactivestreams.Subscriber[])Subscriber<>[]parallelismparallelism()Subscriber<? super T>[]subscribe(org.reactivestreams.Subscriber[])ParallelFlowable()ParallelFlowable<>()FlowablePublishMulticast<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowablePublishMulticast.classFlowablePublishMulticastFlowablePublishMulticast<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,boolean)FlowablePublishMulticast(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,boolean)FlowablePublish<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowablePublish.classFlowablePublishFlowablePublish<T>(org.reactivestreams.Publisher,int)autoConnectautoConnect(int,io.reactivex.rxjava3.functions.Consumer)autoConnect(int)autoConnect()refCountrefCount(int,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)refCount(int,long,java.util.concurrent.TimeUnit)refCount(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)refCount(long,java.util.concurrent.TimeUnit)refCount(int)refCount()connectconnect()resetreset()connect(io.reactivex.rxjava3.functions.Consumer)ConnectableFlowable()ConnectableFlowable<T>()FlowablePublish(org.reactivestreams.Publisher,int)PublishConnection<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowablePublish$PublishConnection.classFlowablePublish$PublishConnectionFlowablePublish<>AtomicReference<PublishConnection<T>>currentnFlowableReduceMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReduceMaybe.classFlowableReduceMaybeFlowableReduceMaybe<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiFunction)FlowableReduceMaybe(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiFunction)seed"seed is null"seed is nullFlowableReduceSeedSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReduceSeedSingle.classFlowableReduceSeedSingleFlowableReduceSeedSingle<T,R>(org.reactivestreams.Publisher,java.lang.Object,io.reactivex.rxjava3.functions.BiFunction)SingleObserver<? super R>SingleConverter<R,? extends R>Single<Timed<R>>SingleSource<Timed<R>>BiConsumer<? super R,? super Throwable>Function<Throwable,? extends R>Single<Notification<R>>SingleSource<Notification<R>>SingleOperator<? extends R,? super R>Function<? super R,? extends SingleSource<? extends U>>SingleTransformer<? super R,? extends R>Single<R>()FlowableReduceSeedSingle(org.reactivestreams.Publisher,java.lang.Object,io.reactivex.rxjava3.functions.BiFunction)seedSupplier"seedSupplier is null"seedSupplier is nullFlowableReduceWithSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReduceWithSingle.classFlowableReduceWithSingleFlowableReduceWithSingle<T,R>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)FlowableReduceWithSingle(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)"times >= 0 required but it was "times >= 0 required but it was FlowableRepeat<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRepeat.classFlowableRepeatFlowableRepeat<T>(io.reactivex.rxjava3.core.Flowable,long)FlowableRepeat(io.reactivex.rxjava3.core.Flowable,long)FlowableRepeatUntil<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRepeatUntil.classFlowableRepeatUntilFlowableRepeatUntil<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BooleanSupplier)FlowableRepeatUntil(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BooleanSupplier)until"handler is null"handler is nullFlowableRepeatWhen<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRepeatWhen.classFlowableRepeatWhenFlowableRepeatWhen<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableRepeatWhen(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableReplay<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReplay.classFlowableReplaycreateFromcreateFrom(io.reactivex.rxjava3.core.Flowable)Flowable<? extends T>ConnectableFlowable<>()create(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier)ReplayBuffer<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReplay$ReplayBuffer.classFlowableReplay$ReplayBuffer? extends ReplayBuffer<T>Supplier<? extends ReplayBuffer<T>>create(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)create(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)create(io.reactivex.rxjava3.core.Flowable,int,boolean)multicastSelectormulticastSelector(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function)? extends ConnectableFlowable<U>Supplier<? extends ConnectableFlowable<U>>DEFAULT_UNBOUNDED_FACTORYbufferFactoryReplaySubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableReplay$ReplaySubscriber.classFlowableReplay$ReplaySubscriberAtomicReference<ReplaySubscriber<T>>Supplier<ConnectableFlowable<T>>eagerTruncateFlowableRetryBiPredicate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryBiPredicate.classFlowableRetryBiPredicateFlowableRetryBiPredicate<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiPredicate)FlowableRetryBiPredicate(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiPredicate)FlowableRetryPredicate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryPredicate.classFlowableRetryPredicateFlowableRetryPredicate<T>(io.reactivex.rxjava3.core.Flowable,long,io.reactivex.rxjava3.functions.Predicate)FlowableRetryPredicate(io.reactivex.rxjava3.core.Flowable,long,io.reactivex.rxjava3.functions.Predicate)FlowableRetryWhen<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableRetryWhen.classFlowableRetryWhenFlowableRetryWhen<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableRetryWhen(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)SafeSubscriber<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/subscribers/SafeSubscriber.classSafeSubscriberSafeSubscriber<? super T>SafeSubscriber<T>SafeSubscriber<T>(org.reactivestreams.Subscriber)onCompleteNoSubscriptiononCompleteNoSubscription()onNextNoSubscriptiononNextNoSubscription()SafeSubscriber(org.reactivestreams.Subscriber)downstreamemitLastFlowableSampleTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSampleTimed.classFlowableSampleTimedFlowableSampleTimed<T>(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)FlowableSampleTimed(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)sampler"sampler is null"sampler is nullFlowableSamplePublisher<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSamplePublisher.classFlowableSamplePublisherFlowableSamplePublisher<T>(org.reactivestreams.Publisher,org.reactivestreams.Publisher,boolean)FlowableSamplePublisher(org.reactivestreams.Publisher,org.reactivestreams.Publisher,boolean)accumulator"accumulator is null"accumulator is nullFlowableScan<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableScan.classFlowableScanFlowableScan<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiFunction)FlowableScan(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiFunction)"initialValue is null"initialValue is nullFlowableScanSeed<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableScanSeed.classFlowableScanSeedFlowableScanSeed<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)FlowableScanSeed(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)FlowableSerialized<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSerialized.classFlowableSerializedFlowableSerialized<T>(io.reactivex.rxjava3.core.Flowable)FlowableSerialized(io.reactivex.rxjava3.core.Flowable)FlowableSingleMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSingleMaybe.classFlowableSingleMaybeFlowableSingleMaybe<T>(io.reactivex.rxjava3.core.Flowable)FlowableSingleMaybe(io.reactivex.rxjava3.core.Flowable)FlowableSingleSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSingleSingle.classFlowableSingleSingleFlowableSingleSingle<T>(io.reactivex.rxjava3.core.Flowable,java.lang.Object)FlowableSingleSingle(io.reactivex.rxjava3.core.Flowable,java.lang.Object)"count >= 0 expected but it was "count >= 0 expected but it was FlowableSkip<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkip.classFlowableSkipFlowableSkip<T>(io.reactivex.rxjava3.core.Flowable,long)FlowableSkip(io.reactivex.rxjava3.core.Flowable,long)FlowableSkipLast<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipLast.classFlowableSkipLastFlowableSkipLast<T>(io.reactivex.rxjava3.core.Flowable,int)FlowableSkipLast(io.reactivex.rxjava3.core.Flowable,int)FlowableSkipLastTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipLastTimed.classFlowableSkipLastTimedFlowableSkipLastTimed<T>(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)FlowableSkipLastTimed(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)FlowableSkipUntil<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipUntil.classFlowableSkipUntilFlowableSkipUntil<T,U>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher)FlowableSkipUntil(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher)FlowableSkipWhile<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSkipWhile.classFlowableSkipWhileFlowableSkipWhile<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableSkipWhile(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)? super List<T>Function<? super List<T>,? extends Iterable<? extends U>>Subscriber<? super List<T>>Function<? super List<T>,? extends Stream<? extends R>>Stream<List<T>>BaseStream<List<T>,Stream<List<T>>>CompletionStage<List<T>>lastStage(java.util.List)singleStage(java.util.List)firstStage(java.util.List)Collector<? super List<T>,A,R>Function<? super List<T>,Optional<? extends R>>TestSubscriber<List<T>>BaseTestConsumer<List<T>,TestSubscriber<List<T>>>FlowableSubscriber<List<T>>Subscriber<List<T>>BiFunction<? super List<T>,? super U,? extends R>Function5<? super List<T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super List<T>,? super T1,? super T2,? super T3,R>Function3<? super List<T>,? super T1,? super T2,R>Flowable<Flowable<List<T>>>Publisher<Flowable<List<T>>>List<List<T>>Collection<List<T>>Iterable<List<T>>Single<List<List<T>>>SingleSource<List<List<T>>>Comparator<? super List<T>>Function<? super List<T>,? extends K>Function<? super List<T>,? extends V>Map<K,Collection<List<T>>>Single<Map<K,Collection<List<T>>>>SingleSource<Map<K,Collection<List<T>>>>Map<K,List<T>>Single<Map<K,List<T>>>SingleSource<Map<K,List<T>>>FlowableConverter<List<T>,? extends R>Timed<List<T>>Flowable<Timed<List<T>>>Publisher<Timed<List<T>>>Function<? super List<T>,? extends Publisher<V>>? extends List<T>Publisher<? extends List<T>>Predicate<? super List<T>>Function<? super List<T>,? extends SingleSource<? extends R>>Function<? super List<T>,? extends MaybeSource<? extends R>>Function<? super List<T>,? extends Publisher<? extends R>>Function<? super List<T>,? extends CompletableSource>FlowableSubscriber<? super List<T>>Consumer<? super List<T>>List[]List<T>[]startWithArray(java.util.List[])startWithItem(java.util.List)MaybeSource<List<T>>Iterable<? extends List<T>>single(java.util.List)Maybe<List<T>>BiFunction<R,? super List<T>,R>BiFunction<List<T>,List<T>,List<T>>ConnectableFlowable<List<T>>? super Flowable<List<T>>Function<? super Flowable<List<T>>,? extends Publisher<R>>Function<? super Flowable<List<T>>,? extends Publisher<? extends R>>ParallelFlowable<List<T>>onErrorReturnItem(java.util.List)Function<? super Throwable,? extends List<T>>? extends Publisher<? extends List<T>>Function<? super Throwable,? extends Publisher<? extends List<T>>>MaybeSource<? extends List<T>>SingleSource<? extends List<T>>Notification<List<T>>Flowable<Notification<List<T>>>Publisher<Notification<List<T>>>Function<? super List<T>,? extends R>FlowableOperator<? extends R,? super List<T>>last(java.util.List)Function<? super List<T>,? extends Publisher<TLeftEnd>>BiFunction<? super List<T>,? super TRight,? extends R>BiFunction<? super List<T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,List<T>>Flowable<GroupedFlowable<K,List<T>>>Publisher<GroupedFlowable<K,List<T>>>BiFunction<? super List<T>,? super U,? extends V>Function<? super List<T>,? extends Publisher<? extends U>>first(java.util.List)elementAt(long,java.util.List)? super Notification<List<T>>Consumer<? super Notification<List<T>>>BiPredicate<? super List<T>,? super List<T>>Function<? super List<T>,K>Function<? super List<T>,Notification<R>>Function<? super List<T>,? extends Publisher<U>>defaultIfEmpty(java.util.List)FlowableTransformer<? super List<T>,? extends R>BiConsumer<? super U,? super List<T>>Flowable<List<List<T>>>Publisher<List<List<T>>>Future<List<T>>blockingSingle(java.util.List)blockingMostRecent(java.util.List)blockingLast(java.util.List)blockingFirst(java.util.List)Flowable<List<T>>()Function<List<T>,List<T>>SingleObserver<? super List<T>>TestObserver<List<T>>BaseTestConsumer<List<T>,TestObserver<List<T>>>Observer<List<T>>MaybeObserver<List<T>>SingleObserver<List<T>>SingleConverter<List<T>,? extends R>Single<Timed<List<T>>>SingleSource<Timed<List<T>>>BiConsumer<? super List<T>,? super Throwable>? extends SingleSource<? extends List<T>>Function<? super Throwable,? extends SingleSource<? extends List<T>>>Function<Throwable,? extends List<T>>Single<Notification<List<T>>>SingleSource<Notification<List<T>>>SingleOperator<? extends R,? super List<T>>Function<? super List<T>,? extends ObservableSource<? extends R>>Function<? super List<T>,? extends SingleSource<? extends U>>SingleTransformer<? super List<T>,? extends R>Single<List<T>>()Comparator<T>comparator"comparator is null"comparator is nullLambdaSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/subscribers/LambdaSubscriber.classLambdaSubscriberlsLambdaSubscriber<T>(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Consumer)hasCustomOnErrorhasCustomOnError()LambdaSubscriber(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Consumer)StrictSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/subscribers/StrictSubscriber.classStrictSubscriberStrictSubscriber<T>(org.reactivestreams.Subscriber)StrictSubscriber(org.reactivestreams.Subscriber)requestedflowableSubscriber"The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"Actually not, but can't throw other exceptions due to RS"Actually not, but can't throw other exceptions due to RSFlowableCreate<>requestOnFlowableSubscribeOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSubscribeOn.classFlowableSubscribeOnFlowableSubscribeOn<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.Scheduler,boolean)FlowableSubscribeOn(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.Scheduler,boolean)nonScheduledRequestsFlowableSwitchIfEmpty<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchIfEmpty.classFlowableSwitchIfEmptyFlowableSwitchIfEmpty<T>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher)FlowableSwitchIfEmpty(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher)FlowableSwitchMapCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableSwitchMapCompletable.classFlowableSwitchMapCompletableFlowableSwitchMapCompletable<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean)FlowableSwitchMapCompletable(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean)FlowableSwitchMap<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableSwitchMap.classFlowableSwitchMapFlowableSwitchMap<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,boolean)FlowableSwitchMap(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int,boolean)FlowableSwitchMapMaybe<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableSwitchMapMaybe.classFlowableSwitchMapMaybeFlowableSwitchMapMaybe<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean)FlowableSwitchMapMaybe(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean)FlowableSwitchMapSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableSwitchMapSingle.classFlowableSwitchMapSingleFlowableSwitchMapSingle<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean)FlowableSwitchMapSingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,boolean)FlowableTake<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTake.classFlowableTakeFlowableTake<T>(io.reactivex.rxjava3.core.Flowable,long)FlowableTake(io.reactivex.rxjava3.core.Flowable,long)FlowableIgnoreElements<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableIgnoreElements.classFlowableIgnoreElementsFlowableIgnoreElements<T>(io.reactivex.rxjava3.core.Flowable)FlowableIgnoreElements(io.reactivex.rxjava3.core.Flowable)FlowableTakeLastOne<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastOne.classFlowableTakeLastOneFlowableTakeLastOne<T>(io.reactivex.rxjava3.core.Flowable)FlowableTakeLastOne(io.reactivex.rxjava3.core.Flowable)FlowableTakeLast<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLast.classFlowableTakeLastFlowableTakeLast<T>(io.reactivex.rxjava3.core.Flowable,int)FlowableTakeLast(io.reactivex.rxjava3.core.Flowable,int)FlowableTakeLastTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeLastTimed.classFlowableTakeLastTimedFlowableTakeLastTimed<T>(io.reactivex.rxjava3.core.Flowable,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)FlowableTakeLastTimed(io.reactivex.rxjava3.core.Flowable,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)stopPredicate"stopPredicate is null"stopPredicate is nullFlowableTakeUntilPredicate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeUntilPredicate.classFlowableTakeUntilPredicateFlowableTakeUntilPredicate<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableTakeUntilPredicate(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableTakeUntil<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeUntil.classFlowableTakeUntilFlowableTakeUntil<T,U>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher)FlowableTakeUntil(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher)FlowableTakeWhile<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTakeWhile.classFlowableTakeWhileFlowableTakeWhile<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)FlowableTakeWhile(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Predicate)windowDurationskipDurationFlowableThrottleFirstTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleFirstTimed.classFlowableThrottleFirstTimedFlowableThrottleFirstTimed<T>(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)FlowableThrottleFirstTimed(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)intervalDurationFlowableThrottleLatest<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableThrottleLatest.classFlowableThrottleLatestFlowableThrottleLatest<T>(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)FlowableThrottleLatest(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)FlowableTimeInterval<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimeInterval.classFlowableTimeIntervalAbstractFlowableWithUpstream<T,Timed<T>>FlowableTimeInterval<T>(io.reactivex.rxjava3.core.Flowable,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)? super Timed<T>Subscriber<? super Timed<T>>Function<? super Timed<T>,? extends Stream<? extends R>>Stream<Timed<T>>BaseStream<Timed<T>,Stream<Timed<T>>>CompletionStage<Timed<T>>lastStage(io.reactivex.rxjava3.schedulers.Timed)singleStage(io.reactivex.rxjava3.schedulers.Timed)firstStage(io.reactivex.rxjava3.schedulers.Timed)Collector<? super Timed<T>,A,R>Function<? super Timed<T>,Optional<? extends R>>TestSubscriber<Timed<T>>BaseTestConsumer<Timed<T>,TestSubscriber<Timed<T>>>FlowableSubscriber<Timed<T>>Subscriber<Timed<T>>BiFunction<? super Timed<T>,? super U,? extends R>Function5<? super Timed<T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super Timed<T>,? super T1,? super T2,? super T3,R>Function3<? super Timed<T>,? super T1,? super T2,R>Flowable<Flowable<Timed<T>>>Publisher<Flowable<Timed<T>>>List<Timed<T>>Collection<Timed<T>>Iterable<Timed<T>>Single<List<Timed<T>>>SingleSource<List<Timed<T>>>Comparator<? super Timed<T>>Function<? super Timed<T>,? extends K>Function<? super Timed<T>,? extends V>Map<K,Collection<Timed<T>>>Single<Map<K,Collection<Timed<T>>>>SingleSource<Map<K,Collection<Timed<T>>>>Map<K,Timed<T>>Single<Map<K,Timed<T>>>SingleSource<Map<K,Timed<T>>>FlowableConverter<Timed<T>,? extends R>Timed<Timed<T>>Flowable<Timed<Timed<T>>>Publisher<Timed<Timed<T>>>Function<? super Timed<T>,? extends Publisher<V>>? extends Timed<T>Publisher<? extends Timed<T>>Predicate<? super Timed<T>>Function<? super Timed<T>,? extends SingleSource<? extends R>>Function<? super Timed<T>,? extends MaybeSource<? extends R>>Function<? super Timed<T>,? extends Publisher<? extends R>>Function<? super Timed<T>,? extends CompletableSource>FlowableSubscriber<? super Timed<T>>Consumer<? super Timed<T>>Timed[]Timed<T>[]startWithArray(io.reactivex.rxjava3.schedulers.Timed[])startWithItem(io.reactivex.rxjava3.schedulers.Timed)Iterable<? extends Timed<T>>single(io.reactivex.rxjava3.schedulers.Timed)BiFunction<R,? super Timed<T>,R>BiFunction<Timed<T>,Timed<T>,Timed<T>>ConnectableFlowable<Timed<T>>? super Flowable<Timed<T>>Function<? super Flowable<Timed<T>>,? extends Publisher<R>>Function<? super Flowable<Timed<T>>,? extends Publisher<? extends R>>ParallelFlowable<Timed<T>>onErrorReturnItem(io.reactivex.rxjava3.schedulers.Timed)Function<? super Throwable,? extends Timed<T>>? extends Publisher<? extends Timed<T>>Function<? super Throwable,? extends Publisher<? extends Timed<T>>>MaybeSource<? extends Timed<T>>SingleSource<? extends Timed<T>>Notification<Timed<T>>Flowable<Notification<Timed<T>>>Publisher<Notification<Timed<T>>>Function<? super Timed<T>,? extends R>FlowableOperator<? extends R,? super Timed<T>>last(io.reactivex.rxjava3.schedulers.Timed)Function<? super Timed<T>,? extends Publisher<TLeftEnd>>BiFunction<? super Timed<T>,? super TRight,? extends R>BiFunction<? super Timed<T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,Timed<T>>Flowable<GroupedFlowable<K,Timed<T>>>Publisher<GroupedFlowable<K,Timed<T>>>Function<? super Timed<T>,? extends Iterable<? extends U>>BiFunction<? super Timed<T>,? super U,? extends V>Function<? super Timed<T>,? extends Publisher<? extends U>>first(io.reactivex.rxjava3.schedulers.Timed)elementAt(long,io.reactivex.rxjava3.schedulers.Timed)? super Notification<Timed<T>>Consumer<? super Notification<Timed<T>>>BiPredicate<? super Timed<T>,? super Timed<T>>Function<? super Timed<T>,K>Function<? super Timed<T>,Notification<R>>Function<? super Timed<T>,? extends Publisher<U>>defaultIfEmpty(io.reactivex.rxjava3.schedulers.Timed)FlowableTransformer<? super Timed<T>,? extends R>BiConsumer<? super U,? super Timed<T>>Flowable<List<Timed<T>>>Publisher<List<Timed<T>>>Future<Timed<T>>Timed<>blockingSingle(io.reactivex.rxjava3.schedulers.Timed)blockingMostRecent(io.reactivex.rxjava3.schedulers.Timed)blockingLast(io.reactivex.rxjava3.schedulers.Timed)blockingFirst(io.reactivex.rxjava3.schedulers.Timed)Flowable<Timed<T>>()AbstractFlowableWithUpstream<T,Timed<T>>(io.reactivex.rxjava3.core.Flowable)FlowableTimeInterval(io.reactivex.rxjava3.core.Flowable,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)itemTimeoutIndicatorfirstTimeoutIndicator"firstTimeoutIndicator is null"firstTimeoutIndicator is nullFlowableTimeoutTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimeoutTimed.classFlowableTimeoutTimedFlowableTimeoutTimed<T>(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,org.reactivestreams.Publisher)FlowableTimeoutTimed(io.reactivex.rxjava3.core.Flowable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,org.reactivestreams.Publisher)"itemTimeoutIndicator is null"itemTimeoutIndicator is nullFlowableTimeout<T,U,V>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableTimeout.classFlowableTimeoutFlowableTimeout<T,U,V>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,org.reactivestreams.Publisher)FlowableTimeout(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,org.reactivestreams.Publisher)Function<T,Timed<T>>FlowableToListSingle<T,List<T>>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableToListSingle.classFlowableToListSingleFuseToFlowable<List<T>>FlowableToListSingle<T,U>FlowableToListSingle<T,U>(io.reactivex.rxjava3.core.Flowable)FlowableToListSingle(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier)FlowableToListSingle<T,U>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Supplier)FlowableToListSingle(io.reactivex.rxjava3.core.Flowable)"capacityHint"Supplier<Map<K,T>>BiConsumer<Map<K,T>,T>Supplier<Map<K,V>>BiConsumer<Map<K,V>,T>mapSupplierSupplier<Map<K,Collection<T>>>Function<K,List<T>>collectionFactoryList<V>Function<K,List<V>>"mapSupplier is null"mapSupplier is null"collectionFactory is null"collectionFactory is nullBiConsumer<Map<K,Collection<V>>,T>io.reactivex.rxjava3.internal.operators.observableObservableFromPublisher<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromPublisher.classObservableFromPublisherC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observableObservableFromPublisher<T>(org.reactivestreams.Publisher)ObservableFromPublisher(org.reactivestreams.Publisher)FlowableUnsubscribeOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableUnsubscribeOn.classFlowableUnsubscribeOnFlowableUnsubscribeOn<T>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.Scheduler)FlowableUnsubscribeOn(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.core.Scheduler)FlowableWindow<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindow.classFlowableWindowAbstractFlowableWithUpstream<T,Flowable>AbstractFlowableWithUpstream<T,Flowable<T>>FlowableWindow<T>(io.reactivex.rxjava3.core.Flowable,long,long,int)Subscriber<? super Flowable<T>>Function<? super Flowable<T>,? extends Stream<? extends R>>Stream<Flowable<T>>BaseStream<Flowable<T>,Stream<Flowable<T>>>CompletionStage<Flowable<T>>lastStage(io.reactivex.rxjava3.core.Flowable)singleStage(io.reactivex.rxjava3.core.Flowable)firstStage(io.reactivex.rxjava3.core.Flowable)Collector<? super Flowable<T>,A,R>Function<? super Flowable<T>,Optional<? extends R>>TestSubscriber<Flowable<T>>BaseTestConsumer<Flowable<T>,TestSubscriber<Flowable<T>>>FlowableSubscriber<Flowable<T>>Subscriber<Flowable<T>>BiFunction<? super Flowable<T>,? super U,? extends R>Function5<? super Flowable<T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super Flowable<T>,? super T1,? super T2,? super T3,R>Function3<? super Flowable<T>,? super T1,? super T2,R>Flowable<Flowable<Flowable<T>>>Publisher<Flowable<Flowable<T>>>List<Flowable<T>>Collection<Flowable<T>>Iterable<Flowable<T>>Single<List<Flowable<T>>>SingleSource<List<Flowable<T>>>Comparator<? super Flowable<T>>Observable<Flowable<T>>ObservableSource<Flowable<T>>Function<? super Flowable<T>,? extends K>Function<? super Flowable<T>,? extends V>Map<K,Collection<Flowable<T>>>Single<Map<K,Collection<Flowable<T>>>>SingleSource<Map<K,Collection<Flowable<T>>>>Map<K,Flowable<T>>Single<Map<K,Flowable<T>>>SingleSource<Map<K,Flowable<T>>>FlowableConverter<Flowable<T>,? extends R>Timed<Flowable<T>>Flowable<Timed<Flowable<T>>>Publisher<Timed<Flowable<T>>>Function<? super Flowable<T>,? extends Publisher<V>>? extends Flowable<T>Publisher<? extends Flowable<T>>Predicate<? super Flowable<T>>Function<? super Flowable<T>,? extends SingleSource<? extends R>>Function<? super Flowable<T>,? extends MaybeSource<? extends R>>Function<? super Flowable<T>,? extends CompletableSource>FlowableSubscriber<? super Flowable<T>>Consumer<? super Flowable<T>>Flowable[]Flowable<T>[]startWithArray(io.reactivex.rxjava3.core.Flowable[])startWithItem(io.reactivex.rxjava3.core.Flowable)MaybeSource<Flowable<T>>SingleSource<Flowable<T>>Iterable<? extends Flowable<T>>Single<Flowable<T>>single(io.reactivex.rxjava3.core.Flowable)Maybe<Flowable<T>>BiFunction<R,? super Flowable<T>,R>BiFunction<Flowable<T>,Flowable<T>,Flowable<T>>ConnectableFlowable<Flowable<T>>? super Flowable<Flowable<T>>Function<? super Flowable<Flowable<T>>,? extends Publisher<R>>Function<? super Flowable<Flowable<T>>,? extends Publisher<? extends R>>ParallelFlowable<Flowable<T>>onErrorReturnItem(io.reactivex.rxjava3.core.Flowable)Function<? super Throwable,? extends Flowable<T>>? extends Publisher<? extends Flowable<T>>Function<? super Throwable,? extends Publisher<? extends Flowable<T>>>MaybeSource<? extends Flowable<T>>SingleSource<? extends Flowable<T>>Notification<Flowable<T>>Flowable<Notification<Flowable<T>>>Publisher<Notification<Flowable<T>>>Function<? super Flowable<T>,? extends R>FlowableOperator<? extends R,? super Flowable<T>>last(io.reactivex.rxjava3.core.Flowable)Function<? super Flowable<T>,? extends Publisher<TLeftEnd>>BiFunction<? super Flowable<T>,? super TRight,? extends R>BiFunction<? super Flowable<T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,Flowable<T>>Flowable<GroupedFlowable<K,Flowable<T>>>Publisher<GroupedFlowable<K,Flowable<T>>>Function<? super Flowable<T>,? extends Iterable<? extends U>>BiFunction<? super Flowable<T>,? super U,? extends V>Function<? super Flowable<T>,? extends Publisher<? extends U>>first(io.reactivex.rxjava3.core.Flowable)elementAt(long,io.reactivex.rxjava3.core.Flowable)? super Notification<Flowable<T>>Consumer<? super Notification<Flowable<T>>>BiPredicate<? super Flowable<T>,? super Flowable<T>>Function<? super Flowable<T>,K>Function<? super Flowable<T>,Notification<R>>Function<? super Flowable<T>,? extends Publisher<U>>defaultIfEmpty(io.reactivex.rxjava3.core.Flowable)FlowableTransformer<? super Flowable<T>,? extends R>BiConsumer<? super U,? super Flowable<T>>Flowable<List<Flowable<T>>>Publisher<List<Flowable<T>>>Future<Flowable<T>>blockingSingle(io.reactivex.rxjava3.core.Flowable)blockingMostRecent(io.reactivex.rxjava3.core.Flowable)blockingLast(io.reactivex.rxjava3.core.Flowable)blockingFirst(io.reactivex.rxjava3.core.Flowable)Flowable<Flowable<T>>()AbstractFlowableWithUpstream<T,Flowable<T>>(io.reactivex.rxjava3.core.Flowable)FlowableWindow(io.reactivex.rxjava3.core.Flowable,long,long,int)"timespan""timeskip"FlowableWindowTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowTimed.classFlowableWindowTimedFlowableWindowTimed<T>(io.reactivex.rxjava3.core.Flowable,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,long,int,boolean)missingBackpressureMessagemissingBackpressureMessage(long)FlowableWindowTimed(io.reactivex.rxjava3.core.Flowable,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,long,int,boolean)restartFlowableWindowBoundary<T,B>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowBoundary.classFlowableWindowBoundaryFlowableWindowBoundary<T,B>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,int)FlowableWindowBoundary(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,int)FlowableWindowBoundarySelector<T,U,V>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWindowBoundarySelector.classFlowableWindowBoundarySelectorFlowableWindowBoundarySelector<T,B,V>? super BFunction<? super B,? extends Publisher<V>>FlowableWindowBoundarySelector<T,B,V>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,int)FlowableWindowBoundarySelector(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,int)openFlowableWithLatestFrom<T,U,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWithLatestFrom.classFlowableWithLatestFromFlowableWithLatestFrom<T,U,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiFunction,org.reactivestreams.Publisher)FlowableWithLatestFrom(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.BiFunction,org.reactivestreams.Publisher)Function<Object[],R>others"others is null"others is nullFlowableWithLatestFromMany<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableWithLatestFromMany.classFlowableWithLatestFromManyFlowableWithLatestFromMany<T,R>(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function)FlowableWithLatestFromMany(io.reactivex.rxjava3.core.Flowable,java.lang.Iterable,io.reactivex.rxjava3.functions.Function)FlowableWithLatestFromMany<T,R>(io.reactivex.rxjava3.core.Flowable,java.lang.Iterable,io.reactivex.rxjava3.functions.Function)FlowableWithLatestFromMany(io.reactivex.rxjava3.core.Flowable,org.reactivestreams.Publisher[],io.reactivex.rxjava3.functions.Function)otherIterableotherArrayFlowableZipIterable<T,U,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableZipIterable.classFlowableZipIterableFlowableZipIterable<T,U,V>AbstractFlowableWithUpstream<T,V>FlowableZipIterable<T,U,V>(io.reactivex.rxjava3.core.Flowable,java.lang.Iterable,io.reactivex.rxjava3.functions.BiFunction)Subscriber<? super V>Function<? super V,? extends Stream<? extends R>>Stream<V>BaseStream<V,Stream<V>>Collector<? super V,A,R>Function<? super V,Optional<? extends R>>TestSubscriber<V>BaseTestConsumer<V,TestSubscriber<V>>FlowableSubscriber<V>Subscriber<V>BiFunction<? super V,? super U,? extends R>Function5<? super V,? super T1,? super T2,? super T3,? super T4,R>Function4<? super V,? super T1,? super T2,? super T3,R>Function3<? super V,? super T1,? super T2,R>Flowable<Flowable<V>>Publisher<Flowable<V>>Single<List<V>>SingleSource<List<V>>Comparator<? super V>Function<? super V,? extends K>Function<? super V,? extends V>FlowableConverter<V,? extends R>Timed<V>Flowable<Timed<V>>Publisher<Timed<V>>Function<? super V,? extends Publisher<V>>Publisher<? extends V>Predicate<? super V>Function<? super V,? extends SingleSource<? extends R>>Function<? super V,? extends MaybeSource<? extends R>>Function<? super V,? extends Publisher<? extends R>>Function<? super V,? extends CompletableSource>FlowableSubscriber<? super V>Consumer<? super V>V[]MaybeSource<V>SingleSource<V>Iterable<? extends V>Single<V>Maybe<V>BiFunction<R,? super V,R>ConnectableFlowable<V>? super Flowable<V>Function<? super Flowable<V>,? extends Publisher<R>>Function<? super Flowable<V>,? extends Publisher<? extends R>>ParallelFlowable<V>Function<? super Throwable,? extends V>? extends Publisher<? extends V>Function<? super Throwable,? extends Publisher<? extends V>>MaybeSource<? extends V>SingleSource<? extends V>Notification<V>Flowable<Notification<V>>Publisher<Notification<V>>Function<? super V,? extends R>FlowableOperator<? extends R,? super V>Function<? super V,? extends Publisher<TLeftEnd>>BiFunction<? super V,? super TRight,? extends R>BiFunction<? super V,? super Flowable<TRight>,? extends R>Function<? super V,? extends Iterable<? extends U>>BiFunction<? super V,? super U,? extends V>Function<? super V,? extends Publisher<? extends U>>? super Notification<V>Consumer<? super Notification<V>>BiPredicate<? super V,? super V>Function<? super V,K>Function<? super V,Notification<R>>Function<? super V,? extends Publisher<U>>FlowableTransformer<? super V,? extends R>BiConsumer<? super U,? super V>Flowable<List<V>>Publisher<List<V>>Flowable<V>()AbstractFlowableWithUpstream<T,V>(io.reactivex.rxjava3.core.Flowable)FlowableZipIterable(io.reactivex.rxjava3.core.Flowable,java.lang.Iterable,io.reactivex.rxjava3.functions.BiFunction)tsTestSubscriber<T>()BaseTestConsumer<T,TestSubscriber<T>>()requestMorerequestMore(long)onStartonStart()TestSubscriber(org.reactivestreams.Subscriber,long)TestSubscriber<T>(org.reactivestreams.Subscriber,long)TestSubscriber(org.reactivestreams.Subscriber)TestSubscriber<T>(org.reactivestreams.Subscriber)TestSubscriber(long)TestSubscriber<T>(long)TestSubscriber()create(org.reactivestreams.Subscriber)create(long)initialRequestoptional"optional is null"optional is nullOptional<Flowable<T>>Supplier<? extends Flowable<T>>orElseGetorElseGet(java.util.function.Supplier)hashCodehashCode()equalsequals(java.lang.Object)XorElseThroworElseThrow(java.util.function.Supplier)? extends XSupplier<? extends X>orElseThrow()orElseorElse(java.lang.Object)orElse(io.reactivex.rxjava3.core.Flowable)stream()Optional<? extends T>? extends Optional<? extends T>Supplier<? extends Optional<? extends T>>oror(java.util.function.Supplier)Optional<? extends Flowable<T>>? extends Optional<? extends Flowable<T>>Supplier<? extends Optional<? extends Flowable<T>>>Optional<U>flatMap(java.util.function.Function)Optional<? extends U>? extends Optional<? extends U>Function<? super T,? extends Optional<? extends U>>Function<? super Flowable<T>,? extends Optional<? extends U>>map(java.util.function.Function)Function<? super Flowable<T>,? extends U>C:/modules/java.base/java/util/function/Predicate.classfilter(java.util.function.Predicate)ifPresentOrElseifPresentOrElse(java.util.function.Consumer,java.lang.Runnable)ifPresentifPresent(java.util.function.Consumer)isPresentisPresent()ofNullableofNullable(java.lang.Object)ofof(java.lang.Object)Supplier<Flowable<T>>Function<T,Flowable<T>>()identityidentity()Function<T,V>andThenandThen(java.util.function.Function)Function<V,R>compose(java.util.function.Function)Function<? super V,? extends T>Function<V,Flowable<T>>apply(java.lang.Object)FlowableFromCompletionStage<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFromCompletionStage.classFlowableFromCompletionStageFlowableFromCompletionStage<T>(java.util.concurrent.CompletionStage)FlowableFromCompletionStage(java.util.concurrent.CompletionStage)"stream is null"stream is nullFlowableFromStream<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFromStream.classFlowableFromStreamFlowableFromStream<T>(java.util.stream.Stream)closeSafelycloseSafely(java.lang.AutoCloseable)subscribeStreamsubscribeStream(org.reactivestreams.Subscriber,java.util.stream.Stream)FlowableFromStream(java.util.stream.Stream)FlowableMapOptional<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableMapOptional.classFlowableMapOptionalFlowableMapOptional<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableMapOptional(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function)FlowableCollectWithCollectorSingle<T,A,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableCollectWithCollectorSingle.classFlowableCollectWithCollectorSingleFuseToFlowable<R>FlowableCollectWithCollectorSingle<T,A,R>(io.reactivex.rxjava3.core.Flowable,java.util.stream.Collector)FlowableCollectWithCollectorSingle(io.reactivex.rxjava3.core.Flowable,java.util.stream.Collector)FlowableFirstStageSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFirstStageSubscriber.classFlowableFirstStageSubscriberFlowableStageSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableStageSubscriber.classFlowableStageSubscriberFlowableFirstStageSubscriber<T>(boolean,java.lang.Object)afterSubscribeafterSubscribe(org.reactivestreams.Subscription)FlowableStageSubscriber()FlowableStageSubscriber<T>()FlowableFirstStageSubscriber(boolean,java.lang.Object)FlowableSingleStageSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableSingleStageSubscriber.classFlowableSingleStageSubscriberFlowableSingleStageSubscriber<T>(boolean,java.lang.Object)FlowableSingleStageSubscriber(boolean,java.lang.Object)FlowableLastStageSubscriber<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableLastStageSubscriber.classFlowableLastStageSubscriberFlowableLastStageSubscriber<T>(boolean,java.lang.Object)FlowableLastStageSubscriber(boolean,java.lang.Object)onCloseonClose(java.lang.Runnable)closeclose()unorderedunordered()isParallelisParallel()run()FlowableFlatMapStream<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/FlowableFlatMapStream.classFlowableFlatMapStreamFlowableFlatMapStream<T,R>(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int)FlowableFlatMapStream(io.reactivex.rxjava3.core.Flowable,io.reactivex.rxjava3.functions.Function,int)The {@code Flowable} class that implements the <a href="https://github.com/reactive-streams/reactive-streams-jvm">Reactive Streams</a> {@link Publisher}Pattern and offers factory methods, intermediate operators and the ability to consume reactive dataflows.<em>Reactive Streams</em> operates with {@code Publisher}s which {@code Flowable} extends. Many operatorstherefore accept general {@code Publisher}s directly and allow direct interoperation with other<em>Reactive Streams</em> implementations.The {@code Flowable} hosts the default buffer size of 128 elements for operators, accessible via {@link #bufferSize()},that can be overridden globally via the system parameter {@code rx3.buffer-size}. Most operators, however, haveoverloads that allow setting their internal buffer size explicitly.<img width="640" height="317" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/legend.v3.png" alt="">The {@code Flowable} follows the protocolonSubscribe onNext* (onError | onComplete)?where the stream can be disposed through the {@link Subscription} instance provided to consumers through{@link Subscriber#onSubscribe(Subscription)}.Unlike the {@code Observable.subscribe()} of version 1.x, {@link #subscribe(Subscriber)} does not allow external cancellationof a subscription and the {@link Subscriber} instance is expected to expose such capability if needed.{@code Flowable}s support backpressure and require {@code Subscriber}s to signal demand via {@link Subscription#request(long)}.Disposable d = Flowable.just("Hello world!").delay(1, TimeUnit.SECONDS).subscribeWith(new DisposableSubscriber&lt;String&gt;() {&#64;Override public void onStart() {System.out.println("Start!");request(1);&#64;Override public void onNext(String t) {System.out.println(t);&#64;Override public void onError(Throwable t) {t.printStackTrace();&#64;Override public void onComplete() {Thread.sleep(500);// the sequence can now be cancelled via dispose()The <em>Reactive Streams</em> specification is relatively strict when defining interactions between {@code Publisher}s and {@code Subscriber}s, so much sothat there is a significant performance penalty due certain timing requirements and the need to prepare for invalidrequest amounts via {@link Subscription#request(long)}.Therefore, RxJava has introduced the {@link FlowableSubscriber} interface that indicates the consumer can be driven with relaxed rules.All RxJava operators are implemented with these relaxed rules in mind.If the subscribing {@code Subscriber} does not implement this interface, for example, due to it being from another <em>Reactive Streams</em> compliantlibrary, the {@code Flowable} will automatically apply a compliance wrapper around it.{@code Flowable} is an abstract class, but it is not advised to implement sources and custom operators by extending the class directly dueto the large amounts of <a href="https://github.com/reactive-streams/reactive-streams-jvm#specification">Reactive Streams</a>rules to be followed to the letter. See <a href="https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0">the wiki</a> forsome guidance if such custom implementations are necessary.The recommended way of creating custom {@code Flowable}s is by using the {@link #create(FlowableOnSubscribe, BackpressureStrategy)} factory method:Flowable&lt;String&gt; source = Flowable.create(new FlowableOnSubscribe&lt;String&gt;() {public void subscribe(FlowableEmitter&lt;String&gt; emitter) throws Exception {// signal an itememitter.onNext("Hello");// could be some blocking operationThread.sleep(1000);// the consumer might have cancelled the flowif (emitter.isCancelled()) {return;emitter.onNext("World");// the end-of-sequence has to be signaled, otherwise the// consumers may never finish}, BackpressureStrategy.BUFFER);System.out.println("Subscribe!");source.subscribe(System.out::println);RxJava reactive sources, such as {@code Flowable}, are generally synchronous and sequential in nature. In the ReactiveX design, the location (thread)where operators run is <i>orthogonal</i> to when the operators can work with data. This means that asynchrony and parallelismhas to be explicitly expressed via operators such as {@link #subscribeOn(Scheduler)}, {@link #observeOn(Scheduler)} and {@link #parallel()}. In general,operators featuring a {@link Scheduler} parameter are introducing this type of asynchrony into the flow.For more information see the <a href="http://reactivex.io/documentation/Publisher.html">ReactiveX documentation</a>.the type of the items emitted by the {@code Flowable}io.reactivex.rxjava3.subscribers.DisposableSubscriberThe default buffer size.Mirrors the one {@link Publisher} in an {@link Iterable} of several {@code Publisher}s that first either emits an item or sendsa termination notification.<img width="640" height="417" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.amb.png" alt="">When one of the {@code Publisher}s signal an item or terminates first, all subscriptions to the other{@code Publisher}s are canceled.<dd>The operator itself doesn't interfere with backpressure which is determined by the winning{@code Publisher}'s backpressure behavior.</dd><dd>If any of the losing {@code Publisher}s signals an error, the error is routed to the globalthe common element typean {@code Iterable} of {@code Publisher}s sources competing to react first. A subscription to each {@code Publisher} will<a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>Mirrors the one {@link Publisher} in an array of several {@code Publisher}s that first either emits an item or sends<img width="640" height="417" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.ambArray.png" alt="">an array of {@code Publisher} sources competing to react first. A subscription to each {@code Publisher} willReturns the default internal buffer size used by most async operators.<p>The value can be overridden via system parameter {@code rx3.buffer-size}<em>before</em> the {@code Flowable} class is loaded.the default internal buffer size.Combines a collection of source {@link Publisher}s by emitting an item that aggregates the latest values of each ofthe source {@code Publisher}s each time an item is received from any of the source {@code Publisher}s, where thisaggregation is defined by a specified function.Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, theimplementation of this operator has to create an {@code Object[]} instead. Unfortunately, a{@code Function<Integer[], R>} passed to the method would trigger a {@link ClassCastException}.If any of the sources never produces an item but only terminates (normally or with an error), theresulting sequence terminates immediately (normally or with all the errors accumulated until that point).If that input source is also synchronous, other sources after it will not be subscribed to.If the provided array of source {@code Publisher}s is empty, the resulting sequence completes immediately without emittingany items and without any calls to the combiner function.<dd>The returned {@code Publisher} honors backpressure from downstream. The source {@code Publisher}sare requested in a bounded manner, however, their backpressure is not enforced (the operator won't signal{@link MissingBackpressureException}) and may lead to {@link OutOfMemoryError} due to internal buffer bloat.</dd><dd>{@code combineLatestArray} does not operate by default on a particular {@link Scheduler}.</dd>the common base type of source valuesthe result typethe collection of source {@code Publisher}sthe aggregation function used to combine the items emitted by the source {@code Publisher}sif {@code sources} or {@code combiner} is {@code null}<a href="http://reactivex.io/documentation/operators/combinelatest.html">ReactiveX operators documentation: CombineLatest</a>the internal buffer size and prefetch amount applied to every source {@code Flowable}if {@code bufferSize} is non-positiveIf the provided iterable of source {@code Publisher}s is empty, the resulting sequence completes immediately without emitting<dd>{@code combineLatest} does not operate by default on a particular {@link Scheduler}.</dd>If the provided iterable of source {@code Publisher}s is empty, the resulting sequence completes immediately without emitting any items andwithout any calls to the combiner function.<dd>{@code combineLatestArrayDelayError} does not operate by default on a particular {@link Scheduler}.</dd>aggregation is defined by a specified function and delays any error from the sources untilall source {@code Publisher}s terminate.<dd>{@code combineLatestDelayError} does not operate by default on a particular {@link Scheduler}.</dd>Combines two source {@link Publisher}s by emitting an item that aggregates the latest values of each of thesource {@code Publisher}s each time an item is received from either of the source {@code Publisher}s, where this<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.v3.png" alt=""><T1>the element type of the first source<T2>the element type of the second sourcethe combined output typethe first source {@code Publisher}the second source {@code Publisher}if {@code source1}, {@code source2} or {@code combiner} is {@code null}Combines three source {@link Publisher}s by emitting an item that aggregates the latest values of each of thesource {@code Publisher}s each time an item is received from any of the source {@code Publisher}s, where this<T3>the element type of the third sourcethe third source {@code Publisher}if {@code source1}, {@code source2}, {@code source3} or {@code combiner} is {@code null}Combines four source {@link Publisher}s by emitting an item that aggregates the latest values of each of the<T4>the element type of the fourth sourcethe fourth source {@code Publisher}if {@code source1}, {@code source2}, {@code source3},{@code source4} or {@code combiner} is {@code null}Combines five source {@link Publisher}s by emitting an item that aggregates the latest values of each of the<T5>the element type of the fifth sourcethe fifth source {@code Publisher}{@code source4}, {@code source5} or {@code combiner} is {@code null}Combines six source {@link Publisher}s by emitting an item that aggregates the latest values of each of the<T6>the element type of the sixth sourcethe sixth source {@code Publisher}{@code source4}, {@code source5}, {@code source6} or {@code combiner} is {@code null}Combines seven source {@link Publisher}s by emitting an item that aggregates the latest values of each of the<T7>the element type of the seventh sourcethe seventh source {@code Publisher}{@code source4}, {@code source5}, {@code source6},{@code source7} or {@code combiner} is {@code null}Combines eight source {@link Publisher}s by emitting an item that aggregates the latest values of each of the<T8>the element type of the eighth sourcethe eighth source {@code Publisher}{@code source7}, {@code source8} or {@code combiner} is {@code null}Combines nine source {@link Publisher}s by emitting an item that aggregates the latest values of each of the<T9>the element type of the ninth sourcethe ninth source {@code Publisher}{@code source7}, {@code source8}, {@code source9}or {@code combiner} is {@code null}Concatenates elements of each {@link Publisher} provided via an {@link Iterable} sequence into a single sequenceof elements without interleaving them.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.v3.png" alt=""><dd>The operator honors backpressure from downstream. The {@code Publisher}sources are expected to honor backpressure as well.If any of the source {@code Publisher}s violate this, it <em>may</em> throw an{@link IllegalStateException} when that {@code Publisher} completes.</dd>the common value type of the sourcesthe {@code Iterable} sequence of {@code Publisher}s unlike general sources, fromIterable can only throw on a boundary because it is consumed only thereReturns a {@code Flowable} that emits the items emitted by each of the {@link Publisher}s emitted by the source{@code Publisher}, one after the other, without interleaving them.<dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}sources are expected to honor backpressure as well. If the outer violates this, a{@link MissingBackpressureException} is signaled. If any of the inner {@code Publisher}s violatesthis, it <em>may</em> throw an {@link IllegalStateException} when an inner {@code Publisher} completes.</dd>the common element base typea {@code Publisher} that emits {@code Publisher}s<a href="http://reactivex.io/documentation/operators/concat.html">ReactiveX operators documentation: Concat</a>the number of {@code Publisher}s to prefetch from the sources sequence.Returns a {@code Flowable} that emits the items emitted by two {@link Publisher}s, one after the other, withoutinterleaving them.{@link IllegalStateException} when that source {@code Publisher} completes.</dd>a {@code Publisher} to be concatenatedReturns a {@code Flowable} that emits the items emitted by three {@link Publisher}s, one after the other, withoutif {@code source1}, {@code source2} or {@code source3} is {@code null}Returns a {@code Flowable} that emits the items emitted by four {@link Publisher}s, one after the other, withoutif {@code source1}, {@code source2}, {@code source3} or {@code source4} is {@code null}Concatenates a variable number of {@link Publisher} sources.Note: named this way because of overload conflict with {@code concat(Publisher<Publisher<T>>}).the array of source {@code Publisher}sthe common base value typeConcatenates a variable number of {@link Publisher} sources and delays errors from any of themtill all terminate.Concatenates an array of {@link Publisher}s eagerly into a single stream of values.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.png" alt="">Eager concatenation means that once a subscriber subscribes, this operator subscribes to all of thesource {@code Publisher}s. The operator buffers the values emitted by these {@code Publisher}s and then drains themin order, each one after the previous one completes.If any of the source {@code Publisher}s violate this, the operator will signal a{@link MissingBackpressureException}.</dd><dd>This method does not operate by default on a particular {@link Scheduler}.</dd>an array of {@code Publisher}s that need to be eagerly concatenatedthe new {@code Flowable} instance with the specified concatenation behavior<img width="640" height="406" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.nn.png" alt="">the maximum number of concurrent subscriptions at a time, {@link Integer#MAX_VALUE}is interpreted as an indication to subscribe to all sources at oncethe number of elements to prefetch from each {@code Publisher} sourceif {@code maxConcurrency} or {@code prefetch} is non-positiveConcatenates an array of {@link Publisher}s eagerly into a single stream of valuesand delaying any errors until all sources terminate.<img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.png" alt="">source {@code Publisher}s. The operator buffers the values emitted by these {@code Publisher}sand then drains them in order, each one after the previous one completes.2.2.1 - experimental<img width="640" height="359" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.nn.png" alt="">is interpreted as indication to subscribe to all sources at onceConcatenates the {@link Iterable} sequence of {@link Publisher}s into a single sequence by subscribing to each {@code Publisher},one after the other, one at a time and delays any errors till the all inner {@code Publisher}s terminate.the new {@code Flowable} with the concatenating behaviorConcatenates the {@link Publisher} sequence of {@code Publisher}s into a single sequence by subscribing to each inner {@code Publisher},one after the other, one at a time and delays any errors till the all inner and the outer {@code Publisher}s terminate.<dd>{@code concatDelayError} fully supports backpressure.</dd>the {@code Publisher} sequence of {@code Publisher}sthe number of elements to prefetch from the outer {@code Publisher}if {@code true}, exceptions from the outer and all inner {@code Publisher}s are delayed to the endif {@code false}, exception from the outer {@code Publisher} is delayed till the current inner {@code Publisher} terminatesif {@code prefetch} is {@code null}Concatenates a sequence of {@link Publisher}s eagerly into a single stream of values.<img width="640" height="422" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.i.png" alt=""><dd>Backpressure is honored towards the downstream and the inner {@code Publisher}s areexpected to support backpressure. Violating this assumption, the operator willsignal {@link MissingBackpressureException}.</dd>a sequence of {@code Publisher}s that need to be eagerly concatenatedConcatenates a sequence of {@link Publisher}s eagerly into a single stream of values andruns a limited number of inner sequences at once.<img width="640" height="375" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.in.png" alt=""><dd>Backpressure is honored towards the downstream and both the outer and inner {@code Publisher}s arethe maximum number of concurrently running inner {@code Publisher}s; {@link Integer#MAX_VALUE}is interpreted as all inner {@code Publisher}s can be active at the same timethe number of elements to prefetch from each inner {@code Publisher} sourceConcatenates a {@link Publisher} sequence of {@code Publisher}s eagerly into a single stream of values.<img width="640" height="490" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.p.png" alt="">emitted source {@code Publisher}s as they are observed. The operator buffers the values emitted by these{@code Publisher}s and then drains them in order, each one after the previous one completes.Concatenates a {@link Publisher} sequence of {@code Publisher}s eagerly into a single stream of values and<img width="640" height="421" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.pn.png" alt="">Concatenates a sequence of {@link Publisher}s eagerly into a single stream of values,delaying errors until all the inner sequences terminate.<img width="640" height="428" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.i.png" alt="">delaying errors until all the inner sequences terminate and runs a limited numberof inner sequences at once.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.in.png" alt="">Concatenates a {@link Publisher} sequence of {@code Publisher}s eagerly into a single stream of values,delaying errors until all the inner and the outer sequences terminate.<img width="640" height="496" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.p.png" alt="">delaying errors until all the inner and outer sequences terminate and runs a limited number of innersequences at once.<img width="640" height="421" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.pn.png" alt="">Provides an API (via a cold {@code Flowable}) that bridges the reactive world with the callback-style,generally non-backpressured world.Flowable.&lt;Event&gt;create(emitter -&gt; {emitter.onNext(e);if (e.isLast()) {Whenever a {@link Subscriber} subscribes to the returned {@code Flowable}, the provided{@link FlowableOnSubscribe} callback is invoked with a fresh instance of a {@link FlowableEmitter}that will interact only with that specific {@code Subscriber}. If this {@code Subscriber}cancels the flow (making {@link FlowableEmitter#isCancelled} return {@code true}),other observers subscribed to the same returned {@code Flowable} are not affected.You should call the {@link FlowableEmitter#onNext(Object)}, {@link FlowableEmitter#onError(Throwable)}and {@link FlowableEmitter#onComplete()} methods in a serialized fashion. Therest of its methods are thread-safe.<dd>The backpressure behavior is determined by the {@code mode} parameter.</dd>the element typethe emitter that is called when a {@code Subscriber} subscribes to the returned {@code Flowable}the backpressure mode to apply if the downstream {@code Subscriber} doesn't request (fast) enoughif {@code source} or {@code mode} is {@code null}Returns a {@code Flowable} that calls a {@link Publisher} factory to create a {@code Publisher} for each new {@link Subscriber}that subscribes. That is, for each subscriber, the actual {@code Publisher} that subscriber observes isdetermined by the factory function.<img width="640" height="340" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defer.v3.png" alt="">The defer {@code Subscriber} allows you to defer or delay emitting items from a {@code Publisher} until such time as a{@code Subscriber} subscribes to the {@code Publisher}. This allows a {@code Subscriber} to easily obtain updates or arefreshed version of the sequence.<dd>The operator itself doesn't interfere with backpressure which is determined by the {@code Publisher}returned by the {@code supplier}.</dd>the {@code Publisher} factory function to invoke for each {@code Subscriber} that subscribes to theresulting {@code Flowable}the type of the items emitted by the {@code Publisher}<a href="http://reactivex.io/documentation/operators/defer.html">ReactiveX operators documentation: Defer</a>Returns a {@code Flowable} that emits no items to the {@link Subscriber} and immediately invokes its{@link Subscriber#onComplete onComplete} method.<img width="640" height="190" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/empty.v3.png" alt=""><dd>This source doesn't produce any elements and effectively ignores downstream backpressure.</dd><dd>{@code empty} does not operate by default on a particular {@link Scheduler}.</dd>the type of the items (ostensibly) emitted by the {@link Publisher}the shared {@code Flowable} instance<a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX operators documentation: Empty</a>Returns a {@code Flowable} that invokes a {@link Subscriber}'s {@link Subscriber#onError onError} method when the{@code Subscriber} subscribes to it.<img width="640" height="190" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.v3.png" alt="">a {@link Supplier} factory to return a {@link Throwable} for each individual {@code Subscriber}the type of the items (ostensibly) emitted by the resulting {@code Flowable}<a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX operators documentation: Throw</a>the particular {@link Throwable} to pass to {@link Subscriber#onError onError}Returns a {@code Flowable} instance that runs the given {@link Action} for each {@link Subscriber} andemits either its exception or simply completes.<img width="640" height="285" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromAction.png" alt="">delivered to the downstream via {@link Subscriber#onError(Throwable)},except when the downstream has canceled the resulting {@code Flowable} source.the target typethe {@code Action} to run for each {@code Subscriber}Converts an array into a {@link Publisher} that emits the items in the array.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.v3.png" alt=""><dd>The operator honors backpressure from downstream and iterates the given {@code array}on demand (i.e., when requested).</dd><dd>{@code fromArray} does not operate by default on a particular {@link Scheduler}.</dd>the array of elementsthe type of items in the array and the type of items to be emitted by the resulting {@code Flowable}if {@code items} is {@code null}<a href="http://reactivex.io/documentation/operators/from.html">ReactiveX operators documentation: From</a>Returns a {@code Flowable} that, when a {@link Subscriber} subscribes to it, invokes a function you specify and thenemits the value returned from that function.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCallable.v3.png" alt="">This allows you to defer the execution of the function you specify until a {@code Subscriber} subscribes to the{@link Publisher}. That is to say, it makes the function "lazy."<dd>The operator honors backpressure from downstream.</dd><dd> If the {@link Callable} throws an exception, the respective {@link Throwable} isexcept when the downstream has canceled this {@code Flowable} source.a function, the execution of which should be deferred; {@code fromCallable} will invoke thisfunction only when a {@code Subscriber} subscribes to the {@code Publisher} that {@code fromCallable} returnsthe type of the item emitted by the {@code Publisher}Wraps a {@link CompletableSource} into a {@code Flowable}.<img width="640" height="278" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromCompletable.png" alt=""><dd>{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.</dd>the {@code CompletableSource} to convert fromif {@code completableSource} is {@code null}Converts a {@link Future} into a {@link Publisher}.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/from.Future.v3.png" alt="">The operator calls {@link Future#get()}, which is a blocking method, on the subscription thread.It is recommended applying {@link #subscribeOn(Scheduler)} to move this blocking wait to abackground thread, and if the {@link Scheduler} supports it, interrupt the wait when the flowis disposed.Also note that this operator will consume a {@link CompletionStage}-based {@code Future} subclass (such as{@link CompletableFuture}) in a blocking manner as well. Use the {@link #fromCompletionStage(CompletionStage)}operator to convert and consume such sources in a non-blocking fashion instead.Unlike 1.x, canceling the {@code Flowable} won't cancel the future. If necessary, one can use composition to achieve thecancellation effect: {@code futurePublisher.doOnCancel(() -> future.cancel(true));}.<dd>{@code fromFuture} does not operate by default on a particular {@code Scheduler}.</dd>the source {@code Future}the type of object that the {@code Future} returns, and also the type of item to be emitted bythe resulting {@code Flowable}#fromCompletionStage(CompletionStage)Converts a {@link Future} into a {@link Publisher}, with a timeout on the {@code Future}.The operator calls {@link Future#get(long, TimeUnit)}, which is a blocking method, on the subscription thread.the maximum time to wait before calling {@code get}the {@link TimeUnit} of the {@code timeout} argumentif {@code future} or {@code unit} is {@code null}Converts an {@link Iterable} sequence into a {@link Publisher} that emits the items in the sequence.<dd>The operator honors backpressure from downstream and iterates the given {@code iterable}<dd>{@code fromIterable} does not operate by default on a particular {@link Scheduler}.</dd>the source {@code Iterable} sequencethe type of items in the {@code Iterable} sequence and the type of items to be emitted by the#fromStream(Stream)Returns a {@code Flowable} instance that when subscribed to, subscribes to the {@link MaybeSource} instance andemits {@code onSuccess} as a single item or forwards any {@code onComplete} or{@code onError} signal.<img width="640" height="226" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromMaybe.png" alt="">Converts the given {@link ObservableSource} into a {@code Flowable} by applying the specified backpressure strategy.Marble diagrams for the various backpressure strategies are as follows:<li>{@link BackpressureStrategy#BUFFER}<img width="640" height="264" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.buffer.png" alt=""><li>{@link BackpressureStrategy#DROP}<img width="640" height="374" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.drop.png" alt=""><li>{@link BackpressureStrategy#LATEST}<img width="640" height="284" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.latest.png" alt=""><li>{@link BackpressureStrategy#ERROR}<img width="640" height="365" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.error.png" alt=""><li>{@link BackpressureStrategy#MISSING}<img width="640" height="397" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromObservable.missing.png" alt=""><dd>The operator applies the chosen backpressure strategy of {@link BackpressureStrategy} enum.</dd>the element type of the source and resulting sequencethe {@code ObservableSource} to convertthe backpressure strategy to applyif {@code source} or {@code strategy} is {@code null}Converts an arbitrary <em>Reactive Streams</em> {@link Publisher} into a {@code Flowable} if not already a{@code Flowable}.If possible, use {@link #create(FlowableOnSubscribe, BackpressureStrategy)} to create asource-like {@code Flowable} instead.<dd>The operator is a pass-through for backpressure and its behavior is determined by thebackpressure behavior of the wrapped publisher.</dd>the value type of the flowthe {@code Publisher} to convert#create(FlowableOnSubscribe, BackpressureStrategy)Returns a {@code Flowable} instance that runs the given {@link Runnable} for each {@link Subscriber} and<img width="640" height="286" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromRunnable.png" alt="">the {@code Runnable} to run for each {@code Subscriber}Returns a {@code Flowable} instance that when subscribed to, subscribes to the {@link SingleSource} instance andemits {@code onSuccess} as a single item or forwards the {@code onError} signal.<img width="640" height="341" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromSingle.png" alt="">the value type of the {@code SingleSource} elementReturns a {@code Flowable} that, when a {@link Subscriber} subscribes to it, invokes a supplier function you specify and then<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.fromSupplier.v3.png" alt=""><dd> If the {@link Supplier} throws an exception, the respective {@link Throwable} isa function, the execution of which should be deferred; {@code fromSupplier} will invoke thisfunction only when a {@code Subscriber} subscribes to the {@code Publisher} that {@code fromSupplier} returnsReturns a cold, synchronous, stateless and backpressure-aware generator of values.never concurrently and only while the function body is executing. Calling them from multiple threadsor outside the function call is not supported and leads to an undefined behavior.<dd>The operator honors downstream backpressure.</dd><dd>{@code generate} does not operate by default on a particular {@link Scheduler}.</dd>the generated value typethe {@link Consumer} called whenever a particular downstream {@link Subscriber} hasrequested a value. The callback then should call {@code onNext}, {@code onError} or{@code onComplete} to signal a value or a terminal event. Signaling multiple {@code onNext}in a call will make the operator signal {@link IllegalStateException}.if {@code generator} is {@code null}Returns a cold, synchronous, stateful and backpressure-aware generator of values.<S>the type of the per-{@link Subscriber} statethe {@link Supplier} to generate the initial state for each {@code Subscriber}the {@link Consumer} called with the current state whenever a particular downstream {@code Subscriber} hasif {@code initialState} or {@code generator} is {@code null}the {@code Consumer} that is called with the current state when the generatorterminates the sequence or it gets canceledif {@code initialState}, {@code generator} or {@code disposeState} is {@code null}the {@link Function} called with the current state whenever a particular downstream {@code Subscriber} has{@code onComplete} to signal a value or a terminal event and should return a (new) state forthe next invocation. Signaling multiple {@code onNext}the {@link Consumer} that is called with the current state when the generatorReturns a {@code Flowable} that emits a {@code 0L} after the {@code initialDelay} and ever-increasing numbersafter each {@code period} of time thereafter.<img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.p.v3.png" alt=""><dd>The operator generates values based on time and ignores downstream backpressure whichmay lead to {@link MissingBackpressureException} at some point in the chain.Downstream consumers should consider applying one of the {@code onBackpressureXXX} operators as well.</dd><dd>{@code interval} operates by default on the {@code computation} {@link Scheduler}.</dd>the initial delay time to wait before emitting the first value of 0Lthe period of time between emissions of the subsequent numbersthe time unit for both {@code initialDelay} and {@code period}<a href="http://reactivex.io/documentation/operators/interval.html">ReactiveX operators documentation: Interval</a>1.0.12after each {@code period} of time thereafter, on a specified {@link Scheduler}.<img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.ps.v3.png" alt="">the {@code Scheduler} on which the waiting happens and items are emittedReturns a {@code Flowable} that emits a sequential number every specified interval of time.<img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/interval.v3.png" alt=""><dd>The operator signals a {@link MissingBackpressureException} if the downstreamis not ready to receive the next value.</dd>the period size in time units (see below)time units to use for the interval sizeReturns a {@code Flowable} that emits a sequential number every specified interval of time, on aspecified {@link Scheduler}.<img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/interval.s.v3.png" alt="">the {@code Scheduler} to use for scheduling the itemsSignals a range of long values, the first after some initial delay and the rest periodically after.The sequence completes immediately after the last value {@code (start + count - 1)} has been reached.<dd>The operator signals a {@link MissingBackpressureException} if the downstream can't keep up.</dd><dd>{@code intervalRange} by default operates on the {@link Schedulers#computation() computation} {@link Scheduler}.</dd>that start value of the rangethe number of values to emit in total, if zero, the operator emits an {@code onComplete} after the initial delay.the initial delay before signaling the first value (the start)the period between subsequent valuesthe unit of measure of the {@code initialDelay} and {@code period} amountsif {@code count} is less than zero, or if {@code start} + {@code count} &minus; 1 exceeds{@link Long#MAX_VALUE}#range(int, int)The sequence completes immediately after the last value (start + count - 1) has been reached.<dd>you provide the {@link Scheduler}.</dd>the target {@code Scheduler} where the values and terminal signals will be emittedReturns a {@code Flowable} that signals the given (constant reference) item and then completes.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.v3.png" alt="">Note that the item is taken and re-emitted as is and not computed by any means by {@code just}. Use {@link #fromCallable(Callable)}to generate a single item on demand (when {@link Subscriber}s subscribe to it).See the multi-parameter overloads of {@code just} to emit more than one (constant reference) items one after the other.Use {@link #fromArray(Object...)} to emit an arbitrary number of items that are known upfront.To emit the items of an {@link Iterable} sequence (such as a {@link java.util.List}), use {@link #fromIterable(Iterable)}.<dd>{@code just} does not operate by default on a particular {@link Scheduler}.</dd>the item to emitthe type of that item<a href="http://reactivex.io/documentation/operators/just.html">ReactiveX operators documentation: Just</a>#just(Object, Object)#fromArray(Object...)#fromIterable(Iterable)Converts two items into a {@link Publisher} that emits those items.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.m.v3.png" alt=""><dd>The operator honors backpressure from downstream and signals each value on-demand (i.e., when requested).</dd>first itemsecond itemthe type of these itemsif {@code item1} or {@code item2} is {@code null}Converts three items into a {@link Publisher} that emits those items.third itemif {@code item1}, {@code item2} or {@code item3} is {@code null}Converts four items into a {@link Publisher} that emits those items.fourth itemif {@code item1}, {@code item2}, {@code item3},or {@code item4} is {@code null}Converts five items into a {@link Publisher} that emits those items.fifth item{@code item4} or {@code item5} is {@code null}Converts six items into a {@link Publisher} that emits those items.sixth item{@code item4}, {@code item5} or {@code item6} is {@code null}Converts seven items into a {@link Publisher} that emits those items.seventh item{@code item4}, {@code item5}, {@code item6}or {@code item7} is {@code null}Converts eight items into a {@link Publisher} that emits those items.eighth item{@code item4}, {@code item5}, {@code item6},{@code item7} or {@code item8} is {@code null}Converts nine items into a {@link Publisher} that emits those items.ninth item{@code item7}, {@code item8} or {@code item9} is {@code null}Converts ten items into a {@link Publisher} that emits those items.tenth item{@code item7}, {@code item8}, {@code item9},or {@code item10} is {@code null}Flattens an {@link Iterable} of {@link Publisher}s into one {@code Publisher}, without any transformation, while limiting thenumber of concurrent subscriptions to these {@code Publisher}s.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.v3.png" alt="">You can combine the items emitted by multiple {@code Publisher}s so that they appear as a single {@code Publisher}, byusing the {@code merge} method.<dd>The operator honors backpressure from downstream. The source {@code Publisher}s are expected to honorbackpressure; if violated, the operator <em>may</em> signal {@link MissingBackpressureException}.</dd><dd>If any of the source {@code Publisher}s signal a {@link Throwable} via {@code onError}, the resulting{@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are canceled.If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with thesignaled by source(s) after the returned {@code Flowable} has been canceled or terminated with aUse {@link #mergeDelayError(Iterable, int, int)} to merge sources and terminate only when all source {@code Publisher}sthe {@code Iterable} of {@code Publisher}sthe maximum number of {@code Publisher}s that may be subscribed to concurrentlythe number of items to prefetch from each inner {@code Publisher}if {@code maxConcurrency} or {@code bufferSize} is non-positive<a href="http://reactivex.io/documentation/operators/merge.html">ReactiveX operators documentation: Merge</a>#mergeDelayError(Iterable, int, int)Flattens an array of {@link Publisher}s into one {@code Publisher}, without any transformation, while limiting theUse {@link #mergeArrayDelayError(int, int, Publisher[])} to merge sources and terminate only when all source {@code Publisher}sthe array of {@code Publisher}s#mergeArrayDelayError(int, int, Publisher...)Flattens an {@link Iterable} of {@link Publisher}s into one {@code Publisher}, without any transformation.Use {@link #mergeDelayError(Iterable)} to merge sources and terminate only when all source {@code Publisher}sUse {@link #mergeDelayError(Iterable, int)} to merge sources and terminate only when all source {@code Publisher}sif {@code maxConcurrency} is less than or equal to 0#mergeDelayError(Iterable, int)Flattens a {@link Publisher} that emits {@code Publisher}s into a single {@code Publisher} that emits the items emitted bythos {@code Publisher}s , without any transformation.<img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.oo.v3.png" alt=""><dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumedin unbounded mode (i.e., no backpressure is applied to it). The inner {@code Publisher}s are expected to honorUse {@link #mergeDelayError(Publisher)} to merge sources and terminate only when all source {@code Publisher}sthose {@code Publisher}s, without any transformation, while limiting the maximum number of concurrentsubscriptions to these {@code Publisher}s.<dd>The operator honors backpressure from downstream. Both the outer and inner {@code Publisher}s are expected to honorUse {@link #mergeDelayError(Publisher, int)} to merge sources and terminate only when all source {@code Publisher}s1.1.0Flattens an array of {@link Publisher}s into one {@code Publisher}, without any transformation.<img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.io.v3.png" alt="">You can combine items emitted by multiple {@code Publisher}s so that they appear as a single {@code Publisher}, byUse {@link #mergeArrayDelayError(Publisher...)} to merge sources and terminate only when all source {@code Publisher}s#mergeArrayDelayError(Publisher...)Flattens two {@link Publisher}s into a single {@code Publisher}, without any transformation.Use {@link #mergeDelayError(Publisher, Publisher)} to merge sources and terminate only when all source {@code Publisher}sa {@code Publisher} to be merged#mergeDelayError(Publisher, Publisher)Flattens three {@link Publisher}s into a single {@code Publisher}, without any transformation.Use {@link #mergeDelayError(Publisher, Publisher, Publisher)} to merge sources and terminate only when all source {@code Publisher}s#mergeDelayError(Publisher, Publisher, Publisher)Flattens four {@link Publisher}s into a single {@code Publisher}, without any transformation.Use {@link #mergeDelayError(Publisher, Publisher, Publisher, Publisher)} to merge sources and terminate only when all source {@code Publisher}s#mergeDelayError(Publisher, Publisher, Publisher, Publisher)Flattens an {@link Iterable} of {@link Publisher}s into one {@code Publisher}, in a way that allows a {@link Subscriber} to receive allsuccessfully emitted items from each of the source {@code Publisher}s without being interrupted by an errornotification from one of them.This behaves like {@link #merge(Publisher)} except that if any of the merged {@code Publisher}s notify of anerror via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain from propagating thaterror notification until all of the merged {@code Publisher}s have finished emitting items.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeDelayError.v3.png" alt="">Even if multiple merged {@code Publisher}s send {@code onError} notifications, {@code mergeDelayError} will onlyinvoke the {@code onError} method of its {@code Subscriber}s once.<dd>The operator honors backpressure from downstream. All inner {@code Publisher}s are expected to honornotification from one of them, while limiting the number of concurrent subscriptions to these {@code Publisher}s.Flattens an array of {@link Publisher}s into one {@code Publisher}, in a way that allows a {@link Subscriber} to receive all<dd>The operator honors backpressure from downstream. All source {@code Publisher}s are expected to honorFlattens a {@link Publisher} that emits {@code Publisher}s into one {@code Publisher}, in a way that allows a {@link Subscriber} toreceive all successfully emitted items from all of the source {@code Publisher}s without being interrupted byan error notification from one of them.an error notification from one of them, while limiting theFlattens an array of {@link Publisher}s into one {@code Flowable}, in a way that allows a {@link Subscriber} to receive allFlattens two {@link Publisher}s into one {@code Publisher}, in a way that allows a {@link Subscriber} to receive allThis behaves like {@link #merge(Publisher, Publisher)} except that if any of the merged {@code Publisher}snotify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrain frompropagating that error notification until all of the merged {@code Publisher}s have finished emitting items.Even if both merged {@code Publisher}s send {@code onError} notifications, {@code mergeDelayError} will onlyFlattens three {@link Publisher}s into one {@code Publisher}, in a way that allows a {@link Subscriber} to receive allsuccessfully emitted items from all of the source {@code Publisher}s without being interrupted by an errorThis behaves like {@link #merge(Publisher, Publisher, Publisher)} except that if any of the merged{@code Publisher}s notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrainfrom propagating that error notification until all of the merged {@code Publisher}s have finished emittingitems.Flattens four {@link Publisher}s into one {@code Publisher}, in a way that allows a {@link Subscriber} to receive allThis behaves like {@link #merge(Publisher, Publisher, Publisher, Publisher)} except that if any ofthe merged {@code Publisher}s notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError}will refrain from propagating that error notification until all of the merged {@code Publisher}s have finishedemitting items.Returns a {@code Flowable} that never sends any items or notifications to a {@link Subscriber}.<img width="640" height="185" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/never.v3.png" alt="">This {@link Publisher} is useful primarily for testing purposes.the type of items (not) emitted by the {@code Publisher}<a href="http://reactivex.io/documentation/operators/empty-never-throw.html">ReactiveX operators documentation: Never</a>Returns a {@code Flowable} that emits a sequence of {@link Integer}s within a specified range.<img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/range.v3.png" alt=""><dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).</dd><dd>{@code range} does not operate by default on a particular {@link Scheduler}.</dd>the value of the first {@code Integer} in the sequencethe number of sequential {@code Integer}s to generate{@link Integer#MAX_VALUE}<a href="http://reactivex.io/documentation/operators/range.html">ReactiveX operators documentation: Range</a>#rangeLong(long, long)#intervalRange(long, long, long, long, TimeUnit)Returns a {@code Flowable} that emits a sequence of {@link Long}s within a specified range.<dd>{@code rangeLong} does not operate by default on a particular {@link Scheduler}.</dd>the value of the first {@code Long} in the sequencethe number of sequential {@code Long}s to generateReturns a {@link Single} that emits a {@link Boolean} value that indicates whether two {@link Publisher} sequences are thesame by comparing the items emitted by each {@code Publisher} pairwise.<img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.v3.png" alt=""><dd>This operator honors downstream backpressure and expects both of its sourcesto honor backpressure as well. If violated, the operator will emit a {@link MissingBackpressureException}.</dd>the first {@code Publisher} to comparethe second {@code Publisher} to comparethe type of items emitted by each {@code Publisher}<a href="http://reactivex.io/documentation/operators/sequenceequal.html">ReactiveX operators documentation: SequenceEqual</a>same by comparing the items emitted by each {@code Publisher} pairwise based on the results of a specifiedequality function.backpressure; if violated, the operator signals a {@link MissingBackpressureException}.</dd>a function used to compare items emitted by each {@code Publisher}if {@code source1}, {@code source2} or {@code isEqual} is {@code null}the number of items to prefetch from the first and second source {@code Publisher}Converts a {@link Publisher} that emits {@code Publisher}s into a {@code Publisher} that emits the items emitted by themost recently emitted of those {@code Publisher}s.<img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchDo.v3.png" alt="">{@code switchOnNext} subscribes to a {@code Publisher} that emits {@code Publisher}s. Each time it observes one ofthese emitted {@code Publisher}s, the {@code Publisher} returned by {@code switchOnNext} begins emitting the itemsemitted by that {@code Publisher}. When a new {@code Publisher} is emitted, {@code switchOnNext} stops emitting itemsfrom the earlier-emitted {@code Publisher} and begins emitting items from the new one.The resulting {@code Flowable} completes if both the outer {@code Publisher} and the last inner {@code Publisher}, if any, complete.If the outer {@code Publisher} signals an {@code onError}, the inner {@code Publisher} is canceled and the error delivered in-sequence.<dd>The operator honors backpressure from downstream. The outer {@code Publisher} is consumed in anunbounded manner (i.e., without backpressure) and the inner {@code Publisher}s are expected to honorbackpressure but it is not enforced; the operator won't signal a {@link MissingBackpressureException}but the violation <em>may</em> lead to {@link OutOfMemoryError} due to internal buffer bloat.</dd>the item typethe source {@code Publisher} that emits {@code Publisher}sthe number of items to prefetch from the inner {@code Publisher}smost recently emitted of those {@code Publisher}s and delays any exception until all {@code Publisher}s terminate.The resulting {@code Flowable} completes if both the main {@code Publisher} and the last inner {@code Publisher}, if any, complete.If the main {@code Publisher} signals an {@code onError}, the termination of the last inner {@code Publisher} will emit that error as isor wrapped into a {@link CompositeException} along with the other possible errors the former inner {@code Publisher}s signaled.Returns a {@code Flowable} that emits {@code 0L} after a specified delay, and then completes.<img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.v3.png" alt=""><dd>This operator does not support backpressure as it uses time. If the downstream needs a slower rateit should slow the timer or use something like {@link #onBackpressureDrop}.</dd><dd>{@code timer} operates by default on the {@code computation} {@link Scheduler}.</dd>the initial delay before emitting a single {@code 0L}time units to use for {@code delay}<a href="http://reactivex.io/documentation/operators/timer.html">ReactiveX operators documentation: Timer</a>Returns a {@code Flowable} that emits {@code 0L} after a specified delay, on a specified {@link Scheduler}, and thencompletes.<img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timer.s.v3.png" alt="">the initial delay before emitting a single 0Lthe {@code Scheduler} to use for scheduling the itemCreate a {@code Flowable} by wrapping a {@link Publisher} <em>which has to be implemented accordingto the <b>Reactive Streams</b> specification by handling backpressure andcancellation correctly; no safeguards are provided by the {@code Flowable} itself</em>.<dd>This operator is a pass-through for backpressure and the behavior is determined by theprovided {@code Publisher} implementation.</dd><dd>{@code unsafeCreate} by default doesn't operate on any particular {@link Scheduler}.</dd>the {@code Publisher} instance to wrapif {@code onSubscribe} is a subclass of {@code Flowable}; suchinstances don't need conversion and is possibly a port remnant from 1.x or one should use {@link #hide()}instead.Constructs a {@code Flowable} that creates a dependent resource object, a {@link Publisher} withthat resource and calls the provided {@code resourceDisposer} function if this inner source terminates or thedownstream cancels the flow.<img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/using.v3.png" alt=""><dd>The operator is a pass-through for backpressure and otherwise depends on thebackpressure support of the {@code Publisher} returned by the {@code resourceFactory}.</dd>the element type of the generated {@code Publisher}<D>the type of the resource associated with the output sequencethe factory function to create a resource object that depends on the {@code Publisher}the factory function to create a {@code Publisher}the function that will dispose of the resourceif {@code resourceSupplier}, {@code sourceSupplier} or {@code resourceCleanup} is {@code null}<a href="http://reactivex.io/documentation/operators/using.html">ReactiveX operators documentation: Using</a>downstream disposes the flow; doing it before these end-states have been reached if {@code eager == true}, after otherwise.If {@code true}, the resource disposal will happen either on a {@code cancel()} call before the upstream is disposedIf {@code false} the resource disposal will happen either on a {@code cancel()} call after the upstream is disposedReturns a {@code Flowable} that emits the results of a specified combiner function applied to combinations ofitems emitted, in sequence, by an {@link Iterable} of other {@link Publisher}s.{@code zip} applies this function in strict sequence, so the first item emitted by the new {@code Publisher}will be the result of the function applied to the first item emitted by each of the source {@code Publisher}s;the second item emitted by the new {@code Publisher} will be the result of the function applied to the seconditem emitted by each of those {@code Publisher}s; and so forth.The resulting {@code Flowable} returned from {@code zip} will invoke {@code onNext} as many times asthe number of {@code onNext} invocations of the source {@code Publisher} that emits the fewest items.The operator subscribes to its sources in the order they are specified and completes eagerly ifone of the sources is shorter than the rest while canceling the other sources. Therefore, itis possible those other sources will never be able to run to completion (and thus not calling{@code doOnComplete()}). This can also happen if the sources are exactly the same length; ifsource A completes and B has been consumed and is about to complete, the operator detects A won'tbe sending further values and it will cancel B immediately. For example:<pre><code>zip(Arrays.asList(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)), (a) -&gt; a)</code></pre>{@code action1} will be called but {@code action2} won't.<br>To work around this termination property,use {@link #doOnCancel(Action)} as well or use {@code using()} to do cleanup in case of completionor cancellation.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.v3.png" alt=""><dd>The operator expects backpressure from the sources and honors backpressure from the downstream.(I.e., zipping with {@link #interval(long, TimeUnit)} may result in {@link MissingBackpressureException}, useone of the {@code onBackpressureX} to handle similar, backpressure-ignoring sources.</dd><dd>{@code zip} does not operate by default on a particular {@link Scheduler}.</dd>the common value typethe zipped result typean {@code Iterable} of source {@code Publisher}sa function that, when applied to an item emitted by each of the source {@code Publisher}s, results inan item that will be emitted by the resulting {@code Flowable}if {@code sources} or {@code zipper} is {@code null}<a href="http://reactivex.io/documentation/operators/zip.html">ReactiveX operators documentation: Zip</a>The resulting {@code Floawble} returned from {@code zip} will invoke {@code onNext} as many times asdelay errors signaled by any of the source {@code Publisher} until all {@code Publisher}s terminatethe number of elements to prefetch from each source {@code Publisher}the common source value typetwo items emitted, in sequence, by two other {@link Publisher}s.will be the result of the function applied to the first item emitted by {@code o1} and the first itememitted by {@code o2}; the second item emitted by the new {@code Publisher} will be the result of the functionapplied to the second item emitted by {@code o1} and the second item emitted by {@code o2}; and so forth.The resulting {@code Flowable} returned from {@code zip} will invoke {@link Subscriber#onNext onNext}as many times as the number of {@code onNext} invocations of the source {@code Publisher} that emits the fewest<pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)</code></pre>the value type of the first sourcethe value type of the second sourcea second source {@code Publisher}a function that, when applied to an item emitted by each of the source {@code Publisher}s, resultsin an item that will be emitted by the resulting {@code Flowable}if {@code source1}, {@code source2} or {@code zipper} is {@code null}delay errors from any of the source {@code Publisher}s till the other terminatesthree items emitted, in sequence, by three other {@link Publisher}s.will be the result of the function applied to the first item emitted by {@code o1}, the first itememitted by {@code o2}, and the first item emitted by {@code o3}; the second item emitted by the new{@code Publisher} will be the result of the function applied to the second item emitted by {@code o1}, thesecond item emitted by {@code o2}, and the second item emitted by {@code o3}; and so forth.<pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c) -&gt; a + b)</code></pre>the value type of the third sourcea third source {@code Publisher}if {@code source1}, {@code source2}, {@code source3} or {@code zipper} is {@code null}four items emitted, in sequence, by four other {@link Publisher}s.emitted by {@code o2}, the first item emitted by {@code o3}, and the first item emitted by {@code 04};<pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d) -&gt; a + b)</code></pre>the value type of the fourth sourcea fourth source {@code Publisher}{@code source4} or {@code zipper} is {@code null}five items emitted, in sequence, by five other {@link Publisher}s.emitted by {@code o2}, the first item emitted by {@code o3}, the first item emitted by {@code o4}, andthe first item emitted by {@code o5}; the second item emitted by the new {@code Publisher} will be the result ofthe function applied to the second item emitted by each of those {@code Publisher}s; and so forth.<pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e) -&gt; a + b)</code></pre>the value type of the fifth sourcea fifth source {@code Publisher}{@code source4}, {@code source5} or {@code zipper} is {@code null}six items emitted, in sequence, by six other {@link Publisher}s.will be the result of the function applied to the first item emitted by each source {@code Publisher}, thesecond item emitted by the new {@code Publisher} will be the result of the function applied to the second itememitted by each of those {@code Publisher}s, and so forth.<pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f) -&gt; a + b)</code></pre>the value type of the sixth sourcea sixth source {@code Publisher}{@code source4}, {@code source5}, {@code source6}or {@code zipper} is {@code null}seven items emitted, in sequence, by seven other {@link Publisher}s.<pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g) -&gt; a + b)</code></pre>the value type of the seventh sourcea seventh source {@code Publisher}{@code source7} or {@code zipper} is {@code null}eight items emitted, in sequence, by eight other {@link Publisher}s.<pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h) -&gt; a + b)</code></pre>the value type of the eighth sourcean eighth source {@code Publisher}{@code source7}, {@code source8} or {@code zipper} is {@code null}nine items emitted, in sequence, by nine other {@link Publisher}s.<pre><code>zip(range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2), ..., (a, b, c, d, e, f, g, h, i) -&gt; a + b)</code></pre>the value type of the ninth sourcea ninth source {@code Publisher}items emitted, in sequence, by an array of other {@link Publisher}s.<pre><code>zip(new Publisher[]{range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)}, (a) -&gt;a)</code></pre><dd>{@code zipArray} does not operate by default on a particular {@link Scheduler}.</dd>an array of source {@code Publisher}s *************************************************************************************************** Instance operatorsReturns a {@link Single} that emits a {@link Boolean} that indicates whether all of the items emitted by the current{@code Flowable} satisfy a condition.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.v3.png" alt=""><dd>The operator honors backpressure from downstream and consumes the current {@code Flowable} in an unboundedmanner (i.e., without applying backpressure).</dd><dd>{@code all} does not operate by default on a particular {@link Scheduler}.</dd>a function that evaluates an item and returns a {@code Boolean}<a href="http://reactivex.io/documentation/operators/all.html">ReactiveX operators documentation: All</a>Mirrors the {@link Publisher} (current or provided) that first either emits an item or sends a terminationnotification.<img width="640" height="376" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.ambWith.png" alt="">When the current {@code Flowable} signals an item or terminates first, the subscription to the other{@code Publisher} is canceled. If the other {@code Publisher} signals an item or terminates first,the subscription to the current {@code Flowable} is canceled.If the losing {@code Publisher} signals an error, the error is routed to the globala {@code Publisher} competing to react first. A subscription to this provided {@code Publisher} will occur after subscribingto the current {@code Flowable}.Returns a {@link Single} that emits {@code true} if any item emitted by the current {@code Flowable} satisfies aspecified condition, otherwise {@code false}. <em>Note:</em> this always emits {@code false} if thecurrent {@code Flowable} is empty.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/exists.v3.png" alt="">In Rx.Net this is the {@code any} operator but we renamed it in RxJava to better match Java namingidioms.<dd>The operator honors backpressure from downstream and consumes the current {@code Flowable} in an unbounded manner(i.e., no backpressure applied to it).</dd><dd>{@code any} does not operate by default on a particular {@link Scheduler}.</dd>the condition to test items emitted by the current {@code Flowable}<a href="http://reactivex.io/documentation/operators/contains.html">ReactiveX operators documentation: Contains</a>Returns the first item emitted by this {@code Flowable}, or throws{@link NoSuchElementException} if it emits no items.<dd>The operator consumes the current {@code Flowable} in an unbounded manner<dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.</dd>NoSuchElementExceptionif this {@code Flowable} emits no items<a href="http://reactivex.io/documentation/operators/first.html">ReactiveX documentation: First</a>Returns the first item emitted by this {@code Flowable}, or a default value if it emits noa default value to return if this {@code Flowable} emits no itemsif {@code defaultItem} is {@code null}Consumes the current {@code Flowable} in a blocking fashion and invokes the given{@link Consumer} with each upstream item on the <em>current thread</em> until theupstream terminates.<img width="640" height="330" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.forEach.v3.png" alt=""><em>Note:</em> the method will only return if the upstream terminates or the currentthread is interrupted.This method executes the {@code Consumer} on the current thread while{@link #subscribe(Consumer)} executes the consumer on the original caller thread of thesequence.<dd>The operator requests {@link Flowable#bufferSize()} upfront, then 75% of thisamount when 75% is received.</dd><dd>{@code blockingForEach} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Consumer} to invoke for each item emitted by the {@code Flowable}if {@code onNext} is {@code null}if an error occurs; {@code Error}s and {@code RuntimeException}s are rethrownas they are, checked {@code Exception}s are wrapped into {@code RuntimeException}s<a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX documentation: Subscribe</a>#subscribe(Consumer)#blockingForEach(Consumer, int)<dd>The operator requests the given {@code prefetch} amount upfront, then 75% of thisthe number of items to prefetch upfront, then 75% of it after 75% receivedConverts this {@code Flowable} into an {@link Iterable}.<img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.toIterable.v3.png" alt=""><dd>The operator expects the upstream to honor backpressure otherwise the returned{@code Iterable}'s iterator will throw a {@link MissingBackpressureException}.</dd><dd>{@code blockingIterable} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code Iterable} instance{@code Iterable}'s iterator will throw a {@link MissingBackpressureException}.the number of items to prefetch from the current {@code Flowable}Returns the last item emitted by this {@code Flowable}, or throws{@link NoSuchElementException} if this {@code Flowable} emits no items.<img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.last.v3.png" alt=""><dd>{@code blockingLast} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/last.html">ReactiveX documentation: Last</a>Returns the last item emitted by this {@code Flowable}, or a default value if it emits no<img width="640" height="310" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.lastOrDefault.v3.png" alt="">Returns an {@link Iterable} that returns the latest item emitted by this {@code Flowable},waiting if necessary for one to become available.If this {@code Flowable} produces items faster than {@code Iterator.next} takes them,{@code onNext} events might be skipped, but {@code onError} or {@code onComplete} events are not.Note also that an {@code onNext} directly followed by {@code onComplete} might hide the {@code onNext}event.<dd>{@code blockingLatest} does not operate by default on a particular {@link Scheduler}.</dd>Returns an {@link Iterable} that always returns the item most recently emitted by this<img width="640" height="490" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.mostRecent.v3.png" alt=""><dd>{@code blockingMostRecent} does not operate by default on a particular {@link Scheduler}.</dd>the initial item that the {@code Iterable} sequence will yield if this{@code Flowable} has not yet emitted an itemif {@code initialItem} is {@code null}Returns an {@link Iterable} that blocks until this {@code Flowable} emits another item, thenreturns that item.<img width="640" height="490" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.next.v3.png" alt=""><dd>{@code blockingNext} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX documentation: TakeLast</a>If this {@code Flowable} completes after emitting a single item, return that item, otherwisethrow a {@link NoSuchElementException}.<img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.single.v3.png" alt=""><dd>{@code blockingSingle} does not operate by default on a particular {@link Scheduler}.</dd>If this {@code Flowable} completes after emitting a single item, return that item; if it emitsmore than one item, throw an {@link IllegalArgumentException}; if it emits no items, return a defaultvalue.<img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.singleOrDefault.v3.png" alt="">Returns a {@link Future} representing the only value emitted by this {@code Flowable}.<img width="640" height="311" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png" alt="">If the {@code Flowable} emits more than one item, {@link java.util.concurrent.Future} will receive an{@link java.lang.IndexOutOfBoundsException}. If the {@code Flowable} is empty, {@link java.util.concurrent.Future}will receive a {@link java.util.NoSuchElementException}. The {@code Flowable} source has to terminate in orderfor the returned {@code Future} to terminate as well.If the {@code Flowable} may emit more than one item, use {@code Flowable.toList().toFuture()}.Runs the current {@code Flowable} to a terminal event, ignoring any values and rethrowing any exception.Note that calling this method will block the caller thread until the upstream terminatesnormally or with an error. Therefore, calling this method from special threads such as theAndroid Main Thread or the Swing Event Dispatch Thread is not recommended.#blockingSubscribe(Consumer)#blockingSubscribe(Consumer, Consumer)#blockingSubscribe(Consumer, Consumer, Action)Subscribes to the source and calls the given callbacks <strong>on the current thread</strong>.If the {@code Flowable} emits an error, it is wrapped into an{@link io.reactivex.rxjava3.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}and routed to the {@link RxJavaPlugins#onError(Throwable)} handler.Using the overloads {@link #blockingSubscribe(Consumer, Consumer)}or {@link #blockingSubscribe(Consumer, Consumer, Action)} instead is recommended.the callback action for each source value<dd>The operator consumes the current {@code Flowable} in an bounded manner (up to bufferSizeoutstanding request amount for items).</dd><p>History: 2.1.15 - experimentalthe size of the bufferthe callback action for an error eventif {@code onNext} or {@code onError} is {@code null}the callback action for the completion event.if {@code onNext}, {@code onError} or {@code onComplete} is {@code null}Subscribes to the source and calls the {@link Subscriber} methods <strong>on the current thread</strong>.normally, with an error or the {@code Subscriber} cancels the {@link Subscription} it receives viaTherefore, calling this method from special threads such as the<dd>The supplied {@code Subscriber} determines how backpressure is applied.</dd>The cancellation and backpressure is composed through.the subscriber to forward events and calls to in the current threadif {@code subscriber} is {@code null}Returns a {@code Flowable} that emits buffers of items it collects from the current {@code Flowable}. The resulting{@code Flowable} emits connected, non-overlapping buffers, each containing {@code count} items. When the current{@code Flowable} completes, the resulting {@code Flowable} emits the current buffer and propagates the notification from thecurrent {@code Flowable}. Note that if the current {@code Flowable} issues an {@code onError} notification the event is passed onimmediately without first emitting the buffer it is in the process of assembling.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer3.v3.png" alt=""><dd>The operator honors backpressure from downstream and expects the current {@code Flowable} to honor it aswell, although not enforced; violation <em>may</em> lead to {@link MissingBackpressureException} somewheredownstream.</dd><dd>This version of {@code buffer} does not operate by default on a particular {@link Scheduler}.</dd>the maximum number of items in each buffer before it should be emittedif {@code count} is non-positive<a href="http://reactivex.io/documentation/operators/buffer.html">ReactiveX operators documentation: Buffer</a>{@code Flowable} emits buffers every {@code skip} items, each containing {@code count} items. When the current<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer4.v3.png" alt="">the maximum size of each buffer before it should be emittedhow many items emitted by the current {@code Flowable} should be skipped before starting a newbuffer. Note that when {@code skip} and {@code count} are equal, this is the same operation as{@link #buffer(int)}.if {@code count} or {@code skip} is non-positive<U>the collection subclass type to buffer intoa factory function that returns an instance of the collection subclass to be used and returnedas the bufferif {@code bufferSupplier} is {@code null}{@code Flowable} starts a new buffer periodically, as determined by the {@code timeskip} argument. It emitseach buffer after a fixed timespan, specified by the {@code timespan} argument. When the current<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.v3.png" alt=""><dd>This operator does not support backpressure as it uses time. It requests {@link Long#MAX_VALUE}upstream and does not obey downstream requests.</dd><dd>This version of {@code buffer} operates by default on the {@code computation} {@link Scheduler}.</dd>the period of time each buffer collects items before it is emittedthe period of time after which a new buffer will be createdthe unit of time that applies to the {@code timespan} and {@code timeskip} arguments{@code Flowable} starts a new buffer periodically, as determined by the {@code timeskip} argument, and on thespecified {@code scheduler}. It emits each buffer after a fixed timespan, specified by the{@code timespan} argument. When the current {@code Flowable} completes, the resulting {@code Flowable} emits the current bufferand propagates the notification from the current {@code Flowable}. Note that if the current {@code Flowable} issues an {@code onError}notification the event is passed on immediately without first emitting the buffer it is in the process ofassembling.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer7.s.v3.png" alt=""><dd>You specify which {@link Scheduler} this operator will use.</dd>the {@code Scheduler} to use when determining the end and start of a bufferif {@code unit}, {@code scheduler} or {@code bufferSupplier} is {@code null}{@code Flowable} emits connected, non-overlapping buffers, each of a fixed duration specified by the<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.v3.png" alt="">the period of time each buffer collects items before it is emitted and replaced with a newthe unit of time that applies to the {@code timespan} argument{@code timespan} argument or a maximum size specified by the {@code count} argument (whichever is reachedfirst). When the current {@code Flowable} completes, the resulting {@code Flowable} emits the current buffer and propagates thenotification from the current {@code Flowable}. Note that if the current {@code Flowable} issues an {@code onError} notification the eventis passed on immediately without first emitting the buffer it is in the process of assembling.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.v3.png" alt="">the unit of time which applies to the {@code timespan} argumentthe maximum size of each buffer before it is emitted{@code timespan} argument as measured on the specified {@code scheduler}, or a maximum size specified bythe {@code count} argument (whichever is reached first). When the current {@code Flowable} completes, the resulting{@code Flowable} emits the current buffer and propagates the notification from the current {@code Flowable}. Note that if thecurrent {@code Flowable} issues an {@code onError} notification the event is passed on immediately without first emitting thebuffer it is in the process of assembling.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer6.s.v3.png" alt="">if {@code true}, the time window is restarted when the max capacity of the current bufferis reached{@code timespan} argument and on the specified {@code scheduler}. When the current {@code Flowable} completes, theresulting {@code Flowable} emits the current buffer and propagates the notification from the current {@code Flowable}. Note thatif the current {@code Flowable} issues an {@code onError} notification the event is passed on immediately without first emittingthe buffer it is in the process of assembling.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer5.s.v3.png" alt="">{@code Flowable} emits buffers that it creates when the specified {@code openingIndicator} {@link Publisher} emits anitem, and closes when the {@code Publisher} returned from {@code closingIndicator} emits an item. If any of the current{@code PFlowable}, {@code openingIndicator} or {@code closingIndicator} issues an {@code onError} notification the event is passedon immediately without first emitting the buffer it is in the process of assembling.<img width="640" height="470" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer2.v3.png" alt=""><dd>This operator does not support backpressure as it is instead controlled by the given {@code Publisher}s andbuffers data. It requests {@link Long#MAX_VALUE} upstream and does not obey downstream requests.</dd><TOpening>the element type of the buffer-opening {@code Publisher}<TClosing>the element type of the individual buffer-closing {@code Publisher}sthe {@code Publisher} that, when it emits an item, causes a new buffer to be createdthe {@link Function} that is used to produce a {@code Publisher} for every buffer created. When this{@code Publisher} emits an item, the associated buffer is emitted.if {@code openingIndicator} or {@code closingIndicator} is {@code null}{@code Flowable}, {@code openingIndicator} or {@code closingIndicator} issues an {@code onError} notification the event is passedif {@code openingIndicator}, {@code closingIndicator} or {@code bufferSupplier} is {@code null}Returns a {@code Flowable} that emits non-overlapping buffered items from the current {@code Flowable} each time thespecified boundary {@link Publisher} emits an item.<img width="640" height="395" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/buffer8.v3.png" alt="">Completion of either the source or the boundary {@code Publisher} causes the returned {@code Publisher} to emit thelatest buffer and complete. If either the current {@code Flowable} or the boundary {@code Publisher} issues an {@code onError} notificationthe event is passed on immediately without first emitting the buffer it is in the process of assembling.<dd>This operator does not support backpressure as it is instead controlled by the {@code Publisher}{@code boundary} and buffers data. It requests {@link Long#MAX_VALUE} upstream and does not obeydownstream requests.</dd><B>the boundary value type (ignored)the boundary {@code Publisher}if {@code boundaryIndicator} is {@code null}#buffer(Publisher, int)the initial capacity of each buffer chunkif {@code initialCapacity} is non-positive#buffer(Publisher)if {@code boundaryIndicator} or {@code bufferSupplier} is {@code null}Returns a {@code Flowable} that subscribes to this {@link Publisher} lazily, caches all of its eventsand replays them, in the same order as received, to all the downstream subscribers.<img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cache.v3.png" alt="">This is useful when you want a {@code Publisher} to cache responses and you can't control thesubscribe/cancel behavior of all the {@link Subscriber}s.The operator subscribes only when the first downstream subscriber subscribes and maintainsa single subscription towards this {@code Publisher}. In contrast, the operator family of {@link #replay()}that return a {@link ConnectableFlowable} require an explicit call to {@link ConnectableFlowable#connect()}.<em>Note:</em> You sacrifice the ability to cancel the origin when you use the {@code cache}operator so be careful not to use this operator on {@code Publisher}s that emit an infinite or very large numberof items that will use up memory.A possible workaround is to apply {@link #takeUntil(Publisher)} with a predicate oranother source before (and perhaps after) the application of {@code cache()}.AtomicBoolean shouldStop = new AtomicBoolean();source.takeUntil(v -&gt; shouldStop.get()).cache().takeUntil(v -&gt; shouldStop.get()).subscribe(...);Since the operator doesn't allow clearing the cached values either, the possible workaround isto forget all references to it via {@link #onTerminateDetach()} applied along with the previousworkaround:.onTerminateDetach()<dd>The operator consumes this {@code Publisher} in an unbounded fashion but respects the backpressureof each downstream {@code Subscriber} individually.</dd><a href="http://reactivex.io/documentation/operators/replay.html">ReactiveX operators documentation: Replay</a>#takeUntil(Predicate)#takeUntil(Publisher)another source before (and perhaps after) the application of {@code cacheWithInitialCapacity()}.<dd>{@code cacheWithInitialCapacity} does not operate by default on a particular {@link Scheduler}.</dd><em>Note:</em> The capacity hint is not an upper bound on cache size. For that, consider{@link #replay(int)} in combination with {@link ConnectableFlowable#autoConnect()} or similar.hint for number of items to cache (for optimizing underlying data structure)Returns a {@code Flowable} that emits the items emitted by the current {@code Flowable}, converted to the specifiedtype.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cast.v3.png" alt=""><dd>The operator doesn't interfere with backpressure which is determined by the current {@code Flowable}'sbackpressure behavior.</dd><dd>{@code cast} does not operate by default on a particular {@link Scheduler}.</dd>the output value type cast tothe target class type that {@code cast} will cast the items emitted by the current {@code Flowable}into before emitting them from the resulting {@code Flowable}if {@code clazz} is {@code null}<a href="http://reactivex.io/documentation/operators/map.html">ReactiveX operators documentation: Map</a>Collects items emitted by the finite source {@link Publisher} into a single mutable data structure and returnsa {@link Single} that emits this structure.<img width="640" height="330" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collect.v3.png" alt="">This is a simplified version of {@code reduce} that does not need to return the state on each pass.Note that this operator requires the upstream to signal {@code onComplete} for the accumulator object tobe emitted. Sources that are infinite and never complete will never emit anything through thisoperator and an infinite source may lead to a fatal {@link OutOfMemoryError}.<dd>This operator does not support backpressure because by intent it will receive all values and reducethem to a single {@code onNext}.</dd><dd>{@code collect} does not operate by default on a particular {@link Scheduler}.</dd>the accumulator and output typethe mutable data structure that will collect the itemsa function that accepts the {@code state} and an emitted item, and modifies {@code state}accordinglyif {@code initialItemSupplier} or {@code collector} is {@code null}<a href="http://reactivex.io/documentation/operators/reduce.html">ReactiveX operators documentation: Reduce</a>#collect(Collector)<dd>{@code collectInto} does not operate by default on a particular {@link Scheduler}.</dd>if {@code initialItem} or {@code collector} is {@code null}Transform the current {@code Flowable} by applying a particular {@link FlowableTransformer} function to it.This method operates on the {@code Flowable} itself whereas {@link #lift} operates on the {@code Flowable}'s{@link Subscriber}s.If the operator you are creating is designed to act on the individual items emitted by a current{@code Flowable}, use {@link #lift}. If your operator is designed to transform the current {@code Flowable} as a whole(for instance, by applying a particular set of existing RxJava operators to it) use {@code compose}.<dd>The operator itself doesn't interfere with the backpressure behavior which only dependson what kind of {@link Publisher} the {@code FlowableTransformer} returns.</dd>the value type of the output {@code Publisher}implements the function that transforms the current {@code Flowable}the new composed {@code Flowable} instanceif {@code composer} is {@code null}<a href="https://github.com/ReactiveX/RxJava/wiki/Implementing-Your-Own-Operators">RxJava wiki: Implementing Your Own Operators</a>Returns a new {@code Flowable} that emits items resulting from applying a function that you supply to each itememitted by the current {@code Flowable}, where that function returns a {@link Publisher}, and then emitting the itemsthat result from concatenating those returned {@code Publisher}s.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.v3.png" alt="">Note that there is no guarantee where the given {@code mapper} function will be executed; it could be on the subscribing thread,on the upstream thread signaling the new item to be mapped or on the thread where the inner source terminates. To ensurethe {@code mapper} function is confined to a known thread, use the {@link #concatMap(Function, int, Scheduler)} overload.<dd>The operator honors backpressure from downstream. Both this and the inner {@code Publisher}s areexpected to honor backpressure as well. If the current {@code Flowable} violates the rule, the operator willsignal a {@link MissingBackpressureException}. If any of the inner {@code Publisher}s doesn't honorbackpressure, that <em>may</em> throw an {@link IllegalStateException} when that{@code Publisher} completes.</dd><dd>{@code concatMap} does not operate by default on a particular {@link Scheduler}.</dd>the type of the inner {@code Publisher} sources and thus the output typea function that, when applied to an item emitted by the current {@code Flowable}, returns a{@code Publisher}if {@code mapper} is {@code null}<a href="http://reactivex.io/documentation/operators/flatmap.html">ReactiveX operators documentation: FlatMap</a>the number of elements to prefetch from the current {@code Flowable}#concatMap(Function, int, Scheduler)Returns a new {@code Flowable} that emits items resulting from applying a function (on a designated scheduler)that you supply to each item emitted by the current {@code Flowable}, where that function returns a {@link Publisher}, and then emitting the itemsThe difference between {@link #concatMap(Function, int)} and this operator is that this operator guarantees the {@code mapper}function is executed on the specified scheduler.<dd>{@code concatMap} executes the given {@code mapper} function on the provided {@link Scheduler}.</dd>the scheduler where the {@code mapper} function will be executedif {@code mapper} or {@code scheduler} is {@code null}#concatMap(Function, int)#concatMapDelayError(Function, boolean, int, Scheduler)Maps the upstream items into {@link CompletableSource}s and subscribes to them one after theother completes.<dd>The operator expects the upstream to support backpressure. If this {@code Flowable} violates the rule, the operator willsignal a {@link MissingBackpressureException}.</dd><dd>{@code concatMapCompletable} does not operate by default on a particular {@link Scheduler}.</dd><p>History: 2.1.11 - experimentalthe function called with the upstream item and should returna {@code CompletableSource} to become the next source tobe subscribed tothe new {@link Completable} instance#concatMapCompletableDelayError(Function)The number of upstream items to prefetch so that fresh items areready to be mapped when a previous {@code CompletableSource} terminates.The operator replenishes after half of the prefetch amount has been consumedand turned into {@code CompletableSource}s.#concatMapCompletableDelayError(Function, boolean, int)other terminates, delaying all errors till both this {@code Flowable} and allinner {@code CompletableSource}s terminate.<dd>{@code concatMapCompletableDelayError} does not operate by default on a particular {@link Scheduler}.</dd>#concatMapCompletable(Function, int)other terminates, optionally delaying all errors till both this {@code Flowable} and allIf {@code true}, errors from this {@code Flowable} or any of theinner {@code CompletableSource}s are delayed until allof them terminate. If {@code false}, an error from this{@code Flowable} is delayed until the current inner{@code CompletableSource} terminates and only then isit emitted to the downstream.#concatMapCompletable(Function)Maps each of the items into a {@link Publisher}, subscribes to them one after the other,one at a time and emits their values in orderwhile delaying any error from either this or any of the inner {@code Publisher}still all of them terminate.the {@code mapper} function is confined to a known thread, use the {@link #concatMapDelayError(Function, boolean, int, Scheduler)} overload.<dd>{@code concatMapDelayError} does not operate by default on a particular {@link Scheduler}.</dd>the result value typethe function that maps the items of this {@code Publisher} into the inner {@code Publisher}s.the new {@code Flowable} instance with the concatenation behaviorif {@code true}, all errors from the outer and inner {@code Publisher} sources are delayed until the end,if {@code false}, an error from the main source is signaled when the current inner {@code Publisher} source terminatesMaps each of the upstream items into a {@link Publisher}, subscribes to them one after the other,while executing the mapper function on the designated scheduler, delaying any error from either this or any of theinner {@code Publisher}s till all of them terminate.The difference between {@link #concatMapDelayError(Function, boolean, int)} and this operator is that this operator guarantees the {@code mapper}<dd>{@code concatMapDelayError} executes the given {@code mapper} function on the provided {@link Scheduler}.</dd>#concatMapDelayError(Function, boolean, int)Maps a sequence of values into {@link Publisher}s and concatenates these {@code Publisher}s eagerly into a singleinner {@code Publisher}s. The operator buffers the values emitted by these {@code Publisher}s and then drains them inorder, each one after the previous one completes.<dd>Backpressure is honored towards the downstream, however, due to the eagerness requirement, sourcesare subscribed to in unbounded mode and their values are queued up in an unbounded buffer.</dd>the function that maps a sequence of values into a sequence of {@code Publisher}s that will beeagerly concatenatedthe maximum number of concurrent subscribed {@code Publisher}shints about the number of expected values from each inner {@code Publisher}, must be positive{@code Flowable} sequence.if {@code true}, exceptions from the current {@code Flowable} and all the inner {@code Publisher}s are delayed untilall of them terminate, if {@code false}, exception from the current {@code Flowable} is delayed until thecurrently running {@code Publisher} terminatesReturns a {@code Flowable} that concatenate each item emitted by the current {@code Flowable} with the values in an{@link Iterable} corresponding to that item that is generated by a selector.<dd>The operator honors backpressure from downstream. The current {@code Flowable}s is<dd>{@code concatMapIterable} does not operate by default on a particular {@link Scheduler}.</dd>the type of item emitted by the resulting {@code Flowable}a function that returns an {@code Iterable} sequence of values for when given an item emitted by thecurrent {@code Flowable}<dd>The operator honors backpressure from downstream. The current {@code Flowable} isMaps the upstream items into {@link MaybeSource}s and subscribes to them one after theother succeeds or completes, emits their success value if available or terminates immediately ifeither this {@code Flowable} or the current inner {@code MaybeSource} fail.<dd>The operator expects the upstream to support backpressure and honorsthe backpressure from downstream. If this {@code Flowable} violates the rule, the operator will<dd>{@code concatMapMaybe} does not operate by default on a particular {@link Scheduler}.</dd>the result type of the inner {@code MaybeSource}sa {@code MaybeSource} to become the next source to#concatMapMaybeDelayError(Function)#concatMapMaybe(Function, int)ready to be mapped when a previous {@code MaybeSource} terminates.and turned into {@code MaybeSource}s.#concatMapMaybe(Function)#concatMapMaybeDelayError(Function, boolean, int)other terminates, emits their success value if available and delaying all errorstill both this {@code Flowable} and all inner {@code MaybeSource}s terminate.<dd>{@code concatMapMaybeDelayError} does not operate by default on a particular {@link Scheduler}.</dd>#concatMapMaybeDelayError(Function, boolean)other terminates, emits their success value if available and optionally delaying all errorsinner {@code MaybeSource}s are delayed until all{@code MaybeSource} terminates and only then isMaps the upstream items into {@link SingleSource}s and subscribes to them one after theother succeeds, emits their success values or terminates immediately ifeither this {@code Flowable} or the current inner {@code SingleSource} fail.<dd>{@code concatMapSingle} does not operate by default on a particular {@link Scheduler}.</dd>the result type of the inner {@code SingleSource}sa {@code SingleSource} to become the next source to#concatMapSingleDelayError(Function)#concatMapSingle(Function, int)ready to be mapped when a previous {@code SingleSource} terminates.and turned into {@code SingleSource}s.#concatMapSingle(Function)#concatMapSingleDelayError(Function, boolean, int)other succeeds or fails, emits their success values and delays all errorstill both this {@code Flowable} and all inner {@code SingleSource}s terminate.<dd>{@code concatMapSingleDelayError} does not operate by default on a particular {@link Scheduler}.</dd>#concatMapSingleDelayError(Function, boolean)other succeeds or fails, emits their success values and optionally delays all errorsinner {@code SingleSource}s are delayed until all{@code SingleSource} terminates and only then isother succeeds or fails, emits their success values and optionally delays errorsReturns a {@code Flowable} that emits the items emitted from the current {@code Flowable}, then the next, one afterthe other, without interleaving them.<dd>The operator honors backpressure from downstream. Both this and the {@code other} {@link Publisher}sare expected to honor backpressure as well. If any of then violates this rule, it <em>may</em> throw an{@link IllegalStateException} when the current {@code Flowable} completes.</dd>a {@code Publisher} to be concatenated after the currentReturns a {@code Flowable} that emits the items from this {@code Flowable} followed by the success item or error eventof the other {@link SingleSource}.<dd>The operator supports backpressure and makes sure the success item of the other {@code SingleSource}is only emitted when there is a demand for it.</dd><p>History: 2.1.10 - experimentalthe {@code SingleSource} whose signal should be emitted after this {@code Flowable} completes normally.Returns a {@code Flowable} that emits the items from this {@code Flowable} followed by the success item or terminal eventsof the other {@link MaybeSource}.<dd>The operator supports backpressure and makes sure the success item of the other {@code MaybeSource}the {@code MaybeSource} whose signal should be emitted after this {@code Flowable} completes normally.Returns a {@code Flowable} that emits items from this {@code Flowable} and when it completes normally, theother {@link CompletableSource} is subscribed to and the returned {@code Flowable} emits its terminal events.<dd>The operator does not interfere with backpressure between the current {@code Flowable} and thedownstream consumer (i.e., acts as pass-through). When the operator switches to the{@link Completable}, backpressure is no longer present because {@code Completable} doesn'thave items to apply backpressure to.</dd>the {@code CompletableSource} to subscribe to once the current {@code Flowable} completes normallyReturns a {@link Single} that emits a {@link Boolean} that indicates whether the current {@code Flowable} emitted aspecified item.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/contains.v3.png" alt=""><dd>The operator honors backpressure from downstream and consumes the current {@code Flowable} in anunbounded manner (i.e., without applying backpressure).</dd><dd>{@code contains} does not operate by default on a particular {@link Scheduler}.</dd>the item to search for in the emissions from the current {@code Flowable}Returns a {@link Single} that counts the total number of items emitted by the current {@code Flowable} and emitsthis count as a 64-bit {@link Long}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/longCount.v3.png" alt=""><dd>{@code count} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/count.html">ReactiveX operators documentation: Count</a>Returns a {@code Flowable} that mirrors the current {@code Flowable}, except that it drops items emitted by thecurrent {@code Flowable} that are followed by another item within a computed debounce duration.<img width="640" height="425" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.f.v3.png" alt="">The delivery of the item happens on the thread of the first {@code onNext} or {@code onComplete}signal of the generated {@link Publisher} sequence,which if takes too long, a newer item may arrive from the upstream, causing thegenerated sequence to get cancelled, which may also interrupt any downstream blocking operation(yielding an {@code InterruptedException}). It is recommended processing itemsthat may take long time to be moved to another thread via {@link #observeOn} applied after{@code debounce} itself.<dd>This operator does not support backpressure as it uses the {@code debounceSelector} to markboundaries.</dd><dd>This version of {@code debounce} does not operate by default on a particular {@link Scheduler}.</dd>the debounce value type (ignored)function to retrieve a sequence that indicates the throttle duration for each itemif {@code debounceIndicator} is {@code null}<a href="http://reactivex.io/documentation/operators/debounce.html">ReactiveX operators documentation: Debounce</a><a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">RxJava wiki: Backpressure</a>current {@code Flowable} that are followed by newer items before a timeout value expires. The timer resets oneach emission.<em>Note:</em> If items keep being emitted by the current {@code Flowable} faster than the timeout then no itemswill be emitted by the resulting {@code Flowable}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.v3.png" alt="">Delivery of the item after the grace period happens on the {@code computation} {@link Scheduler}'s{@code Worker} which if takes too long, a newer item may arrive from the upstream, causing the{@code Worker}'s task to get disposed, which may also interrupt any downstream blocking operation<dd>This operator does not support backpressure as it uses time to control data flow.</dd><dd>{@code debounce} operates by default on the {@code computation} {@code Scheduler}.</dd>the length of the window of time that must pass after the emission of an item from the current{@code Flowable} in which it emits no items in order for the item to be emitted by thethe unit of time for the specified {@code timeout}#throttleWithTimeout(long, TimeUnit)current {@code Flowable} that are followed by newer items before a timeout value expires on a specified{@link Scheduler}. The timer resets on each emission.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.s.v3.png" alt="">Delivery of the item after the grace period happens on the given {@code Scheduler}'sthe time each item has to be "the most recent" of those emitted by the current {@code Flowable} toensure that it's not droppedthe {@code Scheduler} to use internally to manage the timers that handle the timeout for each#throttleWithTimeout(long, TimeUnit, Scheduler)Returns a {@code Flowable} that emits the items emitted by the current {@code Flowable} or a specified default itemif the current {@code Flowable} is empty.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/defaultIfEmpty.v3.png" alt=""><dd>If the current {@code Flowable} is empty, this operator is guaranteed to honor backpressure from downstream.If the current {@code Flowable} is non-empty, it is expected to honor backpressure as well; if the rule is violated,a {@link MissingBackpressureException} <em>may</em> get signaled somewhere downstream.<dd>{@code defaultIfEmpty} does not operate by default on a particular {@link Scheduler}.</dd>the item to emit if the current {@code Flowable} emits no items<a href="http://reactivex.io/documentation/operators/defaultifempty.html">ReactiveX operators documentation: DefaultIfEmpty</a>Returns a {@code Flowable} that delays the emissions of the current {@code Flowable} via another {@link Publisher} on aper-item basis.<img width="640" height="450" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.o.v3.png" alt=""><em>Note:</em> the resulting {@code Flowable} will immediately propagate any {@code onError} notificationfrom the current {@code Flowable}.<dd>The operator doesn't interfere with the backpressure behavior which is determined by the current {@code Flowable}.All of the other {@code Publisher}s supplied by the function are consumedin an unbounded manner (i.e., no backpressure applied to them).</dd><dd>This version of {@code delay} does not operate by default on a particular {@link Scheduler}.</dd>the item delay value type (ignored)a function that returns a {@code Publisher} for each item emitted by the current {@code Flowable}, which isthen used to delay the emission of that item by the resulting {@code Flowable} until the {@code Publisher}returned from {@code itemDelay} emits an itemif {@code itemDelayIndicator} is {@code null}Returns a {@code Flowable} that emits the items emitted by the current {@code Flowable} shifted forward in time by aspecified delay. The {@code onError} notification from the current {@code Flowable} is not delayed.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.v3.png" alt=""><dd>The operator doesn't interfere with the backpressure behavior which is determined by the current {@code Flowable}.</dd><dd>This version of {@code delay} operates by default on the {@code computation} {@link Scheduler}.</dd>the delay to shift the source bythe {@link TimeUnit} in which {@code period} is definedspecified delay. If {@code delayError} is {@code true}, error notifications will also be delayed.if {@code true}, the upstream exception is signaled with the given delay, after all preceding normal elements,if {@code false}, the upstream exception is signaled immediately<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.s.v3.png" alt="">the {@code Scheduler} to use for delayingReturns a {@code Flowable} that delays the subscription to and emissions from the current {@code Flowable} via another{@link Publisher} on a per-item basis.<img width="640" height="450" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delay.oo.v3.png" alt="">All of the other {@code Publisher}s supplied by the functions are consumedthe subscription delay value type (ignored)<V>a function that returns a {@code Publisher} that triggers the subscription to the current {@code Flowable}once it emits any itemif {@code subscriptionIndicator} and {@code itemDelayIndicator} is {@code null}Returns a {@code Flowable} that delays the subscription to this {@link Publisher}until the other {@code Publisher} emits an element or completes normally.<dd>The operator forwards the backpressure requests to this {@code Publisher} oncethe subscription happens and requests {@link Long#MAX_VALUE} from the other {@code Publisher}</dd>the value type of the other {@code Publisher}, irrelevantthe other {@code Publisher} that should trigger the subscriptionto this {@code Publisher}.if {@code subscriptionIndicator} is {@code null}Returns a {@code Flowable} that delays the subscription to the current {@code Flowable} by a given amount of time.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.v3.png" alt="">Returns a {@code Flowable} that delays the subscription to the current {@code Flowable} by a given amount of time,<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.s.v3.png" alt="">Returns a {@code Flowable} that reverses the effect of {@link #materialize materialize} by transforming the{@link Notification} objects extracted from the source items via a selector functioninto their respective {@link Subscriber} signal types.<img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/dematerialize.v3.png" alt="">The intended use of the {@code selector} function is to perform atype-safe identity mapping (see example) on a source that is already of type{@code Notification<T>}. The Java language doesn't allowlimiting instance methods to a certain generic argument shape, therefore,a function is used to ensure the conversion remains type safe.When the upstream signals an {@link Notification#createOnError(Throwable) onError} or{@link Notification#createOnComplete() onComplete} item, thereturned {@code Flowable} cancels of the flow and terminates with that type of terminal event:Flowable.just(createOnNext(1), createOnComplete(), createOnNext(2)).doOnCancel(() -&gt; System.out.println("Canceled!"));.dematerialize(notification -&gt; notification).assertResult(1);If the upstream signals {@code onError} or {@code onComplete} directly, the flow is terminatedwith the same event.Flowable.just(createOnNext(1), createOnNext(2)).assertResult(1, 2);If this behavior is not desired, the completion can be suppressed by applying {@link #concatWith(Publisher)}with a {@link #never()} source.<dd>{@code dematerialize} does not operate by default on a particular {@link Scheduler}.</dd>the output value typefunction that returns the upstream item and should return a {@code Notification} to signalthe corresponding {@code Subscriber} event to the downstream.if {@code selector} is {@code null}<a href="http://reactivex.io/documentation/operators/materialize-dematerialize.html">ReactiveX operators documentation: Dematerialize</a>Returns a {@code Flowable} that emits all items emitted by the current {@code Flowable} that are distinctbased on {@link Object#equals(Object)} comparison.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.v3.png" alt="">It is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()} and {@link Object#hashCode()} to providea meaningful comparison between items as the default Java implementation only considers reference equivalence.By default, {@code distinct()} uses an internal {@link java.util.HashSet} per {@link Subscriber} to rememberpreviously seen items and uses {@link java.util.Set#add(Object)} returning {@code false} as theindicator for duplicates.Note that this internal {@link HashSet} may grow unbounded as items won't be removed from it bythe operator. Therefore, using very long or infinite upstream (with very distinct elements) may leadto {@link OutOfMemoryError}.Customizing the retention policy can happen only by providing a custom {@link java.util.Collection} implementationto the {@link #distinct(Function, Supplier)} overload.<dd>{@code distinct} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/distinct.html">ReactiveX operators documentation: Distinct</a>#distinct(Function)#distinct(Function, Supplier)Returns a {@code Flowable} that emits all items emitted by the current {@code Flowable} that are distinct accordingto a key selector function and based on {@link Object#equals(Object)} comparison of the objectsreturned by the key selector function.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.key.v3.png" alt="">It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} and {@link Object#hashCode()} to providea meaningful comparison between the key objects as the default Java implementation only considers reference equivalence.previously seen keys and uses {@link java.util.Set#add(Object)} returning {@code false} as theNote that this internal {@link HashSet} may grow unbounded as keys won't be removed from it bythe operator. Therefore, using very long or infinite upstream (with very distinct keys) may lead<K>the key typea function that projects an emitted item to a key value that is used to decide whether an itemis distinct from another one or notif {@code keySelector} is {@code null}function called for each individual {@link Subscriber} to return a {@link Collection} subtype for holding the extractedkeys and whose add() method's return indicates uniqueness.if {@code keySelector} or {@code collectionSupplier} is {@code null}Returns a {@code Flowable} that emits all items emitted by the current {@code Flowable} that are distinct from theirimmediate predecessors based on {@link Object#equals(Object)} comparison.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.v3.png" alt="">It is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()} to provideAlternatively, use the {@link #distinctUntilChanged(BiPredicate)} overload and provide a comparison functionin case the class {@code T} can't be overridden with custom {@code equals()} or the comparison itselfshould happen on different terms or properties of the class {@code T}.Note that the operator always retains the latest item from upstream regardless of the comparison resultand uses it in the next comparison with the next upstream item.Note that if element type {@code T} in the flow is mutable, the comparison of the previous and currentitem may yield unexpected results if the items are mutated externally. Common cases are mutable{@link CharSequence}s or {@link List}s where the objects will actually have the samereferences when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same.To avoid such situation, it is recommended that mutable data is converted to an immutable one,for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}.<dd>{@code distinctUntilChanged} does not operate by default on a particular {@link Scheduler}.</dd>#distinctUntilChanged(BiPredicate)immediate predecessors, according to a key selector function and based on {@link Object#equals(Object)} comparisonof those objects returned by the key selector function.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.key.v3.png" alt="">It is recommended the keys' class {@code K} overrides the default {@code Object.equals()} to providein case the class {@code K} can't be overridden with custom {@code equals()} or the comparison itselfshould happen on different terms or properties of the item class {@code T} (for which the keys can bederived via a similar selector).Note that the operator always retains the latest key from upstream regardless of the comparison resultand uses it in the next comparison with the next key derived from the next upstream item.immediate predecessors when compared with each other via the provided comparator function.the function that receives the previous item and the current item and isexpected to return {@code true} if the two are equal, thus skipping the current value.if {@code comparer} is {@code null}Calls the specified action after this {@code Flowable} signals {@code onError} or {@code onComplete} or gets canceled by<p>In case of a race between a terminal event and a cancellation, the provided {@code onFinally} action<p>Note that the {@code onFinally} action is shared between subscriptions and as such<dd>The operator doesn't interfere with backpressure which is determined by the current {@code Flowable}'s backpressurebehavior.</dd><dt><b>Operator-fusion:</b></dt><dd>This operator supports normal and conditional {@link Subscriber}s as well as boundary-limitedsynchronous or asynchronous queue-fusion.</dd>the action called when this {@code Flowable} terminates or gets canceledCalls the specified consumer with the current item after this item has been emitted to the downstream.<p>Note that the {@code onAfterNext} action is shared between subscriptions and as such<dd>{@code doAfterNext} does not operate by default on a particular {@link Scheduler}.</dd>the {@link Consumer} that will be called after emitting an item from upstream to the downstreamif {@code onAfterNext} is {@code null}Registers an {@link Action} to be called when this {@link Publisher} invokes either{@link Subscriber#onComplete onComplete} or {@link Subscriber#onError onError}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/finallyDo.v3.png" alt="">an {@code Action} to be invoked when the current {@code Flowable} finishes#doOnTerminate(Action)Calls the cancel {@link Action} if the downstream cancels the sequence.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnUnsubscribe.v3.png" alt="">The action is shared between subscriptions and thus may be called concurrently from multiplethreads; the action must be thread-safe.If the action throws a runtime exception, that exception is rethrown by the {@code onCancel()} call,sometimes as a {@link CompositeException} if there were multiple exceptions along the way.<dd>{@code doOnCancel} does not interact with backpressure requests or value delivery; backpressurebehavior is preserved between its upstream and its downstream.</dd><dd>{@code doOnCancel} does not operate by default on a particular {@link Scheduler}.</dd>the action that gets called when the current {@code Flowable}'s {@link Subscription} is canceledif {@code onCancel} is {@code null}Invokes an {@link Action} just before the current {@code Flowable} calls {@code onComplete}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.v3.png" alt="">the action to invoke when the current {@code Flowable} calls {@code onComplete}Calls the appropriate onXXX consumer (shared between all subscribers) whenever a signal with the same typepasses through, before forwarding them to downstream.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.v3.png" alt=""><dd>{@code doOnEach} does not operate by default on a particular {@link Scheduler}.</dd>if {@code onNext}, {@code onError}, {@code onComplete} or {@code onAfterTerminate} is {@code null}Invokes a {@link Consumer} with a {@link Notification} instances matching the signals emitted by the current {@code Flowable}before they are forwarded to the downstream.the action to invoke for each item emitted by the current {@code Flowable}if {@code onNotification} is {@code null}Calls the appropriate methods of the given {@link Subscriber} when the current {@code Flowable} signals events before forwarding itto the downstream.In case the {@code onError} of the supplied {@code Subscriber} throws, the downstream will receive a compositeexception containing the original exception and the exception thrown by {@code onError}. If either the{@code onNext} or the {@code onComplete} method of the supplied {@code Subscriber} throws, the downstream will beterminated and will receive this thrown exception.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnEach.o.v3.png" alt="">the {@code Subscriber} to be notified about {@code onNext}, {@code onError} and {@code onComplete} events on itsrespective methods before the actual downstream {@code Subscriber} gets notified.Calls the given {@link Consumer} with the error {@link Throwable} if the current {@code Flowable} failed before forwarding it toIn case the {@code onError} action throws, the downstream will receive a composite exception containingthe original exception and the exception thrown by {@code onError}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.v3.png" alt="">the action to invoke if the current {@code Flowable} calls {@code onError}Calls the appropriate {@code onXXX} method (shared between all {@link Subscriber}s) for the lifecycle events ofthe sequence (subscription, cancellation, requesting).<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.v3.png" alt="">a {@link Consumer} called with the {@link Subscription} sent via {@link Subscriber#onSubscribe(Subscription)}a {@link LongConsumer} called with the request amount sent via {@link Subscription#request(long)}called when the downstream cancels the {@code Subscription} via {@link Subscription#cancel()}if {@code onSubscribe}, {@code onRequest} or {@code onCancel} is {@code null}Calls the given {@link Consumer} with the value emitted by the current {@code Flowable} before forwarding it to the downstream.<dd>{@code doOnNext} does not operate by default on a particular {@link Scheduler}.</dd>the action to invoke when the current {@code Flowable} calls {@code onNext}#doAfterNext(Consumer)Calls the given {@link LongConsumer} with the request amount from the downstream before forwarding it<b>Note:</b> This operator is for tracing the internal behavior of back-pressure requestpatterns and generally intended for debugging use.<dd>{@code doOnRequest} does not operate by default on a particular {@link Scheduler}.</dd>the action that gets called when a {@link Subscriber} requests items from the current{@code Flowable}if {@code onRequest} is {@code null}<a href="http://reactivex.io/documentation/operators/do.html">ReactiveX operatorsdocumentation: Do</a>Calls the given {@link Consumer} with the {@link Subscription} provided by the current {@code Flowable} uponsubscription from the downstream before forwarding it to the subscriber's{@link Subscriber#onSubscribe(Subscription) onSubscribe} method.<img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSubscribe.v3.png" alt="">the {@code Consumer} that gets called when a {@link Subscriber} subscribes to the current {@code Flowable}Calls the given {@link Action} when the current {@code Flowable} completes normally or with an error before those signalsare forwarded to the downstream.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.v3.png" alt="">This differs from {@code doAfterTerminate} in that this happens <em>before</em> the {@code onComplete} or{@code onError} notification.the action to invoke when the current {@code Flowable} calls {@code onComplete} or {@code onError}#doAfterTerminate(Action)Returns a {@link Maybe} that emits the single item at a specified index in a sequence of emissions fromthis {@code Flowable} or completes if this {@code Flowable} sequence has fewer elements than index.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.v3.png" alt=""><dd>The operator honors backpressure from downstream and consumes the current {@code Flowable} in a bounded manner.</dd><dd>{@code elementAt} does not operate by default on a particular {@link Scheduler}.</dd>the zero-based index of the item to retrieveIndexOutOfBoundsExceptionif {@code index} is negative<a href="http://reactivex.io/documentation/operators/elementat.html">ReactiveX operators documentation: ElementAt</a>Returns a {@link Single} that emits the item found at a specified index in a sequence of emissions fromthis {@code Flowable}, or a default item if that index is out of range.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrDefault.v3.png" alt="">the default itemthis {@code Flowable} or signals a {@link NoSuchElementException} if this {@code Flowable} has fewer elements than index.<dd>{@code elementAtOrError} does not operate by default on a particular {@link Scheduler}.</dd>if {@code index} is less than 0Filters items emitted by the current {@code Flowable} by only emitting those that satisfy a specified predicate.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/filter.v3.png" alt=""><dd>{@code filter} does not operate by default on a particular {@link Scheduler}.</dd>a function that evaluates each item emitted by the current {@code Flowable}, returning {@code true}if it passes the filter<a href="http://reactivex.io/documentation/operators/filter.html">ReactiveX operators documentation: Filter</a>Returns a {@link Maybe} that emits only the very first item emitted by this {@code Flowable} orcompletes if this {@code Flowable} is empty.<img width="640" height="286" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstElement.m.png" alt=""><dd>{@code firstElement} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/first.html">ReactiveX operators documentation: First</a>Returns a {@link Single} that emits only the very first item emitted by this {@code Flowable}, or a defaultitem if this {@code Flowable} completes without emitting anything.<img width="640" height="285" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.s.png" alt=""><dd>{@code first} does not operate by default on a particular {@link Scheduler}.</dd>the default item to emit if the current {@code Flowable} doesn't emit anythingReturns a {@link Single} that emits only the very first item emitted by this {@code Flowable} orsignals a {@link NoSuchElementException} if this {@code Flowable} is empty.<img width="640" height="237" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.png" alt=""><dd>{@code firstOrError} does not operate by default on a particular {@link Scheduler}.</dd> take may trigger UNBOUNDED_INReturns a {@code Flowable} that emits items based on applying a function that you supply to each item emittedby the current {@code Flowable}, where that function returns a {@link Publisher}, and then merging those resulting{@code Publisher}s and emitting the results of this merger.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.v3.png" alt=""><dd>The operator honors backpressure from downstream. The upstream {@code Flowable} is consumedin a bounded manner (up to {@link #bufferSize()} outstanding request amount for items).The inner {@code Publisher}s are expected to honor backpressure; if violated,the operator <em>may</em> signal {@link MissingBackpressureException}.</dd><dd>{@code flatMap} does not operate by default on a particular {@link Scheduler}.</dd>the value type of the inner {@code Publisher}s and the output typeif {@code true}, exceptions from the current {@code Flowable} and all inner {@code Publisher}s are delayed until all of them terminateif {@code false}, the first one signaling an exception will terminate the whole sequence immediately{@code Publisher}s and emitting the results of this merger, while limiting the maximum number of concurrent<!-- <p> --><!-- <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMap.v3.png" alt=""> -->in a bounded manner (up to {@code maxConcurrency} outstanding request amount for items).the number of elements to prefetch from each inner {@code Publisher}Returns a {@code Flowable} that applies a function to each item emitted or notification raised by the current{@code Flowable} and then flattens the {@link Publisher}s returned from these functions and emits the resulting items.<img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.v3.png" alt="">a function that returns a {@code Publisher} to merge for each item emitted by the current {@code Flowable}a function that returns a {@code Publisher} to merge for an {@code onError} notification from the currenta function that returns a {@code Publisher} to merge for an {@code onComplete} notification from the currentif {@code onNextMapper}, {@code onErrorMapper} or {@code onCompleteSupplier} is {@code null}{@code Flowable} and then flattens the {@link Publisher}s returned from these functions and emits the resulting items,while limiting the maximum number of concurrent subscriptions to these {@code Publisher}s.<!-- <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.v3.png" alt=""> -->Returns a {@code Flowable} that emits the results of a specified function to the pair of values emitted by thecurrent {@code Flowable} and a specified collection {@link Publisher}.<img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.v3.png" alt="">the type of items emitted by the inner {@code Publisher}sthe type of items emitted by the combiner functiona function that returns a {@code Publisher} for each item emitted by the current {@code Flowable}a function that combines one item emitted by each of the source and collection {@code Publisher}s andreturns an item to be emitted by the resulting {@code Flowable}if {@code mapper} or {@code combiner} is {@code null}current {@code Flowable} and a specified inner {@link Publisher}.the type of items emitted by the combiner functionscurrent {@code Flowable} and a specified collection {@link Publisher}, while limiting the maximum number of concurrent<!-- <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.v3.png" alt=""> -->the number of elements to prefetch from the inner {@code Publisher}s.Maps each element of the upstream {@code Flowable} into {@link CompletableSource}s, subscribes to them andwaits until the upstream and all {@code CompletableSource}s complete.<dd>The operator consumes the upstream in an unbounded manner.</dd><dd>{@code flatMapCompletable} does not operate by default on a particular {@link Scheduler}.</dd>the function that received each source value and transforms them into {@code CompletableSource}s.waits until the upstream and all {@code CompletableSource}s complete, optionally delaying all errors.<dd>If {@code maxConcurrency == }{@link Integer#MAX_VALUE} the operator consumes the upstream in an unbounded manner.Otherwise, the operator expects the upstream to honor backpressure. If the upstream doesn't support backpressurethe operator behaves as if {@code maxConcurrency == }{@link Integer#MAX_VALUE} was used.</dd>if {@code true}, errors from the upstream and inner {@code CompletableSource}s are delayed until each of themterminates.the maximum number of active subscriptions to the {@code CompletableSource}s.Merges {@link Iterable}s generated by a mapper {@link Function} for each individual item emitted bythe current {@code Flowable} into a single {@code Flowable} sequence.<img width="640" height="342" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt=""><dd>{@code flatMapIterable} does not operate by default on a particular {@link Scheduler}.</dd>the output type and the element type of the {@code Iterable}sthe type of item emitted by the resulting {@code Iterable}the current {@code Flowable} into a single {@code Flowable} sequence where the resulting items willbe the combination of the original item and each inner item of the respective {@code Iterable} as returnedby the {@code resultSelector} {@link BiFunction}.<img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.r.png" alt=""><dd>The operator honors backpressure from downstream and the current {@code Flowable}s isconsumed in a bounded manner (requesting {@link #bufferSize()} items upfront, then 75% of it after 75% received).</dd>the element type of the {@code Iterable}sthe output type as determined by the {@code resultSelector} functiona function that returns an {@code Iterable} sequence of values for each item emitted by the currenta function that returns an item based on the item emitted by the current {@code Flowable} and the{@code Iterable} returned for that item by the {@code collectionSelector}the element type of the inner {@code Iterable} sequencesMaps each element of the upstream {@code Flowable} into {@link MaybeSource}s, subscribes to all of themand merges their {@code onSuccess} values, in no particular order, into a single {@code Flowable} sequence.<dd>{@code flatMapMaybe} does not operate by default on a particular {@link Scheduler}.</dd>the function that received each source value and transforms them into {@code MaybeSource}s.Maps each element of the upstream {@code Flowable} into {@link MaybeSource}s, subscribes to at most{@code maxConcurrency} {@code MaybeSource}s at a time and merges their {@code onSuccess} values,in no particular order, into a single {@code Flowable} sequence, optionally delaying all errors.if {@code true}, errors from the upstream and inner {@code MaybeSource}s are delayed until each of themthe maximum number of active subscriptions to the {@code MaybeSource}s.Maps each element of the upstream {@code Flowable} into {@link SingleSource}s, subscribes to all of them<dd>{@code flatMapSingle} does not operate by default on a particular {@link Scheduler}.</dd>the function that received each source value and transforms them into {@code SingleSource}s.Maps each element of the upstream {@code Flowable} into {@link SingleSource}s, subscribes to at most{@code maxConcurrency} {@code SingleSource}s at a time and merges their {@code onSuccess} values,if {@code true}, errors from the upstream and inner {@code SingleSources} are delayed until each of themthe maximum number of active subscriptions to the {@code SingleSource}s.Subscribes to the current {@code Flowable} and receives notifications for each element.Alias to {@link #subscribe(Consumer)}<dd>The operator consumes the current {@code Flowable} in an unbounded manner (i.e., nobackpressure is applied to it).</dd><dd>{@code forEach} does not operate by default on a particular {@link Scheduler}.</dd>{@link Consumer} to execute for each item.a {@link Disposable} that allows canceling an asynchronous sequence<a href="http://reactivex.io/documentation/operators/subscribe.html">ReactiveX operators documentation: Subscribe</a>Subscribes to the current {@code Flowable} and receives notifications for each element until the{@code onNext} Predicate returns {@code false}.<dd>{@code forEachWhile} does not operate by default on a particular {@link Scheduler}.</dd>{@link Predicate} to execute for each item.Subscribes to the current {@code Flowable} and receives notifications for each element and error events until the{@link Consumer} to execute when an error is emitted.Subscribes to the current {@code Flowable} and receives notifications for each element and the terminal events until the{@link Action} to execute when completion is signaled.Groups the items emitted by the current {@code Flowable} according to a specified criterion, and emits thesegrouped items as {@link GroupedFlowable}s. The emitted {@code GroupedFlowable} allows only a single{@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before thesource terminates, the next emission by the source having the same key will trigger a new{@code GroupedFlowable} emission.<img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupBy.v3.png" alt=""><em>Note:</em> A {@code GroupedFlowable} will cache the items it is to emit until such time as itis subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those{@code GroupedFlowable}s that do not concern you. Instead, you can signal to them that they maydiscard their buffers by applying an operator like {@link #ignoreElements} to them.Note that the {@code GroupedFlowable}s should be subscribed to as soon as possible, otherwise,the unconsumed groups may starve other groups due to the internal backpressurecoordination of the {@code groupBy} operator. Such hangs can be usually avoided by using{@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrencyvalue to be greater or equal to the expected number of groups, possibly using{@link Integer#MAX_VALUE} if the number of expected groups is unknown.Note also that ignoring groups or subscribing later (i.e., on another thread) will result inso-called group abandonment where a group will only contain one element and the group will bere-created over and over as new upstream items trigger a new group. The behavior isa trade-off between no-dataloss, upstream cancellation and excessive group creation.<dd>The consumer of the returned {@code Flowable} has to be ready to receive new {@code GroupedFlowable}s or elsethis operator will signal {@link MissingBackpressureException}. To avoid this exception, makesure a combining operator (such as {@code flatMap}) has adequate amount of buffering/prefetch configured.The inner {@code GroupedFlowable}s honor backpressure but due to the single-source multiple consumernature of this operator, each group must be consumed so the whole operator can make progress and not hang.</dd><dd>{@code groupBy} does not operate by default on a particular {@link Scheduler}.</dd><dd>If the upstream signals or the callback(s) throw an exception, the returned {@code Flowable} andall active inner {@code GroupedFlowable}s will signal the same exception.</dd>a function that extracts the key for each item<a href="http://reactivex.io/documentation/operators/groupby.html">ReactiveX operators documentation: GroupBy</a>#groupBy(Function, boolean)#groupBy(Function, Function)if {@code true}, the exception from the current {@code Flowable} is delayed in each group until that specific group emittedthe normal values; if {@code false}, the exception bypasses values in the groups and is reported immediately.a function that extracts the return element for each itemif {@code keySelector} or {@code valueSelector} is {@code null}#groupBy(Function, Function, boolean)#groupBy(Function, Function, boolean, int)#groupBy(Function, Function, boolean, int, Function)the hint for how many {@code GroupedFlowable}s and element in each {@code GroupedFlowable} should be buffered{@code GroupedFlowable} emission. The {@code evictingMapFactory} is used to create a map that willbe used to hold the {@code GroupedFlowable}s by key. The evicting map created by this factory mustnotify the provided {@code Consumer<Object>} with the entry value (not the key!) when an entry in thismap has been evicted. The next source emission will bring about the completion of the evicted{@code GroupedFlowable}s and the arrival of an item with the same key as a completed {@code GroupedFlowable}will prompt the creation and emission of a new {@code GroupedFlowable} with that key.<p>A use case for specifying an {@code evictingMapFactory} is where the source is infinite and fast andover time the number of keys grows enough to be a concern in terms of the memory footprint of theinternal hash map containing the {@code GroupedFlowable}s.<p>The map created by an {@code evictingMapFactory} must be thread-safe.<p>An example of an {@code evictingMapFactory} using <a href="https://google.github.io/guava/releases/24.0-jre/api/docs/com/google/common/cache/CacheBuilder.html">CacheBuilder</a> from the Guava library is below:Function&lt;Consumer&lt;Object&gt;, Map&lt;Integer, Object&gt;&gt; evictingMapFactory =notify -&gt;CacheBuilder.newBuilder().maximumSize(3).removalListener(entry -&gt; {try {// emit the value not the key!notify.accept(entry.getValue());} catch (Exception e) {throw new RuntimeException(e);.&lt;Integer, Object&gt; build().asMap();// Emit 1000 items but ensure that the// internal map never has more than 3 items in it.range(1, 1000)// note that number of keys is 10.groupBy(x -&gt; x % 10, x -&gt; x, true, 16, evictingMapFactory).flatMap(g -&gt; g).forEach(System.out::println);<p>History: 2.1.10 - betaThe factory used to create a map that will be used by the implementation to hold the{@code GroupedFlowable}s. The evicting map created by this factory mustnotify the provided {@code Consumer<Object>} with the entry value (not the key!) whenan entry in this map has been evicted. The next source emission will bring about thecompletion of the evicted {@code GroupedFlowable}s. See example above.if {@code keySelector}, {@code valueSelector} or {@code evictingMapFactory} is {@code null}Returns a {@code Flowable} that correlates two {@link Publisher}s when they overlap in time and groups the results.There are no guarantees in what order the items get combined when multipleitems from one or both source {@code Publisher}s overlap.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/groupJoin.v3.png" alt=""><dd>The operator doesn't support backpressure and consumes all participating {@code Publisher}s inan unbounded mode (i.e., not applying any backpressure to them).</dd><dd>{@code groupJoin} does not operate by default on a particular {@link Scheduler}.</dd><TRight>the value type of the right {@code Publisher} source<TLeftEnd>the element type of the left duration {@code Publisher}s<TRightEnd>the element type of the right duration {@code Publisher}sthe other {@code Publisher} to correlate items from the current {@code Flowable} witha function that returns a {@code Publisher} whose emissions indicate the duration of the values ofthe current {@code Flowable}the {@code right} {@code Publisher}a function that takes an item emitted by each {@code Publisher} and returns the value to be emittedby the resulting {@code Flowable}if {@code other}, {@code leftEnd}, {@code rightEnd} or {@code resultSelector} is {@code null}<a href="http://reactivex.io/documentation/operators/join.html">ReactiveX operators documentation: Join</a>Hides the identity of this {@code Flowable} and its {@link Subscription}.<p>Allows hiding extra features such as {@link Processor}'s{@link Subscriber} methods or preventing certain identity-basedoptimizations (fusion).<dd>The operator is a pass-through for backpressure, the behavior is determined by the upstream'sIgnores all items emitted by the current {@code Flowable} and only calls {@code onComplete} or {@code onError}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ignoreElements.v3.png" alt=""><dd>This operator ignores backpressure as it doesn't emit any elements and consumes the current {@code Flowable}in an unbounded manner (i.e., no backpressure is applied to it).</dd><dd>{@code ignoreElements} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/ignoreelements.html">ReactiveX operators documentation: IgnoreElements</a>Returns a {@link Single} that emits {@code true} if the current {@code Flowable} is empty, otherwise {@code false}.In Rx.Net this is negated as the {@code any} {@link Subscriber} but we renamed this in RxJava to better match Javanaming idioms.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/isEmpty.v3.png" alt=""><dd>{@code isEmpty} does not operate by default on a particular {@link Scheduler}.</dd>Correlates the items emitted by two {@link Publisher}s based on overlapping durations.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/join_.v3.png" alt=""><dd>{@code join} does not operate by default on a particular {@link Scheduler}.</dd>the second {@code Publisher} to join items froma function to select a duration for each item emitted by the current {@code Flowable}, used todetermine overlapa function to select a duration for each item emitted by the {@code right} {@code Publisher}, used toa function that computes an item to be emitted by the resulting {@code Flowable} for any twooverlapping items emitted by the two {@code Publisher}sReturns a {@link Maybe} that emits the last item emitted by this {@code Flowable} or completes ifthis {@code Flowable} is empty.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/last.v3.png" alt=""><dd>{@code lastElement} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/last.html">ReactiveX operators documentation: Last</a>Returns a {@link Single} that emits only the last item emitted by this {@code Flowable}, or a default itemif this {@code Flowable} completes without emitting any items.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrDefault.v3.png" alt=""><dd>{@code last} does not operate by default on a particular {@link Scheduler}.</dd>the default item to emit if the current {@code Flowable} is emptyReturns a {@link Single} that emits only the last item emitted by this {@code Flowable} or signalsa {@link NoSuchElementException} if this {@code Flowable} is empty.<img width="640" height="236" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png" alt=""><dd>{@code lastOrError} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@code Flowable} which, when subscribed to, invokes the {@link FlowableOperator#apply(Subscriber) apply(Subscriber)} methodof the provided {@link FlowableOperator} for each individual downstream {@link Subscriber} and allows theinsertion of a custom operator by accessing the downstream's {@code Subscriber} during this subscription phaseand providing a new {@code Subscriber}, containing the custom operator's intended business logic, that will beGenerally, such a new {@code Subscriber} will wrap the downstream's {@code Subscriber} and forwards the{@code onNext}, {@code onError} and {@code onComplete} events from the upstream directly or according to theflow control calls of {@code cancel} and {@code request} that would have traveled upstream and perform// Step 1: Create the consumer type that will be returned by the FlowableOperator.apply():public final class CustomSubscriber&lt;T&gt; implements FlowableSubscriber&lt;T&gt;, Subscription {// The downstream's Subscriber that will receive the onXXX eventsfinal Subscriber&lt;? super String&gt; downstream;Subscription upstream;public CustomSubscriber(Subscriber&lt;? super String&gt; downstream) {// In the subscription phase, the upstream sends a Subscription to this class// and subsequently this class has to send a Subscription to the downstream.// Note that relaying the upstream's Subscription instance directly is not allowed in RxJavapublic void onSubscribe(Subscription s) {s.cancel();upstream = s;// The upstream calls this with the next item and the implementation's// responsibility is to emit an item to the downstream based on the intended// business logic, or if it can't do so for the particular item,// request more from the upstreampublic void onNext(T item) {String str = item.toString();if (str.length() &lt; 2) {downstream.onNext(str);upstream.request(1);// Some operators have to intercept the downstream's request calls to trigger// the emission of queued items while others can simply forward the request// amount as is.public void request(long n) {upstream.request(n);// the downstream cancels the flow before it completed. Operators without// resources can simply forward the cancellation to the upstream.// In some cases, a canceled flag may be set by this method so that other parts// of this class may detect the cancellation and stop sending eventspublic void cancel() {upstream.cancel();// Step 2: Create a class that implements the FlowableOperator interface andfinal class CustomOperator&lt;T&gt; implements FlowableOperator&lt;String&gt; {public Subscriber&lt;? super String&gt; apply(Subscriber&lt;? super T&gt; upstream) {return new CustomSubscriber&lt;T&gt;(upstream);Flowable.range(5, 10).lift(new CustomOperator&lt;Integer&gt;()).assertResult("5", "6", "7", "8", "9");an additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Flowable}class and creating a {@link FlowableTransformer} with it is recommended.requires a non-{@code null} {@code Subscriber} instance to be returned, which is then unconditionally subscribed tothe upstream {@code Flowable}. For example, if the operator decided there is no reason to subscribe to thereturn a {@code Subscriber} that should immediately cancel the upstream's {@link Subscription} in its{@code onSubscribe} method. Again, using a {@code FlowableTransformer} and extending the {@code Flowable} is<dd>The {@code Subscriber} instance returned by the {@code FlowableOperator} is responsible to bebackpressure-aware or document the fact that the consumer of the returned {@link Publisher} has to apply one ofthe {@code onBackpressureXXX} operators.</dd>{@code FlowableOperator} may use a {@code Scheduler} to support its own asynchronous behavior.</dd>the {@code FlowableOperator} that receives the downstream's {@code Subscriber} and should returna {@code Subscriber} with custom behavior to be used as the consumer for the currentif {@code lifter} is {@code null}#compose(FlowableTransformer)Returns a {@code Flowable} that applies a specified function to each item emitted by the current {@code Flowable} andemits the results of these function applications.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/map.v3.png" alt=""><dd>{@code map} does not operate by default on a particular {@link Scheduler}.</dd>a function to apply to each item emitted by the current {@code Flowable}#mapOptional(Function)Returns a {@code Flowable} that represents all of the emissions <em>and</em> notifications from the current{@code Flowable} into emissions marked with their original types within {@link Notification} objects.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.v3.png" alt=""><dd>The operator honors backpressure from downstream and expects it from the current {@code Flowable}.If this expectation is violated, the operator <em>may</em> throw an {@link IllegalStateException}.</dd><a href="http://reactivex.io/documentation/operators/materialize-dematerialize.html">ReactiveX operators documentation: Materialize</a>#dematerialize(Function)Flattens this and another {@link Publisher} into a single {@code Publisher}, without any transformation.using the {@code mergeWith} method.<dd>The operator honors backpressure from downstream. This and the other {@code Publisher}s are expected to honorMerges the sequence of items of this {@code Flowable} with the success value of the other {@link SingleSource}.The success value of the other {@code SingleSource} can get interleaved at any point of this<dd>The operator honors backpressure from downstream and ensures the success item from the{@code SingleSource} is emitted only when there is a downstream demand.</dd>the {@code SingleSource} whose success value to merge withMerges the sequence of items of this {@code Flowable} with the success value of the other {@link MaybeSource}or waits for both to complete normally if the {@code MaybeSource} is empty.The success value of the other {@code MaybeSource} can get interleaved at any point of this{@code MaybeSource} is emitted only when there is a downstream demand.</dd>the {@code MaybeSource} which provides a success value to merge with or completesRelays the items of this {@code Flowable} and completes only when the other {@link CompletableSource} completesas well.the {@code CompletableSource} to await for completionSignals the items and terminal signals of the current {@code Flowable} on the specified {@link Scheduler},asynchronously with a bounded buffer of {@link #bufferSize()} slots.<p>Note that {@code onError} notifications will cut ahead of {@code onNext} notifications on the emission thread if {@code Scheduler} is trulyasynchronous. If strict event ordering is required, consider using the {@link #observeOn(Scheduler, boolean)} overload.<img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/observeOn.v3.png" alt="">This operator keeps emitting as many signals as it can on the given {@code Scheduler}'s Worker thread,which may result in a longer than expected occupation of this thread. In other terms,it does not allow per-signal fairness in case the worker runs on a shared underlying thread.If such fairness and signal/work interleaving is preferred, use the delay operator with zero time instead.<dd>This operator honors backpressure from downstream and expects it from the current {@code Flowable}. Violating thisexpectation will lead to {@link MissingBackpressureException}. This is the most common operator where the exceptionpops up; look for sources up the chain that don't support backpressure,such as {@link #interval(long, TimeUnit)}, {@link #timer(long, TimeUnit)},{@link io.reactivex.rxjava3.processors.PublishProcessor PublishProcessor} or{@link io.reactivex.rxjava3.processors.BehaviorProcessor BehaviorProcessor} and apply anyof the {@code onBackpressureXXX} operators <strong>before</strong> applying {@code observeOn} itself.Note also that request amounts are not preserved between the immediate downstream and theimmediate upstream. The operator always requests the default {@link #bufferSize()} amount first, then afterevery 75% of that amount delivered, another 75% of this default value. If preserving the request amountsis to be preferred over potential excess scheduler infrastructure use, consider applying{@link #delay(long, TimeUnit, Scheduler)} with zero time instead.the {@code Scheduler} to notify {@link Subscriber}s on<a href="http://reactivex.io/documentation/operators/observeon.html">ReactiveX operators documentation: ObserveOn</a><a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/">RxJava Threading Examples</a>#subscribeOn#observeOn(Scheduler, boolean)#observeOn(Scheduler, boolean, int)#delay(long, TimeUnit, Scheduler)asynchronously with a bounded buffer and optionally delays {@code onError} notifications.{@link #delay(long, TimeUnit, Scheduler, boolean)} with zero time instead.indicates if the {@code onError} notification may not cut ahead of {@code onNext} notification on the other side of thescheduling boundary. If {@code true}, a sequence ending in {@code onError} will be replayed in the same order as was receivedfrom upstream#observeOn(Scheduler)#delay(long, TimeUnit, Scheduler, boolean)asynchronously with a bounded buffer of configurable size and optionally delays {@code onError} notifications.immediate upstream. The operator always requests the specified {@code bufferSize} amount first, then afterevery 75% of that amount delivered, another 75% of this specified value. If preserving the request amountsthe size of the buffer.Filters the items emitted by the current {@code Flowable}, only emitting those of the specified type.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ofClass.v3.png" alt=""><dd>{@code ofType} does not operate by default on a particular {@link Scheduler}.</dd>the class type to filter the items emitted by the current {@code Flowable}Buffers an unlimited number of items from the current {@code Flowable} and allows it to emit as fast it can while allowing thedownstream to consume the items at its own place.<img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.buffer.v3.png" alt="">An error from the current {@code Flowable} will cut ahead of any unconsumed item. Use {@link #onBackpressureBuffer(boolean)}to have the operator keep the original signal order.manner (i.e., not applying backpressure to it).</dd><dd>{@code onBackpressureBuffer} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/backpressure.html">ReactiveX operators documentation: backpressure operators</a>#onBackpressureBuffer(boolean)downstream to consume the items at its own place, optionally delaying an error until all buffered items have been consumed.if {@code true}, an exception from the current {@code Flowable} is delayed until all buffered elements have beenconsumed by the downstream; if {@code false}, an exception is immediately signaled to the downstream, skippingany buffered elementBuffers an limited number of items from the current {@code Flowable} and allows it to emit as fast it can while allowing thedownstream to consume the items at its own place, however, the resulting {@code Flowable} will signal a{@link MissingBackpressureException} via {@code onError} as soon as the buffer's capacity is exceeded, dropping all undelivereditems, and canceling the flow.An error from the current {@code Flowable} will cut ahead of any unconsumed item. Use {@link #onBackpressureBuffer(int, boolean)}number of slots available in the buffer.if {@code capacity} is non-positive#onBackpressureBuffer(long, Action, BackpressureOverflowStrategy)Buffers an optionally unlimited number of items from the current {@code Flowable} and allows it to emit as fast it can while allowing theIf {@code unbounded} is {@code true}, the resulting {@code Flowable} will signal aif {@code true}, the capacity value is interpreted as the internal "island" size of the unbounded bufferitems, canceling the flow and calling the {@code onOverflow} action.action to execute if an item needs to be buffered, but there are no available slots.if {@code onOverflow} is {@code null}action to execute if an item needs to be buffered, but there are no available slots.  Null is allowed.The resulting {@code Flowable} will behave as determined by {@code overflowStrategy} if the buffer capacity is exceeded:<li>{@link BackpressureOverflowStrategy#ERROR} (default) will call {@code onError} dropping all undelivered items,canceling the source, and notifying the producer with {@code onOverflow}. </li><li>{@link BackpressureOverflowStrategy#DROP_LATEST} will drop any new items emitted by the producer whilethe buffer is full, without generating any {@code onError}.  Each drop will, however, invoke {@code onOverflow}to signal the overflow to the producer.</li><li>{@link BackpressureOverflowStrategy#DROP_OLDEST} will drop the oldest items in the buffer in order to makeroom for newly emitted ones. Overflow will not generate an {@code onError}, but each drop will invoke{@code onOverflow} to signal the overflow to the producer.</li>action to execute if an item needs to be buffered, but there are no available slots, {@code null} is allowed.how should the resulting {@code Flowable} react to buffer overflows, {@code null} is not allowed.if {@code onOverflow} or {@code overflowStrategy} is {@code null}Drops items from the current {@code Flowable} if the downstream is not ready to receive new items (indicatedby a lack of {@link Subscription#request(long)} calls from it).<img width="640" height="245" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.drop.v3.png" alt="">If the downstream request count hits 0 then the resulting {@code Flowable} will refrain from calling {@code onNext} untilthe {@link Subscriber} invokes {@code request(n)} again to increase the request count.<dd>{@code onBackpressureDrop} does not operate by default on a particular {@link Scheduler}.</dd>by a lack of {@link Subscription#request(long)} calls from it) and calls the given {@link Consumer} with suchdropped items.the action to invoke for each item dropped, should be fast and should never block.if {@code onDrop} is {@code null}Drops all but the latest item emitted by the current {@code Flowable} if the downstream is not ready to receivenew items (indicated by a lack of {@link Subscription#request(long)} calls from it) and emits this latestitem when the downstream becomes ready.<img width="640" height="245" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/bp.obp.latest.v3.png" alt="">Its behavior is logically equivalent to {@code blockingLatest()} with the exception thatthe downstream is not blocking while requesting more values.Note that if the current {@code Flowable} does support backpressure, this operator ignores that capabilityand doesn't propagate any backpressure requests from downstream.Note that due to the nature of how backpressure requests are propagated through subscribeOn/observeOn,requesting more than 1 from downstream doesn't guarantee a continuous delivery of {@code onNext} events.<dd>{@code onBackpressureLatest} does not operate by default on a particular {@link Scheduler}.</dd>Reduces a sequence of two not emitted values via a function into a single value if the downstream is not ready to receive<img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.onBackpressureReduce.png" alt=""><dd>{@code onBackpressureReduce} does not operate by default on a particular {@link Scheduler}.</dd>the bi-function to call when there is more than one non-emitted value to downstream,the first argument of the bi-function is previous item and the second one is currentlyemitting from upstreamif {@code reducer} is {@code null}3.0.9 - experimental#onBackpressureReduce(Supplier, BiFunction)Reduces upstream values into an aggregate value, provided by a supplier and combined via a reducer function,while the downstream is not ready to receive items, then emits this aggregate value when the downstream becomes ready.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.onBackpressureReduce.ff.png" alt="">Note that even if the downstream is ready to receive an item, the upstream item will always be aggregated into the output type,calling both the supplier and the reducer to produce the output value.the aggregate type emitted when the downstream requests more itemsthe factory to call to create new item of type R to pass it as the first argument to {@code reducer}.It is called when previous returned value by {@code reducer} already sent todownstream or the very first update from upstream received.the bi-function to call to reduce excessive updates which downstream is not ready to receive.The first argument of type R is the object returned by {@code supplier} or result of previous{@code reducer} invocation. The second argument of type T is the current update from upstream.if {@code supplier} or {@code reducer} is {@code null}#onBackpressureReduce(BiFunction)Returns a {@code Flowable} instance that if the current {@code Flowable} emits an error, it will emit an {@code onComplete}and swallow the throwable.<img width="640" height="372" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.onErrorComplete.png" alt="">Returns a {@code Flowable} instance that if the current {@code Flowable} emits an error and the predicate returns{@code true}, it will emit an {@code onComplete} and swallow the throwable.<img width="640" height="201" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.onErrorComplete.f.png" alt="">the predicate to call when an {@link Throwable} is emitted which should return {@code true}Resumes the flow with a {@link Publisher} returned for the failure {@link Throwable} of the current {@code Flowable} by afunction instead of signaling the error via {@code onError}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.v3.png" alt="">By default, when a {@code Publisher} encounters an error that prevents it from emitting the expected item toits {@link Subscriber}, the {@code Publisher} invokes its {@code Subscriber}'s {@code onError} method, and then quitswithout invoking any more of its {@code Subscriber}'s methods. The {@code onErrorResumeNext} method changes thisbehavior. If you pass a function that returns a {@code Publisher} ({@code resumeFunction}) to{@code onErrorResumeNext}, if the original {@code Publisher} encounters an error, instead of invoking its{@code Subscriber}'s {@code onError} method, it will instead relinquish control to the {@code Publisher} returned from{@code resumeFunction}, which will invoke the {@code Subscriber}'s {@link Subscriber#onNext onNext} method if it isable to do so. In such a case, because no {@code Publisher} necessarily invokes {@code onError}, the {@code Subscriber}may never know that an error happened.<dd>The operator honors backpressure from downstream. This and the resuming {@code Publisher}sare expected to honor backpressure as well.If any of them violate this expectation, the operator <em>may</em> throw an{@link IllegalStateException} when the current {@code Flowable} completes ora {@link MissingBackpressureException} is signaled somewhere downstream.</dd>a function that returns a {@code Publisher} that will take over if the current {@code Flowable} encountersResumes the flow with the given {@link Publisher} when the current {@code Flowable} fails instead of<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeWith.v3.png" alt="">without invoking any more of its {@code Subscriber}'s methods. The {@code onErrorResumeWith} method changes thisbehavior. If you pass another {@code Publisher} ({@code resumeSequence}) to a {@code Publisher}'s{@code onErrorResumeWith} method, if the original {@code Publisher} encounters an error, instead of invoking its{@code Subscriber}'s {@code onError} method, it will instead relinquish control to {@code resumeSequence} whichwill invoke the {@code Subscriber}'s {@link Subscriber#onNext onNext} method if it is able to do so. In such a case,because no {@code Publisher} necessarily invokes {@code onError}, the {@code Subscriber} may never know that an errorhappened.{@link MissingBackpressureException} is signaled somewhere downstream.</dd>the next {@code Publisher} source that will take over if the current {@code Flowable} encountersEnds the flow with a last item returned by a function for the {@link Throwable} error signaled by the current{@code Flowable} instead of signaling the error via {@code onError}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.v3.png" alt="">By default, when a {@link Publisher} encounters an error that prevents it from emitting the expected item towithout invoking any more of its {@code Subscriber}'s methods. The {@code onErrorReturn} method changes thisbehavior. If you pass a function ({@code resumeFunction}) to a {@code Publisher}'s {@code onErrorReturn}method, if the original {@code Publisher} encounters an error, instead of invoking its {@code Subscriber}'s{@code onError} method, it will instead emit the return value of {@code resumeFunction}.<dd>The operator honors backpressure from downstream. The current {@code Flowable} is expected to honorbackpressure as well. If it this expectation is violated, the operator <em>may</em> throwa function that returns a single value that will be emitted along with a regular {@code onComplete} in casethe current {@code Flowable} signals an {@code onError} eventEnds the flow with the given last item when the current {@code Flowable} fails instead of signaling the error via {@code onError}.the value that is emitted along with a regular {@code onComplete} in case the current{@code Flowable} signals an exceptionNulls out references to the upstream producer and downstream {@link Subscriber} ifthe sequence is terminated or downstream cancels.the sequence is terminated or downstream cancelsParallelizes the flow by creating multiple 'rails' (equal to the number of CPUs)and dispatches the upstream items to them in a round-robin fashion.Note that the rails don't execute in parallel on their own and one needs toapply {@link ParallelFlowable#runOn(Scheduler)} to specify the {@link Scheduler} whereeach rail will execute.To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}.<img width="640" height="547" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flowable.parallel.png" alt=""><dd>The operator requires the upstream to honor backpressure and each 'rail' honors backpressureas well.</dd><dd>{@code parallel} does not operate by default on a particular {@code Scheduler}.</dd><p>History: 2.0.5 - experimental; 2.1 - betathe new {@link ParallelFlowable} instanceParallelizes the flow by creating the specified number of 'rails'the number of 'rails' to useif {@code parallelism} is non-positiveand dispatches the upstream items to them in a round-robin fashion anduses the defined per-'rail' prefetch amount.the number of items each 'rail' should prefetchif {@code parallelism} or {@code prefetch} is non-positiveReturns a {@link ConnectableFlowable}, which is a variety of {@link Publisher} that waits until its{@link ConnectableFlowable#connect connect} method is called before it begins emitting items to those{@link Subscriber}s that have subscribed to it.<img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.v3.png" alt=""><dd>The returned {@code ConnectableFlowable} honors backpressure for each of its {@code Subscriber}sand expects the current {@code Flowable} to honor backpressure as well. If this expectation is violated,the operator will signal a {@link MissingBackpressureException} to its {@code Subscriber}s and disconnect.</dd><dd>{@code publish} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code ConnectableFlowable} instance<a href="http://reactivex.io/documentation/operators/publish.html">ReactiveX operators documentation: Publish</a>Returns a {@code Flowable} that emits the results of invoking a specified selector on items emitted by a{@link ConnectableFlowable} that shares a single subscription to the underlying sequence.<img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishConnect.f.v3.png" alt=""><dd>The operator expects the current {@code Flowable} to honor backpressure and if this expectation isviolated, the operator will signal a {@link MissingBackpressureException} through the {@code Flowable}provided to the function. Since the {@link Publisher} returned by the {@code selector} may beindependent of the provided {@code Flowable} to the function, the output's backpressure behavioris determined by this returned {@code Publisher}.</dd>the type of items emitted by the resulting {@code Flowable}a function that can use the multicasted source sequence as many times as needed, withoutcausing multiple subscriptions to the source sequence. {@link Subscriber}s to the given source willreceive all notifications of the source from the time of the subscription forward.Requests {@code n} initially from the upstream and then 75% of {@code n} subsequentlyafter 75% of {@code n} values have been emitted to the downstream.<p>This operator allows preventing the downstream to trigger unbounded mode via {@code request(}{@link Long#MAX_VALUE}{@code )}or compensate for the per-item overhead of small and frequent requests.<dd>The operator expects backpressure from upstream and honors backpressure from downstream.</dd><dd>{@code rebatchRequests} does not operate by default on a particular {@link Scheduler}.</dd>the initial request amount, further request will happen after 75% of this valueif {@code n} is non-positiveReturns a {@link Maybe} that applies a specified accumulator function to the first item emitted by the current{@code Flowable}, then feeds the result of that function along with the second item emitted by the current{@code Flowable} into the same function, and so on until all items have been emitted by the current and finite {@code Flowable},and emits the final result from the final call to your function as its sole item.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduce.v3.png" alt="">This technique, which is called "reduce" here, is sometimes called "aggregate," "fold," "accumulate,""compress," or "inject" in other programming contexts. Groovy, for instance, has an {@code inject} methodthat does a similar operation on lists.<dd>The operator honors backpressure of its downstream consumer and consumes theupstream source in unbounded mode.</dd><dd>{@code reduce} does not operate by default on a particular {@link Scheduler}.</dd>an accumulator function to be invoked on each item emitted by the current {@code Flowable}, whoseresult will be used in the next accumulator call<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Wikipedia: Fold (higher-order function)</a>Returns a {@link Single} that applies a specified accumulator function to the first item emitted by the current{@code Flowable} and a specified seed value, then feeds the result of that function along with the second itememitted by the current {@code Flowable} into the same function, and so on until all items have been emitted by thecurrent and finite {@code Flowable}, emitting the final result from the final call to your function as its sole item.<img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.v3.png" alt="">Note that the {@code seed} is shared among all subscribers to the resulting {@code Flowable}and may cause problems if it is mutable. To make sure each subscriber gets its own value, deferthe application of this operator via {@link #defer(Supplier)}:Flowable&lt;T&gt; source = ...Single.defer(() -&gt; source.reduce(new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item)));// alternatively, by using compose to stay fluentsource.compose(o -&gt;Flowable.defer(() -&gt; o.reduce(new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item)).toFlowable())).firstOrError();// or, by using reduceWith instead of reducesource.reduceWith(() -&gt; new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item)));the accumulator and output value typethe initial (seed) accumulator valuean accumulator function to be invoked on each item emitted by the current {@code Flowable}, theresult of which will be used in the next accumulator callif {@code seed} or {@code reducer} is {@code null}#reduceWith(Supplier, BiFunction){@code Flowable} and a seed value derived from calling a specified {@code seedSupplier}, then feeds the resultof that function along with the second item emitted by the current {@code Flowable} into the same function, and so on untilall items have been emitted by the current and finite {@code Flowable}, emitting the final result from the final call to yourfunction as its sole item.This technique, which is called "reduce" here, is sometimes called "aggregate", "fold", "accumulate","compress", or "inject" in other programming contexts. Groovy, for instance, has an {@code inject} method<dd>{@code reduceWith} does not operate by default on a particular {@link Scheduler}.</dd>the {@link Supplier} that provides the initial (seed) accumulator value for each individual {@link Subscriber}if {@code seedSupplier} or {@code reducer} is {@code null}Returns a {@code Flowable} that repeats the sequence of items emitted by the current {@code Flowable} indefinitely.<img width="640" height="309" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.o.v3.png" alt=""><dd>The operator honors downstream backpressure and expects the current {@code Flowable} to honor backpressure as well.<a href="http://reactivex.io/documentation/operators/repeat.html">ReactiveX operators documentation: Repeat</a>Returns a {@code Flowable} that repeats the sequence of items emitted by the current {@code Flowable} at most{@code count} times.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeat.on.v3.png" alt="">the number of times the current {@code Flowable} items are repeated, a count of 0 will yield an emptysequenceif {@code times} is less than zeroReturns a {@code Flowable} that repeats the sequence of items emitted by the current {@code Flowable} untilthe provided stop function returns {@code true}.a boolean supplier that is called when the current {@code Flowable} completes and unless it returns{@code false}, the current {@code Flowable} is resubscribedReturns a {@code Flowable} that emits the same values as the current {@code Flowable} with the exception of an{@code onComplete}. An {@code onComplete} notification from the source will result in the emission ofa {@code void} item to the {@code Flowable} provided as an argument to the {@code notificationHandler}function. If that {@link Publisher} calls {@code onComplete} or {@code onError} then {@code repeatWhen} willcall {@code onComplete} or {@code onError} on the child subscription. Otherwise, this {@code Publisher} willresubscribe to the current {@code Flowable}.<img width="640" height="430" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatWhen.f.v3.png" alt="">receives a {@code Publisher} of notifications with which a user can complete or error, aborting the repeat.Returns a {@link ConnectableFlowable} that shares a single subscription to the underlying {@link Publisher}that will replay all of its items and notifications to any future {@link Subscriber}. A connectable{@code Flowable} resembles an ordinary {@code Flowable}, except that it does not begin emitting items when it issubscribed to, but only when its {@code connect} method is called.<img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.v3.png" alt=""><dd>This operator supports backpressure. Note that the upstream requests are determined by the child{@code Subscriber} which requests the largest amount: i.e., two child {@code Subscriber}s with requests of 10 and 100 willrequest 100 elements from the current {@code Flowable} sequence.</dd><dd>This version of {@code replay} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@code Flowable} that emits items that are the results of invoking a specified selector on the itemsemitted by a {@link ConnectableFlowable} that shares a single subscription to the current {@code Flowable}.<img width="640" height="450" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.f.v3.png" alt="">{@link Subscriber} which requests the largest amount: i.e., two child {@code Subscriber}s with requests of 10 and 100 willthe selector function, which can use the multicasted sequence as many times as needed, withoutcausing multiple subscriptions to the current {@code Flowable}Returns a {@code Flowable} that emits items that are the results of invoking a specified selector on itemsemitted by a {@link ConnectableFlowable} that shares a single subscription to the current {@code Flowable},replaying {@code bufferSize} notifications.Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than{@code bufferSize} source emissions.<img width="640" height="440" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fn.v3.png" alt="">the buffer size that limits the number of items the operator can replay#replay(Function, int, boolean)if {@code true}, whenever the internal buffer is truncated to the given bufferSize, theoldest item will be guaranteed dereferenced, thus avoiding unexpected retentionreplaying no more than {@code bufferSize} items that were emitted within a specified time window.<img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnt.v3.png" alt=""><dd>This version of {@code replay} operates by default on the {@code computation} {@link Scheduler}.</dd>a selector function, which can use the multicasted sequence as many times as needed, withoutthe duration of the window in which the replayed items must have been emittedthe time unit of {@code time}if {@code selector} or {@code unit} is {@code null}<img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnts.v3.png" alt="">the {@code Scheduler} that is the time source for the windowif {@code selector}, {@code unit} or {@code scheduler} is {@code null}#replay(Function, int, long, TimeUnit, Scheduler, boolean)if {@code true}, whenever the internal buffer is truncated to the given bufferSize/age, theif {@code bufferSize} is less than zeroreplaying all items that were emitted within a specified time window.<img width="640" height="435" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ft.v3.png" alt=""><img width="640" height="440" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fts.v3.png" alt="">the scheduler that is the time source for the window#replay(Function, long, TimeUnit, Scheduler, boolean)if {@code true}, whenever the internal buffer is truncated to the given age, theReturns a {@link ConnectableFlowable} that shares a single subscription to the current {@code Flowable} andreplays at most {@code bufferSize} items to late {@link Subscriber}s. A Connectable {@code Flowable} resemblesan ordinary {@code Flowable}, except that it does not begin emitting items when it is subscribed to, but onlywhen its {@code connect} method is called.To ensure no beyond-bufferSize items are referenced,use the {@link #replay(int, boolean)} overload with {@code eagerTruncate = true}.<img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.n.v3.png" alt="">the buffer size that limits the number of items that can be replayed#replay(int, boolean)replays at most {@code bufferSize} items to late {@link Subscriber}s. A connectable {@code Flowable} resemblesTo ensure no beyond-bufferSize items are referenced, set {@code eagerTruncate = true}.replays at most {@code bufferSize} items that were emitted during a specified time window. A connectable<img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.nt.v3.png" alt="">To ensure no out-of-date or beyond-bufferSize items are referenced,use the {@link #replay(int, long, TimeUnit, Scheduler, boolean)} overload with {@code eagerTruncate = true}.#replay(int, long, TimeUnit, Scheduler, boolean)replays a maximum of {@code bufferSize} items that are emitted within a specified time window to late {@link Subscriber}s. Aconnectable {@code Flowable} resembles an ordinary {@code Flowable}, except that it does not begin emitting itemswhen it is subscribed to, but only when its {@code connect} method is called.<img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.nts.v3.png" alt="">the scheduler that is used as a time source for the window{@code bufferSize} source emissions. To ensure no out-of-date or beyond-bufferSize itemsare referenced, set {@code eagerTruncate = true}.replays all items emitted by it within a specified time window to late {@link Subscriber}s. A connectable {@code Flowable}resembles an ordinary {@code Flowable}, except that it does not begin emitting items when it is subscribed to,but only when its {@code connect} method is called.<img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.t.v3.png" alt="">Note that the internal buffer may retain strong references to the oldest item. To ensure no out-of-date itemsare referenced, use the {@link #replay(long, TimeUnit, Scheduler, boolean)} overload with {@code eagerTruncate = true}.<img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.ts.v3.png" alt="">#replay(long, TimeUnit, Scheduler, boolean)Returns a {@code Flowable} that mirrors the current {@code Flowable}, resubscribing to it if it calls {@code onError}(infinite retry count).<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.v3.png" alt="">If the current {@code Flowable} calls {@link Subscriber#onError}, this method will resubscribe to the current{@code Flowable} rather than propagating the {@code onError} call.Any and all items emitted by the current {@code Flowable} will be emitted by the resulting {@code Flowable}, eventhose emitted during failed subscriptions. For example, if the current {@code Flowable} fails at first but emits{@code [1, 2]} then succeeds the second time and emits {@code [1, 2, 3, 4, 5]} then the complete sequenceof emissions and notifications would be {@code [1, 2, 1, 2, 3, 4, 5, onComplete]}.<a href="http://reactivex.io/documentation/operators/retry.html">ReactiveX operators documentation: Retry</a>and the predicate returns {@code true} for that specific exception and retry count.the predicate that determines if a resubscription may happen in case of a specific exceptionand retry count#retry()up to a specified number of retries.{@code Flowable} for a maximum of {@code count} resubscriptions rather than propagating the{@code onError} call.the number of times to resubscribe if the current {@code Flowable} failsRetries at most times or until the predicate returns {@code false}, whichever happens first.the predicate called with the failure {@link Throwable} and should return {@code true} to trigger a retry.Retries the current {@code Flowable} if the predicate returns {@code true}.the predicate that receives the failure {@link Throwable} and should return {@code true} to trigger a retry.{@code onError}. An {@code onError} notification from the source will result in the emission of a{@link Throwable} item to the {@code Flowable} provided as an argument to the {@code notificationHandler}function. If that {@link Publisher} calls {@code onComplete} or {@code onError} then {@code retry} will call{@code onComplete} or {@code onError} on the child subscription. Otherwise, this {@code Publisher} will<img width="640" height="430" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryWhen.f.v3.png" alt="">This retries 3 times, each time incrementing the number of seconds it waits.Flowable.create((FlowableEmitter&lt;? super String&gt; s) -&gt; {System.out.println("subscribing");s.onError(new RuntimeException("always fails"));}, BackpressureStrategy.BUFFER).retryWhen(attempts -&gt; {return attempts.zipWith(Flowable.range(1, 3), (n, i) -&gt; i).flatMap(i -&gt; {System.out.println("delay retry by " + i + " second(s)");return Flowable.timer(i, TimeUnit.SECONDS);}).blockingForEach(System.out::println);Output is:<pre> {@codesubscribingdelay retry by 1 second(s)delay retry by 2 second(s)delay retry by 3 second(s)} </pre>{@code Throwable} to indicate the operator should retry or terminate. If the upstream toFlowable.timer(1, TimeUnit.SECONDS).map(v -&gt; { throw new RuntimeException(); }).blockingSubscribe(System.out::println, System.out::println);<dd>The operator honors downstream backpressure and expects both the sourceand inner {@code Publisher}s to honor backpressure as well.receives a {@code Publisher} of notifications with which a user can complete or error, aborting theSubscribes to the current {@code Flowable} and wraps the given {@link Subscriber} into a {@link SafeSubscriber}(if not already a {@code SafeSubscriber}) thatdeals with exceptions thrown by a misbehaving {@code Subscriber} (that doesn't follow the<em>Reactive Streams</em> specification).<dd>This operator leaves the reactive world and the backpressure behavior depends on the {@code Subscriber}'s behavior.</dd>the incoming {@code Subscriber} instanceReturns a {@code Flowable} that emits the most recently emitted item (if any) emitted by the current {@code Flowable}within periodic time intervals.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.v3.png" alt=""><dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.</dd>the sampling rate<a href="http://reactivex.io/documentation/operators/sample.html">ReactiveX operators documentation: Sample</a>#throttleLast(long, TimeUnit)within periodic time intervals and optionally emit the very last upstream item when the upstream completes.<img width="640" height="277" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.png" alt="">if {@code true}, and the upstream completes while there is still an unsampled item available,that item is emitted to downstream before completionif {@code false}, an unsampled last item is ignored.within periodic time intervals, where the intervals are defined on a particular {@link Scheduler}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.v3.png" alt="">the {@code Scheduler} to use when sampling#throttleLast(long, TimeUnit, Scheduler)within periodic time intervals, where the intervals are defined on a particular {@link Scheduler}and optionally emit the very last upstream item when the upstream completes.<img width="640" height="277" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.png" alt="">if {@code true} and the upstream completes while there is still an unsampled item available,Returns a {@code Flowable} that, when the specified {@code sampler} {@link Publisher} emits an item or completes,emits the most recently emitted item (if any) emitted by the current {@code Flowable} since the previousemission from the {@code sampler} {@code Publisher}.<img width="640" height="290" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.nolast.png" alt=""><dd>This operator does not support backpressure as it uses the emissions of the {@code sampler}{@code Publisher} to control data flow.</dd><dd>This version of {@code sample} does not operate by default on a particular {@link Scheduler}.</dd>the element type of the sampler {@code Publisher}the {@code Publisher} to use for sampling the current {@code Flowable}if {@code sampler} is {@code null}emission from the {@code sampler} {@code Publisher}and optionally emit the very last upstream item when the upstream or other {@code Publisher} complete.<img width="640" height="290" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.emitlast.png" alt="">Returns a {@code Flowable} that emits the first value emitted by the current {@code Flowable}, then emits one valuefor each subsequent value emitted by the current {@code Flowable}. Each emission after the first is the result ofapplying the specified accumulator function to the previous emission and the corresponding value from the current {@code Flowable}.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scan.v3.png" alt="">This sort of function is sometimes called an accumulator.Violating this expectation, a {@link MissingBackpressureException} <em>may</em> get signaled somewhere downstream.</dd><dd>{@code scan} does not operate by default on a particular {@link Scheduler}.</dd>result will be emitted to {@link Subscriber}s via {@link Subscriber#onNext onNext} and used in thenext accumulator callif {@code accumulator} is {@code null}<a href="http://reactivex.io/documentation/operators/scan.html">ReactiveX operators documentation: Scan</a>Returns a {@code Flowable} that emits the provided initial (seed) value, then emits one value for each value emittedby the current {@code Flowable}. Each emission after the first is the result of applying the specified accumulatorfunction to the previous emission and the corresponding value from the current {@code Flowable}.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/scanSeed.v3.png" alt="">Note that the {@code Flowable} that results from this method will emit {@code initialValue} as its firstemitted item.Note that the {@code initialValue} is shared among all subscribers to the resulting {@code Flowable}Publisher&lt;T&gt; source = ...Flowable.defer(() -&gt; source.scan(new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item)));Flowable.defer(() -&gt; o.scan(new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item))));Violating this expectation, a {@link MissingBackpressureException} <em>may</em> get signaled somewhere downstream.The downstream request pattern is not preserved across this operator.The upstream is requested {@link #bufferSize()} - 1 upfront and 75% of {@link #bufferSize()} thereafter.</dd>the initial, accumulator and result typethe initial (seed) accumulator itemif {@code initialValue} or {@code accumulator} is {@code null}Note that the {@code Flowable} that results from this method will emit the value returned bythe {@code seedSupplier} as its first item.<dd>{@code scanWith} does not operate by default on a particular {@link Scheduler}.</dd>a {@link Supplier} that returns the initial (seed) accumulator item for each individual {@link Subscriber}result will be emitted to {@code Subscriber}s via {@link Subscriber#onNext onNext} and used in theif {@code seedSupplier} or {@code accumulator} is {@code null}Forces the current {@code Flowable}'s emissions and notifications to be serialized and for it to obey<a href="http://reactivex.io/documentation/contract.html">the {@code Publisher} contract</a> in other ways.It is possible for a {@link Publisher} to invoke its {@link Subscriber}s' methods asynchronously, perhaps fromdifferent threads. This could make such a {@code Publisher} poorly-behaved, in that it might try to invoke{@code onComplete} or {@code onError} before one of its {@code onNext} invocations, or it might call{@code onNext} from two different threads concurrently. You can force such a {@code Publisher} to bewell-behaved and sequential by applying the {@code serialize} method to it.<img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/synchronize.v3.png" alt=""><dd>{@code serialize} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/serialize.html">ReactiveX operators documentation: Serialize</a>Returns a new {@code Flowable} that multicasts (and shares a single subscription to) the current {@code Flowable}. As long asthere is at least one {@link Subscriber}, the current {@code Flowable} will be subscribed and emitting data.When all subscribers have canceled it will cancel the current {@code Flowable}.This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount() refCount()}.<img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.v3.png" alt=""><dd>The operator honors backpressure and expects the current {@code Flowable} to honor backpressure as well.If this expectation is violated, the operator will signal a {@link MissingBackpressureException} toits {@code Subscriber}s.</dd><dd>{@code share} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/refcount.html">ReactiveX operators documentation: RefCount</a>Returns a {@link Maybe} that completes if this {@code Flowable} is empty, signals one item if this {@code Flowable}signals exactly one item or signals an {@link IllegalArgumentException} if this {@code Flowable} signalsmore than one item.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/single.v3.png" alt=""><dd>{@code singleElement} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@link Single} that emits the single item emitted by the current {@code Flowable} if itemits only a single item, or a default item if the current {@code Flowable} emits no items. If the current{@code Flowable} emits more than one item, an {@link IllegalArgumentException} is signaled instead.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrDefault.v3.png" alt=""><dd>{@code single} does not operate by default on a particular {@link Scheduler}.</dd>a default value to emit if the current {@code Flowable} emits no itemReturns a {@link Single} that emits the single item emitted by this {@code Flowable}, if this {@code Flowable}emits only a single item, otherwiseif this {@code Flowable} completes without emitting any items a {@link NoSuchElementException} will be signaled andif this {@code Flowable} emits more than one item, an {@link IllegalArgumentException} will be signaled.<img width="640" height="206" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrError.png" alt=""><dd>{@code singleOrError} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@code Flowable} that skips the first {@code count} items emitted by the current {@code Flowable} and emitsthe remainder.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.v3.png" alt=""><dd>This version of {@code skip} does not operate by default on a particular {@link Scheduler}.</dd>the number of items to skipif {@code count} is negative<a href="http://reactivex.io/documentation/operators/skip.html">ReactiveX operators documentation: Skip</a>Returns a {@code Flowable} that skips values emitted by the current {@code Flowable} before a specified time windowelapses.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.t.v3.png" alt=""><dd>The operator doesn't support backpressure as it uses time to skip an arbitrary number of elements andthus has to consume the current {@code Flowable} in an unbounded manner (i.e., no backpressure applied to it).</dd><dd>{@code skip} does not operate on any particular scheduler but uses the current timefrom the {@code computation} {@link Scheduler}.</dd>the length of the time window to skipon a specified {@link Scheduler} elapses.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.ts.v3.png" alt=""><dd>You specify which {@code Scheduler} this operator will use for the timed skipping</dd>the {@code Scheduler} on which the timed wait happensReturns a {@code Flowable} that drops a specified number of items from the end of the sequence emitted by thecurrent {@code Flowable}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.v3.png" alt="">This {@link Subscriber} accumulates a queue long enough to store the first {@code count} items. As more items arereceived, items are taken from the front of the queue and emitted by the resulting {@code Flowable}. This causessuch items to be delayed.<dd>This version of {@code skipLast} does not operate by default on a particular {@link Scheduler}.</dd>number of items to drop from the end of the source sequenceif {@code count} is less than zero<a href="http://reactivex.io/documentation/operators/skiplast.html">ReactiveX operators documentation: SkipLast</a>Returns a {@code Flowable} that drops items emitted by the current {@code Flowable} during a specified time windowbefore the source completes.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.t.v3.png" alt="">Note: this action will cache the latest items arriving in the specified time window.<dd>{@code skipLast} does not operate on any particular scheduler but uses the current timethe length of the time windowif {@code true}, an exception signaled by the current {@code Flowable} is delayed until the regular elements are consumedby the downstream; if {@code false}, an exception is immediately signaled and all regular elements dropped(defined on a specified scheduler) before the source completes.<img width="640" height="340" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.ts.v3.png" alt=""><dd>You specify which {@link Scheduler} this operator will use for tracking the current time</dd>the scheduler used as the time source<dd>You specify which {@link Scheduler} this operator will use to track the current time</dd>the hint about how many elements to expect to be skipped the internal buffer holds pairs of (timestamp, value) so double the default buffer sizeReturns a {@code Flowable} that skips items emitted by the current {@code Flowable} until a second {@link Publisher} emitsan item.<img width="640" height="375" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipUntil.v3.png" alt=""><dd>{@code skipUntil} does not operate by default on a particular {@link Scheduler}.</dd>the element type of the other {@code Publisher}the second {@code Publisher} that has to emit an item before the current {@code Flowable}'s elements beginto be mirrored by the resulting {@code Flowable}<a href="http://reactivex.io/documentation/operators/skipuntil.html">ReactiveX operators documentation: SkipUntil</a>Returns a {@code Flowable} that skips all items emitted by the current {@code Flowable} as long as a specifiedcondition holds {@code true}, but emits all further source items as soon as the condition becomes {@code false}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipWhile.v3.png" alt=""><dd>{@code skipWhile} does not operate by default on a particular {@link Scheduler}.</dd>a function to test each item emitted from the current {@code Flowable}<a href="http://reactivex.io/documentation/operators/skipwhile.html">ReactiveX operators documentation: SkipWhile</a>Returns a {@code Flowable} that emits the events emitted by source {@link Publisher}, in asorted order. Each item emitted by the {@code Publisher} must implement {@link Comparable} with respect to allother items in the sequence.<p>If any item emitted by this {@code Flowable} does not implement {@code Comparable} with respect toall other items emitted by this {@code Flowable}, no items will be emitted and thesequence is terminated with a {@link ClassCastException}.<p>Note that calling {@code sorted} with long, non-terminating or infinite sourcesmight cause {@link OutOfMemoryError}unbounded manner (i.e., without applying backpressure to it).</dd><dd>{@code sorted} does not operate by default on a particular {@link Scheduler}.</dd>sorted order based on a specified comparison function.a function that compares two items emitted by the current {@code Flowable} and returns an {@link Integer}that indicates their sort orderif {@code comparator} is {@code null}Returns a {@code Flowable} that emits the items in a specified {@link Iterable} before it begins to emit itemsemitted by the current {@code Flowable}.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.v3.png" alt=""><dd>The operator honors backpressure from downstream. The Current {@code Flowable}is expected to honor backpressure as well. If it violates this rule, it <em>may</em> throw an<dd>{@code startWithIterable} does not operate by default on a particular {@link Scheduler}.</dd>an {@code Iterable} that contains the items you want the resulting {@code Flowable} to emit first<a href="http://reactivex.io/documentation/operators/startwith.html">ReactiveX operators documentation: StartWith</a>#startWithArray(Object...)#startWithItem(Object)Returns a {@code Flowable} which first runs the other {@link CompletableSource}then the current {@code Flowable} if the other completed normally.<img width="640" height="268" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.startWith.c.png" alt="">Returns a {@code Flowable} which first runs the other {@link SingleSource}then the current {@code Flowable} if the other succeeded normally.<img width="640" height="248" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.startWith.s.png" alt="">Returns a {@code Flowable} which first runs the other {@link MaybeSource}then the current {@code Flowable} if the other succeeded or completed normally.<img width="640" height="168" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.startWith.m.png" alt="">Returns a {@code Flowable} that emits the items in a specified {@link Publisher} before it begins to emititems emitted by the current {@code Flowable}.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.o.v3.png" alt=""><dd>The operator honors backpressure from downstream. Both this and the {@code other} {@code Publisher}sa {@code Publisher} that contains the items you want the modified {@code Publisher} to emit firstReturns a {@code Flowable} that emits a specified item before it begins to emit items emitted by the current<dd>The operator honors backpressure from downstream. The current {@code Flowable}<dd>{@code startWithItem} does not operate by default on a particular {@link Scheduler}.</dd>the item to emit first#startWithIterable(Iterable)Returns a {@code Flowable} that emits the specified items before it begins to emit items emitted by the current<dd>{@code startWithArray} does not operate by default on a particular {@link Scheduler}.</dd>the array of values to emit firstSubscribes to the current {@code Flowable} and ignores {@code onNext} and {@code onComplete} emissions.the new {@link Disposable} instance that allows cancelling the flowSubscribes to the current {@code Flowable} and provides a callback to handle the items it emits.the {@code Consumer<T>} you have designed to accept emissions from the current {@code Flowable}Subscribes to the current {@code Flowable} and provides callbacks to handle the items it emits and any errornotification it issues.the {@code Consumer<Throwable>} you have designed to accept any error notification from theSubscribes to the current {@code Flowable} and provides callbacks to handle the items it emits and any error orcompletion notification it issues.the {@link Action} you have designed to accept a completion notification from theEstablish a connection between this {@code Flowable} and the given {@link FlowableSubscriber} andstart streaming events based on the demand of the {@code FlowableSubscriber}.This is a "factory method" and can be called multiple times, each time starting a new {@link Subscription}.Each {@code Subscription} will work for only a single {@code FlowableSubscriber}.If the same {@code FlowableSubscriber} instance is subscribed to multiple {@code Flowable}s and/or thesame {@code Flowable} multiple times, it must ensure the serialization over its {@code onXXX}methods manually.If the {@code Flowable} rejects the subscription attempt or otherwise fails it will signalthe error via {@link FlowableSubscriber#onError(Throwable)}.This subscribe method relaxes the following <em>Reactive Streams</em> rules:<li>1.3: {@code onNext} should not be called concurrently until {@code onSubscribe} returns.<b>{@link FlowableSubscriber#onSubscribe(Subscription)} should make sure a sync or async call triggered by request() is safe.</b></li><li>2.3: {@code onError} or {@code onComplete} must not call cancel.<b>Calling request() or cancel() is NOP at this point.</b></li><li>2.12: {@code onSubscribe} must be called at most once on the same instance.<b>{@code FlowableSubscriber} reuse is not checked and if happens, it is the responsibility ofthe {@code FlowableSubscriber} to ensure proper serialization of its onXXX methods.</b></li><li>3.9: negative requests should emit an {@code onError(IllegalArgumentException)}.<b>Non-positive requests signal via {@link RxJavaPlugins#onError(Throwable)} and the stream is not affected.</b></li><dd>The backpressure behavior/expectation is determined by the supplied {@code FlowableSubscriber}.</dd><p>History: 2.0.7 - experimental; 2.1 - betathe {@code FlowableSubscriber} that will consume signals from this {@code Flowable} can't call onError because no way to know if a Subscription has been set or not can't call onSubscribe because the call might have set a Subscription alreadyOperator implementations (both source and intermediate) should implement this method thatperforms the necessary business logic and handles the incoming {@link Subscriber}s.<p>There is no need to call any of the plugin hooks on the current {@code Flowable} instance orthe {@code Subscriber}; all hooks and basic safeguards have beenapplied by {@link #subscribe(Subscriber)} before this method gets called.the incoming {@code Subscriber}, never {@code null}Subscribes a given {@link Subscriber} (subclass) to this {@code Flowable} and returns the given{@code Subscriber} as is.Flowable&lt;Integer&gt; source = Flowable.range(1, 10);ResourceSubscriber&lt;Integer&gt; rs = new ResourceSubscriber&lt;&gt;() {composite.add(source.subscribeWith(rs));<dd>The backpressure behavior/expectation is determined by the supplied {@code Subscriber}.</dd>the type of the {@code Subscriber} to use and returnthe {@code Subscriber} (subclass) to use and return, not {@code null}the input {@code subscriber}Asynchronously subscribes {@link Subscriber}s to the current {@code Flowable} on the specified {@link Scheduler}.If there is a {@link #create(FlowableOnSubscribe, BackpressureStrategy)} type source up in thechain, it is recommended to use {@code subscribeOn(scheduler, false)} insteadto avoid same-pool deadlock because requests may pile up behind an eager/blocking emitter.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/subscribeOn.v3.png" alt="">the {@code Scheduler} to perform subscription actions on<a href="http://reactivex.io/documentation/operators/subscribeon.html">ReactiveX operators documentation: SubscribeOn</a>#observeOn#subscribeOn(Scheduler, boolean)Asynchronously subscribes {@link Subscriber}s to the current {@code Flowable} on the specified {@link Scheduler}optionally reroutes requests from other threads to the same {@code Scheduler} thread.chain, it is recommended to have {@code requestOn} {@code false} to avoid same-pool deadlockbecause requests may pile up behind an eager/blocking emitter.if {@code true}, requests are rerouted to the given {@code Scheduler} as well (strong pipelining)if {@code false}, requests coming from any thread are simply forwarded tothe upstream on the same thread (weak pipelining)Returns a {@code Flowable} that emits the items emitted by the current {@code Flowable} or the items of an alternate{@link Publisher} if the current {@code Flowable} is empty.<img width="640" height="256" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchifempty.png" alt=""><dd>If the current {@code Flowable} is empty, the alternate {@code Publisher} is expected to honor backpressure.If the current {@code Flowable} is non-empty, it is expected to honor backpressure as instead.In either case, if violated, a {@link MissingBackpressureException} <em>may</em> getsignaled somewhere downstream.<dd>{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.</dd>the alternate {@code Publisher} to subscribe to if the source does not emit any itemsReturns a new {@code Flowable} by applying a function that you supply to each item emitted by the current{@code Flowable} that returns a {@link Publisher}, and then emitting the items emitted by the most recently emittedof these {@code Publisher}s.The resulting {@code Flowable} completes if both the current {@code Flowable} and the last inner {@code Publisher}, if any, complete.If the current {@code Flowable} signals an {@code onError}, the inner {@code Publisher} is canceled and the error delivered in-sequence.<img width="640" height="350" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.v3.png" alt=""><dd>{@code switchMap} does not operate by default on a particular {@link Scheduler}.</dd>the element type of the inner {@code Publisher}s and the output#switchMapDelayError(Function)the number of elements to prefetch from the current active inner {@code Publisher}#switchMapDelayError(Function, int)Maps the upstream values into {@link CompletableSource}s, subscribes to the newer one whiledisposing the subscription to the previous {@code CompletableSource}, thus keeping at most oneactive {@code CompletableSource} running.<img width="640" height="522" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletable.f.png" alt="">Since a {@code CompletableSource} doesn't produce any items, the resulting reactive type ofthis operator is a {@link Completable} that can only indicate successful completion ora failure in any of the inner {@code CompletableSource}s or the failure of the current<dd>The operator consumes the current {@code Flowable} in an unbounded manner and otherwisedoes not have backpressure in its return type because no items are ever produced.</dd><dd>{@code switchMapCompletable} does not operate by default on a particular {@link Scheduler}.</dd><dd>If either this {@code Flowable} or the active {@code CompletableSource} signals an {@code onError},the resulting {@code Completable} is terminated immediately with that {@link Throwable}.Use the {@link #switchMapCompletableDelayError(Function)} to delay such inner failures untilevery inner {@code CompletableSource}s and the main {@code Flowable} terminates in some fashion.If they fail concurrently, the operator may combine the {@code Throwable}s into a{@link io.reactivex.rxjava3.exceptions.CompositeException CompositeException}and signal it to the downstream instead. If any inactivated (switched out) {@code CompletableSource}signals an {@code onError} late, the {@code Throwable}s will be signaled to the global error handler via{@link RxJavaPlugins#onError(Throwable)} method as {@link UndeliverableException} errors.the function called with each upstream item and should return a{@code CompletableSource} to be subscribed to and awaited for(non blockingly) for its terminal event#switchMapCompletableDelayError(Function)active {@code CompletableSource} running and delaying any main or inner errors until allof them terminate.<img width="640" height="453" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletableDelayError.f.png" alt=""><dd>{@code switchMapCompletableDelayError} does not operate by default on a particular {@link Scheduler}.</dd><dd>The errors of this {@code Flowable} and all the {@code CompletableSource}s, who had the chanceto run to their completion, are delayed untilall of them terminate in some fashion. At this point, if there was only one failure, the respective{@link Throwable} is emitted to the downstream. If there was more than one failure, theoperator combines all {@code Throwable}s into a {@link io.reactivex.rxjava3.exceptions.CompositeException CompositeException}and signals that to the downstream.If any inactivated (switched out) {@code CompletableSource}#switchMapCompletable(Function)of these {@code Publisher}s and delays any error until all {@code Publisher}s terminate.If the current {@code Flowable} signals an {@code onError}, the termination of the last inner {@code Publisher} will emit that error as is<dd>{@code switchMapDelayError} does not operate by default on a particular {@link Scheduler}.</dd>#switchMap(Function)#switchMap(Function, int)Maps the upstream items into {@link MaybeSource}s and switches (subscribes) to the newer oneswhile disposing the older ones (and ignoring their signals) and emits the latest success value of the current one ifavailable while failing immediately if this {@code Flowable} or any of theactive inner {@code MaybeSource}s fail.<dd>The operator honors backpressure from downstream. The main {@code Flowable} is consumed in anunbounded manner (i.e., without backpressure).</dd><dd>{@code switchMapMaybe} does not operate by default on a particular {@link Scheduler}.</dd><dd>This operator terminates with an {@code onError} if this {@code Flowable} or any ofthe inner {@code MaybeSource}s fail while they are active. When this happens concurrently, theirindividual {@link Throwable} errors may get combined and emitted as a single{@link CompositeException}. Otherwise, a late(i.e., inactive or switched out) {@code onError} from this {@code Flowable} or from any ofthe inner {@code MaybeSource}s will be forwarded to the global error handler via{@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable)} as{@link io.reactivex.rxjava3.exceptions.UndeliverableException UndeliverableException}</dd>the function called with the current upstream event and shouldreturn a {@code MaybeSource} to replace the current active inner sourceand get subscribed to.#switchMapMaybeDelayError(Function)while disposing the older ones  (and ignoring their signals) and emits the latest success value of the current one ifavailable, delaying errors from this {@code Flowable} or the inner {@code MaybeSource}s until all terminate.<dd>{@code switchMapMaybeDelayError} does not operate by default on a particular {@link Scheduler}.</dd>#switchMapMaybe(Function)Maps the upstream items into {@link SingleSource}s and switches (subscribes) to the newer oneswhile disposing the older ones (and ignoring their signals) and emits the latest success value of the current onewhile failing immediately if this {@code Flowable} or any of theactive inner {@code SingleSource}s fail.<dd>{@code switchMapSingle} does not operate by default on a particular {@link Scheduler}.</dd>the inner {@code SingleSource}s fail while they are active. When this happens concurrently, theirthe inner {@code SingleSource}s will be forwarded to the global error handler viareturn a {@code SingleSource} to replace the current active inner source#switchMapSingleDelayError(Function)while disposing the older ones  (and ignoring their signals) and emits the latest success value of the current one,delaying errors from this {@code Flowable} or the inner {@code SingleSource}s until all terminate.<dd>{@code switchMapSingleDelayError} does not operate by default on a particular {@link Scheduler}.</dd>#switchMapSingle(Function)Returns a {@code Flowable} that emits only the first {@code count} items emitted by the current {@code Flowable}.If the source emits fewer than {@code count} items then all of its items are emitted.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.v3.png" alt="">This method returns a {@code Flowable} that will invoke a subscribing {@link Subscriber}'s{@link Subscriber#onNext onNext} function a maximum of {@code count} times before invoking{@link Subscriber#onComplete onComplete}.Limits both the number of upstream items (after which the sequence completes)and the total downstream request amount requested from the upstream topossibly prevent the creation of excess items by the upstream.The operator requests at most the given {@code count} of items from upstream evenif the downstream requests more than that. For example, given a {@code take(5)},if the downstream requests 1, a request of 1 is submitted to the upstreamand the operator remembers that only 4 items can be requested now on. A requestof 5 at this point will request 4 from the upstream and any subsequent requests willbe ignored.Note that requests are negotiated on an operator boundary and {@code take}'s amountmay not be preserved further upstream. For example,{@code source.observeOn(Schedulers.computation()).take(5)} will still request thedefault (128) elements from the given {@code source}.<dd>The current {@code Flowable} is consumed in a bounded manner.</dd><dd>This version of {@code take} does not operate by default on a particular {@link Scheduler}.</dd>the maximum number of items and the total request amount, non-negative.Zero will immediately cancel the upstream on subscription and complete<a href="http://reactivex.io/documentation/operators/take.html">ReactiveX operators documentation: Take</a>Returns a {@code Flowable} that emits those items emitted by source {@link Publisher} before a specified time runsout.If time runs out before the {@code Flowable} completes normally, the {@code onComplete} event will besignaled on the default {@code computation} {@link Scheduler}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.t.v3.png" alt=""><dd>This version of {@code take} operates by default on the {@code computation} {@code Scheduler}.</dd>Returns a {@code Flowable} that emits those items emitted by source {@link Publisher} before a specified time (on aspecified {@link Scheduler}) runs out.signaled on the provided {@code Scheduler}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.ts.v3.png" alt="">the {@code Scheduler} used for time sourceReturns a {@code Flowable} that emits at most the last {@code count} items emitted by the current {@code Flowable}. If the source emits fewer than{@code count} items then all of its items are emitted.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.n.v3.png" alt=""><dd>The operator honors backpressure from downstream if the {@code count} is non-zero; ignoresbackpressure if the {@code count} is zero as it doesn't signal any values.</dd><dd>This version of {@code takeLast} does not operate by default on a particular {@link Scheduler}.</dd>the maximum number of items to emit from the end of the sequence of items emitted by the current<a href="http://reactivex.io/documentation/operators/takelast.html">ReactiveX operators documentation: TakeLast</a>Returns a {@code Flowable} that emits at most a specified number of items from the current {@code Flowable} that wereemitted in a specified window of time before the current {@code Flowable} completed.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tn.v3.png" alt="">unbounded manner (i.e., no backpressure is applied to it).</dd><dd>{@code takeLast} does not operate on any particular scheduler but uses the current timethe maximum number of items to emitemitted in a specified window of time before the current {@code Flowable} completed, where the timing information isprovided by a given {@link Scheduler}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tns.v3.png" alt=""><dd>You specify which {@code Scheduler} this operator will use for tracking the current time</dd>the {@code Scheduler} that provides the timestamps for the observed itemsthe hint about how many elements to expect to be lastif {@code count} is negative or {@code bufferSize} is non-positiveReturns a {@code Flowable} that emits the items from the current {@code Flowable} that were emitted in a specifiedwindow of time before the current {@code Flowable} completed.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.t.v3.png" alt="">unbounded manner (i.e., no backpressure is applied to it) but note that this <em>may</em>lead to {@link OutOfMemoryError} due to internal buffer bloat.Consider using {@link #takeLast(long, long, TimeUnit)} in this case.</dd><dd>This version of {@code takeLast} operates by default on the {@code computation} {@link Scheduler}.</dd>window of time before the current {@code Flowable} completed, where the timing information is provided by a specified<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.ts.v3.png" alt="">Consider using {@link #takeLast(long, long, TimeUnit, Scheduler)} in this case.</dd>Returns a {@code Flowable} that emits items emitted by the current {@code Flowable}, checks the specified predicatefor each item, and then completes when the condition is satisfied.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.p.v3.png" alt="">The difference between this operator and {@link #takeWhile(Predicate)} is that here, the condition isevaluated <em>after</em> the item is emitted.<dd>The operator is a pass-through for backpressure; the backpressure behavior is determined by the upstreamsource and the downstream consumer.</dd>a function that evaluates an item emitted by the current {@code Flowable} and returns a {@link Boolean}if {@code stopPredicate} is {@code null}<a href="http://reactivex.io/documentation/operators/takeuntil.html">ReactiveX operators documentation: TakeUntil</a>Flowable#takeWhile(Predicate)Returns a {@code Flowable} that emits the items emitted by the current {@code Flowable} until a second {@link Publisher}emits an item.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeUntil.v3.png" alt="">the {@code Publisher} whose first emitted item will cause {@code takeUntil} to stop emitting itemsfrom the current {@code Flowable}the type of items emitted by {@code other}Returns a {@code Flowable} that emits items emitted by the current {@code Flowable} so long as each item satisfied aspecified condition, and then completes as soon as this condition is not satisfied.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeWhile.v3.png" alt=""><dd>{@code takeWhile} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/takewhile.html">ReactiveX operators documentation: TakeWhile</a>Flowable#takeUntil(Predicate)Returns a {@code Flowable} that emits only the first item emitted by the current {@code Flowable} during sequentialtime windows of a specified duration.This differs from {@link #throttleLast} in that this only tracks the passage of time whereas{@link #throttleLast} ticks at scheduled intervals.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.v3.png" alt=""><dd>{@code throttleFirst} operates by default on the {@code computation} {@link Scheduler}.</dd>time to wait before emitting another item after emitting the last itemthe unit of time of {@code windowDuration}time windows of a specified duration, where the windows are managed by a specified {@link Scheduler}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.s.v3.png" alt="">the unit of time of {@code skipDuration}the {@code Scheduler} to use internally to manage the timers that handle timeout for eacheventReturns a {@code Flowable} that emits only the last item emitted by the current {@code Flowable} during sequentialThis differs from {@link #throttleFirst} in that this ticks along at a scheduled interval whereas{@link #throttleFirst} does not tick, it just tracks the passage of time.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.v3.png" alt=""><dd>{@code throttleLast} operates by default on the {@code computation} {@link Scheduler}.</dd>duration of windows within which the last item emitted by the current {@code Flowable} will beemittedthe unit of time of {@code intervalDuration}#sample(long, TimeUnit)time windows of a specified duration, where the duration is governed by a specified {@link Scheduler}.This differs from {@link #throttleFirst(long, TimeUnit, Scheduler)} in that this ticks along at a scheduled interval whereas{@code throttleFirst} does not tick, it just tracks the passage of time.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.s.v3.png" alt="">#sample(long, TimeUnit, Scheduler)Throttles items from the upstream {@code Flowable} by first emitting the nextitem from upstream, then periodically emitting the latest item (if any) whenthe specified timeout elapses between them.<img width="640" height="326" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.png" alt="">Unlike the option with {@link #throttleLatest(long, TimeUnit, boolean)}, the very last item being held back(if any) is not emitted when the upstream completes.If no items were emitted from the upstream during this timeout phase, the nextupstream item is emitted immediately and the timeout window starts from then.<dd>This operator does not support backpressure as it uses time to control data flow.If the downstream is not ready to receive items, a{@link io.reactivex.rxjava3.exceptions.MissingBackpressureException MissingBackpressureException}will be signaled.</dd><dd>{@code throttleLatest} operates by default on the {@code computation} {@link Scheduler}.</dd><p>History: 2.1.14 - experimentalthe time to wait after an item emission towards the downstreambefore trying to emit the latest item from upstream againthe time unit#throttleLatest(long, TimeUnit, boolean)#throttleLatest(long, TimeUnit, Scheduler)<img width="640" height="326" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.e.png" alt="">If {@code true}, the very last item from the upstream will be emittedimmediately when the upstream completes, regardless if there isa timeout window active or not. If {@code false}, the very lastupstream item is ignored and the flow terminates.#throttleLatest(long, TimeUnit, Scheduler, boolean)<img width="640" height="326" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.s.png" alt="">Unlike the option with {@link #throttleLatest(long, TimeUnit, Scheduler, boolean)}, the very last item being held backthe {@code Scheduler} where the timed wait and latest itememission will be performed<img width="640" height="326" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.se.png" alt="">each emission (alias to {@link #debounce(long, TimeUnit)}).<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.v3.png" alt=""><dd>{@code throttleWithTimeout} operates by default on the {@code computation} {@link Scheduler}.</dd>#debounce(long, TimeUnit){@link Scheduler}. The timer resets on each emission (alias to {@link #debounce(long, TimeUnit, Scheduler)}).<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleWithTimeout.s.v3.png" alt="">#debounce(long, TimeUnit, Scheduler)Returns a {@code Flowable} that emits records of the time interval between consecutive items emitted by the<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.v3.png" alt=""><dd>{@code timeInterval} does not operate on any particular scheduler but uses the current time<a href="http://reactivex.io/documentation/operators/timeinterval.html">ReactiveX operators documentation: TimeInterval</a>current {@code Flowable}, where this interval is computed on a specified {@link Scheduler}.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeInterval.s.v3.png" alt="">from the specified {@code Scheduler}.</dd>the {@code Scheduler} used to compute time intervals Supplied scheduler is only used for creating timestamps.the time unit for the current timeReturns a {@code Flowable} that mirrors the current {@code Flowable}, but notifies {@link Subscriber}s of a{@link TimeoutException} if an item emitted by the current {@code Flowable} doesn't arrive within a window oftime after the emission of the previous item, where that period of time is measured by a {@link Publisher} thatis a function of the previous item.<img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout3.v3.png" alt="">Note: The arrival of the first source item is never timed out.If any of the current {@code Flowable}s violate this, it <em>may</em> throw an<dd>This version of {@code timeout} operates by default on the {@code immediate} {@link Scheduler}.</dd>the timeout value type (ignored)a function that returns a {@code Publisher} for each item emitted by the current{@code Flowable} and that determines the timeout window for the subsequent itemif {@code itemTimeoutIndicator} is {@code null}<a href="http://reactivex.io/documentation/operators/timeout.html">ReactiveX operators documentation: Timeout</a>Returns a {@code Flowable} that mirrors the current {@code Flowable}, but that switches to a fallback {@link Publisher} ifan item emitted by the current {@code Flowable} doesn't arrive within a window of time after the emission of theprevious item, where that period of time is measured by a {@code Publisher} that is a function of the previousitem.<img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout4.v3.png" alt="">a function that returns a {@code Publisher}, for each item emitted by the current {@code Flowable}, thatdetermines the timeout window for the subsequent itemthe fallback {@code Publisher} to switch to if the current {@code Flowable} times outif {@code itemTimeoutIndicator} or {@code fallback} is {@code null}Returns a {@code Flowable} that mirrors the current {@code Flowable} but applies a timeout policy for each emitteditem. If the next item isn't emitted within the specified timeout duration starting from its predecessor,the resulting {@code Flowable} terminates and notifies {@link Subscriber}s of a {@link TimeoutException}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1.v3.png" alt=""><dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.</dd>maximum duration between emitted items before a timeout occursthe unit of time that applies to the {@code timeout} argument.the current {@code Flowable} is disposed and the resulting {@code Flowable} begins instead to mirror a fallback {@link Publisher}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2.v3.png" alt="">maximum duration between items before a timeout occursthe unit of time that applies to the {@code timeout} argumentthe fallback {@code Publisher} to use in case of a timeoutitem using a specified {@link Scheduler}. If the next item isn't emitted within the specified timeout durationstarting from its predecessor, the current {@code Flowable} is disposed and the resulting {@code Flowable} beginsinstead to mirror a fallback {@link Publisher}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.2s.v3.png" alt="">the {@code Scheduler} to run the timeout timers onthe {@code Publisher} to use as the fallback in case of a timeoutitem, where this policy is governed by a specified {@link Scheduler}. If the next item isn't emitted within thespecified timeout duration starting from its predecessor, the resulting {@code Flowable} terminates andnotifies {@link Subscriber}s of a {@link TimeoutException}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1s.v3.png" alt="">{@link TimeoutException} if either the first item emitted by the current {@code Flowable} or any subsequent itemdoesn't arrive within time windows defined by other {@link Publisher}s.<img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout5.v3.png" alt=""><dd>The operator honors backpressure from downstream. Both this and the returned {@code Publisher}s{@link IllegalStateException} when the {@code Publisher} completes.</dd><dd>{@code timeout} does not operate by default on any {@link Scheduler}.</dd>the first timeout value type (ignored)the subsequent timeout value type (ignored)a function that returns a {@code Publisher} that determines the timeout window for the first sourcea function that returns a {@code Publisher} for each item emitted by the current {@code Flowable} and thatdetermines the timeout window in which the subsequent source item must arrive in order tocontinue the sequenceif {@code firstTimeoutIndicator} or {@code itemTimeoutIndicator} is {@code null}Returns a {@code Flowable} that mirrors the current {@code Flowable}, but switches to a fallback {@link Publisher} if eitherthe first item emitted by the current {@code Flowable} or any subsequent item doesn't arrive within time windowsdefined by other {@code Publisher}s.<img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout6.v3.png" alt="">a function that returns a {@code Publisher} which determines the timeout window for the first sourceif {@code firstTimeoutIndicator}, {@code itemTimeoutIndicator} or {@code fallback} is {@code null}Returns a {@code Flowable} that emits each item emitted by the current {@code Flowable}, wrapped in a{@link Timed} object.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.v3.png" alt=""><dd>{@code timestamp} does not operate on any particular scheduler but uses the current time<a href="http://reactivex.io/documentation/operators/timestamp.html">ReactiveX operators documentation: Timestamp</a>{@link Timed} object whose timestamps are provided by a specified {@link Scheduler}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timestamp.s.v3.png" alt=""><dd>This operator does not operate on any particular scheduler but uses the current timethe {@code Scheduler} to use as a time sourceCalls the specified converter function during assembly time and returns its resulting value.<dd>The backpressure behavior depends on what happens in the {@code converter} function.</dd>the function that receives the current {@code Flowable} instance and returns a valueReturns a {@link Single} that emits a single item, a list composed of all the items emitted by thefinite upstream source {@link Publisher}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.v3.png" alt="">Normally, a {@code Publisher} that returns multiple items will do so by invoking its {@link Subscriber}'s{@link Subscriber#onNext onNext} method for each such item. You can change this behavior by having theoperator compose a list of all of these items and then to invoke the {@link SingleObserver}'s {@code onSuccess}method once, passing it the entire list, by calling the {@code Flowable}'s {@code toList} method prior tocalling its {@link #subscribe} method.Note that this operator requires the upstream to signal {@code onComplete} for the accumulated list to<dd>{@code toList} does not operate by default on a particular {@link Scheduler}.</dd><a href="http://reactivex.io/documentation/operators/to.html">ReactiveX operators documentation: To</a>finite source {@link Publisher}.the number of elements expected from the current {@code Flowable}if {@code capacityHint} is non-positiveoperator compose a collection of all of these items and then to invoke the {@link SingleObserver}'s {@code onSuccess}method once, passing it the entire collection, by calling the {@code Flowable}'s {@code toList} method prior toNote that this operator requires the upstream to signal {@code onComplete} for the accumulated collection tothe subclass of a collection of Tsthe {@link Supplier} returning the collection (for each individual {@code Subscriber}) to be filled inif {@code collectionSupplier} is {@code null}Returns a {@link Single} that emits a single {@link HashMap} containing all items emitted by the finite source {@link Publisher},mapped by the keys returned by a specified {@code keySelector} function.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.v3.png" alt="">If more than one source item maps to the same key, the {@code HashMap} will contain the latest of those items.Note that this operator requires the upstream to signal {@code onComplete} for the accumulated map to<dd>{@code toMap} does not operate by default on a particular {@link Scheduler}.</dd>the key type of the Mapthe function that extracts the key from a source item to be used in the {@code HashMap}Returns a {@link Single} that emits a single {@link HashMap} containing values corresponding to items emitted by thefinite source {@link Publisher}, mapped by the keys returned by a specified {@code keySelector} function.If more than one source item maps to the same key, the {@code HashMap} will contain a single entry thatcorresponds to the latest of those items.the value type of the Mapthe function that extracts the value from a source item to be used in the {@code HashMap}Returns a {@link Single} that emits a single {@link Map}, returned by a specified {@code mapFactory} function, thatcontains keys and values extracted from the items emitted by the finite source {@link Publisher}.the function that extracts the key from a source item to be used in the Mapthe function that extracts the value from the source items to be used as value in the Mapthe function that returns a {@code Map} instance to be usedif {@code keySelector}, {@code valueSelector} or {@code mapSupplier} is {@code null}Returns a {@link Single} that emits a single {@link HashMap} that contains an {@link ArrayList} of items emitted by thefinite source {@link Publisher} keyed by a specified {@code keySelector} function.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.v3.png" alt=""><dd>This operator does not support backpressure as by intent it is requesting and buffering everything.</dd><dd>{@code toMultimap} does not operate by default on a particular {@link Scheduler}.</dd>the function that extracts the key from the source items to be used as key in the {@code HashMap}Returns a {@link Single} that emits a single {@link HashMap} that contains an {@link ArrayList} of values extracted by aspecified {@code valueSelector} function from items emitted by the finite source {@link Publisher}, keyed by aspecified {@code keySelector} function.the function that extracts a key from the source items to be used as key in the {@code HashMap}the function that extracts a value from the source items to be used as value in the {@code HashMap}contains a custom collection of values, extracted by a specified {@code valueSelector} function fromitems emitted by the finite source {@link Publisher}, and keyed by the {@code keySelector} function.the function that extracts a key from the source items to be used as the key in the Mapthe function that extracts a value from the source items to be used as the value in the {@code Map}the function that returns a Map instance to be usedthe function that returns a {@link Collection} instance for a particular key to be used in the {@code Map}if {@code keySelector}, {@code valueSelector}, {@code mapSupplier} or {@code collectionFactory} is {@code null}contains an {@link ArrayList} of values, extracted by a specified {@code valueSelector} function from itemsemitted by the finite source {@link Publisher} and keyed by the {@code keySelector} function.the key type of the {@code Map}the value type of the {@code Map}the function that extracts a key from the source items to be used as the key in the {@code Map}Converts the current {@code Flowable} into a non-backpressured {@link Observable}.<dd>{@code Observable}s don't support backpressure thus the current {@code Flowable} is consumed in an unboundedmanner (by requesting {@link Long#MAX_VALUE}).</dd>Returns a {@link Single} that emits a {@link List} that contains the items emitted by the finite source {@link Publisher}, in a<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.v3.png" alt=""><dd>{@code toSortedList} does not operate by default on a particular {@link Scheduler}.</dd><img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.f.v3.png" alt="">a function that compares two items emitted by the current {@code Flowable} and returns an {@code int}the initial capacity of the {@link ArrayList} used to accumulate items before sortingCancels the current {@code Flowable} asynchronously by invoking {@link Subscription#cancel()}on the specified {@link Scheduler}.The operator suppresses signals from the current {@code Flowable} immediately when thedownstream cancels the flow because the actual cancellation itself could take an arbitrary amount of timeto take effect and make the flow stop producing items.the {@code Scheduler} to perform cancellation actions onReturns a {@code Flowable} that emits windows of items it collects from the current {@code Flowable}. The resulting{@code Flowable} emits connected, non-overlapping windows, each containing {@code count} items. When the current{@code Flowable} completes or encounters an error, the resulting {@code Flowable} emits the current window andpropagates the notification from the current {@code Flowable}.<img width="640" height="400" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window3.v3.png" alt="">Note that ignoring windows or subscribing later (i.e., on another thread) will result inso-called window abandonment where a window will only contain one element. The behavior isa trade-off between no-dataloss and ensuring upstream cancellation can happen.<dd>The operator honors backpressure of its inner and outer subscribers, however, the inner {@code Flowable} uses anunbounded buffer that may hold at most {@code count} elements.</dd><dd>This version of {@code window} does not operate by default on a particular {@link Scheduler}.</dd>the maximum size of each window before it should be emitted<a href="http://reactivex.io/documentation/operators/window.html">ReactiveX operators documentation: Window</a>{@code Flowable} emits windows every {@code skip} items, each containing no more than {@code count} items. Whenthe current {@code Flowable} completes or encounters an error, the resulting {@code Flowable} emits the current windowand propagates the notification from the current {@code Flowable}.<img width="640" height="365" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window4.v3.png" alt="">so-called window abandonment where a window may not contain any elements. In this case, subsequentelements will be dropped until the condition for the next window boundary is satisfied. The behavior isa trade-off between no-dataloss and ensuring upstream cancellation can happen under some race conditions.how many items need to be skipped before starting a new window. Note that if {@code skip} and{@code count} are equal this is the same operation as {@link #window(long)}.the capacity hint for the buffer in the inner windowsif {@code count}, {@code skip} or {@code bufferSize} is non-positive{@code Flowable} starts a new window periodically, as determined by the {@code timeskip} argument. It emitseach window after a fixed timespan, specified by the {@code timespan} argument. When the current{@code Flowable} completes or encounters an error, the resulting {@code Flowable} emits thecurrent window and propagates the notification from the current {@code Flowable}.<img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.v3.png" alt="">a trade-off for ensuring upstream cancellation can happen under some race conditions.<dd>The operator consumes the current {@code Flowable} in an unbounded manner.The resulting {@code Flowable} doesn't support backpressure as it usestime to control the creation of windows. The emitted inner {@code Flowable}s honorbackpressure but have an unbounded inner buffer that <em>may</em> lead to {@link OutOfMemoryError}if left unconsumed.</dd><dd>This version of {@code window} operates by default on the {@code computation} {@link Scheduler}.</dd>the period of time each window collects items before it should be emittedthe period of time after which a new window will be created<img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window7.s.v3.png" alt="">time to control the creation of windows. The returned inner {@code Flowable}s honorthe {@code Scheduler} to use when determining the end and start of a windowif {@code timespan}, {@code timeskip} or {@code bufferSize} is non-positive{@code Flowable} emits connected, non-overlapping windows, each of a fixed duration specified by the{@code timespan} argument. When the current {@code Flowable} completes or encounters an error, the resulting{@code Flowable} emits the current window and propagates the notification from the current {@code Flowable}.<img width="640" height="375" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window5.v3.png" alt="">backpressure and may hold up to {@code count} elements at most.</dd>the period of time each window collects items before it should be emitted and replaced with anew window{@code Flowable} emits connected, non-overlapping windows, each of a fixed duration as specified by the{@code timespan} argument or a maximum size as specified by the {@code count} argument (whichever isreached first). When the current {@code Flowable} completes or encounters an error, the resulting {@code Flowable}emits the current window and propagates the notification from the current {@code Flowable}.<img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.v3.png" alt="">if {@code true}, when a window reaches the capacity limit, the timer is restarted as well<img width="640" height="375" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window5.s.v3.png" alt="">first). When the current {@code Flowable} completes or encounters an error, the resulting {@code Flowable} emits the<img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.s.v3.png" alt="">if {@code count}, {@code timespan} or {@code bufferSize} is non-positiveReturns a {@code Flowable} that emits non-overlapping windows of items it collects from the current {@code Flowable}where the boundary of each window is determined by the items emitted from a specified boundary-governing{@link Publisher}.<img width="640" height="475" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window8.v3.png" alt=""><dd>The outer {@code Publisher} of this operator does not support backpressure as it uses a {@code boundary} {@code Publisher} to control dataflow. The inner {@code Publisher}s honor backpressure and buffer everything until the boundary signals the next element.</dd>the window element type (ignored)a {@code Publisher} whose emitted items close and open windows{@code Flowable} emits windows that contain those items emitted by the current {@code Flowable} between the time whenthe {@code windowOpenings} {@link Publisher} emits an item and when the {@code Publisher} returned by{@code closingSelector} emits an item.<img width="640" height="550" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window2.v3.png" alt=""><dd>The outer {@code Publisher} of this operator doesn't support backpressure because the emission of newinner {@code Publisher}s are controlled by the {@code windowOpenings} {@code Publisher}.The inner {@code Publisher}s honor backpressure and buffer everything until the associated closing{@code Publisher} signals or completes.</dd>the element type of the window-opening {@code Publisher}the element type of the window-closing {@code Publisher}sa {@code Publisher} that, when it emits an item, causes another window to be createda {@link Function} that produces a {@code Publisher} for every window created. When this {@code Publisher}emits an item, the associated window is closed and emittedMerges the specified {@link Publisher} into the current {@code Flowable} sequence by using the {@code resultSelector}function only when the current {@code Flowable} (this instance) emits an item.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/withLatestFrom.v3.png" alt=""><dd>The operator is a pass-through for backpressure: the backpressure supportdepends on the upstream and downstream's backpressure behavior. The other {@code Publisher}is consumed in an unbounded fashion.</dd><dd>This operator, by default, doesn't run any particular {@link Scheduler}.</dd>the result type of the combinationthe other {@code Publisher}the function to call when the current {@code Flowable} emits an item and the other {@code Publisher} has alreadyemitted an item, to generate the item to be emitted by the resulting {@code Flowable}if {@code other} or {@code combiner} is {@code null}Combines the value emission from the current {@code Flowable} with the latest emissions from theother {@link Publisher}s via a function to produce the output item.<p>Note that this operator doesn't emit anything until all other sources have produced atleast one value. The resulting emission only happens when the current {@code Flowable} emits (andnot when any of the other sources emit, unlike combineLatest).If a source doesn't produce any value and just completes, the sequence is completed immediately.<dd>This operator is a pass-through for backpressure behavior between the current {@code Flowable}and the downstream {@link Subscriber}. The other {@code Publisher}s are consumed in an unbounded manner.</dd><dd>This operator does not operate by default on a particular {@link Scheduler}.</dd>the first other source's value typethe second other source's value typethe first other {@code Publisher}the second other {@code Publisher}the function called with an array of values from each participating {@code Publisher}the third other source's value typethe third other {@code Publisher}the fourth other source's value typethe fourth other {@code Publisher}the array of other sourcesif {@code others} or {@code combiner} is {@code null}the iterable of other sourcesReturns a {@code Flowable} that emits items that are the result of applying a specified function to pairs ofvalues, one each from the current {@code Flowable} and a specified {@link Iterable} sequence.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zip.i.v3.png" alt="">Note that the {@code other} {@code Iterable} is evaluated as items are observed from the current {@code Flowable}; it isnot pre-consumed. This allows you to zip infinite streams on either side.<dd>{@code zipWith} does not operate by default on a particular {@link Scheduler}.</dd>the type of items in the {@code other} {@code Iterable}the {@code Iterable} sequencea function that combines the pairs of items from the current {@code Flowable} and the {@code Iterable} to generatethe items to be emitted by the resulting {@code Flowable}if {@code other} or {@code zipper} is {@code null}values, one each from the current {@code Flowable} and another specified {@link Publisher}.<pre><code>range(1, 5).doOnComplete(action1).zipWith(range(6, 5).doOnComplete(action2), (a, b) -&gt; a + b)</code></pre>the type of items emitted by the {@code other} {@code Publisher}a function that combines the pairs of items from the two {@code Publisher}s to generate the items tobe emitted by the resulting {@code Flowable}if {@code true}, errors from the current {@code Flowable} or the other {@code Publisher} is delayed until both terminateCreates a {@link TestSubscriber} that requests {@link Long#MAX_VALUE} and subscribesit to this {@code Flowable}.<dd>The returned {@code TestSubscriber} consumes this {@code Flowable} in an unbounded fashion.</dd>the new {@code TestSubscriber} instance NoPMDCreates a {@link TestSubscriber} with the given initial request amount and subscribes<dd>The returned {@code TestSubscriber} requests the given {@code initialRequest} amount upfront.</dd>the initial request amount, positiveCreates a {@link TestSubscriber} with the given initial request amount,optionally cancels it before the subscription and subscribesshould the {@code TestSubscriber} be canceled before the subscription?Converts the existing value of the provided optional into a {@link #just(Object)}or an empty optional into an {@link #empty()} {@code Flowable} instance.<img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromOptional.f.png" alt="">Note that the operator takes an already instantiated optional reference and does notby any means create this original optional. If the optional is to be created perconsumer upon subscription, use {@link #defer(Supplier)} around {@code fromOptional}:Flowable.defer(() -&gt; Flowable.fromOptional(createOptional()));<dd>The returned {@code Flowable} supports backpressure.</dd><dd>{@code fromOptional} does not operate by default on a particular {@link Scheduler}.</dd>the element type of the optional valuethe optional value to convert into a {@code Flowable}if {@code optional} is {@code null}#just(Object)#empty()Signals the completion value or error of the given (hot) {@link CompletionStage}-based asynchronous calculation.<img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.f.png" alt="">Flowable.defer(() -&gt; Flowable.fromCompletionStage(createCompletionStage()));If the {@code CompletionStage} completes with {@code null}, a {@link NullPointerException} is signaled.<dd>The returned {@code Flowable} supports backpressure and caches the completion value until thedownstream is ready to receive it.</dd>the element type of the {@code CompletionStage}the {@code CompletionStage} to convert to {@code Flowable} and signal its terminal value or errorConverts a {@link Stream} into a finite {@code Flowable} and emits its items in the sequence.<img width="640" height="347" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromStream.f.png" alt="">The operator closes the {@code Stream} upon cancellation and when it terminates. Any exceptions raised whenclosing a {@code Stream} are routed to the global error handler ({@link RxJavaPlugins#onError(Throwable)}.If a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #fromIterable(Iterable)}:Stream&lt;T&gt; stream = ...Flowable.fromIterable(stream::iterator);Note that {@code Stream}s can be consumed only once; any subsequent attempt to consume a {@code Stream}will result in an {@link IllegalStateException}.Primitive streams are not supported and items have to be boxed manually (e.g., via {@link IntStream#boxed()}):IntStream intStream = IntStream.rangeClosed(1, 10);Flowable.fromStream(intStream.boxed());{@code Stream} does not support concurrent usage so creating and/or consuming the same instance multiple timesfrom multiple threads can lead to undefined behavior.<dd>The operator honors backpressure from downstream and iterates the given {@code Stream}<dd>{@code fromStream} does not operate by default on a particular {@link Scheduler}.</dd>the element type of the source {@code Stream}the {@code Stream} of values to emitif {@code stream} is {@code null}Maps each upstream value into an {@link Optional} and emits the contained item if not empty.<img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mapOptional.f.png" alt=""><dd>The operator is a pass-through for downstream requests but issues {@code request(1)} whenever themapped {@code Optional} is empty.</dd><dd>{@code mapOptional} does not operate by default on a particular {@link Scheduler}.</dd>the non-{@code null} output typethe function that receives the upstream item and should return a <em>non-empty</em> {@code Optional}to emit as the output or an <em>empty</em> {@code Optional} to skip to the next upstream value#map(Function)#filter(Predicate)Collects the finite upstream's values into a container via a {@link Stream} {@link Collector} callback set and emitsit as the success result.<img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collector.f.png" alt="">the non-{@code null} result type<A>the intermediate container type used for the accumulationthe interface defining the container supplier, accumulator and finisher functions;see {@link Collectors} for some standard implementationsif {@code collector} is {@code null}Collectors#collect(Supplier, BiConsumer)Signals the first upstream item (or the default item if the upstream is empty) via<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstStage.f.png" alt="">CompletionStage&lt;Optional&lt;T&gt;&gt; stage = source.map(Optional::of).firstStage(Optional.empty());<dd>The operator requests one item from upstream and then when received, cancels the upstream.</dd><dd>{@code firstStage} does not operate by default on a particular {@link Scheduler}.</dd>the item to signal if the upstream is empty#firstOrErrorStage()Signals the only expected upstream item (or the default item if the upstream is empty)or signals {@link IllegalArgumentException} if the upstream has more than one itemvia a {@link CompletionStage}.<img width="640" height="229" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleStage.f.png" alt="">CompletionStage&lt;Optional&lt;T&gt;&gt; stage = source.map(Optional::of).singleStage(Optional.empty());<dd>The operator requests two items from upstream and then when more than one item is received, cancels the upstream.</dd><dd>{@code singleStage} does not operate by default on a particular {@link Scheduler}.</dd>#singleOrErrorStage()Signals the last upstream item (or the default item if the upstream is empty) via<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastStage.f.png" alt="">CompletionStage&lt;Optional&lt;T&gt;&gt; stage = source.map(Optional::of).lastStage(Optional.empty());<dd>The operator requests an unbounded number of items from the upstream.</dd><dd>{@code lastStage} does not operate by default on a particular {@link Scheduler}.</dd>#lastOrErrorStage()Signals the first upstream item or a {@link NoSuchElementException} if the upstream is empty via<img width="640" height="343" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrErrorStage.f.png" alt=""><dd>{@code firstOrErrorStage} does not operate by default on a particular {@link Scheduler}.</dd>#firstStage(Object)Signals the only expected upstream item, a {@link NoSuchElementException} if the upstream is empty<img width="640" height="229" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrErrorStage.f.png" alt=""><dd>{@code singleOrErrorStage} does not operate by default on a particular {@link Scheduler}.</dd>#singleStage(Object)Signals the last upstream item or a {@link NoSuchElementException} if the upstream is empty via<img width="640" height="346" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrErrorStage.f.png" alt=""><dd>{@code lastOrErrorStage} does not operate by default on a particular {@link Scheduler}.</dd>#lastStage(Object)Creates a sequential {@link Stream} to consume or process this {@code Flowable} in a blocking manner viathe Java {@code Stream} API.<img width="640" height="446" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingStream.f.png" alt="">Cancellation of the upstream is done via {@link Stream#close()}, therefore, it is strongly recommended theconsumption is performed within a try-with-resources construct:Flowable&lt;Integer&gt; source = Flowable.range(1, 10).subscribeOn(Schedulers.computation());try (Stream&lt;Integer&gt; stream = source.blockingStream()) {stream.limit(3).forEach(System.out::println);<dd>The operator requests {@link #bufferSize()} amount upfront and 75% of it after each 75% of the amount received.</dd><dd>{@code blockingStream} does not operate by default on a particular {@link Scheduler}.</dd>the new {@code Stream} instance#blockingStream(int)<img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingStream.fi.png" alt="">try (Stream&lt;Integer&gt; stream = source.blockingStream(4)) {<dd>The operator requests the given {@code prefetch} amount upfront and 75% of it after each 75% of the amount received.</dd>the number of items to request from the upstream to limit the number ofin-flight items and item generation.Maps each upstream item into a {@link Stream} and emits the {@code Stream}'s items to the downstream in a sequential fashion.<img width="640" height="327" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapStream.f.png" alt="">Due to the blocking and sequential nature of Java {@code Stream}s, the streams are mapped and consumed in a sequential fashionwithout interleaving (unlike a more general {@link #flatMap(Function)}). Therefore, {@code flatMapStream} and{@code concatMapStream} are identical operators and are provided as aliases.If a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #concatMapIterable(Function)}:source.concatMapIterable(v -&gt; createStream(v)::iterator);source.concatMapStream(v -&gt; IntStream.rangeClosed(v + 1, v + 10).boxed());<dd>The operator honors the downstream backpressure and consumes the inner stream only on demand. The operatorprefetches {@link #bufferSize} items of the upstream (then 75% of it after the 75% received)and caches them until they are ready to be mapped into {@code Stream}safter the current {@code Stream} has been consumed.</dd><dd>{@code concatMapStream} does not operate by default on a particular {@link Scheduler}.</dd>the element type of the {@code Stream}s and the resultthe function that receives an upstream item and should return a {@code Stream} whose elementswill be emitted to the downstream#concatMap(Function)#concatMapIterable(Function)#concatMapStream(Function, int)<img width="640" height="270" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapStream.fi.png" alt="">If a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #concatMapIterable(Function, int)}:source.concatMapIterable(v -&gt; createStream(v)::iterator, 32);source.concatMapStream(v -&gt; IntStream.rangeClosed(v + 1, v + 10).boxed(), 32);prefetches the given amount of upstream items and caches them until they are ready to be mapped into {@code Stream}sthe number of upstream items to request upfront, then 75% of this amount after each 75% upstream items received#concatMapIterable(Function, int)#flatMapStream(Function, int)<img width="640" height="328" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapStream.f.png" alt="">If a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #flatMapIterable(Function)}:source.flatMapIterable(v -&gt; createStream(v)::iterator);source.flatMapStream(v -&gt; IntStream.rangeClosed(v + 1, v + 10).boxed());<dd>{@code flatMapStream} does not operate by default on a particular {@link Scheduler}.</dd>#flatMap(Function)#flatMapIterable(Function)<img width="640" height="270" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapStream.fi.png" alt="">If a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #flatMapIterable(Function, int)}:source.flatMapIterable(v -&gt; createStream(v)::iterator, 32);source.flatMapStream(v -&gt; IntStream.rangeClosed(v + 1, v + 10).boxed(), 32);#flatMap(Function, int)#flatMapIterable(Function, int)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableConverter.javaConvenience interface and callback used by the {@link Flowable#to} operator to turn a {@link Flowable} into anotherthe upstream typeApplies a function to the upstream {@link Flowable} and returns a converted value of type {@code R}.the upstream {@code Flowable} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableEmitter.javaFlowableEmitterFlowableEmitter<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableEmitter.classEmitter<>Abstraction over a Reactive Streams {@link org.reactivestreams.Subscriber} that allows associatinga resource with it and exposes the current number of downstreamrequested amount.The {@link #onNext(Object)}, {@link #onError(Throwable)}, {@link #tryOnError(Throwable)}and {@link #onComplete()} methods should be called in a sequential manner, just likethe {@link org.reactivestreams.Subscriber Subscriber}'s methods.Use the {@code FlowableEmitter} the {@link #serialize()} method returns instead of the original{@code FlowableEmitter} instance provided by the generator routine if you want to ensure this.The other methods are thread-safe.downstream cancels the flow or after the event generator logic calls {@link #onError(Throwable)},{@link #onComplete()} or when {@link #tryOnError(Throwable)} succeeds.the value type to emitthe disposable, {@code null} is allowedSets a {@link Cancellable} on this emitter; any previous {@link Disposable}or {@code Cancellable} will be disposed/cancelled.the {@code Cancellable} resource, {@code null} is allowedThe current outstanding request amount.the current outstanding request amountReturns true if the downstream cancelled the sequence or theemitter was terminated via {@link #onError(Throwable)}, {@link #onComplete} or asuccessful {@link #tryOnError(Throwable)}.true if the downstream cancelled the sequence or the emitter was terminatedEnsures that calls to {@code onNext}, {@code onError} and {@code onComplete} are properly serialized.the serialized {@link FlowableEmitter}C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableOnSubscribe.javaFlowableEmitter<T>an instance of a {@link FlowableEmitter} instance that allows pushingevents in a backpressure-safe and cancellation-safe manner.the value type pushedCalled for each {@link org.reactivestreams.Subscriber Subscriber} that subscribes.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableOperator.java? super DownstreamSubscriber<? super Downstream>? super UpstreamSubscriber<? super Upstream>Interface to map/wrap a downstream {@link Subscriber} to an upstream {@code Subscriber}.<Downstream>the value type of the downstream<Upstream>the value type of the upstreamApplies a function to the child {@link Subscriber} and returns a new parent {@code Subscriber}.the child {@code Subscriber} instancethe parent {@code Subscriber} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableSubscriber.javaRepresents a Reactive-Streams inspired {@link Subscriber} that is RxJava 3 onlyand weakens the Reactive Streams rules <a href='https://github.com/reactive-streams/reactive-streams-jvm#1.3'>1.3</a>and <a href='https://github.com/reactive-streams/reactive-streams-jvm#3.9'>3.9</a> of the specificationfor gaining performance.Implementors of this method should make sure everything that needsto be visible in {@link #onNext(Object)} is established beforecalling {@link Subscription#request(long)}. In practice this meansno initialization should happen after the {@code request()} call andadditional behavior is thread safe in respect to {@code onNext}.{@inheritDoc}C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/FlowableTransformer.javaInterface to compose {@link Flowable}s.the upstream value typethe downstream value typeApplies a function to the upstream {@link Flowable} and returns a {@link Publisher} withoptionally different element type.the transformed {@code Publisher} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Maybe.javaMaybeAmb<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeAmb.classMaybeAmbMaybeAmb<T>(io.reactivex.rxjava3.core.MaybeSource[],java.lang.Iterable)MaybeAmb(io.reactivex.rxjava3.core.MaybeSource[],java.lang.Iterable)MaybeConcatIterable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatIterable.classMaybeConcatIterableMaybeConcatIterable<T>(java.lang.Iterable)MaybeConcatIterable(java.lang.Iterable)FlowableConcatMapMaybePublisher<? extends MaybeSource<? extends T>,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapMaybePublisher.classFlowableConcatMapMaybePublisherFlowableConcatMapMaybePublisher<T,R>Function<? extends MaybeSource<? extends T>,? extends MaybeSource<? extends T>>FlowableConcatMapMaybePublisher<T,R>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)FlowableConcatMapMaybePublisher(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)MaybeConcatArray<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatArray.classMaybeConcatArrayMaybeConcatArray<T>(io.reactivex.rxjava3.core.MaybeSource[])MaybeConcatArray(io.reactivex.rxjava3.core.MaybeSource[])MaybeConcatArrayDelayError<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeConcatArrayDelayError.classMaybeConcatArrayDelayErrorMaybeConcatArrayDelayError<T>(io.reactivex.rxjava3.core.MaybeSource[])MaybeConcatArrayDelayError(io.reactivex.rxjava3.core.MaybeSource[])Flowable<MaybeSource<? extends T>>Publisher<MaybeSource<? extends T>>? super MaybeSource<? extends T>Function<? super MaybeSource<? extends T>,? extends Publisher<? extends R>>Subscriber<? super MaybeSource<? extends T>>Function<? super MaybeSource<? extends T>,? extends Stream<? extends R>>Stream<MaybeSource<? extends T>>BaseStream<MaybeSource<? extends T>,Stream<MaybeSource<? extends T>>>CompletionStage<MaybeSource<? extends T>>lastStage(io.reactivex.rxjava3.core.MaybeSource)singleStage(io.reactivex.rxjava3.core.MaybeSource)firstStage(io.reactivex.rxjava3.core.MaybeSource)Collector<? super MaybeSource<? extends T>,A,R>Function<? super MaybeSource<? extends T>,Optional<? extends R>>TestSubscriber<MaybeSource<? extends T>>BaseTestConsumer<MaybeSource<? extends T>,TestSubscriber<MaybeSource<? extends T>>>FlowableSubscriber<MaybeSource<? extends T>>Subscriber<MaybeSource<? extends T>>BiFunction<? super MaybeSource<? extends T>,? super U,? extends R>Function5<? super MaybeSource<? extends T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super MaybeSource<? extends T>,? super T1,? super T2,? super T3,R>Function3<? super MaybeSource<? extends T>,? super T1,? super T2,R>Flowable<Flowable<MaybeSource<? extends T>>>Publisher<Flowable<MaybeSource<? extends T>>>List<MaybeSource<? extends T>>Collection<MaybeSource<? extends T>>Iterable<MaybeSource<? extends T>>Single<List<MaybeSource<? extends T>>>SingleSource<List<MaybeSource<? extends T>>>Comparator<? super MaybeSource<? extends T>>Observable<MaybeSource<? extends T>>ObservableSource<MaybeSource<? extends T>>Function<? super MaybeSource<? extends T>,? extends K>Function<? super MaybeSource<? extends T>,? extends V>Map<K,Collection<MaybeSource<? extends T>>>Single<Map<K,Collection<MaybeSource<? extends T>>>>SingleSource<Map<K,Collection<MaybeSource<? extends T>>>>Map<K,MaybeSource<? extends T>>Single<Map<K,MaybeSource<? extends T>>>SingleSource<Map<K,MaybeSource<? extends T>>>FlowableConverter<MaybeSource<? extends T>,? extends R>Timed<MaybeSource<? extends T>>Flowable<Timed<MaybeSource<? extends T>>>Publisher<Timed<MaybeSource<? extends T>>>Function<? super MaybeSource<? extends T>,? extends Publisher<V>>Predicate<? super MaybeSource<? extends T>>Function<? super MaybeSource<? extends T>,? extends SingleSource<? extends R>>Function<? super MaybeSource<? extends T>,? extends MaybeSource<? extends R>>Function<? super MaybeSource<? extends T>,? extends CompletableSource>FlowableSubscriber<? super MaybeSource<? extends T>>Consumer<? super MaybeSource<? extends T>>startWithArray(io.reactivex.rxjava3.core.MaybeSource[])startWithItem(io.reactivex.rxjava3.core.MaybeSource)MaybeSource<MaybeSource<? extends T>>SingleSource<MaybeSource<? extends T>>Single<MaybeSource<? extends T>>single(io.reactivex.rxjava3.core.MaybeSource)Maybe<MaybeSource<? extends T>>BiFunction<R,? super MaybeSource<? extends T>,R>BiFunction<MaybeSource<? extends T>,MaybeSource<? extends T>,MaybeSource<? extends T>>ConnectableFlowable<MaybeSource<? extends T>>? super Flowable<MaybeSource<? extends T>>Function<? super Flowable<MaybeSource<? extends T>>,? extends Publisher<R>>Function<? super Flowable<MaybeSource<? extends T>>,? extends Publisher<? extends R>>ParallelFlowable<MaybeSource<? extends T>>onErrorReturnItem(io.reactivex.rxjava3.core.MaybeSource)? extends Publisher<? extends MaybeSource<? extends T>>Function<? super Throwable,? extends Publisher<? extends MaybeSource<? extends T>>>SingleSource<? extends MaybeSource<? extends T>>Notification<MaybeSource<? extends T>>Flowable<Notification<MaybeSource<? extends T>>>Publisher<Notification<MaybeSource<? extends T>>>Function<? super MaybeSource<? extends T>,? extends R>FlowableOperator<? extends R,? super MaybeSource<? extends T>>last(io.reactivex.rxjava3.core.MaybeSource)Function<? super MaybeSource<? extends T>,? extends Publisher<TLeftEnd>>BiFunction<? super MaybeSource<? extends T>,? super TRight,? extends R>BiFunction<? super MaybeSource<? extends T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,MaybeSource<? extends T>>Flowable<GroupedFlowable<K,MaybeSource<? extends T>>>Publisher<GroupedFlowable<K,MaybeSource<? extends T>>>Function<? super MaybeSource<? extends T>,? extends Iterable<? extends U>>BiFunction<? super MaybeSource<? extends T>,? super U,? extends V>Function<? super MaybeSource<? extends T>,? extends Publisher<? extends U>>first(io.reactivex.rxjava3.core.MaybeSource)elementAt(long,io.reactivex.rxjava3.core.MaybeSource)? super Notification<MaybeSource<? extends T>>Consumer<? super Notification<MaybeSource<? extends T>>>BiPredicate<? super MaybeSource<? extends T>,? super MaybeSource<? extends T>>Function<? super MaybeSource<? extends T>,K>Function<? super MaybeSource<? extends T>,Notification<R>>Function<? super MaybeSource<? extends T>,? extends Publisher<U>>defaultIfEmpty(io.reactivex.rxjava3.core.MaybeSource)FlowableTransformer<? super MaybeSource<? extends T>,? extends R>BiConsumer<? super U,? super MaybeSource<? extends T>>Flowable<List<MaybeSource<? extends T>>>Publisher<List<MaybeSource<? extends T>>>Future<MaybeSource<? extends T>>blockingSingle(io.reactivex.rxjava3.core.MaybeSource)blockingMostRecent(io.reactivex.rxjava3.core.MaybeSource)blockingLast(io.reactivex.rxjava3.core.MaybeSource)blockingFirst(io.reactivex.rxjava3.core.MaybeSource)Flowable<MaybeSource<? extends T>>()Function<MaybeSource<Object>,Publisher<Object>>Flowable<? extends MaybeSource<? extends T>>? super ? extends MaybeSource<? extends T>Function<? super ? extends MaybeSource<? extends T>,? extends MaybeSource<? extends R>>Subscriber<? super ? extends MaybeSource<? extends T>>Function<? super ? extends MaybeSource<? extends T>,? extends Stream<? extends R>>Stream<? extends MaybeSource<? extends T>>BaseStream<? extends MaybeSource<? extends T>,Stream<? extends MaybeSource<? extends T>>>CompletionStage<? extends MaybeSource<? extends T>>Collector<? super ? extends MaybeSource<? extends T>,A,R>Function<? super ? extends MaybeSource<? extends T>,Optional<? extends R>>TestSubscriber<? extends MaybeSource<? extends T>>BaseTestConsumer<? extends MaybeSource<? extends T>,TestSubscriber<? extends MaybeSource<? extends T>>>FlowableSubscriber<? extends MaybeSource<? extends T>>Subscriber<? extends MaybeSource<? extends T>>BiFunction<? super ? extends MaybeSource<? extends T>,? super U,? extends R>Function5<? super ? extends MaybeSource<? extends T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super ? extends MaybeSource<? extends T>,? super T1,? super T2,? super T3,R>Function3<? super ? extends MaybeSource<? extends T>,? super T1,? super T2,R>Flowable<Flowable<? extends MaybeSource<? extends T>>>Publisher<Flowable<? extends MaybeSource<? extends T>>>List<? extends MaybeSource<? extends T>>Collection<? extends MaybeSource<? extends T>>Single<List<? extends MaybeSource<? extends T>>>SingleSource<List<? extends MaybeSource<? extends T>>>Comparator<? super ? extends MaybeSource<? extends T>>Observable<? extends MaybeSource<? extends T>>ObservableSource<? extends MaybeSource<? extends T>>Function<? super ? extends MaybeSource<? extends T>,? extends K>Function<? super ? extends MaybeSource<? extends T>,? extends V>Map<K,Collection<? extends MaybeSource<? extends T>>>Single<Map<K,Collection<? extends MaybeSource<? extends T>>>>SingleSource<Map<K,Collection<? extends MaybeSource<? extends T>>>>Map<K,? extends MaybeSource<? extends T>>Single<Map<K,? extends MaybeSource<? extends T>>>SingleSource<Map<K,? extends MaybeSource<? extends T>>>FlowableConverter<? extends MaybeSource<? extends T>,? extends R>Timed<? extends MaybeSource<? extends T>>Flowable<Timed<? extends MaybeSource<? extends T>>>Publisher<Timed<? extends MaybeSource<? extends T>>>Function<? super ? extends MaybeSource<? extends T>,? extends Publisher<V>>? extends ? extends MaybeSource<? extends T>Publisher<? extends ? extends MaybeSource<? extends T>>Predicate<? super ? extends MaybeSource<? extends T>>Function<? super ? extends MaybeSource<? extends T>,? extends SingleSource<? extends R>>Function<? super ? extends MaybeSource<? extends T>,? extends Publisher<? extends R>>Function<? super ? extends MaybeSource<? extends T>,? extends CompletableSource>FlowableSubscriber<? super ? extends MaybeSource<? extends T>>Consumer<? super ? extends MaybeSource<? extends T>>? extends MaybeSource<? extends T>[]Iterable<? extends ? extends MaybeSource<? extends T>>Single<? extends MaybeSource<? extends T>>Maybe<? extends MaybeSource<? extends T>>BiFunction<R,? super ? extends MaybeSource<? extends T>,R>BiFunction<? extends MaybeSource<? extends T>,? extends MaybeSource<? extends T>,? extends MaybeSource<? extends T>>ConnectableFlowable<? extends MaybeSource<? extends T>>? super Flowable<? extends MaybeSource<? extends T>>Function<? super Flowable<? extends MaybeSource<? extends T>>,? extends Publisher<R>>Function<? super Flowable<? extends MaybeSource<? extends T>>,? extends Publisher<? extends R>>ParallelFlowable<? extends MaybeSource<? extends T>>Function<? super Throwable,? extends ? extends MaybeSource<? extends T>>? extends Publisher<? extends ? extends MaybeSource<? extends T>>Function<? super Throwable,? extends Publisher<? extends ? extends MaybeSource<? extends T>>>MaybeSource<? extends ? extends MaybeSource<? extends T>>SingleSource<? extends ? extends MaybeSource<? extends T>>Notification<? extends MaybeSource<? extends T>>Flowable<Notification<? extends MaybeSource<? extends T>>>Publisher<Notification<? extends MaybeSource<? extends T>>>Function<? super ? extends MaybeSource<? extends T>,? extends R>FlowableOperator<? extends R,? super ? extends MaybeSource<? extends T>>Function<? super ? extends MaybeSource<? extends T>,? extends Publisher<TLeftEnd>>BiFunction<? super ? extends MaybeSource<? extends T>,? super TRight,? extends R>BiFunction<? super ? extends MaybeSource<? extends T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,? extends MaybeSource<? extends T>>Flowable<GroupedFlowable<K,? extends MaybeSource<? extends T>>>Publisher<GroupedFlowable<K,? extends MaybeSource<? extends T>>>Function<? super ? extends MaybeSource<? extends T>,? extends Iterable<? extends U>>BiFunction<? super ? extends MaybeSource<? extends T>,? super U,? extends V>Function<? super ? extends MaybeSource<? extends T>,? extends Publisher<? extends U>>? super Notification<? extends MaybeSource<? extends T>>Consumer<? super Notification<? extends MaybeSource<? extends T>>>BiPredicate<? super ? extends MaybeSource<? extends T>,? super ? extends MaybeSource<? extends T>>Function<? super ? extends MaybeSource<? extends T>,K>Function<? super ? extends MaybeSource<? extends T>,Notification<R>>Function<? super ? extends MaybeSource<? extends T>,? extends Publisher<U>>FlowableTransformer<? super ? extends MaybeSource<? extends T>,? extends R>BiConsumer<? super U,? super ? extends MaybeSource<? extends T>>Flowable<List<? extends MaybeSource<? extends T>>>Publisher<List<? extends MaybeSource<? extends T>>>Future<? extends MaybeSource<? extends T>>Flowable<? extends MaybeSource<? extends T>>()MaybeCreate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeCreate.classMaybeCreateMaybeCreate<T>(io.reactivex.rxjava3.core.MaybeOnSubscribe)MaybeCreate(io.reactivex.rxjava3.core.MaybeOnSubscribe)MaybeDefer<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDefer.classMaybeDeferMaybeDefer<T>(io.reactivex.rxjava3.functions.Supplier)MaybeDefer(io.reactivex.rxjava3.functions.Supplier)maybeSupplierMaybeError<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeError.classMaybeErrorMaybeError<T>(java.lang.Throwable)MaybeError(java.lang.Throwable)MaybeErrorCallable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeErrorCallable.classMaybeErrorCallableMaybeErrorCallable<T>(io.reactivex.rxjava3.functions.Supplier)MaybeErrorCallable(io.reactivex.rxjava3.functions.Supplier)MaybeFromAction<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromAction.classMaybeFromActionMaybeFromAction<T>(io.reactivex.rxjava3.functions.Action)MaybeFromAction(io.reactivex.rxjava3.functions.Action)MaybeFromSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromSingle.classMaybeFromSingleHasUpstreamSingleSource<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamSingleSource.classHasUpstreamSingleSourceMaybeFromSingle<T>(io.reactivex.rxjava3.core.SingleSource)MaybeFromSingle(io.reactivex.rxjava3.core.SingleSource)MaybeFromCallable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromCallable.classMaybeFromCallableMaybeFromCallable<T>(java.util.concurrent.Callable)MaybeFromCallable(java.util.concurrent.Callable)MaybeFromFuture<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromFuture.classMaybeFromFutureMaybeFromFuture<T>(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit)MaybeFromFuture(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit)ObservableElementAtMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableElementAtMaybe.classObservableElementAtMaybeObservableElementAtMaybe<T>(io.reactivex.rxjava3.core.ObservableSource,long)ObservableElementAtMaybe(io.reactivex.rxjava3.core.ObservableSource,long)FlowableElementAtMaybePublisher<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableElementAtMaybePublisher.classFlowableElementAtMaybePublisherFlowableElementAtMaybePublisher<T>(org.reactivestreams.Publisher,long)FlowableElementAtMaybePublisher(org.reactivestreams.Publisher,long)MaybeFromRunnable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromRunnable.classMaybeFromRunnableMaybeFromRunnable<T>(java.lang.Runnable)MaybeFromRunnable(java.lang.Runnable)runnableMaybeFromSupplier<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFromSupplier.classMaybeFromSupplierMaybeFromSupplier<T>(io.reactivex.rxjava3.functions.Supplier)MaybeFromSupplier(io.reactivex.rxjava3.functions.Supplier)MaybeJust<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeJust.classMaybeJustMaybeJust<T>(java.lang.Object)MaybeJust(java.lang.Object)FlowableFlatMapMaybePublisher<? extends MaybeSource<? extends T>,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapMaybePublisher.classFlowableFlatMapMaybePublisherFlowableFlatMapMaybePublisher<T,R>FlowableFlatMapMaybePublisher<T,R>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean,int)FlowableFlatMapMaybePublisher(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean,int)MaybeFlatten<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatten.classMaybeFlattenAbstractMaybeWithUpstream<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/AbstractMaybeWithUpstream.classAbstractMaybeWithUpstreamHasUpstreamMaybeSource<>MaybeFlatten<>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)AbstractMaybeWithUpstream(io.reactivex.rxjava3.core.MaybeSource)AbstractMaybeWithUpstream<>(io.reactivex.rxjava3.core.MaybeSource)MaybeObserver<? super R>MaybeFlatten(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeMergeArray<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeMergeArray.classMaybeMergeArrayMaybeMergeArray<T>(io.reactivex.rxjava3.core.MaybeSource[])MaybeMergeArray(io.reactivex.rxjava3.core.MaybeSource[])Function<MaybeSource<? extends T>,MaybeSource<? extends T>>MaybeEqualSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeEqualSingle.classMaybeEqualSingleMaybeEqualSingle<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.BiPredicate)MaybeEqualSingle(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.BiPredicate)FlowableSwitchMapMaybePublisher<? extends MaybeSource<? extends T>,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableSwitchMapMaybePublisher.classFlowableSwitchMapMaybePublisherFlowableSwitchMapMaybePublisher<T,R>FlowableSwitchMapMaybePublisher<T,R>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean)FlowableSwitchMapMaybePublisher(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean)"unsafeCreate(Maybe) should be upgraded"unsafeCreate(Maybe) should be upgradedMaybeUnsafeCreate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeUnsafeCreate.classMaybeUnsafeCreateAbstractMaybeWithUpstream<T,T>MaybeUnsafeCreate<T>(io.reactivex.rxjava3.core.MaybeSource)AbstractMaybeWithUpstream<T,T>(io.reactivex.rxjava3.core.MaybeSource)MaybeUnsafeCreate(io.reactivex.rxjava3.core.MaybeSource)MaybeUsing<T,D>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeUsing.classMaybeUsingMaybeUsing<T,D>(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)MaybeUsing(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)resourceDisposerMaybeZipIterable<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeZipIterable.classMaybeZipIterableMaybeZipIterable<T,R>(java.lang.Iterable,io.reactivex.rxjava3.functions.Function)Maybe<Timed<R>>MaybeSource<Timed<R>>MaybeConverter<R,? extends R>MaybeOperator<? extends R,? super R>Function<? super R,? extends MaybeSource<? extends U>>MaybeTransformer<? super R,? extends R>Maybe<R>()MaybeZipIterable(java.lang.Iterable,io.reactivex.rxjava3.functions.Function)MaybeZipArray<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeZipArray.classMaybeZipArrayMaybeZipArray<T,R>(io.reactivex.rxjava3.core.MaybeSource[],io.reactivex.rxjava3.functions.Function)MaybeZipArray(io.reactivex.rxjava3.core.MaybeSource[],io.reactivex.rxjava3.functions.Function)BlockingMultiObserver<T>BlockingMultiObserver<T>()"defaultValue is null"defaultValue is null"onSuccess is null"onSuccess is nullBlockingDisposableMultiObserver<T>BlockingDisposableMultiObserver<T>()MaybeCache<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeCache.classMaybeCacheMaybeCache<T>(io.reactivex.rxjava3.core.MaybeSource)CacheDisposable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeCache$CacheDisposable.classMaybeCache$CacheDisposableAtomicReference<MaybeCache>MaybeCache<>remove(io.reactivex.rxjava3.internal.operators.maybe.MaybeCache.CacheDisposable)AtomicReference<MaybeCache<T>>add(io.reactivex.rxjava3.internal.operators.maybe.MaybeCache.CacheDisposable)MaybeCache(io.reactivex.rxjava3.core.MaybeSource)CacheDisposable[]CacheDisposable<T>[]AtomicReference<CacheDisposable<T>[]>AtomicReference<MaybeSource<T>>CacheDisposable<>AtomicReference<>CacheDisposable<>[]Function<T,? extends U>MaybeTransformer<T,R>Maybe<Upstream>MaybeSource<Upstream>apply(io.reactivex.rxjava3.core.Maybe)MaybeSource<Downstream>MaybeContains<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeContains.classMaybeContainsMaybeContains<T>(io.reactivex.rxjava3.core.MaybeSource,java.lang.Object)MaybeContains(io.reactivex.rxjava3.core.MaybeSource,java.lang.Object)MaybeCount<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeCount.classMaybeCountMaybeCount<T>(io.reactivex.rxjava3.core.MaybeSource)MaybeCount(io.reactivex.rxjava3.core.MaybeSource)MaybeToSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeToSingle.classMaybeToSingleMaybeToSingle<T>(io.reactivex.rxjava3.core.MaybeSource,java.lang.Object)MaybeToSingle(io.reactivex.rxjava3.core.MaybeSource,java.lang.Object)MaybeDematerialize<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDematerialize.classMaybeDematerializeAbstractMaybeWithUpstream<T,R>MaybeDematerialize<T,R>(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Function)AbstractMaybeWithUpstream<T,R>(io.reactivex.rxjava3.core.MaybeSource)MaybeDematerialize(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Function)MaybeDelay<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDelay.classMaybeDelayMaybeDelay<T>(io.reactivex.rxjava3.core.MaybeSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)MaybeDelay(io.reactivex.rxjava3.core.MaybeSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)delayIndicator"delayIndicator is null"delayIndicator is nullMaybeDelayOtherPublisher<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDelayOtherPublisher.classMaybeDelayOtherPublisherMaybeDelayOtherPublisher<T,U>(io.reactivex.rxjava3.core.MaybeSource,org.reactivestreams.Publisher)MaybeDelayOtherPublisher(io.reactivex.rxjava3.core.MaybeSource,org.reactivestreams.Publisher)MaybeDelaySubscriptionOtherPublisher<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDelaySubscriptionOtherPublisher.classMaybeDelaySubscriptionOtherPublisherMaybeDelaySubscriptionOtherPublisher<T,U>(io.reactivex.rxjava3.core.MaybeSource,org.reactivestreams.Publisher)MaybeDelaySubscriptionOtherPublisher(io.reactivex.rxjava3.core.MaybeSource,org.reactivestreams.Publisher)onAfterSuccess"onAfterSuccess is null"onAfterSuccess is nullMaybeDoAfterSuccess<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoAfterSuccess.classMaybeDoAfterSuccessMaybeDoAfterSuccess<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Consumer)MaybeDoAfterSuccess(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Consumer)MaybePeek<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybePeek.classMaybePeekMaybePeek<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action)MaybePeek(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action)onDisposeCallonCompleteCallonErrorCallonSuccessCallonSubscribeCallMaybeDoFinally<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoFinally.classMaybeDoFinallyMaybeDoFinally<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Action)MaybeDoFinally(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Action)MaybeDoOnEvent<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoOnEvent.classMaybeDoOnEventMaybeDoOnEvent<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.BiConsumer)MaybeDoOnEvent(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.BiConsumer)MaybeDoOnLifecycle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoOnLifecycle.classMaybeDoOnLifecycleMaybeDoOnLifecycle<T>(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)MaybeDoOnLifecycle(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)MaybeDoOnTerminate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoOnTerminate.classMaybeDoOnTerminateMaybeDoOnTerminate<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Action)MaybeDoOnTerminate(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Action)MaybeFilter<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFilter.classMaybeFilterMaybeFilter<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Predicate)MaybeFilter(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Predicate)MaybeFlatten<T,R>MaybeFlatten<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)onSuccessMapper"onSuccessMapper is null"onSuccessMapper is nullMaybeFlatMapNotification<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapNotification.classMaybeFlatMapNotificationMaybeFlatMapNotification<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)MaybeFlatMapNotification(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)MaybeFlatMapBiSelector<T,U,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapBiSelector.classMaybeFlatMapBiSelectorMaybeFlatMapBiSelector<T,U,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)MaybeFlatMapBiSelector(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)MaybeFlatMapIterableFlowable<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapIterableFlowable.classMaybeFlatMapIterableFlowableMaybeFlatMapIterableFlowable<T,R>MaybeFlatMapIterableFlowable<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapIterableFlowable(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapIterableObservable<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapIterableObservable.classMaybeFlatMapIterableObservableMaybeFlatMapIterableObservable<T,R>MaybeFlatMapIterableObservable<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapIterableObservable(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapObservable<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/MaybeFlatMapObservable.classMaybeFlatMapObservableMaybeFlatMapObservable<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapObservable(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapPublisher<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/MaybeFlatMapPublisher.classMaybeFlatMapPublisherMaybeFlatMapPublisher<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapPublisher(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapSingle.classMaybeFlatMapSingleMaybeFlatMapSingle<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapSingle(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFlatMapCompletable.classMaybeFlatMapCompletableMaybeFlatMapCompletable<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeFlatMapCompletable(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeHide<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeHide.classMaybeHideMaybeHide<T>(io.reactivex.rxjava3.core.MaybeSource)MaybeHide(io.reactivex.rxjava3.core.MaybeSource)MaybeIsEmptySingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeIsEmptySingle.classMaybeIsEmptySingleFuseToMaybe<Boolean>MaybeIsEmptySingle<T>(io.reactivex.rxjava3.core.MaybeSource)MaybeIsEmptySingle(io.reactivex.rxjava3.core.MaybeSource)"lift is null"lift is nullMaybeLift<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeLift.classMaybeLiftMaybeLift<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeOperator)MaybeLift(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeOperator)MaybeMap<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeMap.classMaybeMapMaybeMap<T,R>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeMap(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeMaterialize<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeMaterialize.classMaybeMaterializeMaybeMaterialize<T>(io.reactivex.rxjava3.core.Maybe)MaybeMaterialize(io.reactivex.rxjava3.core.Maybe)MaybeObserveOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeObserveOn.classMaybeObserveOnMaybeObserveOn<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.Scheduler)MaybeObserveOn(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.Scheduler)MaybeToObservable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeToObservable.classMaybeToObservableMaybeToObservable<T>(io.reactivex.rxjava3.core.MaybeSource)MaybeToObservable(io.reactivex.rxjava3.core.MaybeSource)MaybeOnErrorComplete<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorComplete.classMaybeOnErrorCompleteMaybeOnErrorComplete<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Predicate)MaybeOnErrorComplete(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Predicate)Function<Throwable,MaybeSource<? extends T>>MaybeOnErrorNext<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorNext.classMaybeOnErrorNextMaybeOnErrorNext<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeOnErrorNext(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)resumeFunctionMaybeOnErrorReturn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeOnErrorReturn.classMaybeOnErrorReturnMaybeOnErrorReturn<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeOnErrorReturn(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.functions.Function)MaybeDetach<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDetach.classMaybeDetachMaybeDetach<T>(io.reactivex.rxjava3.core.MaybeSource)MaybeDetach(io.reactivex.rxjava3.core.MaybeSource)SafeMaybeObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/SafeMaybeObserver.classSafeMaybeObserverSafeMaybeObserver<T>(io.reactivex.rxjava3.core.MaybeObserver)SafeMaybeObserver(io.reactivex.rxjava3.core.MaybeObserver)onSubscribeFailedMaybeCallbackObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeCallbackObserver.classMaybeCallbackObserverMaybeCallbackObserver<T>(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)weakCompareAndSetRelease(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)weakCompareAndSetAcquire(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)weakCompareAndSetVolatile(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)compareAndExchangeRelease(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)compareAndExchangeAcquire(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)compareAndExchange(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)setRelease(io.reactivex.rxjava3.disposables.Disposable)setOpaque(io.reactivex.rxjava3.disposables.Disposable)setPlain(io.reactivex.rxjava3.disposables.Disposable)BinaryOperator<Disposable>BiFunction<Disposable,Disposable,Disposable>accumulateAndGet(io.reactivex.rxjava3.disposables.Disposable,java.util.function.BinaryOperator)getAndAccumulate(io.reactivex.rxjava3.disposables.Disposable,java.util.function.BinaryOperator)UnaryOperator<Disposable>Function<Disposable,Disposable>getAndSet(io.reactivex.rxjava3.disposables.Disposable)weakCompareAndSetPlain(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)weakCompareAndSet(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)compareAndSet(io.reactivex.rxjava3.disposables.Disposable,io.reactivex.rxjava3.disposables.Disposable)lazySet(io.reactivex.rxjava3.disposables.Disposable)set(io.reactivex.rxjava3.disposables.Disposable)AtomicReference<Disposable>()AtomicReference<Disposable>(io.reactivex.rxjava3.disposables.Disposable)MaybeCallbackObserver(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)"The RxJavaPlugins.onSubscribe hook returned a null MaybeObserver. Please check the handler provided to RxJavaPlugins.setOnMaybeSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"The RxJavaPlugins.onSubscribe hook returned a null MaybeObserver. Please check the handler provided to RxJavaPlugins.setOnMaybeSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"subscribeActual failed"subscribeActual failedMaybeSubscribeOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeSubscribeOn.classMaybeSubscribeOnMaybeSubscribeOn<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.Scheduler)MaybeSubscribeOn(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.Scheduler)MaybeSwitchIfEmpty<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeSwitchIfEmpty.classMaybeSwitchIfEmptyMaybeSwitchIfEmpty<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)MaybeSwitchIfEmpty(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)MaybeSwitchIfEmptySingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeSwitchIfEmptySingle.classMaybeSwitchIfEmptySingleMaybeSwitchIfEmptySingle<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.SingleSource)MaybeSwitchIfEmptySingle(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.SingleSource)MaybeTakeUntilMaybe<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTakeUntilMaybe.classMaybeTakeUntilMaybeMaybeTakeUntilMaybe<T,U>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)MaybeTakeUntilMaybe(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)MaybeTakeUntilPublisher<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTakeUntilPublisher.classMaybeTakeUntilPublisherMaybeTakeUntilPublisher<T,U>(io.reactivex.rxjava3.core.MaybeSource,org.reactivestreams.Publisher)MaybeTakeUntilPublisher(io.reactivex.rxjava3.core.MaybeSource,org.reactivestreams.Publisher)MaybeTimeInterval<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTimeInterval.classMaybeTimeIntervalMaybeTimeInterval<T>(io.reactivex.rxjava3.core.MaybeSource,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)MaybeObserver<? super Timed<T>>toCompletionStage(io.reactivex.rxjava3.schedulers.Timed)TestObserver<Timed<T>>BaseTestConsumer<Timed<T>,TestObserver<Timed<T>>>Observer<Timed<T>>MaybeObserver<Timed<T>>SingleObserver<Timed<T>>Maybe<Timed<Timed<T>>>MaybeSource<Timed<Timed<T>>>? extends MaybeSource<? extends Timed<T>>Function<? super Throwable,? extends MaybeSource<? extends Timed<T>>>MaybeConverter<Timed<T>,? extends R>Single<Notification<Timed<T>>>SingleSource<Notification<Timed<T>>>MaybeOperator<? extends R,? super Timed<T>>Function<? super Timed<T>,? extends ObservableSource<? extends R>>Function<? super Timed<T>,? extends MaybeSource<? extends U>>BiConsumer<? super Timed<T>,? super Throwable>MaybeTransformer<? super Timed<T>,? extends R>blockingGet(io.reactivex.rxjava3.schedulers.Timed)Maybe<Timed<T>>()MaybeTimeInterval(io.reactivex.rxjava3.core.MaybeSource,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)timeoutIndicator"timeoutIndicator is null"timeoutIndicator is nullMaybeTimeoutMaybe<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTimeoutMaybe.classMaybeTimeoutMaybeMaybeTimeoutMaybe<T,U>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)MaybeTimeoutMaybe(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.MaybeSource)MaybeTimeoutPublisher<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeTimeoutPublisher.classMaybeTimeoutPublisherMaybeTimeoutPublisher<T,U>(io.reactivex.rxjava3.core.MaybeSource,org.reactivestreams.Publisher,io.reactivex.rxjava3.core.MaybeSource)MaybeTimeoutPublisher(io.reactivex.rxjava3.core.MaybeSource,org.reactivestreams.Publisher,io.reactivex.rxjava3.core.MaybeSource)MaybeUnsubscribeOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeUnsubscribeOn.classMaybeUnsubscribeOnMaybeUnsubscribeOn<T>(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.Scheduler)MaybeUnsubscribeOn(io.reactivex.rxjava3.core.MaybeSource,io.reactivex.rxjava3.core.Scheduler)TestObserver<T>()BaseTestConsumer<T,TestObserver<T>>()TestObserver<T>(io.reactivex.rxjava3.core.Observer)Optional<Maybe<T>>? extends Maybe<T>Supplier<? extends Maybe<T>>orElse(io.reactivex.rxjava3.core.Maybe)Stream<Maybe<T>>BaseStream<Maybe<T>,Stream<Maybe<T>>>Optional<? extends Maybe<T>>? extends Optional<? extends Maybe<T>>Supplier<? extends Optional<? extends Maybe<T>>>? super Maybe<T>Function<? super Maybe<T>,? extends Optional<? extends U>>Function<? super Maybe<T>,? extends U>Predicate<? super Maybe<T>>Consumer<? super Maybe<T>>Supplier<Maybe<T>>Function<T,Maybe<T>>Function<? super Maybe<T>,? extends V>Function<V,Maybe<T>>MaybeFromCompletionStage<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/MaybeFromCompletionStage.classMaybeFromCompletionStageMaybeFromCompletionStage<T>(java.util.concurrent.CompletionStage)MaybeFromCompletionStage(java.util.concurrent.CompletionStage)MaybeMapOptional<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/MaybeMapOptional.classMaybeMapOptionalMaybeMapOptional<T,R>(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Function)MaybeMapOptional(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Function)MaybeFlattenStreamAsFlowable<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/MaybeFlattenStreamAsFlowable.classMaybeFlattenStreamAsFlowableMaybeFlattenStreamAsFlowable<T,R>(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Function)MaybeFlattenStreamAsFlowable(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Function)MaybeFlattenStreamAsObservable<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/MaybeFlattenStreamAsObservable.classMaybeFlattenStreamAsObservableMaybeFlattenStreamAsObservable<T,R>(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Function)MaybeFlattenStreamAsObservable(io.reactivex.rxjava3.core.Maybe,io.reactivex.rxjava3.functions.Function)The {@code Maybe} class represents a deferred computation and emission of a single value, no value at all or an exception.The {@code Maybe} class implements the {@link MaybeSource} base interface and the default consumertype it interacts with is the {@link MaybeObserver} via the {@link #subscribe(MaybeObserver)} method.The {@code Maybe} operates with the following sequential protocol:onSubscribe (onSuccess | onError | onComplete)?Note that {@code onSuccess}, {@code onError} and {@code onComplete} are mutually exclusive events; unlike {@link Observable},{@code onSuccess} is never followed by {@code onError} or {@code onComplete}.Like {@code Observable}, a running {@code Maybe} can be stopped through the {@link Disposable} instanceprovided to consumers through {@link MaybeObserver#onSubscribe}.Like an {@code Observable}, a {@code Maybe} is lazy, can be either "hot" or "cold", synchronous orasynchronous. {@code Maybe} instances returned by the methods of this class are <em>cold</em>{@link io.reactivex.rxjava3.subjects.MaybeSubject MaybeSubject}.<img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/maybe.png" alt="">Disposable d = Maybe.just("Hello World").subscribeWith(new DisposableMaybeObserver&lt;String&gt;() {public void onSuccess(String value) {System.out.println("Success: " + value);Note that by design, subscriptions via {@link #subscribe(MaybeObserver)} can't be disposed{@code void} return of the {@link #subscribe(MaybeObserver)} method) and it is theresponsibility of the implementor of the {@code MaybeObserver} to allow this to happen.{@link io.reactivex.rxjava3.observers.DisposableMaybeObserver DisposableMaybeObserver} instance.For convenience, the {@link #subscribeWith(MaybeObserver)} method is provided as well toallow working with a {@code MaybeObserver} (or subclass) instance to be applied with inio.reactivex.rxjava3.observers.DisposableMaybeObserverRuns multiple {@link MaybeSource}s provided by an {@link Iterable} sequence andsignals the events of the first one that signals (disposing the rest).<img width="640" height="518" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.amb.png" alt="">the {@code Iterable} sequence of sources. A subscription to each source willoccur in the same order as in the {@code Iterable}.Runs multiple {@link MaybeSource}s and signals the events of the first one that signals (disposingthe rest).<img width="640" height="519" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ambArray.png" alt="">the array of sources. A subscription to each source willoccur in the same order as in the array.Concatenate the single values, in a non-overlapping fashion, of the {@link MaybeSource} sources provided byan {@link Iterable} sequence as a {@link Flowable} sequence.<img width="640" height="526" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.i.png" alt="">the {@code Iterable} sequence of {@code MaybeSource} instancesReturns a {@link Flowable} that emits the items emitted by two {@link MaybeSource}s, one after the other.<img width="640" height="423" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.png" alt="">a {@code MaybeSource} to be concatenatedReturns a {@link Flowable} that emits the items emitted by three {@link MaybeSource}s, one after the other.Returns a {@link Flowable} that emits the items emitted by four {@link MaybeSource}s, one after the other.a {@link Publisher} sequence as a {@link Flowable} sequence.<img width="640" height="416" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.p.png" alt=""><dd>The returned {@code Flowable} honors the backpressure of the downstream consumer andexpects the {@code Publisher} to honor backpressure as well. If the sources {@code Publisher}violates this, a {@link io.reactivex.rxjava3.exceptions.MissingBackpressureException} is signaled.</dd>the {@code Publisher} of {@code MaybeSource} instances<img width="640" height="416" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.pn.png" alt="">the number of {@code MaybeSource}s to prefetch from the {@code Publisher}Concatenate the single values, in a non-overlapping fashion, of the {@link MaybeSource} sources in the arrayas a {@link Flowable} sequence.<img width="640" height="526" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArray.png" alt="">the array of {@code MaybeSource} instancesConcatenates a variable number of {@link MaybeSource} sources and delays errors from any of themtill all terminate as a {@link Flowable} sequence.<img width="640" height="425" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayDelayError.png" alt="">the array of sourcesConcatenates a sequence of {@link MaybeSource} eagerly into a {@link Flowable} sequence.Eager concatenation means that once an observer subscribes, this operator subscribes to all of thesource {@code MaybeSource}s. The operator buffers the value emitted by these {@code MaybeSource}s and then drains them<img width="640" height="490" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayEager.png" alt="">a sequence of {@code MaybeSource}s that need to be eagerly concatenated<img width="640" height="428" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayEagerDelayError.png" alt="">Concatenates the {@link Iterable} sequence of {@link MaybeSource}s into a single sequence by subscribing to each {@code MaybeSource},one after the other, one at a time and delays any errors till the all inner {@code MaybeSource}s terminate<img width="640" height="451" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError3.i.png" alt="">the {@code Iterable} sequence of {@code MaybeSource}sConcatenates the {@link Publisher} sequence of {@link MaybeSource}s into a single sequence by subscribing to each inner {@code MaybeSource},one after the other, one at a time and delays any errors till the all inner and the outer {@code Publisher} terminate<img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.p.png" alt="">the {@code Publisher} sequence of {@code MaybeSource}s<img width="640" height="299" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.pn.png" alt="">Concatenates a sequence of {@link MaybeSource}s eagerly into a {@link Flowable} sequence.<img width="640" height="526" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.i.png" alt="">source {@code MaybeSource}s. The operator buffers the values emitted by these {@code MaybeSource}s and then drains them<dd>Backpressure is honored towards the downstream.</dd>a sequence of {@code MaybeSource} that need to be eagerly concatenatedConcatenates a sequence of {@link MaybeSource}s eagerly into a {@link Flowable} sequence andruns a limited number of the inner sequences at once.<img width="640" height="439" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.in.png" alt="">the maximum number of concurrently running inner {@code MaybeSource}s; {@link Integer#MAX_VALUE}is interpreted as all inner {@code MaybeSource}s can be active at the same timeConcatenates a {@link Publisher} sequence of {@link MaybeSource}s eagerly into a {@link Flowable} sequence.emitted source {@code MaybeSource}s as they are observed. The operator buffers the values emitted by these{@code MaybeSource}s and then drains them in order, each one after the previous one completes.<img width="640" height="511" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.p.png" alt=""><dd>Backpressure is honored towards the downstream and the outer {@code Publisher} issignal {@link io.reactivex.rxjava3.exceptions.MissingBackpressureException}.</dd>Concatenates a {@link Publisher} sequence of {@link MaybeSource}s eagerly into a {@link Flowable} sequence,running at most the given number of inner {@code MaybeSource}s at once.<img width="640" height="425" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.pn.png" alt="">Concatenates a sequence of {@link MaybeSource}s eagerly into a {@link Flowable} sequence,delaying errors until all inner {@code MaybeSource}s terminate.<img width="640" height="428" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.i.png" alt="">delaying errors until all inner {@code MaybeSource}s terminate andruns a limited number of inner {@code MaybeSource}s at once.<img width="640" height="379" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.in.png" alt="">delaying errors until all the inner and the outer sequence terminate.<img width="640" height="495" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.p.png" alt="">delaying errors until all the inner and the outer sequence terminate andruns a limited number of the inner {@code MaybeSource}s at once.<img width="640" height="421" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.pn.png" alt="">Provides an API (via a cold {@code Maybe}) that bridges the reactive world with the callback-style world.<img width="640" height="499" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.create.png" alt="">Maybe.&lt;Event&gt;create(emitter -&gt; {if (e.isNothing()) {emitter.onSuccess(e);Whenever a {@link MaybeObserver} subscribes to the returned {@code Maybe}, the provided{@link MaybeOnSubscribe} callback is invoked with a fresh instance of a {@link MaybeEmitter}that will interact only with that specific {@code MaybeObserver}. If this {@code MaybeObserver}disposes the flow (making {@link MaybeEmitter#isDisposed} return {@code true}),other observers subscribed to the same returned {@code Maybe} are not affected.the emitter that is called when a {@code MaybeObserver} subscribes to the returned {@code Maybe}Calls a {@link Supplier} for each individual {@link MaybeObserver} to return the actual {@link MaybeSource} source tobe subscribed to.<img width="640" height="498" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.defer.png" alt="">the {@code Supplier} that is called for each individual {@code MaybeObserver} andreturns a {@code MaybeSource} instance to subscribe toReturns a (singleton) {@code Maybe} instance that calls {@link MaybeObserver#onComplete onComplete}immediately.the shared {@code Maybe} instanceReturns a {@code Maybe} that invokes a subscriber's {@link MaybeObserver#onError onError} method when thesubscriber subscribes to it.<img width="640" height="447" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.error.png" alt="">the particular {@link Throwable} to pass to {@link MaybeObserver#onError onError}the type of the item (ostensibly) emitted by the {@code Maybe}Returns a {@code Maybe} that invokes a {@link MaybeObserver}'s {@link MaybeObserver#onError onError} method when the{@code MaybeObserver} subscribes to it.<img width="640" height="440" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.error.f.png" alt="">a {@link Supplier} factory to return a {@link Throwable} for each individual {@code MaybeObserver}the type of the items (ostensibly) emitted by the {@code Maybe}Returns a {@code Maybe} instance that runs the given {@link Action} for each {@link MaybeObserver} and<img width="640" height="287" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromAction.png" alt="">delivered to the downstream via {@link MaybeObserver#onError(Throwable)},except when the downstream has disposed the resulting {@code Maybe} source.the {@code Action} to run for each {@code MaybeObserver}Wraps a {@link CompletableSource} into a {@code Maybe}.<img width="640" height="280" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromCompletable.png" alt="">Wraps a {@link SingleSource} into a {@code Maybe}.<img width="640" height="344" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromSingle.png" alt="">the {@code SingleSource} to convert fromReturns a {@code Maybe} that invokes the given {@link Callable} for each individual {@link MaybeObserver} thatsubscribes and emits the resulting non-{@code null} item via {@code onSuccess} whileconsidering a {@code null} result from the {@code Callable} as indication for valueless completionvia {@code onComplete}.<img width="640" height="183" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromCallable.png" alt="">This operator allows you to defer the execution of the given {@code Callable} until a {@code MaybeObserver}subscribes to the  returned {@code Maybe}. In other terms, this source operator evaluates the given{@code Callable} "lazily".Note that the {@code null} handling of this operator differs from the similar source operators in the other{@link io.reactivex.rxjava3.core base reactive classes}. Those operators signal a {@link NullPointerException} if the value returned by their{@code Callable} is {@code null} while this {@code fromCallable} considers it to indicate thereturned {@code Maybe} is empty.<dd>Any non-fatal exception thrown by {@link Callable#call()} will be forwarded to {@code onError},except if the {@code MaybeObserver} disposed the subscription in the meantime. In this latter case,the exception is forwarded to the global error handler via{@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable)} wrapped into a{@link io.reactivex.rxjava3.exceptions.UndeliverableException UndeliverableException}.Fatal exceptions are rethrown and usually will end up in the executing thread's{@link java.lang.Thread.UncaughtExceptionHandler#uncaughtException(Thread, Throwable)} handler.</dd>a {@code Callable} instance whose execution should be deferred and performed for each individual{@code MaybeObserver} that subscribes to the returned {@code Maybe}.the type of the item emitted by the {@code Maybe}.Converts a {@link Future} into a {@code Maybe}, treating a {@code null} result as an indication of emptiness.<img width="640" height="204" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromFuture.png" alt="">Unlike 1.x, disposing the {@code Maybe} won't cancel the future. If necessary, one can use composition to achieve thecancellation effect: {@code futureMaybe.doOnDispose(() -> future.cancel(true));}.the resulting {@code Maybe}Converts a {@link Future} into a {@code Maybe}, with a timeout on the {@code Future}.<img width="640" height="176" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromFuture.t.png" alt="">cancellation effect: {@code futureMaybe.doOnCancel(() -> future.cancel(true));}.Wraps an {@link ObservableSource} into a {@code Maybe} and emits the very first itemor completes if the source is empty.<img width="640" height="276" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromObservable.png" alt="">the {@code ObservableSource} to convert fromWraps a {@link Publisher} into a {@code Maybe} and emits the very first item<img width="640" height="309" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromPublisher.png" alt=""><dd>The operator consumes the given {@code Publisher} in an unbounded manner(requesting {@link Long#MAX_VALUE}) but cancels it after one item received.</dd>the {@code Publisher} to convert fromReturns a {@code Maybe} instance that runs the given {@link Runnable} for each {@link MaybeObserver} and<img width="640" height="287" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromRunnable.png" alt="">except when the downstream has disposed this {@code Maybe} source.the {@code Runnable} to run for each {@code MaybeObserver}Returns a {@code Maybe} that invokes the given {@link Supplier} for each individual {@link MaybeObserver} thatconsidering a {@code null} result from the {@code Supplier} as indication for valueless completionThis operator allows you to defer the execution of the given {@code Supplier} until a {@code MaybeObserver}{@code Supplier} "lazily".<img width="640" height="311" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.fromSupplier.v3.png" alt="">{@code Supplier} is {@code null} while this {@code fromSupplier} considers it to indicate the<dd>Any non-fatal exception thrown by {@link Supplier#get()} will be forwarded to {@code onError},a {@code Supplier} instance whose execution should be deferred and performed for each individualReturns a {@code Maybe} that emits a specified item.<img width="640" height="485" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.just.png" alt="">To convert any object into a {@code Maybe} that emits that object, pass that object into the{@code just} method.Merges an {@link Iterable} sequence of {@link MaybeSource} instances into a single {@link Flowable} sequence,running all {@code MaybeSource}s at once.<img width="640" height="301" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.i.png" alt=""><dd>If any of the source {@code MaybeSource}s signal a {@link Throwable} via {@code onError}, the resulting{@code Flowable} terminates with that {@code Throwable} and all other source {@code MaybeSource}s are disposed.If more than one {@code MaybeSource} signals an error, the resulting {@code Flowable} may terminate with thesignaled by source(s) after the returned {@code Flowable} has been cancelled or terminated with aUse {@link #mergeDelayError(Iterable)} to merge sources and terminate only when all source {@code MaybeSource}sthe common and resulting value typethe {@code Iterable} sequence of {@code MaybeSource} sourcesMerges a {@link Publisher} sequence of {@link MaybeSource} instances into a single {@link Flowable} sequence,<img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.p.png" alt="">Use {@link #mergeDelayError(Publisher)} to merge sources and terminate only when all source {@code MaybeSource}sthe {@code Flowable} sequence of {@code MaybeSource} sourcesrunning at most maxConcurrency {@code MaybeSource}s at once.<img width="640" height="260" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.pn.png" alt="">Use {@link #mergeDelayError(Publisher, int)} to merge sources and terminate only when all source {@code MaybeSource}sthe maximum number of concurrently running {@code MaybeSource}sFlattens a {@link MaybeSource} that emits a {@code MaybeSource} into a single {@code MaybeSource} that emits the itememitted by the nested {@code MaybeSource}, without any transformation.<img width="640" height="394" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.oo.png" alt=""><dd>The resulting {@code Maybe} emits the outer source's or the inner {@code MaybeSource}'s {@link Throwable} as is.Unlike the other {@code merge()} operators, this operator won't and can't produce a {@link CompositeException} because there isonly one possibility for the outer or the inner {@code MaybeSource} to emit an {@code onError} signal.Therefore, there is no need for a {@code mergeDelayError(MaybeSource<MaybeSource<T>>)} operator.the value type of the sources and the outputa {@code MaybeSource} that emits a {@code MaybeSource}Flattens two {@link MaybeSource}s into a single {@link Flowable}, without any transformation.<img width="640" height="279" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.2.png" alt="">You can combine items emitted by multiple {@code MaybeSource}s so that they appear as a single {@code Flowable}, byUse {@link #mergeDelayError(MaybeSource, MaybeSource)} to merge sources and terminate only when all source {@code MaybeSource}sa {@code MaybeSource} to be merged#mergeDelayError(MaybeSource, MaybeSource)Flattens three {@link MaybeSource}s into a single {@link Flowable}, without any transformation.<img width="640" height="301" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.3.png" alt="">You can combine items emitted by multiple {@code MaybeSource}s so that they appear as a single {@code Flowable}, by usingthe {@code merge} method.Use {@link #mergeDelayError(MaybeSource, MaybeSource, MaybeSource)} to merge sources and terminate only when all source {@code MaybeSource}s#mergeDelayError(MaybeSource, MaybeSource, MaybeSource)Flattens four {@link MaybeSource}s into a single {@link Flowable}, without any transformation.<img width="640" height="289" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.merge.4.png" alt="">Use {@link #mergeDelayError(MaybeSource, MaybeSource, MaybeSource, MaybeSource)} to merge sources and terminate only when all source {@code MaybeSource}s#mergeDelayError(MaybeSource, MaybeSource, MaybeSource, MaybeSource)Merges an array of {@link MaybeSource} instances into a single {@link Flowable} sequence,<img width="640" height="272" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeArray.png" alt="">Use {@link #mergeArrayDelayError(MaybeSource...)} to merge sources and terminate only when all source {@code MaybeSource}sthe array sequence of {@code MaybeSource} sources#mergeArrayDelayError(MaybeSource...)Flattens an array of {@link MaybeSource}s into one {@link Flowable}, in a way that allows a subscriber to receive allsuccessfully emitted items from each of the source {@code MaybeSource}s without being interrupted by an error<img width="640" height="422" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeArrayDelayError.png" alt="">This behaves like {@link #merge(Publisher)} except that if any of the merged {@code MaybeSource}s notify of anerror via {@link Subscriber#onError onError}, {@code mergeArrayDelayError} will refrain from propagating thaterror notification until all of the merged {@code MaybeSource}s have finished emitting items.Even if multiple merged {@code MaybeSource}s send {@code onError} notifications, {@code mergeArrayDelayError} will onlyinvoke the {@code onError} method of its subscribers once.the array of {@code MaybeSource}sFlattens an {@link Iterable} sequence of {@link MaybeSource}s into one {@link Flowable}, in a way that allows a subscriber to receive all<img width="640" height="467" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.i.png" alt="">Even if multiple merged {@code MaybeSource}s send {@code onError} notifications, {@code mergeDelayError} will onlythe {@code Iterable} of {@code MaybeSource}sFlattens a {@link Publisher} that emits {@link MaybeSource}s into one {@link Flowable}, in a way that allows a subscriber toreceive all successfully emitted items from all of the source {@code MaybeSource}s without being interrupted byan error notification from one of them or even the main {@code Publisher}.<img width="640" height="456" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.p.png" alt="">error notification until all of the merged {@code MaybeSource}s and the main {@code Publisher} have finished emitting items.in unbounded mode (i.e., no backpressure is applied to it).</dd>a {@code Publisher} that emits {@code MaybeSource}san error notification from one of them or even the main {@code Publisher} as well as limiting the total number of active {@code MaybeSource}s.<img width="640" height="429" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.pn.png" alt="">This behaves like {@link #merge(Publisher, int)} except that if any of the merged {@code MaybeSource}s notify of an<p>History: 2.1.9 - experimentalthe maximum number of active inner {@code MaybeSource}s to be merged at a timeFlattens two {@link MaybeSource}s into one {@link Flowable}, in a way that allows a subscriber to receive all<img width="640" height="414" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.2.png" alt="">This behaves like {@link #merge(MaybeSource, MaybeSource)} except that if any of the merged {@code MaybeSource}spropagating that error notification until all of the merged {@code MaybeSource}s have finished emitting items.Even if both merged {@code MaybeSource}s send {@code onError} notifications, {@code mergeDelayError} will onlyFlattens three {@link MaybeSource} into one {@link Flowable}, in a way that allows a subscriber to receive allsuccessfully emitted items from all of the source {@code MaybeSource}s without being interrupted by an error<img width="640" height="467" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.3.png" alt="">This behaves like {@link #merge(MaybeSource, MaybeSource, MaybeSource)} except that if any of the merged{@code MaybeSource}s notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError} will refrainfrom propagating that error notification until all of the merged {@code MaybeSource}s have finished emittingFlattens four {@link MaybeSource}s into one {@link Flowable}, in a way that allows a subscriber to receive all<img width="640" height="461" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeDelayError.4.png" alt="">This behaves like {@link #merge(MaybeSource, MaybeSource, MaybeSource, MaybeSource)} except that if any ofthe merged {@code MaybeSource}s notify of an error via {@link Subscriber#onError onError}, {@code mergeDelayError}will refrain from propagating that error notification until all of the merged {@code MaybeSource}s have finishedReturns a {@code Maybe} that never sends any items or notifications to a {@link MaybeObserver}.This {@code Maybe} is useful primarily for testing purposes.the type of items (not) emitted by the {@code Maybe}Returns a {@link Single} that emits a {@link Boolean} value that indicates whether two {@link MaybeSource} sequences are thesame by comparing the items emitted by each {@code MaybeSource} pairwise.<img width="640" height="187" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.sequenceEqual.png" alt="">the first {@code MaybeSource} to comparethe second {@code MaybeSource} to comparethe type of items emitted by each {@code MaybeSource}Returns a {@link Single} that emits a {@link Boolean} value that indicates whether two {@link MaybeSource}s are thesame by comparing the items emitted by each {@code MaybeSource} pairwise based on the results of a specified<img width="640" height="247" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.sequenceEqual.f.png" alt="">a function used to compare items emitted by each {@code MaybeSource}Switches between {@link MaybeSource}s emitted by the source {@link Publisher} whenevera new {@code MaybeSource} is emitted, disposing the previously running {@code MaybeSource},exposing the success items as a {@link Flowable} sequence.<img width="640" height="521" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchOnNext.png" alt=""><dd>The {@code sources} {@code Publisher} is consumed in an unbounded manner (requesting {@link Long#MAX_VALUE}).The returned {@code Flowable} respects the backpressure from the downstream.</dd>or the currently running {@code MaybeSource}, disposing the rest. Late errors arethe element type of the {@code MaybeSource}sthe {@code Publisher} sequence of inner {@code MaybeSource}s to switch betweenexposing the success items as a {@link Flowable} sequence and delaying all errors from<img width="640" height="423" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchOnNextDelayError.png" alt=""><dd>The returned {@code Flowable} collects all errors emitted by either the {@code sources}{@code Publisher} or any inner {@code MaybeSource} and emits them as a {@link CompositeException}Returns a {@code Maybe} that emits {@code 0L} after a specified delay.<img width="640" height="391" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timer.png" alt="">Returns a {@code Maybe} that emits {@code 0L} after a specified delay on a specified {@link Scheduler}.<img width="640" height="392" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timer.s.png" alt=""><strong>Advanced use only:</strong> creates a {@code Maybe} instance withoutany safeguards by using a callback that is called with a {@link MaybeObserver}.<img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.unsafeCreate.png" alt="">the function that is called with the subscribing {@code MaybeObserver}if {@code onSubscribe} is a {@code Maybe}Constructs a {@code Maybe} that creates a dependent resource object which is disposed of when thegenerated {@link MaybeSource} terminates or the downstream calls dispose().<img width="640" height="378" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.using.png" alt="">the element type of the generated {@code MaybeSource}the factory function to create a resource object that depends on the {@code Maybe}the factory function to create a {@code MaybeSource}Constructs a {@code Maybe} that creates a dependent resource object which is disposed first ({code eager == true})when the generated {@link MaybeSource} terminates or the downstream disposes; or after ({code eager == false}).<img width="640" height="323" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.using.b.png" alt="">Eager disposal is particularly appropriate for a synchronous {@code Maybe} that reuses resources. {@code disposeAction} willonly be called once per subscription.or just before the emission of a terminal event ({@code onSuccess}, {@code onComplete} or {@code onError}).or just after the emission of a terminal event ({@code onSuccess}, {@code onComplete} or {@code onError}).Wraps a {@link MaybeSource} instance into a new {@code Maybe} instance if not already a {@code Maybe}instance.<img width="640" height="232" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.wrap.png" alt="">the new wrapped or cast {@code Maybe} instanceReturns a {@code Maybe} that emits the results of a specified combiner function applied to combinations ofitems emitted, in sequence, by an {@link Iterable} of other {@link MaybeSource}s.<img width="640" height="341" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.zip.i.png" alt="">This operator terminates eagerly if any of the source {@code MaybeSource}s signal an {@code onError} or {@code onComplete}. Thisalso means it is possible some sources may not get subscribed to at all.an {@code Iterable} of source {@code MaybeSource}sa function that, when applied to an item emitted by each of the source {@code MaybeSource}s, results inan item that will be emitted by the resulting {@code Maybe}if {@code zipper} or {@code sources} is {@code null}two items emitted, in sequence, by two other {@link MaybeSource}s.<img width="640" height="434" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.zip.n.png" alt="">the first source {@code MaybeSource}a second source {@code MaybeSource}a function that, when applied to an item emitted by each of the source {@code MaybeSource}s, resultsin an item that will be emitted by the resulting {@code Maybe}three items emitted, in sequence, by three other {@link MaybeSource}s.a third source {@code MaybeSource}four items emitted, in sequence, by four other {@link MaybeSource}s.a fourth source {@code MaybeSource}five items emitted, in sequence, by five other {@link MaybeSource}s.a fifth source {@code MaybeSource}six items emitted, in sequence, by six other {@link MaybeSource}s.a sixth source {@code MaybeSource}{@code source4}, {@code source5}, {@code source6} or {@code zipper} is {@code null}seven items emitted, in sequence, by seven other {@link MaybeSource}s.a seventh source {@code MaybeSource}eight items emitted, in sequence, by eight other {@link MaybeSource}s.an eighth source {@code MaybeSource}nine items emitted, in sequence, by nine other {@link MaybeSource}s.a ninth source {@code MaybeSource}{@code source7}, {@code source8}, {@code source9} or {@code zipper} is {@code null}items emitted, in sequence, by an array of other {@link MaybeSource}s.<img width="640" height="340" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.zipArray.png" alt=""><p>This operator terminates eagerly if any of the source {@code MaybeSource}s signal an {@code onError} or {@code onComplete}. Thisan array of source {@code MaybeSource}s ------------------------------------------------------------------ Instance methodsMirrors the {@link MaybeSource} (current or provided) that first signals an event.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ambWith.png" alt="">a {@code MaybeSource} competing to react first. A subscription to this provided source will occur aftersubscribing to the current source.Waits in a blocking fashion until the current {@code Maybe} signals a success value (which is returned),{@code null} if completed or an exception (which is propagated).<img width="640" height="285" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingGet.png" alt=""><dd>{@code blockingGet} does not operate by default on a particular {@link Scheduler}.</dd>the success valuedefaultValue if completed or an exception (which is propagated).<img width="640" height="297" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingGet.v.png" alt="">the default item to return if this {@code Maybe} is emptyif {@code defaultValue} is {@code null}Subscribes to the current {@code Maybe} and <em>blocks the current thread</em> until it terminates.<img width="640" height="238" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.png" alt=""><dd>If the current {@code Maybe} signals an error,Subscribes to the current {@code Maybe} and calls given {@code onSuccess} callback on the <em>current thread</em><img width="640" height="245" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.c.png" alt=""><dd>If either the current {@code Maybe} signals an error or {@code onSuccess} throws,the {@link Consumer} to call if the current {@code Maybe} succeedsif {@code onSuccess} is {@code null}Subscribes to the current {@code Maybe} and calls the appropriate callback on the <em>current thread</em><img width="640" height="256" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.cc.png" alt=""><dd>If either {@code onSuccess} or {@code onError} throw, the {@link Throwable} is routed to thethe {@code Consumer} to call if the current {@code Maybe} signals an errorif {@code onSuccess} or {@code onError} is {@code null}<img width="640" height="251" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.cca.png" alt=""><dd>If either {@code onSuccess}, {@code onError} or {@code onComplete} throw, the {@link Throwable} is routed to thethe {@link Action} to call if the current {@code Maybe} completes without a valueif {@code onSuccess}, {@code onError} or {@code onComplete} is {@code null}Subscribes to the current {@code Maybe} and calls the appropriate {@link MaybeObserver} method on the <em>current thread</em>.<img width="640" height="398" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingSubscribe.o.png" alt=""><dd>An {@code onError} signal is delivered to the {@link MaybeObserver#onError(Throwable)} method.If any of the {@code MaybeObserver}'s methods throw, the {@link RuntimeException} is propagated to the caller of this method.the {@code MaybeObserver} to call methods on the current threadReturns a {@code Maybe} that subscribes to this {@code Maybe} lazily, caches its eventand replays it, to all the downstream subscribers.<img width="640" height="244" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.cache.png" alt="">a single subscription towards this {@code Maybe}.<em>Note:</em> You sacrifice the ability to dispose the origin when you use the {@code cache}.Casts the success value of the current {@code Maybe} into the target type or signals a{@link ClassCastException} if not compatible.<img width="640" height="318" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.cast.png" alt="">the type token to use for casting the success result from the current {@code Maybe}Transform a {@code Maybe} by applying a particular {@link MaybeTransformer} function to it.<img width="640" height="615" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.compose.png" alt="">This method operates on the {@code Maybe} itself whereas {@link #lift} operates on the {@code Maybe}'s {@link MaybeObserver}s.If the operator you are creating is designed to act on the individual item emitted by a {@code Maybe}, use{@link #lift}. If your operator is designed to transform the current {@code Maybe} as a whole (for instance, byapplying a particular set of existing RxJava operators to it) use {@code compose}.the value type of the {@code Maybe} returned by the transformer functionReturns a {@code Maybe} that is based on applying a specified function to the item emitted by the current {@code Maybe},where that function returns a {@link MaybeSource}.<img width="640" height="216" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatMap.png" alt="">Note that flatMap and concatMap for {@code Maybe} is the same operation.a function that, when applied to the item emitted by the current {@code Maybe}, returns a {@code MaybeSource}Returns a {@link Completable} that completes based on applying a specified function to the item emitted by thecurrent {@code Maybe}, where that function returns a {@code Completable}.<img width="640" height="304" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatMapCompletable.png" alt="">This operator is an alias for {@link #flatMapCompletable(Function)}.a function that, when applied to the item emitted by the current {@code Maybe}, returns a{@code Completable}Returns a {@code Maybe} based on applying a specified function to the item emitted by thecurrent {@code Maybe}, where that function returns a {@link Single}.When this {@code Maybe} just completes the resulting {@code Maybe} completes as well.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatMapSingle.png" alt="">This operator is an alias for {@link #flatMapSingle(Function)}.{@code Single}Returns a {@link Flowable} that emits the items emitted from the current {@code Maybe}, then the {@code other} {@link MaybeSource}, one after<img width="640" height="172" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatWith.png" alt="">a {@code MaybeSource} to be concatenated after the currentReturns a {@link Single} that emits a {@link Boolean} that indicates whether the current {@code Maybe} emitted a<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.contains.o.png" alt="">the item to search for in the emissions from the current {@code Maybe}, not {@code null}Returns a {@link Single} that counts the total number of items emitted (0 or 1) by the current {@code Maybe} and emits<img width="640" height="434" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.count.png" alt="">Returns a {@link Single} that emits the item emitted by the current {@code Maybe} or a specified default itemif the current {@code Maybe} is empty.<img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.defaultIfEmpty.png" alt="">the item to emit if the current {@code Maybe} emits no itemsMaps the {@link Notification} success value of the current {@code Maybe} back into normal{@code onSuccess}, {@code onError} or {@code onComplete} signals.<img width="640" height="268" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.dematerialize.png" alt="">Regular {@code onError} or {@code onComplete} signals from the current {@code Maybe} are passed along to the downstream.Maybe.just(Notification.createOnNext(1))the function called with the success item and shouldreturn a {@code Notification} instance.#materialize()Returns a {@code Maybe} that signals the events emitted by the current {@code Maybe} shifted forward in time by aspecified delay.An error signal will not be delayed.<img width="640" height="434" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.t.png" alt="">the {@link TimeUnit} in which {@code time} is defined<img width="640" height="340" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.tb.png" alt="">if {@code true}, both success and error signals are delayed. if {@code false}, only success signals are delayed.<img width="640" height="434" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.ts.png" alt=""><dd>you specify the {@link Scheduler} where the non-blocking wait and emission happens</dd>specified delay running on the specified {@link Scheduler}.<img width="640" height="352" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.tsb.png" alt=""><dd>you specify which {@code Scheduler} this operator will use.</dd>Delays the emission of this {@code Maybe} until the given {@link Publisher} signals an item or completes.<img width="640" height="175" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.p.png" alt=""><dd>The {@code delayIndicator} is consumed in an unbounded manner but is cancelled afterthe first item it produces.</dd>the {@code Publisher} that gets subscribed to when this {@code Maybe} signals an event and thatsignal is emitted when the {@code Publisher} signals an item or completesif {@code delayIndicator} is {@code null}Returns a {@code Maybe} that delays the subscription to this {@code Maybe}until the other {@link Publisher} emits an element or completes normally.<img width="640" height="214" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delaySubscription.p.png" alt=""><dd>The {@code Publisher} source is consumed in an unbounded fashion (without applying backpressure).</dd>Returns a {@code Maybe} that delays the subscription to the current {@code Maybe} by a given amount of time.<img width="640" height="471" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delaySubscription.t.png" alt="">#delaySubscription(long, TimeUnit, Scheduler)Returns a {@code Maybe} that delays the subscription to the current {@code Maybe} by a given amount of time,<img width="640" height="420" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delaySubscription.ts.png" alt="">Calls the specified {@link Consumer} with the success item after this item has been emitted to the downstream.<p>Note that the {@code onAfterSuccess} action is shared between subscriptions and as such<img width="640" height="527" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doAfterSuccess.png" alt=""><dd>{@code doAfterSuccess} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Consumer} that will be called after emitting an item from upstream to the downstreamif {@code onAfterSuccess} is {@code null}Registers an {@link Action} to be called when this {@code Maybe} invokes either{@link MaybeObserver#onComplete onSuccess},{@link MaybeObserver#onComplete onComplete} or {@link MaybeObserver#onError onError}.<img width="640" height="249" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doAfterTerminate.png" alt="">an {@code Action} to be invoked when the current {@code Maybe} finishes onSubscribe onSuccess onError onComplete disposeCalls the specified action after this {@code Maybe} signals {@code onSuccess}, {@code onError} or {@code onComplete} or gets disposed by<img width="640" height="247" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doFinally.png" alt="">the action called when this {@code Maybe} terminates or gets disposedCalls the shared {@link Action} if a {@link MaybeObserver} subscribed to the current {@code Maybe}disposes the common {@link Disposable} it received via {@code onSubscribe}.<img width="640" height="277" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnDispose.png" alt="">the action called when the subscription is disposed (onSuccess | onError | onComplete) afterInvokes an {@link Action} just before the current {@code Maybe} calls {@code onComplete}.<img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.m.v3.png" alt="">the action to invoke when the current {@code Maybe} calls {@code onComplete}the new {@code Maybe} with the side-effecting behavior applied (onSuccess | onError | onComplete)Calls the shared {@link Consumer} with the error sent via {@code onError} for each{@link MaybeObserver} that subscribes to the current {@code Maybe}.<img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.m.v3.png" alt="">the consumer called with the success value of {@code onError}Calls the given {@code onEvent} callback with the (success value, {@code null}) for an {@code onSuccess}, ({@code null}, throwable) foran {@code onError} or ({@code null}, {@code null}) for an {@code onComplete} signal from this {@code Maybe} before delivering saidsignal to the downstream.<img width="640" height="297" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnEvent.png" alt="">The exceptions thrown from the callback will override the event so the downstream receives theerror instead of the original signal.the callback to call with the success value or the exception, whichever is not {@code null}Calls the appropriate {@code onXXX} method (shared between all {@link MaybeObserver}s) for the lifecycle events of<img width="640" height="183" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnLifecycle.png" alt="">a {@link Consumer} called with the {@link Disposable} sent via {@link MaybeObserver#onSubscribe(Disposable)}Calls the shared {@link Consumer} with the {@link Disposable} sent through the {@code onSubscribe} for each<img width="640" height="506" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnSubscribe.png" alt="">the {@code Consumer} called with the {@code Disposable} sent via {@code onSubscribe}Returns a {@code Maybe} instance that calls the given onTerminate callbackjust before this {@code Maybe} completes normally or with an exception.<img width="640" height="249" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnTerminate.png" alt=""><p>History: 2.2.7 - experimentalthe action to invoke when the consumer calls {@code onComplete} or {@code onError}Calls the shared {@link Consumer} with the success value sent via {@code onSuccess} for each<img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSuccess.m.v3.png" alt=""><dd>{@code doOnSuccess} does not operate by default on a particular {@link Scheduler}.</dd>the {@code Consumer} called with the success value of the upstreamFilters the success item of the {@code Maybe} via a predicate function and emitting it if the predicatereturns {@code true}, completing otherwise.<img width="640" height="291" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.filter.png" alt="">a function that evaluates the item emitted by the current {@code Maybe}, returning {@code true}<img width="640" height="357" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.png" alt=""><p>Note that flatMap and concatMap for {@code Maybe} is the same operation.Maps the {@code onSuccess}, {@code onError} or {@code onComplete} signals of the current {@code Maybe} into a {@link MaybeSource} and emits that{@code MaybeSource}'s signals.<img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.mmm.png" alt="">a function that returns a {@code MaybeSource} to merge for the {@code onSuccess} item emitted by this {@code Maybe}a function that returns a {@code MaybeSource} to merge for an {@code onError} notification from this {@code Maybe}a function that returns a {@code MaybeSource} to merge for an {@code onComplete} notification this {@code Maybe}if {@code onSuccessMapper}, {@code onErrorMapper} or {@code onCompleteSupplier} is {@code null}Returns a {@code Maybe} that emits the results of a specified function to the pair of values emitted by thecurrent {@code Maybe} and a specified mapped {@link MaybeSource}.<img width="640" height="268" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.combiner.png" alt="">the type of items emitted by the {@code MaybeSource} returned by the {@code mapper} functionthe type of items emitted by the resulting {@code Maybe}a function that returns a {@code MaybeSource} for the item emitted by the current {@code Maybe}a function that combines one item emitted by each of the source and collection {@code MaybeSource} andreturns an item to be emitted by the resulting {@code MaybeSource}Maps the success value of the current {@code Maybe} into an {@link Iterable} and emits its items as a{@link Flowable} sequence.<img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsFlowable.png" alt=""><dd>{@code flattenAsFlowable} does not operate by default on a particular {@link Scheduler}.</dd>the type of item emitted by the inner {@code Iterable}current {@code Maybe}#flattenStreamAsFlowable(Function)Maps the success value of the current {@code Maybe} into an {@link Iterable} and emits its items as an{@link Observable} sequence.<img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsObservable.png" alt=""><dd>{@code flattenAsObservable} does not operate by default on a particular {@link Scheduler}.</dd>Returns an {@link Observable} that is based on applying a specified function to the item emitted by the current {@code Maybe},where that function returns an {@link ObservableSource}.<img width="640" height="302" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapObservable.png" alt=""><dd>{@code flatMapObservable} does not operate by default on a particular {@link Scheduler}.</dd>a function that, when applied to the item emitted by the current {@code Maybe}, returns an {@code ObservableSource}Returns a {@link Flowable} that emits items based on applying a specified function to the item emitted by thecurrent {@code Maybe}, where that function returns a {@link Publisher}.<img width="640" height="312" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapPublisher.png" alt=""><dd>The returned {@code Flowable} honors the downstream backpressure.</dd><dd>{@code flatMapPublisher} does not operate by default on a particular {@link Scheduler}.</dd><img width="640" height="357" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingle.png" alt=""><img width="640" height="303" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapCompletable3.png" alt="">Hides the identity of this {@code Maybe} and its {@link Disposable}.<img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.hide.png" alt=""><p>Allows preventing certain identity-basedReturns a {@link Completable} that ignores the item emitted by the current {@code Maybe} and only calls {@code onComplete} or {@code onError}.<img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ignoreElement.png" alt=""><dd>{@code ignoreElement} does not operate by default on a particular {@link Scheduler}.</dd>Returns a {@link Single} that emits {@code true} if the current {@code Maybe} is empty, otherwise {@code false}.<img width="640" height="444" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.isEmpty.png" alt="">Returns a {@code Maybe} which, when subscribed to, invokes the {@link MaybeOperator#apply(MaybeObserver) apply(MaybeObserver)} methodof the provided {@link MaybeOperator} for each individual downstream {@code Maybe} and allows theinsertion of a custom operator by accessing the downstream's {@link MaybeObserver} during this subscription phaseand providing a new {@code MaybeObserver}, containing the custom operator's intended business logic, that will be<img width="640" height="352" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.lift.png" alt="">Generally, such a new {@code MaybeObserver} will wrap the downstream's {@code MaybeObserver} and forwards the{@code onSuccess}, {@code onError} and {@code onComplete} events from the upstream directly or according to the// Step 1: Create the consumer type that will be returned by the MaybeOperator.apply():public final class CustomMaybeObserver&lt;T&gt; implements MaybeObserver&lt;T&gt;, Disposable {// The downstream's MaybeObserver that will receive the onXXX eventsfinal MaybeObserver&lt;? super String&gt; downstream;public CustomMaybeObserver(MaybeObserver&lt;? super String&gt; downstream) {public void onSuccess(T item) {downstream.onSuccess(str);// Maybe is expected to produce one of the onXXX events only// Step 2: Create a class that implements the MaybeOperator interface andfinal class CustomMaybeOperator&lt;T&gt; implements MaybeOperator&lt;String&gt; {public MaybeObserver&lt;? super String&gt; apply(MaybeObserver&lt;? super T&gt; upstream) {return new CustomMaybeObserver&lt;T&gt;(upstream);Maybe.just(5).lift(new CustomMaybeOperator&lt;Integer&gt;()).assertResult("5");Maybe.just(15)an additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Maybe}class and creating a {@link MaybeTransformer} with it is recommended.requires a non-{@code null} {@code MaybeObserver} instance to be returned, which is then unconditionally subscribed tothe current {@code Maybe}. For example, if the operator decided there is no reason to subscribe to thereturn a {@code MaybeObserver} that should immediately dispose the upstream's {@link Disposable} in its{@code onSubscribe} method. Again, using a {@code MaybeTransformer} and extending the {@code Maybe} is{@code MaybeOperator} may use a {@code Scheduler} to support its own asynchronous behavior.</dd>the {@code MaybeOperator} that receives the downstream's {@code MaybeObserver} and should returna {@code MaybeObserver} with custom behavior to be used as the consumer for the current{@code Maybe}.if {@code lift} is {@code null}#compose(MaybeTransformer)Returns a {@code Maybe} that applies a specified function to the item emitted by the current {@code Maybe} andemits the result of this function application.<img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.map.png" alt="">a function to apply to the item emitted by the {@code Maybe}Maps the signal types of this {@code Maybe} into a {@link Notification} of the same kindand emits it as a {@link Single}'s {@code onSuccess} value to downstream.Flattens this {@code Maybe} and another {@link MaybeSource} into a single {@link Flowable}, without any transformation.<img width="640" height="218" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeWith.png" alt="">You can combine items emitted by multiple {@code Maybe}s so that they appear as a single {@code Flowable}, byWraps a {@code Maybe} to emit its item (or notify of its error) on a specified {@link Scheduler},asynchronously.<img width="640" height="183" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.observeOn.png" alt="">the {@code Scheduler} to notify subscribers onthe new {@code Maybe} instance that its subscribers are notified on the specified{@code Scheduler}Filters the items emitted by the current {@code Maybe}, only emitting its success value if thatis an instance of the supplied {@link Class}.<img width="640" height="291" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ofType.png" alt="">the class type to filter the items emitted by the current {@code Maybe}<img width="640" height="731" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.to.png" alt="">the function that receives the current {@code Maybe} instance and returns a valueConverts this {@code Maybe} into a backpressure-aware {@link Flowable} instance composing cancellationthrough.<img width="640" height="346" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toFlowable.png" alt=""><dd>The returned {@code Flowable} honors the backpressure of the downstream.</dd>Returns a {@link Future} representing the single value emitted by the current {@code Maybe}or {@code null} if the current {@code Maybe} is empty.<img width="640" height="292" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Maybe.toFuture.png" alt="">Cancelling the {@code Future} will cancel the subscription to the current {@code Maybe}.Converts this {@code Maybe} into an {@link Observable} instance composing disposal<img width="640" height="346" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toObservable.png" alt="">Converts this {@code Maybe} into a {@link Single} instance composing disposalthrough and turning an empty {@code Maybe} into a signal of {@link NoSuchElementException}.<img width="640" height="361" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toSingle.png" alt="">#defaultIfEmpty(Object)Returns a {@code Maybe} instance that if this {@code Maybe} emits an error, it will emit an {@code onComplete}<img width="640" height="372" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorComplete.png" alt="">Returns a {@code Maybe} instance that if this {@code Maybe} emits an error and the predicate returns<img width="640" height="220" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorComplete.f.png" alt="">Resumes the flow with the given {@link MaybeSource} when the current {@code Maybe} fails instead of<img width="640" height="298" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorResumeWith.png" alt="">the next {@code MaybeSource} that will take over if the current {@code Maybe} encountersResumes the flow with a {@link MaybeSource} returned for the failure {@link Throwable} of the current {@code Maybe} by a<img width="640" height="298" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorResumeNext.png" alt="">a function that returns a {@code MaybeSource} that will take over if the current {@code Maybe} encounters{@code Maybe} instead of signaling the error via {@code onError}.<img width="640" height="377" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorReturn.png" alt="">the current {@code Maybe} signals an {@code onError} eventEnds the flow with the given success item when the current {@code Maybe} fails instead of signaling the error via {@code onError}.<img width="640" height="377" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onErrorReturnItem.png" alt="">the value that is emitted as {@code onSuccess} in case the current {@code Maybe} signals an {@code onError}Nulls out references to the upstream producer and downstream {@link MaybeObserver} if<img width="640" height="263" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.onTerminateDetach.png" alt="">the sequence is terminated or downstream calls {@code dispose()}Returns a {@link Flowable} that repeats the sequence of items emitted by the current {@code Maybe} indefinitely.<img width="640" height="276" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeat.png" alt="">Returns a {@link Flowable} that repeats the sequence of items emitted by the current {@code Maybe} at most<img width="640" height="294" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeat.n.png" alt=""><dd>This operator honors downstream backpressure.</dd>the number of times the current {@code Maybe} items are repeated, a count of 0 will yield an emptyReturns a {@link Flowable} that repeats the sequence of items emitted by the current {@code Maybe} until<img width="640" height="329" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeatUntil.png" alt="">Returns a {@link Flowable} that emits the same values as the current {@code Maybe} with the exception of ancall {@code onComplete} or {@code onError} on the child observer. Otherwise, this operator willresubscribe to the current {@code Maybe}.<img width="640" height="562" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeatWhen.png" alt=""><dd>The operator honors downstream backpressure and expects the source {@code Publisher} to honor backpressure as well.Returns a {@code Maybe} that mirrors the current {@code Maybe}, resubscribing to it if it calls {@code onError}<img width="640" height="393" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.png" alt="">If the current {@code Maybe} calls {@link MaybeObserver#onError}, this operator will resubscribe to the current{@code Maybe} rather than propagating the {@code onError} call.<img width="640" height="230" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.f.png" alt=""><img width="640" height="329" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.n.png" alt="">{@code Maybe} for a maximum of {@code count} resubscriptions rather than propagating thethe number of times to resubscribe if the current {@code Maybe} failsRetries at most {@code times} or until the predicate returns {@code false}, whichever happens first.<img width="640" height="259" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.nf.png" alt="">Retries the current {@code Maybe} if it fails and the predicate returns {@code true}.<img width="640" height="240" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.g.png" alt=""><img width="640" height="285" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retryUntil.png" alt="">Returns a {@code Maybe} that emits the same values as the current {@code Maybe} with the exception of an{@link Throwable} item to the {@link Flowable} provided as an argument to the {@code notificationHandler}function. If the returned {@link Publisher} calls {@code onComplete} or {@code onError} then {@code retry} will call{@code onComplete} or {@code onError} on the child subscription. Otherwise, this operator will<img width="640" height="405" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retryWhen.png" alt="">Maybe.create((MaybeEmitter&lt;? super String&gt; s) -&gt; {return attempts.zipWith(Publisher.range(1, 3), (n, i) -&gt; i).flatMap(i -&gt; {the operator is asynchronous, signalling {@code onNext} followed by {@code onComplete} immediately mayMaybe.timer(1, TimeUnit.SECONDS).blockingGet();Wraps the given {@link MaybeObserver}, catches any {@link RuntimeException}s thrown by its{@link MaybeObserver#onSubscribe(Disposable)}, {@link MaybeObserver#onSuccess(Object)},{@link MaybeObserver#onError(Throwable)} or {@link MaybeObserver#onComplete()} methodsand routes those to the global error handler via {@link RxJavaPlugins#onError(Throwable)}.By default, the {@code Maybe} protocol forbids the {@code onXXX} methods to throw, but some{@code MaybeObserver} implementation may do it anyway, causing undefined behavior in thethe potentially misbehaving {@code MaybeObserver}#subscribe(Consumer,Consumer, Action)Returns a {@link Flowable} which first runs the other {@link CompletableSource}then the current {@code Maybe} if the other completed normally.<img width="640" height="268" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.c.png" alt="">then the current {@code Maybe} if the other succeeded normally.<img width="640" height="237" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.s.png" alt="">then the current {@code Maybe} if the other succeeded or completed normally.<img width="640" height="178" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.m.png" alt="">of the other {@link ObservableSource} then runs the current {@code Maybe}.<img width="640" height="179" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.o.png" alt="">of the other {@link Publisher} then runs the current {@code Maybe}.<img width="640" height="179" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.startWith.p.png" alt="">Subscribes to a {@code Maybe} and ignores {@code onSuccess} and {@code onComplete} emissions.If the {@code Maybe} emits an error, it is wrapped into anthe new {@link Disposable} instance that can be used for disposing the subscription at any timeSubscribes to a {@code Maybe} and provides a callback to handle the items it emits.the {@code Consumer<T>} you have designed to accept a success value from the {@code Maybe}Subscribes to a {@code Maybe} and provides callbacks to handle the items it emits and any error{@code Maybe}if {@code onSuccess} is {@code null}, orSubscribes to a {@code Maybe} and provides callbacks to handle the items it emits and any error orif {@code onSuccess}, {@code onError} or{@code onComplete} is {@code null}Implement this method in subclasses to handle the incoming {@link MaybeObserver}s.<p>There is no need to call any of the plugin hooks on the current {@code Maybe} instance orthe {@code MaybeObserver}; all hooks and basic safeguards have beenapplied by {@link #subscribe(MaybeObserver)} before this method gets called.the {@code MaybeObserver} to handle, not {@code null}Asynchronously subscribes subscribers to this {@code Maybe} on the specified {@link Scheduler}.<img width="640" height="753" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.subscribeOn.png" alt="">Subscribes a given {@link MaybeObserver} (subclass) to this {@code Maybe} and returns the given{@code MaybeObserver} as is.Maybe&lt;Integer&gt; source = Maybe.just(1);DisposableMaybeObserver&lt;Integer&gt; ds = new DisposableMaybeObserver&lt;&gt;() {the type of the {@code MaybeObserver} to use and returnthe {@code MaybeObserver} (subclass) to use and return, not {@code null}Returns a {@code Maybe} that emits the items emitted by the current {@code Maybe} or the items of an alternate{@link MaybeSource} if the current {@code Maybe} is empty.<img width="640" height="222" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchIfEmpty.m.png" alt="">the alternate {@code MaybeSource} to subscribe to if the main does not emit any itemsReturns a {@link Single} that emits the items emitted by the current {@code Maybe} or the item of an alternate{@link SingleSource} if the current {@code Maybe} is empty.<img width="640" height="312" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchIfEmpty.s.png" alt=""><p>History: 2.1.4 - experimentalthe alternate {@code SingleSource} to subscribe to if the main does not emit any itemsReturns a {@code Maybe} that emits the items emitted by the current {@code Maybe} until a second {@link MaybeSource}<img width="640" height="219" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.takeUntil.m.png" alt="">the {@code MaybeSource} whose first emitted item will cause {@code takeUntil} to stop emitting itemsfrom the current {@code Maybe}Returns a {@code Maybe} that emits the item emitted by the current {@code Maybe} until a second {@link Publisher}<img width="640" height="199" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.takeUntil.p.png" alt=""><dd>The {@code Publisher} is consumed in an unbounded fashion and is cancelled after the first itememitted.</dd>from the source {@code Publisher}Measures the time (in milliseconds) between the subscription and success item emissionof the current {@code Maybe} and signals it as a tuple ({@link Timed})success value.<img width="640" height="352" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeInterval.png" alt="">If the current {@code Maybe} is empty or fails, the resulting {@code Maybe} willpass along the signals to the downstream. To measure the time to termination,use {@link #materialize()} and apply {@link Single#timeInterval()}.<dd>{@code timeInterval} uses the {@code computation} {@link Scheduler}for determining the current time upon subscription and upon receiving thesuccess item from the current {@code Maybe}.</dd><img width="640" height="355" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeInterval.s.png" alt="">use {@link #materialize()} and apply {@link Single#timeInterval(Scheduler)}.<dd>{@code timeInterval} uses the provided {@link Scheduler}the {@code Scheduler} used for providing the current timeMeasures the time between the subscription and success item emissionuse {@link #materialize()} and apply {@link Single#timeInterval(TimeUnit)}.the time unit for measurementuse {@link #materialize()} and apply {@link Single#timeInterval(TimeUnit, Scheduler)}.Combines the success value from the current {@code Maybe} with the current time (in milliseconds) ofits reception, using the {@code computation} {@link Scheduler} as time source,then signals them as a {@link Timed} instance.<img width="640" height="352" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timestamp.png" alt="">use {@link #materialize()} and apply {@link Single#timestamp()}.<dd>{@code timestamp} uses the {@code computation} {@code Scheduler}for determining the current time upon receiving theits reception, using the given {@link Scheduler} as time source,<img width="640" height="355" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timestamp.s.png" alt="">use {@link #materialize()} and apply {@link Single#timestamp(Scheduler)}.<dd>{@code timestamp} uses the provided {@code Scheduler}Combines the success value from the current {@code Maybe} with the current time ofthen signals it as a {@link Timed} instance.use {@link #materialize()} and apply {@link Single#timestamp(TimeUnit)}.<dd>{@code timestamp} uses the {@code computation} {@code Scheduler},use {@link #materialize()} and apply {@link Single#timestamp(TimeUnit, Scheduler)}.<dd>{@code timestamp} uses the provided {@code Scheduler},which is used for determining the current time upon receiving theReturns a {@code Maybe} that mirrors the current {@code Maybe} but applies a timeout policy for each emittedthe resulting {@code Maybe} terminates and notifies {@link MaybeObserver}s of a {@link TimeoutException}.<img width="640" height="261" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.t.png" alt="">the current {@code Maybe} is disposed and resulting {@code Maybe} begins instead to mirror a fallback {@link MaybeSource}.<img width="640" height="226" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.tm.png" alt="">the fallback {@code MaybeSource} to use in case of a timeoutstarting from its predecessor, the current {@code Maybe} is disposed and resulting {@code Maybe} begins insteadto mirror a fallback {@link MaybeSource}.<img width="640" height="227" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.tsm.png" alt="">the {@code MaybeSource} to use as the fallback in case of a timeoutif {@code fallback}, {@code unit} or {@code scheduler} is {@code null}item, where this policy is governed on a specified {@link Scheduler}. If the next item isn't emitted within thespecified timeout duration starting from its predecessor, the resulting {@code Maybe} terminates andnotifies {@link MaybeObserver}s of a {@link TimeoutException}.<img width="640" height="261" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.ts.png" alt="">If the current {@code Maybe} didn't signal an event before the {@code timeoutIndicator} {@link MaybeSource} signals, a{@link TimeoutException} is signaled instead.<img width="640" height="235" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.m.png" alt=""><dd>{@code timeout} does not operate by default on a particular {@link Scheduler}.</dd>the value type of thethe {@code MaybeSource} that indicates the timeout by signaling {@code onSuccess}or {@code onComplete}.if {@code timeoutIndicator} is {@code null}If the current {@code Maybe} didn't signal an event before the {@code timeoutIndicator} {@link MaybeSource} signals,the current {@code Maybe} is disposed and the {@code fallback} {@code MaybeSource} subscribed toas a continuation.<img width="640" height="194" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.mm.png" alt="">the {@code MaybeSource} that is subscribed to if the current {@code Maybe} times outif {@code timeoutIndicator} or {@code fallback} is {@code null}If the current {@code Maybe} source didn't signal an event before the {@code timeoutIndicator} {@link Publisher} signals, a<img width="640" height="212" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.p.png" alt=""><dd>The {@code timeoutIndicator} {@code Publisher} is consumed in an unbounded manner andis cancelled after its first item.</dd>the {@code Publisher} that indicates the timeout by signaling {@code onSuccess}If the current {@code Maybe} didn't signal an event before the {@code timeoutIndicator} {@link Publisher} signals,the current {@code Maybe} is disposed and the {@code fallback} {@link MaybeSource} subscribed to<img width="640" height="169" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.pm.png" alt="">or {@code onComplete}Returns a {@code Maybe} which makes sure when a {@link MaybeObserver} disposes the {@link Disposable},that call is propagated up on the specified {@link Scheduler}.<img width="640" height="693" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.unsubscribeOn.png" alt="">the target scheduler where to execute the disposalWaits until this and the other {@link MaybeSource} signal a success value then applies the given {@link BiFunction}to those values and emits the {@code BiFunction}'s resulting value to downstream.<img width="640" height="451" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.zipWith.png" alt=""><p>If either this or the other {@code MaybeSource} is empty or signals an error, the resulting {@code Maybe} willterminate immediately and dispose the other source.the type of items emitted by the {@code other} {@code MaybeSource}the other {@code MaybeSource}a function that combines the pairs of items from the two {@code MaybeSource}s to generate the items tobe emitted by the resulting {@code Maybe} Test helperit to this {@code Maybe}.Creates a {@link TestObserver} optionally in cancelled state, then subscribes it to this {@code Maybe}.if {@code true}, the {@code TestObserver} will be disposed before subscribing to thisor an empty optional into an {@link #empty()} {@code Maybe} instance.<img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromOptional.m.png" alt="">Maybe.defer(() -&gt; Maybe.fromOptional(createOptional()));the optional value to convert into a {@code Maybe}<img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.s.png" alt="">Maybe.defer(() -&gt; Maybe.fromCompletionStage(createCompletionStage()));If the {@code CompletionStage} completes with {@code null}, the resulting {@code Maybe} is completed via {@code onComplete}.the {@code CompletionStage} to convert to {@code Maybe} and signal its terminal value or errorMaps the upstream success value into an {@link Optional} and emits the contained item if not empty.<img width="640" height="323" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mapOptional.m.png" alt="">the function that receives the upstream success item and should return a <em>non-empty</em> {@code Optional}to emit as the success output or an <em>empty</em> {@code Optional} to complete the {@code Maybe}Signals the upstream success item (or a {@link NoSuchElementException} if the upstream is empty) via<img width="640" height="349" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toCompletionStage.m.png" alt="">{@link #toCompletionStage(Object)} with {@code null} or turn the upstream into a sequence of {@link Optional}s anddefault to {@link Optional#empty()}:#toCompletionStage(Object)Signals the upstream success item (or the default item if the upstream is empty) via<img width="640" height="323" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toCompletionStage.mv.png" alt="">Maps the upstream succecss value into a Java {@link Stream} and emits itsitems to the downstream consumer as a {@link Flowable}.<img width="640" height="246" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenStreamAsFlowable.m.png" alt="">The operator closes the {@code Stream} upon cancellation and when it terminates. The exceptions raised whenIf a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #flattenAsFlowable(Function)}:source.flattenAsFlowable(item -&gt; createStream(item)::iterator);source.flattenStreamAsFlowable(item -&gt; IntStream.rangeClosed(1, 10).boxed());<dd>{@code flattenStreamAsFlowable} does not operate by default on a particular {@link Scheduler}.</dd>the element type of the {@code Stream} and the output {@code Flowable}the function that receives the upstream success item and shouldreturn a {@code Stream} of values to emit.#flattenAsFlowable(Function)#flattenStreamAsObservable(Function)items to the downstream consumer as an {@link Observable}.<img width="640" height="241" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenStreamAsObservable.m.png" alt="">If a {@code Stream} should not be closed, turn it into an {@link Iterable} and use {@link #flattenAsObservable(Function)}:source.flattenAsObservable(item -&gt; createStream(item)::iterator);source.flattenStreamAsObservable(item -&gt; IntStream.rangeClosed(1, 10).boxed());<dd>{@code flattenStreamAsObservable} does not operate by default on a particular {@link Scheduler}.</dd>the element type of the {@code Stream} and the output {@code Observable}#flattenAsObservable(Function)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeConverter.javaConvenience interface and callback used by the {@link Maybe#to} operator to turn a {@link Maybe} into anotherApplies a function to the upstream {@link Maybe} and returns a converted value of type {@code R}.the upstream {@code Maybe} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeEmitter.javaMaybeEmitterAbstraction over an RxJava {@link MaybeObserver} that allows associatingCalling {@link #onSuccess(Object)} or {@link #onComplete()} multiple times has no effect.Calling {@link #onError(Throwable)} multiple times or after the other two will route thedownstream cancels the flow or after the event generator logic calls {@link #onSuccess(Object)},Signal a success value.the value, not nullthe exception, not {@code null}Sets a {@link Disposable} on this emitter; any previous {@code Disposable}emitter was terminated via {@link #onSuccess(Object)}, {@link #onError(Throwable)},{@link #onComplete} or athe {@code Throwable} error to signal if possibleC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeObserver.javaProvides a mechanism for receiving push-based notification of a single value, an error or completion without any value.When a {@code MaybeObserver} is subscribed to a {@link MaybeSource} through the {@link MaybeSource#subscribe(MaybeObserver)} method,the {@code MaybeSource} calls {@link #onSubscribe(Disposable)}  with a {@link Disposable} that allows{@code MaybeSource} will call a {@code MaybeObserver}'s {@link #onSuccess(Object)}, {@link #onError(Throwable)}Calling the {@code MaybeObserver}'s method must happen in a serialized fashion, that is, they must not<pre><code>    onSubscribe (onSuccess | onError | onComplete)?</code></pre>Note that unlike with the {@code Observable} protocol, {@link #onComplete()} is not called after the success item has beensignalled via {@link #onSuccess(Object)}.Subscribing a {@code MaybeObserver} to multiple {@code MaybeSource}s is not recommended. If such reusehappens, it is the duty of the {@code MaybeObserver} implementation to be ready to receive multiple calls toCalling {@link #onSubscribe(Disposable)}, {@link #onSuccess(Object)} or {@link #onError(Throwable)} with a<a href="http://reactivex.io/documentation/observable.html">ReactiveX documentation: Observable</a>the type of item the MaybeObserver expects to observeProvides the {@link MaybeObserver} with the means of cancelling (disposing) theconnection (channel) with the {@link Maybe} in bothsynchronous (from within {@code onSubscribe(Disposable)} itself) and asynchronous manner.the {@link Disposable} instance whose {@link Disposable#dispose()} canbe called anytime to cancel the connectionNotifies the {@link MaybeObserver} with one item and that the {@link Maybe} has finished sendingpush-based notifications.The {@link Maybe} will not call this method if it calls {@link #onError}.the item emitted by the {@code Maybe}Notifies the {@link MaybeObserver} that the {@link Maybe} has experienced an error condition.If the {@link Maybe} calls this method, it will not thereafter call {@link #onSuccess}.the exception encountered by the {@code Maybe}C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeOnSubscribe.javaMaybeEmitter<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeEmitter.classan instance of a {@link MaybeEmitter} instance that allows pushingCalled for each {@link MaybeObserver} that subscribes.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeOperator.javaMaybeObserver<? super Downstream>MaybeObserver<? super Upstream>Interface to map/wrap a downstream {@link MaybeObserver} to an upstream {@code MaybeObserver}.Applies a function to the child {@link MaybeObserver} and returns a new parent {@code MaybeObserver}.the child {@code MaybeObserver} instancethe parent {@code MaybeObserver} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeSource.javaRepresents a basic {@link Maybe} source base interface,consumable via an {@link MaybeObserver}.This class also serves the base type for custom operators wrapped intoMaybe via {@link Maybe#create(MaybeOnSubscribe)}.Subscribes the given {@link MaybeObserver} to this {@link MaybeSource} instance.the {@code MaybeObserver}, not {@code null}C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/MaybeTransformer.javaInterface to compose {@link Maybe}s.Applies a function to the upstream {@link Maybe} and returns a {@link MaybeSource} withthe transformed {@code MaybeSource} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Notification.javaCOMPLETENotification(java.lang.Object)Notification<Object>(java.lang.Object)createOnCompletecreateOnComplete()createOnErrorcreateOnError(java.lang.Throwable)createOnNextcreateOnNext(java.lang.Object)getErrorgetError()getValuegetValue()isOnNextisOnNext()isOnErrorisOnError()isOnCompleteisOnComplete()oobjNotification<?>"OnCompleteNotification"OnCompleteNotification"OnErrorNotification["OnErrorNotification["]"]"OnNextNotification["OnNextNotification["value is null"value is nullNotification<T>(java.lang.Object)"error is null"error is nullRepresents the reactive signal types: {@code onNext}, {@code onError} and {@code onComplete} andholds their parameter values (a value, a {@link Throwable}, nothing).Not meant to be implemented externally.Returns true if this notification is an {@code onComplete} signal.true if this notification is an {@code onComplete} signalReturns true if this notification is an {@code onError} signal and{@link #getError()} returns the contained {@link Throwable}.true if this notification is an {@code onError} signal#getError()Returns true if this notification is an {@code onNext} signal and{@link #getValue()} returns the contained value.true if this notification is an {@code onNext} signal#getValue()Returns the contained value if this notification is an {@code onNext}signal, null otherwise.the value contained or null#isOnNext()Returns the container {@link Throwable} error if this notification is an {@code onError}the {@code Throwable} error contained or {@code null}#isOnError()Constructs an onNext notification containing the given value.the value to carry around in the notification, not {@code null}the new Notification instanceif value is {@code null}Constructs an onError notification containing the error.the error Throwable to carry around in the notification, not nullif error is {@code null}Returns the empty and stateless shared instance of a notification representingan {@code onComplete} signal.the target value typethe shared Notification instance representing an {@code onComplete} signalThe singleton instance for createOnComplete.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Observable.javatimeout0(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.core.ObservableSource)timeout0(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.Scheduler)ObservableAmb<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAmb.classObservableAmbObservableAmb<T>(io.reactivex.rxjava3.core.ObservableSource[],java.lang.Iterable)ObservableAmb(io.reactivex.rxjava3.core.ObservableSource[],java.lang.Iterable)Observable<? extends T>ObservableCombineLatest<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCombineLatest.classObservableCombineLatestObservableCombineLatest<T,R>(io.reactivex.rxjava3.core.ObservableSource[],java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int,boolean)ObservableCombineLatest(io.reactivex.rxjava3.core.ObservableSource[],java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int,boolean)Observable<? extends ObservableSource<? extends T>>? super ? extends ObservableSource<? extends T>Function<? super ? extends ObservableSource<? extends T>,? extends ObservableSource<? extends R>>Observer<? super ? extends ObservableSource<? extends T>>Function<? super ? extends ObservableSource<? extends T>,? extends Stream<? extends R>>Stream<? extends ObservableSource<? extends T>>BaseStream<? extends ObservableSource<? extends T>,Stream<? extends ObservableSource<? extends T>>>CompletionStage<? extends ObservableSource<? extends T>>lastStage(io.reactivex.rxjava3.core.ObservableSource)singleStage(io.reactivex.rxjava3.core.ObservableSource)firstStage(io.reactivex.rxjava3.core.ObservableSource)Collector<? super ? extends ObservableSource<? extends T>,A,R>Function<? super ? extends ObservableSource<? extends T>,Optional<? extends R>>TestObserver<? extends ObservableSource<? extends T>>BaseTestConsumer<? extends ObservableSource<? extends T>,TestObserver<? extends ObservableSource<? extends T>>>Observer<? extends ObservableSource<? extends T>>MaybeObserver<? extends ObservableSource<? extends T>>SingleObserver<? extends ObservableSource<? extends T>>BiFunction<? super ? extends ObservableSource<? extends T>,? super U,? extends R>Function5<? super ? extends ObservableSource<? extends T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super ? extends ObservableSource<? extends T>,? super T1,? super T2,? super T3,R>Function3<? super ? extends ObservableSource<? extends T>,? super T1,? super T2,R>Observable<Observable<? extends ObservableSource<? extends T>>>ObservableSource<Observable<? extends ObservableSource<? extends T>>>List<? extends ObservableSource<? extends T>>Collection<? extends ObservableSource<? extends T>>Single<List<? extends ObservableSource<? extends T>>>SingleSource<List<? extends ObservableSource<? extends T>>>Comparator<? super ? extends ObservableSource<? extends T>>Flowable<? extends ObservableSource<? extends T>>Publisher<? extends ObservableSource<? extends T>>Function<? super ? extends ObservableSource<? extends T>,? extends K>Function<? super ? extends ObservableSource<? extends T>,? extends V>Map<K,Collection<? extends ObservableSource<? extends T>>>Single<Map<K,Collection<? extends ObservableSource<? extends T>>>>SingleSource<Map<K,Collection<? extends ObservableSource<? extends T>>>>Map<K,? extends ObservableSource<? extends T>>Single<Map<K,? extends ObservableSource<? extends T>>>SingleSource<Map<K,? extends ObservableSource<? extends T>>>ObservableConverter<? extends ObservableSource<? extends T>,? extends R>Timed<? extends ObservableSource<? extends T>>Observable<Timed<? extends ObservableSource<? extends T>>>ObservableSource<Timed<? extends ObservableSource<? extends T>>>Function<? super ? extends ObservableSource<? extends T>,? extends ObservableSource<V>>? extends ? extends ObservableSource<? extends T>ObservableSource<? extends ? extends ObservableSource<? extends T>>Predicate<? super ? extends ObservableSource<? extends T>>Function<? super ? extends ObservableSource<? extends T>,? extends SingleSource<? extends R>>Function<? super ? extends ObservableSource<? extends T>,? extends MaybeSource<? extends R>>Function<? super ? extends ObservableSource<? extends T>,? extends CompletableSource>Consumer<? super ? extends ObservableSource<? extends T>>? extends ObservableSource<? extends T>[]startWithArray(io.reactivex.rxjava3.core.ObservableSource[])startWithItem(io.reactivex.rxjava3.core.ObservableSource)MaybeSource<? extends ObservableSource<? extends T>>SingleSource<? extends ObservableSource<? extends T>>Iterable<? extends ? extends ObservableSource<? extends T>>Single<? extends ObservableSource<? extends T>>single(io.reactivex.rxjava3.core.ObservableSource)Maybe<? extends ObservableSource<? extends T>>BiFunction<R,? super ? extends ObservableSource<? extends T>,R>BiFunction<? extends ObservableSource<? extends T>,? extends ObservableSource<? extends T>,? extends ObservableSource<? extends T>>ConnectableObservable<? extends ObservableSource<? extends T>>? super Observable<? extends ObservableSource<? extends T>>Function<? super Observable<? extends ObservableSource<? extends T>>,? extends ObservableSource<R>>onErrorReturnItem(io.reactivex.rxjava3.core.ObservableSource)Function<? super Throwable,? extends ? extends ObservableSource<? extends T>>? extends ObservableSource<? extends ? extends ObservableSource<? extends T>>Function<? super Throwable,? extends ObservableSource<? extends ? extends ObservableSource<? extends T>>>MaybeSource<? extends ? extends ObservableSource<? extends T>>SingleSource<? extends ? extends ObservableSource<? extends T>>Notification<? extends ObservableSource<? extends T>>Observable<Notification<? extends ObservableSource<? extends T>>>ObservableSource<Notification<? extends ObservableSource<? extends T>>>Function<? super ? extends ObservableSource<? extends T>,? extends R>ObservableOperator<? extends R,? super ? extends ObservableSource<? extends T>>last(io.reactivex.rxjava3.core.ObservableSource)Function<? super ? extends ObservableSource<? extends T>,? extends ObservableSource<TLeftEnd>>BiFunction<? super ? extends ObservableSource<? extends T>,? super TRight,? extends R>BiFunction<? super ? extends ObservableSource<? extends T>,? super Observable<TRight>,? extends R>GroupedObservable<K,? extends ObservableSource<? extends T>>Observable<GroupedObservable<K,? extends ObservableSource<? extends T>>>ObservableSource<GroupedObservable<K,? extends ObservableSource<? extends T>>>Function<? super ? extends ObservableSource<? extends T>,? extends Iterable<? extends U>>BiFunction<? super ? extends ObservableSource<? extends T>,? super U,? extends V>Function<? super ? extends ObservableSource<? extends T>,? extends ObservableSource<? extends U>>first(io.reactivex.rxjava3.core.ObservableSource)elementAt(long,io.reactivex.rxjava3.core.ObservableSource)? super Notification<? extends ObservableSource<? extends T>>Consumer<? super Notification<? extends ObservableSource<? extends T>>>BiPredicate<? super ? extends ObservableSource<? extends T>,? super ? extends ObservableSource<? extends T>>Function<? super ? extends ObservableSource<? extends T>,K>Function<? super ? extends ObservableSource<? extends T>,Notification<R>>Function<? super ? extends ObservableSource<? extends T>,? extends ObservableSource<U>>defaultIfEmpty(io.reactivex.rxjava3.core.ObservableSource)ObservableTransformer<? super ? extends ObservableSource<? extends T>,? extends R>BiConsumer<? super U,? super ? extends ObservableSource<? extends T>>Observable<List<? extends ObservableSource<? extends T>>>ObservableSource<List<? extends ObservableSource<? extends T>>>Future<? extends ObservableSource<? extends T>>blockingSingle(io.reactivex.rxjava3.core.ObservableSource)blockingMostRecent(io.reactivex.rxjava3.core.ObservableSource)blockingLast(io.reactivex.rxjava3.core.ObservableSource)blockingFirst(io.reactivex.rxjava3.core.ObservableSource)Observable<? extends ObservableSource<? extends T>>()ObservableConcatMap<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatMap.classObservableConcatMapAbstractObservableWithUpstream<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/AbstractObservableWithUpstream.classAbstractObservableWithUpstreamHasUpstreamObservableSource<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/fuseable/HasUpstreamObservableSource.classHasUpstreamObservableSourceObservableConcatMap<>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode)AbstractObservableWithUpstream(io.reactivex.rxjava3.core.ObservableSource)AbstractObservableWithUpstream<>(io.reactivex.rxjava3.core.ObservableSource)Observer<? super U>ObservableConcatMap(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode)Observable<ObservableSource<? extends T>>ObservableSource<ObservableSource<? extends T>>? super ObservableSource<? extends T>Function<? super ObservableSource<? extends T>,? extends ObservableSource<? extends R>>Observer<? super ObservableSource<? extends T>>Function<? super ObservableSource<? extends T>,? extends Stream<? extends R>>Stream<ObservableSource<? extends T>>BaseStream<ObservableSource<? extends T>,Stream<ObservableSource<? extends T>>>CompletionStage<ObservableSource<? extends T>>Collector<? super ObservableSource<? extends T>,A,R>Function<? super ObservableSource<? extends T>,Optional<? extends R>>TestObserver<ObservableSource<? extends T>>BaseTestConsumer<ObservableSource<? extends T>,TestObserver<ObservableSource<? extends T>>>Observer<ObservableSource<? extends T>>MaybeObserver<ObservableSource<? extends T>>SingleObserver<ObservableSource<? extends T>>BiFunction<? super ObservableSource<? extends T>,? super U,? extends R>Function5<? super ObservableSource<? extends T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super ObservableSource<? extends T>,? super T1,? super T2,? super T3,R>Function3<? super ObservableSource<? extends T>,? super T1,? super T2,R>Observable<Observable<ObservableSource<? extends T>>>ObservableSource<Observable<ObservableSource<? extends T>>>List<ObservableSource<? extends T>>Collection<ObservableSource<? extends T>>Iterable<ObservableSource<? extends T>>Single<List<ObservableSource<? extends T>>>SingleSource<List<ObservableSource<? extends T>>>Comparator<? super ObservableSource<? extends T>>Flowable<ObservableSource<? extends T>>Publisher<ObservableSource<? extends T>>Function<? super ObservableSource<? extends T>,? extends K>Function<? super ObservableSource<? extends T>,? extends V>Map<K,Collection<ObservableSource<? extends T>>>Single<Map<K,Collection<ObservableSource<? extends T>>>>SingleSource<Map<K,Collection<ObservableSource<? extends T>>>>Map<K,ObservableSource<? extends T>>Single<Map<K,ObservableSource<? extends T>>>SingleSource<Map<K,ObservableSource<? extends T>>>ObservableConverter<ObservableSource<? extends T>,? extends R>Timed<ObservableSource<? extends T>>Observable<Timed<ObservableSource<? extends T>>>ObservableSource<Timed<ObservableSource<? extends T>>>Function<? super ObservableSource<? extends T>,? extends ObservableSource<V>>Predicate<? super ObservableSource<? extends T>>Function<? super ObservableSource<? extends T>,? extends SingleSource<? extends R>>Function<? super ObservableSource<? extends T>,? extends MaybeSource<? extends R>>Function<? super ObservableSource<? extends T>,? extends CompletableSource>Consumer<? super ObservableSource<? extends T>>MaybeSource<ObservableSource<? extends T>>SingleSource<ObservableSource<? extends T>>Single<ObservableSource<? extends T>>Maybe<ObservableSource<? extends T>>BiFunction<R,? super ObservableSource<? extends T>,R>BiFunction<ObservableSource<? extends T>,ObservableSource<? extends T>,ObservableSource<? extends T>>ConnectableObservable<ObservableSource<? extends T>>? super Observable<ObservableSource<? extends T>>Function<? super Observable<ObservableSource<? extends T>>,? extends ObservableSource<R>>? extends ObservableSource<? extends ObservableSource<? extends T>>Function<? super Throwable,? extends ObservableSource<? extends ObservableSource<? extends T>>>Notification<ObservableSource<? extends T>>Observable<Notification<ObservableSource<? extends T>>>ObservableSource<Notification<ObservableSource<? extends T>>>Function<? super ObservableSource<? extends T>,? extends R>ObservableOperator<? extends R,? super ObservableSource<? extends T>>Function<? super ObservableSource<? extends T>,? extends ObservableSource<TLeftEnd>>BiFunction<? super ObservableSource<? extends T>,? super TRight,? extends R>BiFunction<? super ObservableSource<? extends T>,? super Observable<TRight>,? extends R>GroupedObservable<K,ObservableSource<? extends T>>Observable<GroupedObservable<K,ObservableSource<? extends T>>>ObservableSource<GroupedObservable<K,ObservableSource<? extends T>>>Function<? super ObservableSource<? extends T>,? extends Iterable<? extends U>>BiFunction<? super ObservableSource<? extends T>,? super U,? extends V>Function<? super ObservableSource<? extends T>,? extends ObservableSource<? extends U>>? super Notification<ObservableSource<? extends T>>Consumer<? super Notification<ObservableSource<? extends T>>>BiPredicate<? super ObservableSource<? extends T>,? super ObservableSource<? extends T>>Function<? super ObservableSource<? extends T>,K>Function<? super ObservableSource<? extends T>,Notification<R>>Function<? super ObservableSource<? extends T>,? extends ObservableSource<U>>ObservableTransformer<? super ObservableSource<? extends T>,? extends R>BiConsumer<? super U,? super ObservableSource<? extends T>>Observable<List<ObservableSource<? extends T>>>ObservableSource<List<ObservableSource<? extends T>>>Future<ObservableSource<? extends T>>Observable<ObservableSource<? extends T>>()"bufferSize is null"bufferSize is nullObservableCreate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCreate.classObservableCreateObservableCreate<T>(io.reactivex.rxjava3.core.ObservableOnSubscribe)ObservableCreate(io.reactivex.rxjava3.core.ObservableOnSubscribe)ObservableDefer<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDefer.classObservableDeferObservableDefer<T>(io.reactivex.rxjava3.functions.Supplier)ObservableDefer(io.reactivex.rxjava3.functions.Supplier)ObservableError<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableError.classObservableErrorObservableError<T>(io.reactivex.rxjava3.functions.Supplier)ObservableError(io.reactivex.rxjava3.functions.Supplier)ObservableFromAction<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromAction.classObservableFromActionObservableFromAction<T>(io.reactivex.rxjava3.functions.Action)ObservableFromAction(io.reactivex.rxjava3.functions.Action)ObservableFromArray<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromArray.classObservableFromArrayObservableFromArray<T>(java.lang.Object[])ObservableFromArray(java.lang.Object[])ObservableFromCallable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromCallable.classObservableFromCallableObservableFromCallable<T>(java.util.concurrent.Callable)ObservableFromCallable(java.util.concurrent.Callable)ObservableFromCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromCompletable.classObservableFromCompletableObservableFromCompletable<T>(io.reactivex.rxjava3.core.CompletableSource)ObservableFromCompletable(io.reactivex.rxjava3.core.CompletableSource)ObservableFromFuture<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromFuture.classObservableFromFutureObservableFromFuture<T>(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit)ObservableFromFuture(java.util.concurrent.Future,long,java.util.concurrent.TimeUnit)ObservableFromIterable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromIterable.classObservableFromIterableObservableFromIterable<T>(java.lang.Iterable)ObservableFromIterable(java.lang.Iterable)ObservableFromRunnable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromRunnable.classObservableFromRunnableObservableFromRunnable<T>(java.lang.Runnable)ObservableFromRunnable(java.lang.Runnable)SingleToObservable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleToObservable.classSingleToObservableSingleToObservable<T>(io.reactivex.rxjava3.core.SingleSource)SingleToObservable(io.reactivex.rxjava3.core.SingleSource)ObservableFromSupplier<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromSupplier.classObservableFromSupplierObservableFromSupplier<T>(io.reactivex.rxjava3.functions.Supplier)ObservableFromSupplier(io.reactivex.rxjava3.functions.Supplier)ObservableGenerate<T,S>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGenerate.classObservableGenerateObservableGenerate<T,S>(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction,io.reactivex.rxjava3.functions.Consumer)ObservableGenerate(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction,io.reactivex.rxjava3.functions.Consumer)Observer<? super Long>Observable<Observable<Long>>ObservableSource<Observable<Long>>ObservableConverter<Long,? extends R>Observable<Timed<Long>>ObservableSource<Timed<Long>>Function<? super Long,? extends ObservableSource<V>>ObservableSource<? extends Long>ConnectableObservable<Long>? super Observable<Long>Function<? super Observable<Long>,? extends ObservableSource<R>>? extends ObservableSource<? extends Long>Function<? super Throwable,? extends ObservableSource<? extends Long>>Observable<Notification<Long>>ObservableSource<Notification<Long>>ObservableOperator<? extends R,? super Long>Function<? super Long,? extends ObservableSource<TLeftEnd>>BiFunction<? super Long,? super Observable<TRight>,? extends R>GroupedObservable<K,Long>Observable<GroupedObservable<K,Long>>ObservableSource<GroupedObservable<K,Long>>Function<? super Long,? extends ObservableSource<? extends U>>Function<? super Long,? extends ObservableSource<U>>ObservableTransformer<? super Long,? extends R>Observable<List<Long>>ObservableSource<List<Long>>Observable<Long>()ObservableJust<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableJust.classObservableJustObservableJust<T>(java.lang.Object)ObservableJust(java.lang.Object)ObservableFlatMap<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMap.classObservableFlatMapObservableFlatMap<>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean,int,int)ObservableFlatMap(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean,int,int)ObservableSequenceEqualSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSequenceEqualSingle.classObservableSequenceEqualSingleFuseToObservable<Boolean>ObservableSequenceEqualSingle<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiPredicate,int)ObservableSequenceEqualSingle(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiPredicate,int)ObservableSwitchMap<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchMap.classObservableSwitchMapObservableSwitchMap<>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int,boolean)ObservableSwitchMap(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int,boolean)"unsafeCreate(Observable) should be upgraded"unsafeCreate(Observable) should be upgradedObservableFromUnsafeSource<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFromUnsafeSource.classObservableFromUnsafeSourceObservableFromUnsafeSource<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableFromUnsafeSource(io.reactivex.rxjava3.core.ObservableSource)ObservableUsing<T,D>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableUsing.classObservableUsingObservableUsing<T,D>(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)ObservableUsing(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)ObservableZip<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableZip.classObservableZipObservableZip<T,R>(io.reactivex.rxjava3.core.ObservableSource[],java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int,boolean)ObservableZip(io.reactivex.rxjava3.core.ObservableSource[],java.lang.Iterable,io.reactivex.rxjava3.functions.Function,int,boolean)ObservableAllSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAllSingle.classObservableAllSingleObservableAllSingle<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableAllSingle(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableAnySingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableAnySingle.classObservableAnySingleObservableAnySingle<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableAnySingle(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)BlockingFirstObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/BlockingFirstObserver.classBlockingFirstObserverBlockingBaseObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/BlockingBaseObserver.classBlockingBaseObserverBlockingFirstObserver<T>()BlockingBaseObserver()BlockingBaseObserver<T>()BlockingFirstObserver()BlockingObservableIterable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableIterable.classBlockingObservableIterableBlockingObservableIterable<T>(io.reactivex.rxjava3.core.ObservableSource,int)BlockingObservableIterable(io.reactivex.rxjava3.core.ObservableSource,int)BlockingLastObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/BlockingLastObserver.classBlockingLastObserverBlockingLastObserver<T>()BlockingLastObserver()BlockingObservableLatest<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableLatest.classBlockingObservableLatestBlockingObservableLatest<T>(io.reactivex.rxjava3.core.ObservableSource)BlockingObservableLatest(io.reactivex.rxjava3.core.ObservableSource)BlockingObservableMostRecent<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableMostRecent.classBlockingObservableMostRecentBlockingObservableMostRecent<T>(io.reactivex.rxjava3.core.ObservableSource,java.lang.Object)BlockingObservableMostRecent(io.reactivex.rxjava3.core.ObservableSource,java.lang.Object)BlockingObservableNext<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/BlockingObservableNext.classBlockingObservableNextBlockingObservableNext<T>(io.reactivex.rxjava3.core.ObservableSource)BlockingObservableNext(io.reactivex.rxjava3.core.ObservableSource)FutureObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/FutureObserver.classFutureObserverFutureObserver<T>()FutureObserver()ObservableBuffer<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBuffer.classObservableBufferAbstractObservableWithUpstream<T,U>HasUpstreamObservableSource<T>ObservableBuffer<T,U>(io.reactivex.rxjava3.core.ObservableSource,int,int,io.reactivex.rxjava3.functions.Supplier)Observable<Observable<U>>ObservableSource<Observable<U>>ObservableConverter<U,? extends R>Observable<Timed<U>>ObservableSource<Timed<U>>ConnectableObservable<U>? super Observable<U>Function<? super Observable<U>,? extends ObservableSource<R>>Function<? super Throwable,? extends ObservableSource<? extends U>>Observable<Notification<U>>ObservableSource<Notification<U>>ObservableOperator<? extends R,? super U>Function<? super U,? extends ObservableSource<TLeftEnd>>BiFunction<? super U,? super Observable<TRight>,? extends R>GroupedObservable<K,U>Observable<GroupedObservable<K,U>>ObservableSource<GroupedObservable<K,U>>Function<? super U,? extends ObservableSource<? extends U>>Function<? super U,? extends ObservableSource<U>>ObservableTransformer<? super U,? extends R>Observable<List<U>>ObservableSource<List<U>>Observable<U>()AbstractObservableWithUpstream<T,U>(io.reactivex.rxjava3.core.ObservableSource)ObservableBuffer(io.reactivex.rxjava3.core.ObservableSource,int,int,io.reactivex.rxjava3.functions.Supplier)ObservableBufferTimed<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferTimed.classObservableBufferTimedObservableBufferTimed<T,U>(io.reactivex.rxjava3.core.ObservableSource,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.functions.Supplier,int,boolean)ObservableBufferTimed(io.reactivex.rxjava3.core.ObservableSource,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.functions.Supplier,int,boolean)ObservableBufferBoundary<T,U,TOpening,TClosing>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferBoundary.classObservableBufferBoundaryObservableSource<? extends Open>ObservableSource<? extends Close>? extends ObservableSource<? extends Close>Function<? super Open,? extends ObservableSource<? extends Close>>ObservableBufferBoundary<T,U,TOpening,TClosing>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)ObservableBufferBoundary(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)ObservableBufferExactBoundary<T,U,B>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableBufferExactBoundary.classObservableBufferExactBoundaryObservableBufferExactBoundary<T,U,B>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier)ObservableBufferExactBoundary(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier)ObservableCache<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCache.classObservableCacheAbstractObservableWithUpstream<T,T>ObservableCache<T>(io.reactivex.rxjava3.core.Observable,int)AbstractObservableWithUpstream<T,T>(io.reactivex.rxjava3.core.ObservableSource)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCache$CacheDisposable.classObservableCache$CacheDisposableObservableCache<>replay(io.reactivex.rxjava3.internal.operators.observable.ObservableCache.CacheDisposable)remove(io.reactivex.rxjava3.internal.operators.observable.ObservableCache.CacheDisposable)add(io.reactivex.rxjava3.internal.operators.observable.ObservableCache.CacheDisposable)hasObservershasObservers()ObservableCache(io.reactivex.rxjava3.core.Observable,int)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCache$Node.classObservableCache$NodeObservableCollectSingle<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCollectSingle.classObservableCollectSingleFuseToObservable<U>ObservableCollectSingle<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiConsumer)ObservableCollectSingle(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiConsumer)ObservableTransformer<T,R>Observable<Upstream>ObservableSource<Upstream>apply(io.reactivex.rxjava3.core.Observable)ObservableSource<Downstream>ObservableConcatMap<T,R>AbstractObservableWithUpstream<T,R>ObservableConcatMap<T,U>ObservableConcatMap<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode)ObservableConcatMapScheduler<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatMapScheduler.classObservableConcatMapSchedulerObservableConcatMapScheduler<T,U>ObservableConcatMapScheduler<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode,io.reactivex.rxjava3.core.Scheduler)ObservableConcatMapScheduler(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int,io.reactivex.rxjava3.internal.util.ErrorMode,io.reactivex.rxjava3.core.Scheduler)ObservableConcatMapEager<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatMapEager.classObservableConcatMapEagerObservableConcatMapEager<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int,int)AbstractObservableWithUpstream<T,R>(io.reactivex.rxjava3.core.ObservableSource)ObservableConcatMapEager(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int,int)ObservableConcatMapCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableConcatMapCompletable.classObservableConcatMapCompletableObservableConcatMapCompletable<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)ObservableConcatMapCompletable(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)ObservableFlattenIterable<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlattenIterable.classObservableFlattenIterableObservableFlattenIterable<T,R>ObservableFlattenIterable<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableFlattenIterable(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableConcatMapMaybe<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableConcatMapMaybe.classObservableConcatMapMaybeObservableConcatMapMaybe<T,R>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)ObservableConcatMapMaybe(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)ObservableConcatMapSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableConcatMapSingle.classObservableConcatMapSingleObservableConcatMapSingle<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)ObservableConcatMapSingle(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)ObservableConcatWithSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatWithSingle.classObservableConcatWithSingleObservableConcatWithSingle<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.SingleSource)ObservableConcatWithSingle(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.SingleSource)ObservableConcatWithMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatWithMaybe.classObservableConcatWithMaybeObservableConcatWithMaybe<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.MaybeSource)ObservableConcatWithMaybe(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.MaybeSource)ObservableConcatWithCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableConcatWithCompletable.classObservableConcatWithCompletableObservableConcatWithCompletable<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.CompletableSource)ObservableConcatWithCompletable(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.CompletableSource)ObservableCountSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableCountSingle.classObservableCountSingleFuseToObservable<Long>ObservableCountSingle<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableCountSingle(io.reactivex.rxjava3.core.ObservableSource)ObservableDebounce<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDebounce.classObservableDebounceObservableDebounce<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableDebounce(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableDebounceTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDebounceTimed.classObservableDebounceTimedObservableDebounceTimed<T>(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)ObservableDebounceTimed(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)Function<T,ObservableSource<T>>ObservableDelay<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelay.classObservableDelayObservableDelay<T>(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)ObservableDelay(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)ObservableDelaySubscriptionOther<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDelaySubscriptionOther.classObservableDelaySubscriptionOtherObservableDelaySubscriptionOther<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)ObservableDelaySubscriptionOther(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)ObservableDematerialize<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDematerialize.classObservableDematerializeObservableDematerialize<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableDematerialize(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableDistinct<T,K>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDistinct.classObservableDistinctObservableDistinct<T,K>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)ObservableDistinct(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)ObservableDistinctUntilChanged<T,K>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDistinctUntilChanged.classObservableDistinctUntilChangedObservableDistinctUntilChanged<T,K>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiPredicate)ObservableDistinctUntilChanged(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiPredicate)ObservableDistinctUntilChanged<T,T>ObservableDoAfterNext<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDoAfterNext.classObservableDoAfterNextObservableDoAfterNext<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Consumer)ObservableDoAfterNext(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Consumer)ObservableDoFinally<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDoFinally.classObservableDoFinallyObservableDoFinally<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Action)ObservableDoFinally(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Action)ObservableDoOnEach<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDoOnEach.classObservableDoOnEachObservableDoOnEach<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action)ObservableDoOnEach(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Action)ObservableDoOnLifecycle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDoOnLifecycle.classObservableDoOnLifecycleObservableDoOnLifecycle<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)ObservableDoOnLifecycle(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)ObservableElementAtSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableElementAtSingle.classObservableElementAtSingleObservableElementAtSingle<T>(io.reactivex.rxjava3.core.ObservableSource,long,java.lang.Object)ObservableElementAtSingle(io.reactivex.rxjava3.core.ObservableSource,long,java.lang.Object)ObservableFilter<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFilter.classObservableFilterObservableFilter<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableFilter(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableFlatMap<T,R>ObservableFlatMap<T,U>ObservableFlatMap<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean,int,int)ObservableMapNotification<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMapNotification.classObservableMapNotificationAbstractObservableWithUpstream<T,ObservableSource<? extends R>>Observable<ObservableSource<? extends R>>ObservableSource<ObservableSource<? extends R>>ObservableMapNotification<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)? super ObservableSource<? extends R>Observer<? super ObservableSource<? extends R>>Function<? super ObservableSource<? extends R>,? extends Stream<? extends R>>Stream<ObservableSource<? extends R>>BaseStream<ObservableSource<? extends R>,Stream<ObservableSource<? extends R>>>CompletionStage<ObservableSource<? extends R>>Collector<? super ObservableSource<? extends R>,A,R>Function<? super ObservableSource<? extends R>,Optional<? extends R>>TestObserver<ObservableSource<? extends R>>BaseTestConsumer<ObservableSource<? extends R>,TestObserver<ObservableSource<? extends R>>>Observer<ObservableSource<? extends R>>MaybeObserver<ObservableSource<? extends R>>SingleObserver<ObservableSource<? extends R>>BiFunction<? super ObservableSource<? extends R>,? super U,? extends R>Function5<? super ObservableSource<? extends R>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super ObservableSource<? extends R>,? super T1,? super T2,? super T3,R>Function3<? super ObservableSource<? extends R>,? super T1,? super T2,R>Observable<Observable<ObservableSource<? extends R>>>ObservableSource<Observable<ObservableSource<? extends R>>>List<ObservableSource<? extends R>>Collection<ObservableSource<? extends R>>Iterable<ObservableSource<? extends R>>Single<List<ObservableSource<? extends R>>>SingleSource<List<ObservableSource<? extends R>>>Comparator<? super ObservableSource<? extends R>>Flowable<ObservableSource<? extends R>>Publisher<ObservableSource<? extends R>>Function<? super ObservableSource<? extends R>,? extends K>Function<? super ObservableSource<? extends R>,? extends V>Map<K,Collection<ObservableSource<? extends R>>>Single<Map<K,Collection<ObservableSource<? extends R>>>>SingleSource<Map<K,Collection<ObservableSource<? extends R>>>>Map<K,ObservableSource<? extends R>>Single<Map<K,ObservableSource<? extends R>>>SingleSource<Map<K,ObservableSource<? extends R>>>ObservableConverter<ObservableSource<? extends R>,? extends R>Timed<ObservableSource<? extends R>>Observable<Timed<ObservableSource<? extends R>>>ObservableSource<Timed<ObservableSource<? extends R>>>Function<? super ObservableSource<? extends R>,? extends ObservableSource<V>>ObservableSource<? extends ObservableSource<? extends R>>Predicate<? super ObservableSource<? extends R>>Function<? super ObservableSource<? extends R>,? extends ObservableSource<? extends R>>Function<? super ObservableSource<? extends R>,? extends SingleSource<? extends R>>Function<? super ObservableSource<? extends R>,? extends MaybeSource<? extends R>>Function<? super ObservableSource<? extends R>,? extends CompletableSource>Consumer<? super ObservableSource<? extends R>>ObservableSource<? extends R>[]MaybeSource<ObservableSource<? extends R>>SingleSource<ObservableSource<? extends R>>Iterable<? extends ObservableSource<? extends R>>Single<ObservableSource<? extends R>>Maybe<ObservableSource<? extends R>>BiFunction<R,? super ObservableSource<? extends R>,R>BiFunction<ObservableSource<? extends R>,ObservableSource<? extends R>,ObservableSource<? extends R>>ConnectableObservable<ObservableSource<? extends R>>? super Observable<ObservableSource<? extends R>>Function<? super Observable<ObservableSource<? extends R>>,? extends ObservableSource<R>>? extends ObservableSource<? extends ObservableSource<? extends R>>Function<? super Throwable,? extends ObservableSource<? extends ObservableSource<? extends R>>>MaybeSource<? extends ObservableSource<? extends R>>SingleSource<? extends ObservableSource<? extends R>>Notification<ObservableSource<? extends R>>Observable<Notification<ObservableSource<? extends R>>>ObservableSource<Notification<ObservableSource<? extends R>>>Function<? super ObservableSource<? extends R>,? extends R>ObservableOperator<? extends R,? super ObservableSource<? extends R>>Function<? super ObservableSource<? extends R>,? extends ObservableSource<TLeftEnd>>BiFunction<? super ObservableSource<? extends R>,? super TRight,? extends R>BiFunction<? super ObservableSource<? extends R>,? super Observable<TRight>,? extends R>GroupedObservable<K,ObservableSource<? extends R>>Observable<GroupedObservable<K,ObservableSource<? extends R>>>ObservableSource<GroupedObservable<K,ObservableSource<? extends R>>>Function<? super ObservableSource<? extends R>,? extends Iterable<? extends U>>BiFunction<? super ObservableSource<? extends R>,? super U,? extends V>Function<? super ObservableSource<? extends R>,? extends ObservableSource<? extends U>>? super Notification<ObservableSource<? extends R>>Consumer<? super Notification<ObservableSource<? extends R>>>BiPredicate<? super ObservableSource<? extends R>,? super ObservableSource<? extends R>>Function<? super ObservableSource<? extends R>,K>Function<? super ObservableSource<? extends R>,Notification<R>>Function<? super ObservableSource<? extends R>,? extends ObservableSource<U>>ObservableTransformer<? super ObservableSource<? extends R>,? extends R>BiConsumer<? super U,? super ObservableSource<? extends R>>Observable<List<ObservableSource<? extends R>>>ObservableSource<List<ObservableSource<? extends R>>>Future<ObservableSource<? extends R>>Observable<ObservableSource<? extends R>>()AbstractObservableWithUpstream<T,ObservableSource<? extends R>>(io.reactivex.rxjava3.core.ObservableSource)ObservableMapNotification(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Supplier)Function<T,ObservableSource<? extends R>>ObservableFlatMapCompletableCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapCompletableCompletable.classObservableFlatMapCompletableCompletableObservableFlatMapCompletableCompletable<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean)ObservableFlatMapCompletableCompletable(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean)Function<T,ObservableSource<U>>ObservableFlatMapMaybe<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapMaybe.classObservableFlatMapMaybeObservableFlatMapMaybe<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean)ObservableFlatMapMaybe(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean)ObservableFlatMapSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableFlatMapSingle.classObservableFlatMapSingleObservableFlatMapSingle<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean)ObservableFlatMapSingle(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,boolean)ForEachWhileObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/ForEachWhileObserver.classForEachWhileObserverForEachWhileObserver<T>(io.reactivex.rxjava3.functions.Predicate,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)ForEachWhileObserver(io.reactivex.rxjava3.functions.Predicate,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)ObservableGroupBy<T,K,V>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupBy.classObservableGroupByAbstractObservableWithUpstream<T,GroupedObservable<K,V>>ObservableGroupBy<T,K,V>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,int,boolean)? super GroupedObservable<K,V>Observer<? super GroupedObservable<K,V>>Function<? super GroupedObservable<K,V>,? extends Stream<? extends R>>Stream<GroupedObservable<K,V>>BaseStream<GroupedObservable<K,V>,Stream<GroupedObservable<K,V>>>CompletionStage<GroupedObservable<K,V>>lastStage(io.reactivex.rxjava3.observables.GroupedObservable)singleStage(io.reactivex.rxjava3.observables.GroupedObservable)firstStage(io.reactivex.rxjava3.observables.GroupedObservable)Collector<? super GroupedObservable<K,V>,A,R>Function<? super GroupedObservable<K,V>,Optional<? extends R>>TestObserver<GroupedObservable<K,V>>BaseTestConsumer<GroupedObservable<K,V>,TestObserver<GroupedObservable<K,V>>>Observer<GroupedObservable<K,V>>MaybeObserver<GroupedObservable<K,V>>SingleObserver<GroupedObservable<K,V>>BiFunction<? super GroupedObservable<K,V>,? super U,? extends R>Function5<? super GroupedObservable<K,V>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super GroupedObservable<K,V>,? super T1,? super T2,? super T3,R>Function3<? super GroupedObservable<K,V>,? super T1,? super T2,R>Observable<Observable<GroupedObservable<K,V>>>ObservableSource<Observable<GroupedObservable<K,V>>>List<GroupedObservable<K,V>>Collection<GroupedObservable<K,V>>Iterable<GroupedObservable<K,V>>Single<List<GroupedObservable<K,V>>>SingleSource<List<GroupedObservable<K,V>>>Comparator<? super GroupedObservable<K,V>>Flowable<GroupedObservable<K,V>>Publisher<GroupedObservable<K,V>>Function<? super GroupedObservable<K,V>,? extends K>Function<? super GroupedObservable<K,V>,? extends V>Map<K,Collection<GroupedObservable<K,V>>>Single<Map<K,Collection<GroupedObservable<K,V>>>>SingleSource<Map<K,Collection<GroupedObservable<K,V>>>>Map<K,GroupedObservable<K,V>>Single<Map<K,GroupedObservable<K,V>>>SingleSource<Map<K,GroupedObservable<K,V>>>ObservableConverter<GroupedObservable<K,V>,? extends R>Timed<GroupedObservable<K,V>>Observable<Timed<GroupedObservable<K,V>>>ObservableSource<Timed<GroupedObservable<K,V>>>Function<? super GroupedObservable<K,V>,? extends ObservableSource<V>>? extends GroupedObservable<K,V>ObservableSource<? extends GroupedObservable<K,V>>Predicate<? super GroupedObservable<K,V>>Function<? super GroupedObservable<K,V>,? extends ObservableSource<? extends R>>Function<? super GroupedObservable<K,V>,? extends SingleSource<? extends R>>Function<? super GroupedObservable<K,V>,? extends MaybeSource<? extends R>>Function<? super GroupedObservable<K,V>,? extends CompletableSource>Consumer<? super GroupedObservable<K,V>>GroupedObservable[]GroupedObservable<K,V>[]startWithArray(io.reactivex.rxjava3.observables.GroupedObservable[])startWithItem(io.reactivex.rxjava3.observables.GroupedObservable)MaybeSource<GroupedObservable<K,V>>SingleSource<GroupedObservable<K,V>>Iterable<? extends GroupedObservable<K,V>>Single<GroupedObservable<K,V>>single(io.reactivex.rxjava3.observables.GroupedObservable)Maybe<GroupedObservable<K,V>>BiFunction<R,? super GroupedObservable<K,V>,R>BiFunction<GroupedObservable<K,V>,GroupedObservable<K,V>,GroupedObservable<K,V>>ConnectableObservable<GroupedObservable<K,V>>? super Observable<GroupedObservable<K,V>>Function<? super Observable<GroupedObservable<K,V>>,? extends ObservableSource<R>>onErrorReturnItem(io.reactivex.rxjava3.observables.GroupedObservable)Function<? super Throwable,? extends GroupedObservable<K,V>>? extends ObservableSource<? extends GroupedObservable<K,V>>Function<? super Throwable,? extends ObservableSource<? extends GroupedObservable<K,V>>>MaybeSource<? extends GroupedObservable<K,V>>SingleSource<? extends GroupedObservable<K,V>>Notification<GroupedObservable<K,V>>Observable<Notification<GroupedObservable<K,V>>>ObservableSource<Notification<GroupedObservable<K,V>>>Function<? super GroupedObservable<K,V>,? extends R>ObservableOperator<? extends R,? super GroupedObservable<K,V>>last(io.reactivex.rxjava3.observables.GroupedObservable)Function<? super GroupedObservable<K,V>,? extends ObservableSource<TLeftEnd>>BiFunction<? super GroupedObservable<K,V>,? super TRight,? extends R>BiFunction<? super GroupedObservable<K,V>,? super Observable<TRight>,? extends R>GroupedObservable<K,GroupedObservable<K,V>>Observable<GroupedObservable<K,GroupedObservable<K,V>>>ObservableSource<GroupedObservable<K,GroupedObservable<K,V>>>Function<? super GroupedObservable<K,V>,? extends Iterable<? extends U>>BiFunction<? super GroupedObservable<K,V>,? super U,? extends V>Function<? super GroupedObservable<K,V>,? extends ObservableSource<? extends U>>first(io.reactivex.rxjava3.observables.GroupedObservable)elementAt(long,io.reactivex.rxjava3.observables.GroupedObservable)? super Notification<GroupedObservable<K,V>>Consumer<? super Notification<GroupedObservable<K,V>>>BiPredicate<? super GroupedObservable<K,V>,? super GroupedObservable<K,V>>Function<? super GroupedObservable<K,V>,K>Function<? super GroupedObservable<K,V>,Notification<R>>Function<? super GroupedObservable<K,V>,? extends ObservableSource<U>>defaultIfEmpty(io.reactivex.rxjava3.observables.GroupedObservable)ObservableTransformer<? super GroupedObservable<K,V>,? extends R>BiConsumer<? super U,? super GroupedObservable<K,V>>Observable<List<GroupedObservable<K,V>>>ObservableSource<List<GroupedObservable<K,V>>>Future<GroupedObservable<K,V>>GroupedObservable<>blockingSingle(io.reactivex.rxjava3.observables.GroupedObservable)blockingMostRecent(io.reactivex.rxjava3.observables.GroupedObservable)blockingLast(io.reactivex.rxjava3.observables.GroupedObservable)blockingFirst(io.reactivex.rxjava3.observables.GroupedObservable)Observable<GroupedObservable<K,V>>()AbstractObservableWithUpstream<T,GroupedObservable<K,V>>(io.reactivex.rxjava3.core.ObservableSource)ObservableGroupBy(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,int,boolean)ObservableGroupJoin<T,TRight,TLeftEnd,TRightEnd,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupJoin.classObservableGroupJoinObservableGroupJoin<TLeft,TRight,TLeftEnd,TRightEnd,R>AbstractObservableWithUpstream<TLeft,R>HasUpstreamObservableSource<TLeft>ObservableSource<TLeft>Function<? super TLeft,? extends ObservableSource<TLeftEnd>>BiFunction<? super TLeft,? super Observable<TRight>,? extends R>ObservableGroupJoin<TLeft,TRight,TLeftEnd,TRightEnd,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)AbstractObservableWithUpstream<TLeft,R>(io.reactivex.rxjava3.core.ObservableSource)ObservableGroupJoin(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)ObservableHide<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableHide.classObservableHideObservableHide<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableHide(io.reactivex.rxjava3.core.ObservableSource)ObservableIgnoreElementsCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableIgnoreElementsCompletable.classObservableIgnoreElementsCompletableObservableIgnoreElementsCompletable<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableIgnoreElementsCompletable(io.reactivex.rxjava3.core.ObservableSource)ObservableJoin<T,TRight,TLeftEnd,TRightEnd,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableJoin.classObservableJoinObservableJoin<T,TRight,TLeftEnd,TRightEnd,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)ObservableJoin(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)ObservableLastMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableLastMaybe.classObservableLastMaybeObservableLastMaybe<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableLastMaybe(io.reactivex.rxjava3.core.ObservableSource)ObservableLastSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableLastSingle.classObservableLastSingleObservableLastSingle<T>(io.reactivex.rxjava3.core.ObservableSource,java.lang.Object)ObservableLastSingle(io.reactivex.rxjava3.core.ObservableSource,java.lang.Object)ObservableLift<R,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableLift.classObservableLiftObservableLift<R,T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableOperator)ObservableLift(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableOperator)ObservableMap<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMap.classObservableMapObservableMap<T,U>ObservableMap<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableMap(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableMaterialize<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMaterialize.classObservableMaterializeAbstractObservableWithUpstream<T,Notification<T>>ObservableMaterialize<T>(io.reactivex.rxjava3.core.ObservableSource)Observer<? super Notification<T>>Observable<Observable<Notification<T>>>ObservableSource<Observable<Notification<T>>>ObservableConverter<Notification<T>,? extends R>Observable<Timed<Notification<T>>>ObservableSource<Timed<Notification<T>>>Function<? super Notification<T>,? extends ObservableSource<V>>ObservableSource<? extends Notification<T>>ConnectableObservable<Notification<T>>? super Observable<Notification<T>>Function<? super Observable<Notification<T>>,? extends ObservableSource<R>>? extends ObservableSource<? extends Notification<T>>Function<? super Throwable,? extends ObservableSource<? extends Notification<T>>>Observable<Notification<Notification<T>>>ObservableSource<Notification<Notification<T>>>ObservableOperator<? extends R,? super Notification<T>>Function<? super Notification<T>,? extends ObservableSource<TLeftEnd>>BiFunction<? super Notification<T>,? super Observable<TRight>,? extends R>GroupedObservable<K,Notification<T>>Observable<GroupedObservable<K,Notification<T>>>ObservableSource<GroupedObservable<K,Notification<T>>>Function<? super Notification<T>,? extends ObservableSource<? extends U>>Function<? super Notification<T>,? extends ObservableSource<U>>ObservableTransformer<? super Notification<T>,? extends R>Observable<List<Notification<T>>>ObservableSource<List<Notification<T>>>Observable<Notification<T>>()AbstractObservableWithUpstream<T,Notification<T>>(io.reactivex.rxjava3.core.ObservableSource)ObservableMaterialize(io.reactivex.rxjava3.core.ObservableSource)ObservableMergeWithSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMergeWithSingle.classObservableMergeWithSingleObservableMergeWithSingle<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.SingleSource)ObservableMergeWithSingle(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.SingleSource)ObservableMergeWithMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMergeWithMaybe.classObservableMergeWithMaybeObservableMergeWithMaybe<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.MaybeSource)ObservableMergeWithMaybe(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.MaybeSource)ObservableMergeWithCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableMergeWithCompletable.classObservableMergeWithCompletableObservableMergeWithCompletable<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.CompletableSource)ObservableMergeWithCompletable(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.CompletableSource)ObservableObserveOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableObserveOn.classObservableObserveOnObservableObserveOn<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.Scheduler,boolean,int)ObservableObserveOn(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.Scheduler,boolean,int)ObservableOnErrorComplete<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableOnErrorComplete.classObservableOnErrorCompleteObservableOnErrorComplete<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableOnErrorComplete(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableOnErrorNext<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableOnErrorNext.classObservableOnErrorNextObservableOnErrorNext<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableOnErrorNext(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)Function<Throwable,ObservableSource<? extends T>>ObservableOnErrorReturn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableOnErrorReturn.classObservableOnErrorReturnObservableOnErrorReturn<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableOnErrorReturn(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableDetach<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableDetach.classObservableDetachObservableDetach<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableDetach(io.reactivex.rxjava3.core.ObservableSource)ObservablePublish<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservablePublish.classObservablePublishObservablePublish<T>(io.reactivex.rxjava3.core.ObservableSource)ConnectableObservable()ConnectableObservable<T>()ObservablePublish(io.reactivex.rxjava3.core.ObservableSource)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservablePublish$PublishConnection.classObservablePublish$PublishConnectionInnerDisposable[]InnerDisposable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservablePublish$InnerDisposable.classObservablePublish$InnerDisposableObservablePublish<>InnerDisposable<T>[]AtomicReference<InnerDisposable<T>[]>ObservablePublishSelector<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservablePublishSelector.classObservablePublishSelectorObservablePublishSelector<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservablePublishSelector(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableReduceMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableReduceMaybe.classObservableReduceMaybeObservableReduceMaybe<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction)ObservableReduceMaybe(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction)ObservableReduceSeedSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableReduceSeedSingle.classObservableReduceSeedSingleObservableReduceSeedSingle<T,R>(io.reactivex.rxjava3.core.ObservableSource,java.lang.Object,io.reactivex.rxjava3.functions.BiFunction)ObservableReduceSeedSingle(io.reactivex.rxjava3.core.ObservableSource,java.lang.Object,io.reactivex.rxjava3.functions.BiFunction)ObservableReduceWithSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableReduceWithSingle.classObservableReduceWithSingleObservableReduceWithSingle<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)ObservableReduceWithSingle(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)ObservableRepeat<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRepeat.classObservableRepeatObservableRepeat<T>(io.reactivex.rxjava3.core.Observable,long)ObservableRepeat(io.reactivex.rxjava3.core.Observable,long)ObservableRepeatUntil<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRepeatUntil.classObservableRepeatUntilObservableRepeatUntil<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.BooleanSupplier)ObservableRepeatUntil(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.BooleanSupplier)ObservableRepeatWhen<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRepeatWhen.classObservableRepeatWhenObservableRepeatWhen<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableRepeatWhen(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableReplay<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableReplay.classObservableReplaycreateFrom(io.reactivex.rxjava3.core.ObservableSource)ConnectableObservable<>()BufferSupplier<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableReplay$BufferSupplier.classObservableReplay$BufferSuppliercreate(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.internal.operators.observable.ObservableReplay.BufferSupplier)BufferSupplier<T>create(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)create(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)create(io.reactivex.rxjava3.core.ObservableSource,int,boolean)? extends ConnectableObservable<U>Supplier<? extends ConnectableObservable<U>>ReplayObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableReplay$ReplayObserver.classObservableReplay$ReplayObserverAtomicReference<ReplayObserver<T>>Supplier<ConnectableObservable<T>>ObservableRetryBiPredicate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryBiPredicate.classObservableRetryBiPredicateObservableRetryBiPredicate<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.BiPredicate)ObservableRetryBiPredicate(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.BiPredicate)ObservableRetryPredicate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryPredicate.classObservableRetryPredicateObservableRetryPredicate<T>(io.reactivex.rxjava3.core.Observable,long,io.reactivex.rxjava3.functions.Predicate)ObservableRetryPredicate(io.reactivex.rxjava3.core.Observable,long,io.reactivex.rxjava3.functions.Predicate)ObservableRetryWhen<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableRetryWhen.classObservableRetryWhenObservableRetryWhen<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)ObservableRetryWhen(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function)SafeObserver<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/observers/SafeObserver.classSafeObserverSafeObserver<T>SafeObserver<T>(io.reactivex.rxjava3.core.Observer)SafeObserver(io.reactivex.rxjava3.core.Observer)ObservableSampleTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSampleTimed.classObservableSampleTimedObservableSampleTimed<T>(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)ObservableSampleTimed(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)ObservableSampleWithObservable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSampleWithObservable.classObservableSampleWithObservableObservableSampleWithObservable<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,boolean)ObservableSampleWithObservable(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,boolean)ObservableScan<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableScan.classObservableScanObservableScan<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction)ObservableScan(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction)ObservableScanSeed<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableScanSeed.classObservableScanSeedObservableScanSeed<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)ObservableScanSeed(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.BiFunction)ObservableSerialized<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSerialized.classObservableSerializedObservableSerialized<T>(io.reactivex.rxjava3.core.Observable)ObservableSerialized(io.reactivex.rxjava3.core.Observable)ObservableSingleMaybe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSingleMaybe.classObservableSingleMaybeObservableSingleMaybe<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableSingleMaybe(io.reactivex.rxjava3.core.ObservableSource)ObservableSingleSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSingleSingle.classObservableSingleSingleObservableSingleSingle<T>(io.reactivex.rxjava3.core.ObservableSource,java.lang.Object)ObservableSingleSingle(io.reactivex.rxjava3.core.ObservableSource,java.lang.Object)ObservableSkip<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSkip.classObservableSkipObservableSkip<T>(io.reactivex.rxjava3.core.ObservableSource,long)ObservableSkip(io.reactivex.rxjava3.core.ObservableSource,long)ObservableSkipLast<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSkipLast.classObservableSkipLastObservableSkipLast<T>(io.reactivex.rxjava3.core.ObservableSource,int)ObservableSkipLast(io.reactivex.rxjava3.core.ObservableSource,int)ObservableSkipLastTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSkipLastTimed.classObservableSkipLastTimedObservableSkipLastTimed<T>(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)ObservableSkipLastTimed(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)ObservableSkipUntil<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSkipUntil.classObservableSkipUntilObservableSkipUntil<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)ObservableSkipUntil(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)ObservableSkipWhile<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSkipWhile.classObservableSkipWhileObservableSkipWhile<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableSkipWhile(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)Observer<? super List<T>>Observable<Observable<List<T>>>ObservableSource<Observable<List<T>>>ObservableConverter<List<T>,? extends R>Observable<Timed<List<T>>>ObservableSource<Timed<List<T>>>Function<? super List<T>,? extends ObservableSource<V>>ObservableSource<? extends List<T>>ConnectableObservable<List<T>>? super Observable<List<T>>Function<? super Observable<List<T>>,? extends ObservableSource<R>>? extends ObservableSource<? extends List<T>>Function<? super Throwable,? extends ObservableSource<? extends List<T>>>Observable<Notification<List<T>>>ObservableSource<Notification<List<T>>>ObservableOperator<? extends R,? super List<T>>Function<? super List<T>,? extends ObservableSource<TLeftEnd>>BiFunction<? super List<T>,? super Observable<TRight>,? extends R>GroupedObservable<K,List<T>>Observable<GroupedObservable<K,List<T>>>ObservableSource<GroupedObservable<K,List<T>>>Function<? super List<T>,? extends ObservableSource<? extends U>>Function<? super List<T>,? extends ObservableSource<U>>ObservableTransformer<? super List<T>,? extends R>Observable<List<List<T>>>ObservableSource<List<List<T>>>Observable<List<T>>()LambdaObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/LambdaObserver.classLambdaObserverLambdaObserver<T>(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Consumer)LambdaObserver(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action,io.reactivex.rxjava3.functions.Consumer)"The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"The RxJavaPlugins.onSubscribe hook returned a null Observer. Please change the handler provided to RxJavaPlugins.setOnObservableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/PluginsObservableSubscribeOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSubscribeOn.classObservableSubscribeOnObservableSubscribeOn<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.Scheduler)ObservableSubscribeOn(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.Scheduler)ObservableSwitchIfEmpty<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableSwitchIfEmpty.classObservableSwitchIfEmptyObservableSwitchIfEmpty<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)ObservableSwitchIfEmpty(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)ObservableSwitchMap<T,R>ObservableSwitchMap<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int,boolean)ObservableSwitchMapCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableSwitchMapCompletable.classObservableSwitchMapCompletableObservableSwitchMapCompletable<T>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,boolean)ObservableSwitchMapCompletable(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,boolean)ObservableSwitchMapMaybe<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableSwitchMapMaybe.classObservableSwitchMapMaybeObservableSwitchMapMaybe<T,R>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,boolean)ObservableSwitchMapMaybe(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,boolean)ObservableSwitchMapSingle<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/ObservableSwitchMapSingle.classObservableSwitchMapSingleObservableSwitchMapSingle<T,R>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,boolean)ObservableSwitchMapSingle(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function,boolean)ObservableTake<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTake.classObservableTakeObservableTake<T>(io.reactivex.rxjava3.core.ObservableSource,long)ObservableTake(io.reactivex.rxjava3.core.ObservableSource,long)limitObservableIgnoreElements<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableIgnoreElements.classObservableIgnoreElementsObservableIgnoreElements<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableIgnoreElements(io.reactivex.rxjava3.core.ObservableSource)ObservableTakeLastOne<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastOne.classObservableTakeLastOneObservableTakeLastOne<T>(io.reactivex.rxjava3.core.ObservableSource)ObservableTakeLastOne(io.reactivex.rxjava3.core.ObservableSource)ObservableTakeLast<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLast.classObservableTakeLastObservableTakeLast<T>(io.reactivex.rxjava3.core.ObservableSource,int)ObservableTakeLast(io.reactivex.rxjava3.core.ObservableSource,int)ObservableTakeLastTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeLastTimed.classObservableTakeLastTimedObservableTakeLastTimed<T>(io.reactivex.rxjava3.core.ObservableSource,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)ObservableTakeLastTimed(io.reactivex.rxjava3.core.ObservableSource,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,int,boolean)ObservableTakeUntil<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeUntil.classObservableTakeUntilObservableTakeUntil<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)ObservableTakeUntil(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource)ObservableTakeUntilPredicate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeUntilPredicate.classObservableTakeUntilPredicateObservableTakeUntilPredicate<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableTakeUntilPredicate(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableTakeWhile<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTakeWhile.classObservableTakeWhileObservableTakeWhile<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableTakeWhile(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Predicate)ObservableThrottleFirstTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableThrottleFirstTimed.classObservableThrottleFirstTimedObservableThrottleFirstTimed<T>(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)ObservableThrottleFirstTimed(io.reactivex.rxjava3.core.ObservableSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)ObservableThrottleLatest<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableThrottleLatest.classObservableThrottleLatestObservableThrottleLatest<T>(io.reactivex.rxjava3.core.Observable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)ObservableThrottleLatest(io.reactivex.rxjava3.core.Observable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)ObservableTimeInterval<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTimeInterval.classObservableTimeIntervalAbstractObservableWithUpstream<T,Timed<T>>ObservableTimeInterval<T>(io.reactivex.rxjava3.core.ObservableSource,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)Observer<? super Timed<T>>Observable<Observable<Timed<T>>>ObservableSource<Observable<Timed<T>>>ObservableConverter<Timed<T>,? extends R>Observable<Timed<Timed<T>>>ObservableSource<Timed<Timed<T>>>Function<? super Timed<T>,? extends ObservableSource<V>>ObservableSource<? extends Timed<T>>ConnectableObservable<Timed<T>>? super Observable<Timed<T>>Function<? super Observable<Timed<T>>,? extends ObservableSource<R>>? extends ObservableSource<? extends Timed<T>>Function<? super Throwable,? extends ObservableSource<? extends Timed<T>>>Observable<Notification<Timed<T>>>ObservableSource<Notification<Timed<T>>>ObservableOperator<? extends R,? super Timed<T>>Function<? super Timed<T>,? extends ObservableSource<TLeftEnd>>BiFunction<? super Timed<T>,? super Observable<TRight>,? extends R>GroupedObservable<K,Timed<T>>Observable<GroupedObservable<K,Timed<T>>>ObservableSource<GroupedObservable<K,Timed<T>>>Function<? super Timed<T>,? extends ObservableSource<? extends U>>Function<? super Timed<T>,? extends ObservableSource<U>>ObservableTransformer<? super Timed<T>,? extends R>Observable<List<Timed<T>>>ObservableSource<List<Timed<T>>>Observable<Timed<T>>()AbstractObservableWithUpstream<T,Timed<T>>(io.reactivex.rxjava3.core.ObservableSource)ObservableTimeInterval(io.reactivex.rxjava3.core.ObservableSource,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler)ObservableTimeoutTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTimeoutTimed.classObservableTimeoutTimedObservableTimeoutTimed<T>(io.reactivex.rxjava3.core.Observable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.ObservableSource)ObservableTimeoutTimed(io.reactivex.rxjava3.core.Observable,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.ObservableSource)ObservableTimeout<T,U,V>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableTimeout.classObservableTimeoutObservableTimeout<T,U,V>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.core.ObservableSource)ObservableTimeout(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.core.ObservableSource)ObservableToListSingle<T,List<T>>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableToListSingle.classObservableToListSingleFuseToObservable<List<T>>ObservableToListSingle<T,U>ObservableToListSingle<T,U>(io.reactivex.rxjava3.core.ObservableSource,int)ObservableToListSingle(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier)ObservableToListSingle<T,U>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Supplier)ObservableToListSingle(io.reactivex.rxjava3.core.ObservableSource,int)Function<? super T,? extends T>ObservableUnsubscribeOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableUnsubscribeOn.classObservableUnsubscribeOnObservableUnsubscribeOn<T>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.Scheduler)ObservableUnsubscribeOn(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.Scheduler)ObservableWindow<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindow.classObservableWindowAbstractObservableWithUpstream<T,Observable>AbstractObservableWithUpstream<T,Observable<T>>ObservableWindow<T>(io.reactivex.rxjava3.core.ObservableSource,long,long,int)Observer<? super Observable<T>>Function<? super Observable<T>,? extends Stream<? extends R>>Stream<Observable<T>>BaseStream<Observable<T>,Stream<Observable<T>>>CompletionStage<Observable<T>>lastStage(io.reactivex.rxjava3.core.Observable)singleStage(io.reactivex.rxjava3.core.Observable)firstStage(io.reactivex.rxjava3.core.Observable)Collector<? super Observable<T>,A,R>Function<? super Observable<T>,Optional<? extends R>>TestObserver<Observable<T>>BaseTestConsumer<Observable<T>,TestObserver<Observable<T>>>Observer<Observable<T>>MaybeObserver<Observable<T>>SingleObserver<Observable<T>>BiFunction<? super Observable<T>,? super U,? extends R>Function5<? super Observable<T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super Observable<T>,? super T1,? super T2,? super T3,R>Function3<? super Observable<T>,? super T1,? super T2,R>Observable<Observable<Observable<T>>>ObservableSource<Observable<Observable<T>>>List<Observable<T>>Collection<Observable<T>>Iterable<Observable<T>>Single<List<Observable<T>>>SingleSource<List<Observable<T>>>Comparator<? super Observable<T>>Flowable<Observable<T>>Publisher<Observable<T>>Function<? super Observable<T>,? extends K>Function<? super Observable<T>,? extends V>Map<K,Collection<Observable<T>>>Single<Map<K,Collection<Observable<T>>>>SingleSource<Map<K,Collection<Observable<T>>>>Map<K,Observable<T>>Single<Map<K,Observable<T>>>SingleSource<Map<K,Observable<T>>>ObservableConverter<Observable<T>,? extends R>Timed<Observable<T>>Observable<Timed<Observable<T>>>ObservableSource<Timed<Observable<T>>>Function<? super Observable<T>,? extends ObservableSource<V>>? extends Observable<T>ObservableSource<? extends Observable<T>>Predicate<? super Observable<T>>Function<? super Observable<T>,? extends ObservableSource<? extends R>>Function<? super Observable<T>,? extends SingleSource<? extends R>>Function<? super Observable<T>,? extends MaybeSource<? extends R>>Function<? super Observable<T>,? extends CompletableSource>Consumer<? super Observable<T>>Observable[]Observable<T>[]startWithArray(io.reactivex.rxjava3.core.Observable[])startWithItem(io.reactivex.rxjava3.core.Observable)MaybeSource<Observable<T>>SingleSource<Observable<T>>Iterable<? extends Observable<T>>Single<Observable<T>>single(io.reactivex.rxjava3.core.Observable)Maybe<Observable<T>>BiFunction<R,? super Observable<T>,R>BiFunction<Observable<T>,Observable<T>,Observable<T>>ConnectableObservable<Observable<T>>? super Observable<Observable<T>>Function<? super Observable<Observable<T>>,? extends ObservableSource<R>>onErrorReturnItem(io.reactivex.rxjava3.core.Observable)Function<? super Throwable,? extends Observable<T>>? extends ObservableSource<? extends Observable<T>>Function<? super Throwable,? extends ObservableSource<? extends Observable<T>>>MaybeSource<? extends Observable<T>>SingleSource<? extends Observable<T>>Notification<Observable<T>>Observable<Notification<Observable<T>>>ObservableSource<Notification<Observable<T>>>Function<? super Observable<T>,? extends R>ObservableOperator<? extends R,? super Observable<T>>last(io.reactivex.rxjava3.core.Observable)Function<? super Observable<T>,? extends ObservableSource<TLeftEnd>>BiFunction<? super Observable<T>,? super TRight,? extends R>BiFunction<? super Observable<T>,? super Observable<TRight>,? extends R>GroupedObservable<K,Observable<T>>Observable<GroupedObservable<K,Observable<T>>>ObservableSource<GroupedObservable<K,Observable<T>>>Function<? super Observable<T>,? extends Iterable<? extends U>>BiFunction<? super Observable<T>,? super U,? extends V>Function<? super Observable<T>,? extends ObservableSource<? extends U>>first(io.reactivex.rxjava3.core.Observable)elementAt(long,io.reactivex.rxjava3.core.Observable)? super Notification<Observable<T>>Consumer<? super Notification<Observable<T>>>BiPredicate<? super Observable<T>,? super Observable<T>>Function<? super Observable<T>,K>Function<? super Observable<T>,Notification<R>>Function<? super Observable<T>,? extends ObservableSource<U>>defaultIfEmpty(io.reactivex.rxjava3.core.Observable)ObservableTransformer<? super Observable<T>,? extends R>BiConsumer<? super U,? super Observable<T>>Observable<List<Observable<T>>>ObservableSource<List<Observable<T>>>Future<Observable<T>>blockingSingle(io.reactivex.rxjava3.core.Observable)blockingMostRecent(io.reactivex.rxjava3.core.Observable)blockingLast(io.reactivex.rxjava3.core.Observable)blockingFirst(io.reactivex.rxjava3.core.Observable)Observable<Observable<T>>()AbstractObservableWithUpstream<T,Observable<T>>(io.reactivex.rxjava3.core.ObservableSource)ObservableWindow(io.reactivex.rxjava3.core.ObservableSource,long,long,int)ObservableWindowTimed<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowTimed.classObservableWindowTimedObservableWindowTimed<T>(io.reactivex.rxjava3.core.Observable,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,long,int,boolean)ObservableWindowTimed(io.reactivex.rxjava3.core.Observable,long,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,long,int,boolean)ObservableWindowBoundary<T,B>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowBoundary.classObservableWindowBoundaryObservableWindowBoundary<T,B>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,int)ObservableWindowBoundary(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,int)ObservableWindowBoundarySelector<T,U,V>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWindowBoundarySelector.classObservableWindowBoundarySelectorObservableWindowBoundarySelector<T,B,V>Function<? super B,? extends ObservableSource<V>>ObservableWindowBoundarySelector<T,B,V>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int)ObservableWindowBoundarySelector(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.Function,int)ObservableWithLatestFrom<T,U,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWithLatestFrom.classObservableWithLatestFromObservableWithLatestFrom<T,U,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction,io.reactivex.rxjava3.core.ObservableSource)ObservableWithLatestFrom(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.functions.BiFunction,io.reactivex.rxjava3.core.ObservableSource)ObservableWithLatestFromMany<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableWithLatestFromMany.classObservableWithLatestFromManyObservableWithLatestFromMany<T,R>(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource[],io.reactivex.rxjava3.functions.Function)ObservableWithLatestFromMany(io.reactivex.rxjava3.core.ObservableSource,java.lang.Iterable,io.reactivex.rxjava3.functions.Function)ObservableWithLatestFromMany<T,R>(io.reactivex.rxjava3.core.ObservableSource,java.lang.Iterable,io.reactivex.rxjava3.functions.Function)ObservableWithLatestFromMany(io.reactivex.rxjava3.core.ObservableSource,io.reactivex.rxjava3.core.ObservableSource[],io.reactivex.rxjava3.functions.Function)ObservableZipIterable<T,U,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableZipIterable.classObservableZipIterableObservableZipIterable<T,U,V>ObservableZipIterable<T,U,V>(io.reactivex.rxjava3.core.Observable,java.lang.Iterable,io.reactivex.rxjava3.functions.BiFunction)Observer<? super V>TestObserver<V>BaseTestConsumer<V,TestObserver<V>>Observer<V>MaybeObserver<V>SingleObserver<V>Observable<Observable<V>>ObservableSource<Observable<V>>ObservableConverter<V,? extends R>Observable<Timed<V>>ObservableSource<Timed<V>>Function<? super V,? extends ObservableSource<V>>ObservableSource<? extends V>Function<? super V,? extends ObservableSource<? extends R>>ConnectableObservable<V>? super Observable<V>Function<? super Observable<V>,? extends ObservableSource<R>>? extends ObservableSource<? extends V>Function<? super Throwable,? extends ObservableSource<? extends V>>Observable<Notification<V>>ObservableSource<Notification<V>>ObservableOperator<? extends R,? super V>Function<? super V,? extends ObservableSource<TLeftEnd>>BiFunction<? super V,? super Observable<TRight>,? extends R>Function<? super V,? extends ObservableSource<? extends U>>Function<? super V,? extends ObservableSource<U>>ObservableTransformer<? super V,? extends R>Observable<List<V>>ObservableSource<List<V>>Observable<V>()ObservableZipIterable(io.reactivex.rxjava3.core.Observable,java.lang.Iterable,io.reactivex.rxjava3.functions.BiFunction)Optional<Observable<T>>Supplier<? extends Observable<T>>orElse(io.reactivex.rxjava3.core.Observable)Optional<? extends Observable<T>>? extends Optional<? extends Observable<T>>Supplier<? extends Optional<? extends Observable<T>>>Function<? super Observable<T>,? extends Optional<? extends U>>Function<? super Observable<T>,? extends U>Supplier<Observable<T>>Function<T,Observable<T>>Function<V,Observable<T>>ObservableFromCompletionStage<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFromCompletionStage.classObservableFromCompletionStageObservableFromCompletionStage<T>(java.util.concurrent.CompletionStage)ObservableFromCompletionStage(java.util.concurrent.CompletionStage)ObservableFromStream<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFromStream.classObservableFromStreamObservableFromStream<T>(java.util.stream.Stream)subscribeStream(io.reactivex.rxjava3.core.Observer,java.util.stream.Stream)ObservableFromStream(java.util.stream.Stream)ObservableMapOptional<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableMapOptional.classObservableMapOptionalObservableMapOptional<T,R>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function)ObservableMapOptional(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function)ObservableCollectWithCollectorSingle<T,A,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableCollectWithCollectorSingle.classObservableCollectWithCollectorSingleFuseToObservable<R>ObservableCollectWithCollectorSingle<T,A,R>(io.reactivex.rxjava3.core.Observable,java.util.stream.Collector)ObservableCollectWithCollectorSingle(io.reactivex.rxjava3.core.Observable,java.util.stream.Collector)ObservableFirstStageObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFirstStageObserver.classObservableFirstStageObserverObservableStageObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableStageObserver.classObservableStageObserverObservableFirstStageObserver<T>(boolean,java.lang.Object)disposeUpstreamdisposeUpstream()ObservableStageObserver()ObservableStageObserver<T>()ObservableFirstStageObserver(boolean,java.lang.Object)ObservableSingleStageObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableSingleStageObserver.classObservableSingleStageObserverObservableSingleStageObserver<T>(boolean,java.lang.Object)ObservableSingleStageObserver(boolean,java.lang.Object)ObservableLastStageObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableLastStageObserver.classObservableLastStageObserverObservableLastStageObserver<T>(boolean,java.lang.Object)ObservableLastStageObserver(boolean,java.lang.Object)ObservableFlatMapStream<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/ObservableFlatMapStream.classObservableFlatMapStreamObservableFlatMapStream<T,R>(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function)ObservableFlatMapStream(io.reactivex.rxjava3.core.Observable,io.reactivex.rxjava3.functions.Function)The {@code Observable} class is the non-backpressured, optionally multi-valued base reactive class thatoffers factory methods, intermediate operators and the ability to consume synchronousand/or asynchronous reactive dataflows.Many operators in the class accept {@link ObservableSource}(s), the base reactive interfacefor such non-backpressured flows, which {@code Observable} itself implements as well.The {@code Observable}'s operators, by default, run with a buffer size of 128 elements (see {@link Flowable#bufferSize()}),The design of this class was derived from the<a href="https://github.com/reactive-streams/reactive-streams-jvm">Reactive-Streams design and specification</a>by removing any backpressure-related infrastructure and implementation detail, replacing the{@code org.reactivestreams.Subscription} with {@link Disposable} as the primary means to dispose ofa flow.The {@code Observable} follows the protocolwherethe stream can be disposed through the {@code Disposable} instance provided to consumers through{@code Observer.onSubscribe}.Unlike the {@code Observable} of version 1.x, {@link #subscribe(Observer)} does not allow external disposalof a subscription and the {@link Observer} instance is expected to expose such capability.<p>Example:Disposable d = Observable.just("Hello world!").subscribeWith(new DisposableObserver&lt;String&gt;() {// the sequence can now be disposed via dispose()the type of the items emitted by the {@code Observable}io.reactivex.rxjava3.observers.DisposableObserverMirrors the one {@link ObservableSource} in an {@link Iterable} of several {@code ObservableSource}s that first either emits an item or sends<img width="640" height="505" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.amb.png" alt="">When one of the {@code ObservableSource}s signal an item or terminates first, all subscriptions to the other{@code ObservableSource}s are disposed.If any of the losing {@code ObservableSource}s signals an error, the error is routed to the globalan {@code Iterable} of {@code ObservableSource} sources competing to react first. A subscription to each source willMirrors the one {@link ObservableSource} in an array of several {@code ObservableSource}s that first either emits an item or sends<img width="640" height="505" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.ambArray.png" alt="">an array of {@code ObservableSource} sources competing to react first. A subscription to each source willReturns the default 'island' size or capacity-increment hint for unbounded buffers.<p>Delegates to {@link Flowable#bufferSize} but is public for convenience.<em>before</em> the {@link Flowable} class is loaded.the default 'island' size or capacity-increment hintCombines a collection of source {@link ObservableSource}s by emitting an item that aggregates the latest values of each ofthe returned {@code ObservableSource}s each time an item is received from any of the returned {@code ObservableSource}s, where thisresulting sequence terminates immediately (normally or with all the errors accumulated till that point).If the provided iterable of {@code ObservableSource}s is empty, the resulting sequence completes immediately without emittingthe collection of source {@code ObservableSource}sthe aggregation function used to combine the items emitted by the returned {@code ObservableSource}sCombines an {@link Iterable} of source {@link ObservableSource}s by emitting an item that aggregates the latest values of each ofIf the provided {@code Iterable} of {@code ObservableSource}s is empty, the resulting sequence completes immediately without emittingthe expected number of row combination items to be buffered internally the queue holds a pair of values so we need to double the capacityCombines an array of source {@link ObservableSource}s by emitting an item that aggregates the latest values of each ofthe {@code ObservableSource}s each time an item is received from any of the returned {@code ObservableSource}s, where thisIf the provided array of {@code ObservableSource}s is empty, the resulting sequence completes immediately without emittingthe aggregation function used to combine the items emitted by the {@code ObservableSource}sthe {@code ObservableSource}s each time an item is received from any of the {@code ObservableSource}s, where thisCombines two source {@link ObservableSource}s by emitting an item that aggregates the latest values of each of the{@code ObservableSource}s each time an item is received from either of the {@code ObservableSource}s, where thisthe first source {@code ObservableSource}the second source {@code ObservableSource}Combines three source {@link ObservableSource}s by emitting an item that aggregates the latest values of each of the{@code ObservableSource}s each time an item is received from any of the {@code ObservableSource}s, where thisthe third source {@code ObservableSource}Combines four source {@link ObservableSource}s by emitting an item that aggregates the latest values of each of thethe fourth source {@code ObservableSource}Combines five source {@link ObservableSource}s by emitting an item that aggregates the latest values of each of thethe fifth source {@code ObservableSource}Combines six source {@link ObservableSource}s by emitting an item that aggregates the latest values of each of thethe sixth source {@code ObservableSource}Combines seven source {@link ObservableSource}s by emitting an item that aggregates the latest values of each of thethe seventh source {@code ObservableSource}Combines eight source {@link ObservableSource}s by emitting an item that aggregates the latest values of each of thethe eighth source {@code ObservableSource}Combines nine source {@link ObservableSource}s by emitting an item that aggregates the latest values of each of thethe ninth source {@code ObservableSource}{@code source7}, {@code source8}, {@code source9} or {@code combiner} is {@code null}Combines an array of {@link ObservableSource}s by emitting an item that aggregates the latest values of each of<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatestDelayError.v3.png" alt="">all source {@code ObservableSource}s terminate.Combines an {@link Iterable} of {@link ObservableSource}s by emitting an item that aggregates the latest values of each ofthe {@code Iterable} of source {@code ObservableSource}sConcatenates elements of each {@link ObservableSource} provided via an {@link Iterable} sequence into a single sequencethe {@code Iterable} sequence of {@code ObservableSource}sReturns an {@code Observable} that emits the items emitted by each of the {@link ObservableSource}s emitted by the{@code ObservableSource}, one after the other, without interleaving them.an {@code ObservableSource} that emits {@code ObservableSource}sReturns an {@code Observable} that emits the items emitted by each of the {@link ObservableSource}s emitted by the outerthe number of inner {@code ObservableSource}s expected to be buffered.Returns an {@code Observable} that emits the items emitted by two {@link ObservableSource}s, one after the other, withoutan {@code ObservableSource} to be concatenatedReturns an {@code Observable} that emits the items emitted by three {@link ObservableSource}s, one after the other, withoutReturns an {@code Observable} that emits the items emitted by four {@link ObservableSource}s, one after the other, withoutConcatenates a variable number of {@link ObservableSource} sources.Note: named this way because of overload conflict with {@code concat(ObservableSource<ObservableSource>)}<img width="640" height="290" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArray.v3.png" alt="">Concatenates a variable number of {@link ObservableSource} sources and delays errors from any of themConcatenates an array of {@link ObservableSource}s eagerly into a single stream of values.<img width="640" height="411" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png" alt="">{@code ObservableSource}s. The operator buffers the values emitted by these {@code ObservableSource}s and then drains theman array of {@code ObservableSource}s that need to be eagerly concatenatedthe new {@code Observable} instance with the specified concatenation behavior<img width="640" height="495" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.nn.png" alt="">the number of elements expected from each {@code ObservableSource} to be bufferedConcatenates an array of {@link ObservableSource}s eagerly into a single stream of values<img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEagerDelayError.png" alt="">{@code ObservableSource}s. The operator buffers the values emitted by these {@code ObservableSource}s<img width="640" height="460" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEagerDelayError.nn.png" alt="">Concatenates the {@link Iterable} sequence of {@link ObservableSource}s into a single {@code Observable} sequenceby subscribing to each {@code ObservableSource}, one after the other, one at a time and delays any errors tillthe all inner {@code ObservableSource}s terminate.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatDelayError.v3.png" alt="">the new {@code Observable} with the concatenating behaviorConcatenates the {@link ObservableSource} sequence of {@code ObservableSource}s into a single {@code Observable} sequenceby subscribing to each inner {@code ObservableSource}, one after the other, one at a time and delays any errors till theall inner and the outer {@code ObservableSource}s terminate.the {@code ObservableSource} sequence of {@code ObservableSource}sConcatenates the {@link ObservableSource} sequence of {@code ObservableSource}s into a single sequence by subscribing to each inner {@code ObservableSource},one after the other, one at a time and delays any errors till the all inner and the outer {@code ObservableSource}s terminate.the number of inner {@code ObservableSource}s expected to be bufferedif {@code true}, exceptions from the outer and all inner {@code ObservableSource}s are delayed to the endif {@code false}, exception from the outer {@code ObservableSource} is delayed till the active {@code ObservableSource} terminatesConcatenates a sequence of {@link ObservableSource}s eagerly into a single stream of values.<img width="640" height="422" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.i.png" alt="">a sequence of {@code ObservableSource}s that need to be eagerly concatenatedConcatenates a sequence of {@link ObservableSource}s eagerly into a single stream of values and<img width="640" height="379" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.in.png" alt="">the maximum number of concurrently running inner {@code ObservableSource}s; {@link Integer#MAX_VALUE}is interpreted as all inner {@code ObservableSource}s can be active at the same timethe number of elements expected from each inner {@code ObservableSource} to be bufferedConcatenates an {@link ObservableSource} sequence of {@code ObservableSource}s eagerly into a single stream of values.<img width="640" height="495" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.o.png" alt="">emitted source {@code ObservableSource}s as they are observed. The operator buffers the values emitted by these{@code ObservableSource}s and then drains them in order, each one after the previous one completes.Concatenates an {@link ObservableSource} sequence of {@code ObservableSource}s eagerly into a single stream of valuesand runs a limited number of inner sequences at once.<img width="640" height="442" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.on.png" alt="">the number of inner {@code ObservableSource} expected to be bufferedConcatenates a sequence of {@link ObservableSource}s eagerly into a single stream of values,<img width="640" height="428" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.i.png" alt="">delaying errors until all the inner sequences terminate and runs a limited number of inner<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.in.png" alt="">Concatenates an {@link ObservableSource} sequence of {@code ObservableSource}s eagerly into a single stream of values,<img width="640" height="496" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.o.png" alt="">delaying errors until all the inner and the outer sequence terminate and runs a limited number of inner sequences at once.<img width="640" height="421" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.on.png" alt="">Provides an API (via a cold {@code Observable}) that bridges the reactive world with the callback-style world.Observable.&lt;Event&gt;create(emitter -&gt; {Whenever an {@link Observer} subscribes to the returned {@code Observable}, the provided{@link ObservableOnSubscribe} callback is invoked with a fresh instance of an {@link ObservableEmitter}that will interact only with that specific {@code Observer}. If this {@code Observer}disposes the flow (making {@link ObservableEmitter#isDisposed} return {@code true}),other observers subscribed to the same returned {@code Observable} are not affected.<img width="640" height="200" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/create.v3.png" alt="">You should call the {@code ObservableEmitter}'s {@code onNext}, {@code onError} and {@code onComplete} methods in a serialized fashion. Thethe emitter that is called when an {@code Observer} subscribes to the returned {@code Observable}ObservableEmitterReturns an {@code Observable} that calls an {@link ObservableSource} factory to create an {@code ObservableSource} for each new {@link Observer}that subscribes. That is, for each subscriber, the actual {@code ObservableSource} that subscriber observes isThe {@code defer} operator allows you to defer or delay emitting items from an {@code ObservableSource} until such time as an{@code Observer} subscribes to the {@code ObservableSource}. This allows an {@code Observer} to easily obtain updates or athe {@code ObservableSource} factory function to invoke for each {@code Observer} that subscribes to theresulting {@code Observable}the type of the items emitted by the {@code ObservableSource}Returns an {@code Observable} that emits no items to the {@link Observer} and immediately invokes its{@link Observer#onComplete onComplete} method.the type of the items (ostensibly) emitted by the {@code Observable}the shared {@code Observable} instanceReturns an {@code Observable} that invokes an {@link Observer}'s {@link Observer#onError onError} method when the{@code Observer} subscribes to it.<img width="640" height="221" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.supplier.png" alt="">a {@link Supplier} factory to return a {@link Throwable} for each individual {@code Observer}<img width="640" height="221" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.item.png" alt="">the particular {@link Throwable} to pass to {@link Observer#onError onError}Returns an {@code Observable} instance that runs the given {@link Action} for each {@link Observer} and<img width="640" height="287" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromAction.png" alt="">delivered to the downstream via {@link Observer#onError(Throwable)},except when the downstream has canceled the resulting {@code Observable} source.the {@code Action} to run for each {@code Observer}Converts an array into an {@link ObservableSource} that emits the items in the array.the type of items in the array and the type of items to be emitted by the resulting {@code Observable}Returns an {@code Observable} that, when an observer subscribes to it, invokes a function you specify and thenThis allows you to defer the execution of the function you specify until an observer subscribes to the{@code Observable}. That is to say, it makes the function "lazy."except when the downstream has disposed the current {@code Observable} source.{@link RxJavaPlugins#onError(Throwable)} as an {@link UndeliverableException}.function only when an observer subscribes to the {@code Observable} that {@code fromCallable} returnsthe type of the item returned by the {@code Callable} and emitted by the {@code Observable}Wraps a {@link CompletableSource} into an {@code Observable}.<img width="640" height="278" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromCompletable.png" alt="">Converts a {@link Future} into an {@code Observable}.<img width="640" height="284" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.noarg.png" alt="">Unlike 1.x, disposing the {@code Observable} won't cancel the future. If necessary, one can use composition to achieve thecancellation effect: {@code futureObservableSource.doOnDispose(() -> future.cancel(true));}.the resulting {@code Observable}Converts a {@link Future} into an {@code Observable}, with a timeout on the {@code Future}.<img width="640" height="287" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.png" alt="">Converts an {@link Iterable} sequence into an {@code Observable} that emits the items in the sequence.<img width="640" height="187" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromIterable.v3.png" alt="">Returns an {@code Observable} instance that when subscribed to, subscribes to the {@link MaybeSource} instance and<img width="640" height="226" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromMaybe.png" alt="">Converts an arbitrary <em>Reactive Streams</em> {@link Publisher} into an {@code Observable}.<img width="640" height="344" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromPublisher.o.png" alt="">If possible, use {@link #create(ObservableOnSubscribe)} to create asource-like {@code Observable} instead.<dd>The source {@code publisher} is consumed in an unbounded fashion without applying anybackpressure to it.</dd>#create(ObservableOnSubscribe)Returns an {@code Observable} instance that runs the given {@link Runnable} for each {@link Observer} and<img width="640" height="286" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromRunnable.png" alt="">the {@code Runnable} to run for each {@code Observer}Returns an {@code Observable} instance that when subscribed to, subscribes to the {@link SingleSource} instance and<img width="640" height="341" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromSingle.png" alt="">Returns an {@code Observable} that, when an observer subscribes to it, invokes a supplier function you specify and then<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.fromSupplier.v3.png" alt="">function only when an observer subscribes to the {@code Observable} that {@code fromSupplier} returnsthe type of the item emitted by the {@code Observable}Returns a cold, synchronous and stateless generator of values.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/generate.2.v3.png" alt="">the {@link Consumer} called in a loop after a downstream {@link Observer} hassubscribed. The callback then should call {@code onNext}, {@code onError} orReturns a cold, synchronous and stateful generator of values.the type of the per-{@link Observer} statethe {@link Supplier} to generate the initial state for each {@code Observer}the {@link BiConsumer} called in a loop after a downstream {@code Observer} hasterminates the sequence or it gets disposedReturns an {@code Observable} that emits a {@code 0L} after the {@code initialDelay} and ever increasing numbersReturns an {@code Observable} that emits a sequential number every specified interval of time.Returns an {@code Observable} that emits a sequential number every specified interval of time, on a<img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/intervalRange.v3.png" alt="">if {@code count} is negative, or if {@code start} + {@code count} &minus; 1 exceeds<img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/intervalRange.s.v3.png" alt="">     * <dl>the target scheduler where the values and terminal signals will be emittedReturns an {@code Observable} that signals the given (constant reference) item and then completes.<img width="640" height="290" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.item.png" alt="">to generate a single item on demand (when {@link Observer}s subscribe to it).Converts two items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.2.v3.png" alt="">Converts three items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.3.v3.png" alt="">Converts four items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.4.v3.png" alt="">if {@code item1}, {@code item2}, {@code item3} or {@code item4} is {@code null}Converts five items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.5.v3.png" alt="">Converts six items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.6.v3.png" alt="">Converts seven items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.7.v3.png" alt="">Converts eight items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.8.v3.png" alt="">Converts nine items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.9.v3.png" alt="">Converts ten items into an {@code Observable} that emits those items.<img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.10.v3.png" alt="">{@code item7}, {@code item8}, {@code item9}Flattens an {@link Iterable} of {@link ObservableSource}s into one {@code Observable}, without any transformation, while limiting thenumber of concurrent subscriptions to these {@code ObservableSource}s.You can combine the items emitted by multiple {@code ObservableSource}s so that they appear as a single {@code ObservableSource}, by<dd>If any of the returned {@code ObservableSource}s signal a {@link Throwable} via {@code onError}, the resulting{@code Observable} terminates with that {@code Throwable} and all other source {@code ObservableSource}s are disposed.If more than one {@code ObservableSource} signals an error, the resulting {@code Observable} may terminate with thesignaled by source(s) after the returned {@code Observable} has been disposed or terminated with aUse {@link #mergeDelayError(Iterable, int, int)} to merge sources and terminate only when all source {@code ObservableSource}sthe {@code Iterable} of {@code ObservableSource}sthe maximum number of {@code ObservableSource}s that may be subscribed to concurrentlythe number of items expected from each inner {@code ObservableSource} to be bufferedFlattens an array of {@link ObservableSource}s into one {@code Observable}, without any transformation, while limiting the<dd>If any of the {@code ObservableSource}s signal a {@link Throwable} via {@code onError}, the resultingUse {@link #mergeArrayDelayError(int, int, ObservableSource...)} to merge sources and terminate only when all source {@code ObservableSource}sthe array of {@code ObservableSource}s#mergeArrayDelayError(int, int, ObservableSource...)Flattens an {@link Iterable} of {@link ObservableSource}s into one {@code Observable}, without any transformation.Use {@link #mergeDelayError(Iterable)} to merge sources and terminate only when all source {@code ObservableSource}sUse {@link #mergeDelayError(Iterable, int)} to merge sources and terminate only when all source {@code ObservableSource}sFlattens an {@link ObservableSource} that emits {@code ObservableSource}s into a single {@code Observable} that emits the items emitted bythose {@code ObservableSource}s, without any transformation.Use {@link #mergeDelayError(ObservableSource)} to merge sources and terminate only when all source {@code ObservableSource}s#mergeDelayError(ObservableSource)those {@code ObservableSource}s, without any transformation, while limiting the maximum number of concurrentsubscriptions to these {@code ObservableSource}s.Use {@link #mergeDelayError(ObservableSource, int)} to merge sources and terminate only when all source {@code ObservableSource}s#mergeDelayError(ObservableSource, int)Flattens two {@link ObservableSource}s into a single {@code Observable}, without any transformation.You can combine items emitted by multiple {@code ObservableSource}s so that they appear as a single {@code ObservableSource}, byUse {@link #mergeDelayError(ObservableSource, ObservableSource)} to merge sources and terminate only when all source {@code ObservableSource}san {@code ObservableSource} to be merged#mergeDelayError(ObservableSource, ObservableSource)Flattens three {@link ObservableSource}s into a single {@code Observable}, without any transformation.Use {@link #mergeDelayError(ObservableSource, ObservableSource, ObservableSource)} to merge sources and terminate only when all source {@code ObservableSource}s#mergeDelayError(ObservableSource, ObservableSource, ObservableSource)Flattens four {@link ObservableSource}s into a single {@code Observable}, without any transformation.Use {@link #mergeDelayError(ObservableSource, ObservableSource, ObservableSource, ObservableSource)} to merge sources and terminate only when all source {@code ObservableSource}s#mergeDelayError(ObservableSource, ObservableSource, ObservableSource, ObservableSource)Flattens an array of {@link ObservableSource}s into one {@code Observable}, without any transformation.Use {@link #mergeArrayDelayError(ObservableSource...)} to merge sources and terminate only when all source {@code ObservableSource}s#mergeArrayDelayError(ObservableSource...)Flattens an {@link Iterable} of {@link ObservableSource}s into one {@code Observable}, in a way that allows an {@link Observer} to receive allsuccessfully emitted items from each of the returned {@code ObservableSource}s without being interrupted by an errorThis behaves like {@link #merge(ObservableSource)} except that if any of the merged {@code ObservableSource}s notify of anerror via {@link Observer#onError onError}, {@code mergeDelayError} will refrain from propagating thaterror notification until all of the merged {@code ObservableSource}s have finished emitting items.Even if multiple merged {@code ObservableSource}s send {@code onError} notifications, {@code mergeDelayError} will onlyinvoke the {@code onError} method of its {@code Observer}s once.notification from one of them, while limiting the number of concurrent subscriptions to these {@code ObservableSource}s.Flattens an array of {@link ObservableSource}s into one {@code Observable}, in a way that allows an {@link Observer} to receive allsuccessfully emitted items from each of the {@code ObservableSource}s without being interrupted by an errorFlattens an {@link ObservableSource} that emits {@code ObservableSource}s into one {@code Observable}, in a way that allows an {@link Observer} toreceive all successfully emitted items from all of the emitted {@code ObservableSource}s without being interrupted byFlattens two {@link ObservableSource}s into one {@code Observable}, in a way that allows an {@link Observer} to receive allThis behaves like {@link #merge(ObservableSource, ObservableSource)} except that if any of the merged {@code ObservableSource}snotify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrain frompropagating that error notification until all of the merged {@code ObservableSource}s have finished emitting items.Even if both merged {@code ObservableSource}s send {@code onError} notifications, {@code mergeDelayError} will onlyFlattens three {@link ObservableSource}s into one {@code Observable}, in a way that allows an {@link Observer} to receive allsuccessfully emitted items from all of the {@code ObservableSource}s without being interrupted by an errorThis behaves like {@link #merge(ObservableSource, ObservableSource, ObservableSource)} except that if any of the merged{@code ObservableSource}s notify of an error via {@link Observer#onError onError}, {@code mergeDelayError} will refrainfrom propagating that error notification until all of the merged {@code ObservableSource}s have finished emittingFlattens four {@link ObservableSource}s into one {@code Observable}, in a way that allows an {@link Observer} to receive allThis behaves like {@link #merge(ObservableSource, ObservableSource, ObservableSource, ObservableSource)} except that if any ofthe merged {@code ObservableSource}s notify of an error via {@link Observer#onError onError}, {@code mergeDelayError}will refrain from propagating that error notification until all of the merged {@code ObservableSource}s have finishedReturns an {@code Observable} that never sends any items or notifications to an {@link Observer}.The returned {@code Observable} is useful primarily for testing purposes.the type of items (not) emitted by the {@code Observable}Returns an {@code Observable} that emits a sequence of {@link Integer}s within a specified range.Returns an {@code Observable} that emits a sequence of {@link Long}s within a specified range.<img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/rangeLong.png" alt="">Returns a {@link Single} that emits a {@link Boolean} value that indicates whether two {@link ObservableSource} sequences are thesame by comparing the items emitted by each {@code ObservableSource} pairwise.<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.2.v3.png" alt="">the first {@code ObservableSource} to comparethe second {@code ObservableSource} to comparethe type of items emitted by each {@code ObservableSource}same by comparing the items emitted by each {@code ObservableSource} pairwise based on the results of a specifieda function used to compare items emitted by each {@code ObservableSource}the number of items expected from the first and second source {@code ObservableSource} to be bufferedConverts an {@link ObservableSource} that emits {@code ObservableSource}s into an {@code Observable} that emits the items emitted by themost recently emitted of those {@code ObservableSource}s.{@code switchOnNext} subscribes to an {@code ObservableSource} that emits {@code ObservableSource}s. Each time it observes one ofthese emitted {@code ObservableSource}s, the {@code ObservableSource} returned by {@code switchOnNext} begins emitting the itemsemitted by that {@code ObservableSource}. When a new inner {@code ObservableSource} is emitted, {@code switchOnNext} stops emitting itemsfrom the earlier-emitted {@code ObservableSource} and begins emitting items from the new one.The resulting {@code Observable} completes if both the outer {@code ObservableSource} and the last inner {@code ObservableSource}, if any, complete.If the outer {@code ObservableSource} signals an {@code onError}, the inner {@code ObservableSource} is disposed and the error delivered in-sequence.the {@code ObservableSource} that emits {@code ObservableSource}sthe expected number of items to cache from the inner {@code ObservableSource}smost recently emitted of those {@code ObservableSource}s and delays any exception until all {@code ObservableSource}s terminate.<img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.v3.png" alt="">The resulting {@code Observable} completes if both the main {@code ObservableSource} and the last inner {@code ObservableSource}, if any, complete.If the main {@code ObservableSource} signals an {@code onError}, the termination of the last inner {@code ObservableSource} will emit that error as isor wrapped into a {@link CompositeException} along with the other possible errors the former inner {@code ObservableSource}s signaled.Returns an {@code Observable} that emits {@code 0L} after a specified delay, and then completes.Returns an {@code Observable} that emits {@code 0L} after a specified delay, on a specified {@link Scheduler}, and thenCreate an {@code Observable} by wrapping an {@link ObservableSource} <em>which has to be implemented accordingto the {@code Observable} specification derived from the <b>Reactive Streams</b> specification by handlingdisposal correctly; no safeguards are provided by the {@code Observable} itself</em>.the {@code ObservableSource} instance to wrapif the {@code onSubscribe} is already an {@code Observable}, use{@link #wrap(ObservableSource)} in this case#wrap(ObservableSource)Constructs an {@code Observable} that creates a dependent resource object, an {@link ObservableSource} withdownstream disposes the flow.the element type of the generated {@code Observable}the factory function to create a resource object that depends on the {@code ObservableSource}the factory function to create an {@code ObservableSource}that resource and calls the provided {@code disposer} function if this inner source terminates or thethe element type of the generated {@code ObservableSource}If {@code true}, the resource disposal will happen either on a {@code dispose()} call before the upstream is disposedIf {@code false}, the resource disposal will happen either on a {@code dispose()} call after the upstream is disposedif {@code resourceSupplier}, {@code sourceSupplier} and {@code resourceCleanup} is {@code null}Wraps an {@link ObservableSource} into an {@code Observable} if not already an {@code Observable}.the {@code ObservableSource} instance to wrap or cast to {@code Observable}the new {@code Observable} instance or the same as the sourceReturns an {@code Observable} that emits the results of a specified combiner function applied to combinations ofitems emitted, in sequence, by an {@link Iterable} of other {@link ObservableSource}s.{@code zip} applies this function in strict sequence, so the first item emitted by the resulting {@code Observable}will be the result of the function applied to the first item emitted by each of the {@code ObservableSource}s;the second item emitted by the resulting {@code Observable} will be the result of the function applied to the seconditem emitted by each of those {@code ObservableSource}s; and so forth.The resulting {@code Observable<R>} returned from {@code zip} will invoke {@code onNext} as many times asthe number of {@code onNext} invocations of the {@code ObservableSource} that emits the fewest items.The operator subscribes to its sources in order they are specified and completes eagerly ifone of the sources is shorter than the rest while disposing the other sources. Therefore, itbe sending further values and it will dispose B immediately. For example:use {@link #doOnDispose(Action)} as well or use {@code using()} to do cleanup in case of completionor a dispose() call.an {@code Iterable} of source {@code ObservableSource}sa function that, when applied to an item emitted by each of the {@code ObservableSource}s, results inan item that will be emitted by the resulting {@code Observable}<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipIterable.o.v3.png" alt="">delay errors signaled by any of the {@code ObservableSource} until all {@code ObservableSource}s terminatethe number of elements expected from each source {@code ObservableSource} to be bufferedtwo items emitted, in sequence, by two other {@link ObservableSource}s.emitted by {@code o2}; the second item emitted by the resulting {@code Observable} will be the result of the functionThe resulting {@code Observable<R>} returned from {@code zip} will invoke {@link Observer#onNext onNext}as many times as the number of {@code onNext} invocations of the {@code ObservableSource} that emits the fewesta second source {@code ObservableSource}a function that, when applied to an item emitted by each of the {@code ObservableSource}s, resultsin an item that will be emitted by the resulting {@code Observable}delay errors from any of the {@code ObservableSource}s till the other terminatesthree items emitted, in sequence, by three other {@link ObservableSource}s.emitted by {@code o2}, and the first item emitted by {@code o3}; the second item emitted by the resulting{@code Observable} will be the result of the function applied to the second item emitted by {@code o1}, thea third source {@code ObservableSource}four items emitted, in sequence, by four other {@link ObservableSource}s.a fourth source {@code ObservableSource}five items emitted, in sequence, by five other {@link ObservableSource}s.the first item emitted by {@code o5}; the second item emitted by the resulting {@code Observable} will be the result ofthe function applied to the second item emitted by each of those {@code ObservableSource}s; and so forth.a fifth source {@code ObservableSource}six items emitted, in sequence, by six other {@link ObservableSource}s.will be the result of the function applied to the first item emitted by each source {@code ObservableSource}, thesecond item emitted by the resulting {@code Observable} will be the result of the function applied to the second itememitted by each of those {@code ObservableSource}s, and so forth.a sixth source {@code ObservableSource}seven items emitted, in sequence, by seven other {@link ObservableSource}s.a seventh source {@code ObservableSource}eight items emitted, in sequence, by eight other {@link ObservableSource}s.an eighth source {@code ObservableSource}nine items emitted, in sequence, by nine other {@link ObservableSource}s.a ninth source {@code ObservableSource}items emitted, in sequence, by an array of other {@link ObservableSource}s.<pre><code>zip(new ObservableSource[]{range(1, 5).doOnComplete(action1), range(6, 5).doOnComplete(action2)}, (a) -&gt;<img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipArray.o.v3.png" alt="">an array of source {@code ObservableSource}s{@code Observable} satisfy a condition.<img width="640" height="265" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.o.png" alt="">Mirrors the current {@code Observable} or the other {@link ObservableSource} provided of which the first either emits an item or sends a termination<img width="640" height="448" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.ambWith.png" alt="">When the current {@code Observable} signals an item or terminates first, the subscription to the other{@code ObservableSource} is disposed. If the other {@code ObservableSource} signals an item or terminates first,the subscription to the current {@code Observable} is disposed.If the losing {@code ObservableSource} signals an error, the error is routed to the globalan {@code ObservableSource} competing to react first. A subscription to this provided source will occur afterReturns a {@link Single} that emits {@code true} if any item emitted by the current {@code Observable} satisfies acurrent {@code Observable} is empty.<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/any.2.v3.png" alt="">In Rx.Net this is the {@code any} {@link Observer} but we renamed it in RxJava to better match Java namingthe condition to test items emitted by the current {@code Observable}Returns the first item emitted by the current {@code Observable}, or throws<img width="640" height="413" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingFirst.o.png" alt="">the first item emitted by the current {@code Observable}if the current {@code Observable} emits no itemsReturns the first item emitted by the current {@code Observable}, or a default value if it emits no<img width="640" height="329" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingFirst.o.default.png" alt="">a default value to return if the current {@code Observable} emits no itemsthe first item emitted by the current {@code Observable}, or the default value if it emits noConsumes the current {@code Observable} in a blocking fashion and invokes the given<img width="640" height="330" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingForEach.o.v3.png" alt="">the {@code Consumer} to invoke for each item emitted by the {@code Observable}if an error occursthe number of items expected to be buffered (allows reducing buffer reallocations)Exposes the current {@code Observable} as an {@link Iterable} which, when iterated,subscribes to the current {@code Observable} and blocksuntil the current {@code Observable} emits items or terminates.<img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.v3.png" alt="">the expected number of items to be bufferedReturns the last item emitted by the current {@code Observable}, or throws{@link NoSuchElementException} if the current {@code Observable} emits no items.<img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLast.o.v3.png" alt="">the last item emitted by the current {@code Observable}Returns the last item emitted by the current {@code Observable}, or a default value if it emits no<img width="640" height="310" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLastDefault.o.v3.png" alt="">the last item emitted by the {@code Observable}, or the default value if it emits noReturns an {@link Iterable} that returns the latest item emitted by the current {@code Observable},<img width="640" height="350" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLatest.o.png" alt="">If the current {@code Observable} produces items faster than {@code Iterator.next} takes them,Returns an {@link Iterable} that always returns the item most recently emitted by the current{@code Observable}.<img width="640" height="426" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingMostRecent.o.v3.png" alt="">the initial value that the {@code Iterable} sequence will yield if the current{@code Observable} has not yet emitted an itemReturns an {@link Iterable} that blocks until the current {@code Observable} emits another item, then<img width="640" height="427" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingNext.o.v3.png" alt="">If the current {@code Observable} completes after emitting a single item, return that item, otherwise<img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingle.o.v3.png" alt="">the single item emitted by the current {@code Observable}If the current {@code Observable} completes after emitting a single item, return that item; if it emits<img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingleDefault.o.v3.png" alt="">the single item emitted by the current {@code Observable}, or the default value if it emits noReturns a {@link Future} representing the only value emitted by the current {@code Observable}.<img width="640" height="299" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png" alt="">If the {@code Observable} emits more than one item, {@code Future} will receive an{@link IndexOutOfBoundsException}. If the {@code Observable} is empty, {@code Future}will receive an {@link NoSuchElementException}. The {@code Observable} source has to terminate in orderIf the {@code Observable} may emit more than one item, use {@code Observable.toList().toFuture()}.Runs the current {@code Observable} to a terminal event, ignoring any values and rethrowing any exception.<img width="640" height="270" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png" alt=""><img width="640" height="394" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png" alt="">If the {@code Observable} emits an error, it is wrapped into an<img width="640" height="397" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png" alt=""><img width="640" height="394" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png" alt="">Subscribes to the source and calls the {@link Observer} methods <strong>on the current thread</strong>.normally, with an error or the {@code Observer} disposes the {@link Disposable} it receives via{@link Observer#onSubscribe(Disposable)}.The a dispose() call is composed through.the {@code Observer} instance to forward events and calls to in the current threadReturns an {@code Observable} that emits buffers of items it collects from the current {@code Observable}. The resulting{@code Observable} emits connected, non-overlapping buffers, each containing {@code count} items. When the current{@code Observable} completes, the resulting {@code Observable} emits the current buffer and propagates the notificationfrom the current {@code Observable}. Note that if the current {@code Observable} issues an {@code onError} notification{@code Observable} emits buffers every {@code skip} items, each containing {@code count} items. When the currenthow many items emitted by the current {@code Observable} should be skipped before starting a new{@code Observable} starts a new buffer periodically, as determined by the {@code timeskip} argument. It emits{@code Observable} starts a new buffer periodically, as determined by the {@code timeskip} argument, and on the{@code timespan} argument. When the current {@code Observable} completes, the resulting {@code Observable} emits thecurrent buffer and propagates the notification from the current {@code Observable}. Note that if the current{@code Observable} issues an {@code onError} notification the event is passed on immediately without first emitting the{@code Observable} emits connected, non-overlapping buffers, each of a fixed duration specified by thefirst). When the current {@code Observable} completes, the resulting {@code Observable} emits the current buffer andpropagates the notification from the current {@code Observable}. Note that if the current {@code Observable} issues an{@code onError} notification the event is passed on immediately without first emitting the buffer it is in the process ofthe {@code count} argument (whichever is reached first). When the current {@code Observable} completes, the resulting{@code Observable} emits the current buffer and propagates the notification from the current {@code Observable}. Notethat if the current {@code Observable} issues an {@code onError} notification the event is passed on immediately withoutfirst emitting the buffer it is in the process of assembling.{@code timespan} argument and on the specified {@code scheduler}. When the current {@code Observable} completes,the resulting {@code Observable} emits the current buffer and propagates the notification from the current{@code Observable}. Note that if the current {@code Observable} issues an {@code onError} notification the event is passed on{@code Observable} emits buffers that it creates when the specified {@code openingIndicator} {@link ObservableSource} emits anitem, and closes when the {@code ObservableSource} returned from {@code closingIndicator} emits an item. If any of thecurrent {@code Observable}, {@code openingIndicator} or {@code closingIndicator} issues an {@code onError} notification theevent is passed on immediately without first emitting the buffer it is in the process of assembling.the element type of the buffer-opening {@code ObservableSource}the element type of the individual buffer-closing {@code ObservableSource}sthe {@code ObservableSource} that, when it emits an item, causes a new buffer to be createdthe {@link Function} that is used to produce an {@code ObservableSource} for every buffer created. When this indicator{@code ObservableSource} emits an item, the associated buffer is emitted.Returns an {@code Observable} that emits non-overlapping buffered items from the current {@code Observable} each time thespecified boundary {@link ObservableSource} emits an item.Completion of either the source or the boundary {@code ObservableSource} causes the returned {@code ObservableSource} to emit thelatest buffer and complete. If either the current {@code Observable} or the boundary {@code ObservableSource} issues anthe boundary {@code ObservableSource}#buffer(ObservableSource, int)#buffer(ObservableSource)Returns an {@code Observable} that subscribes to the current {@code Observable} lazily, caches all of its eventsand replays them, in the same order as received, to all the downstream observers.This is useful when you want an {@code Observable} to cache responses and you can't control thesubscribe/dispose behavior of all the {@link Observer}s.The operator subscribes only when the first downstream observer subscribes and maintainsa single subscription towards the current {@code Observable}. In contrast, the operator family of {@link #replay()}that return a {@link ConnectableObservable} require an explicit call to {@link ConnectableObservable#connect()}.<em>Note:</em> You sacrifice the ability to dispose the origin when you use the {@code cache}operator so be careful not to use this operator on {@code Observable}s that emit an infinite or very large numberA possible workaround is to apply {@code takeUntil} with a predicate or#takeUntil(ObservableSource)<img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cacheWithInitialCapacity.o.v3.png" alt="">A possible workaround is to apply `takeUntil` with a predicate or{@link #replay(int)} in combination with {@link ConnectableObservable#autoConnect()} or similar.Returns an {@code Observable} that emits the items emitted by the current {@code Observable}, converted to the specifiedthe target class type that {@code cast} will cast the items emitted by the current {@code Observable}into before emitting them from the resulting {@code Observable}Collects items emitted by the finite source {@code Observable} into a single mutable data structure and returns<img width="640" height="330" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collect.2.v3.png" alt="">a function that accepts the {@code state} and an emitted item, and modifies the accumulator accordingly<img width="640" height="330" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.v3.png" alt="">Transform the current {@code Observable} by applying a particular {@link ObservableTransformer} function to it.This method operates on the {@code Observable} itself whereas {@link #lift} operates on the {@link ObservableSource}'s{@link Observer}s.If the operator you are creating is designed to act on the individual items emitted by the current{@code Observable}, use {@link #lift}. If your operator is designed to transform the current {@code Observable} as a wholethe value type of the output {@code ObservableSource}implements the function that transforms the current {@code Observable}Returns a new {@code Observable} that emits items resulting from applying a function that you supply to each itememitted by the current {@code Observable}, where that function returns an {@link ObservableSource}, and then emitting the itemsthat result from concatenating those returned {@code ObservableSource}s.the type of the inner {@code ObservableSource} sources and thus the output typea function that, when applied to an item emitted by the current {@code Observable}, returns an{@code ObservableSource}the number of elements expected from the current {@code Observable} to be bufferedMaps each of the items into an {@link ObservableSource}, subscribes to them one after the other,while delaying any error from either this or any of the inner {@code ObservableSource}s<img width="640" height="348" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png" alt="">the function that maps the items of the current {@code Observable} into the inner {@code ObservableSource}s.the new {@code Observable} instance with the concatenation behaviorif {@code true}, all errors from the outer and inner {@code ObservableSource} sources are delayed until the end,if {@code false}, an error from the main source is signaled when the current {@code Observable} source terminatesMaps a sequence of values into {@link ObservableSource}s and concatenates these {@code ObservableSource}s eagerly into a single{@code Observable} sequence.current {@code Observable}s. The operator buffers the values emitted by these {@code ObservableSource}s and then drains them in<img width="640" height="361" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png" alt="">the function that maps a sequence of values into a sequence of {@code ObservableSource}s that will bethe maximum number of concurrent subscribed {@code ObservableSource}shints about the number of expected items from each inner {@code ObservableSource}, must be positive<img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png" alt="">if {@code true}, exceptions from the current {@code Observable} and all the inner {@code ObservableSource}s are delayed untilall of them terminate, if {@code false}, exception from the current {@code Observable} is delayed until thecurrently running {@code ObservableSource} terminatesthe number of elements expected from the current {@code Observable} and each inner {@code ObservableSource} to be bufferedMaps each element of the current {@code Observable} into {@link CompletableSource}s, subscribes to them one at a time inorder and waits until the upstream and all {@code CompletableSource}s complete.<img width="640" height="506" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png" alt=""><p>History: 2.1.6 - experimentala function that, when applied to an item emitted by the current {@code Observable}, returns a {@code CompletableSource}the number of upstream items expected to be buffered until the current {@code CompletableSource}, mapped fromthe current item, completes.other terminates, delaying all errors till both the current {@code Observable} and allother terminates, optionally delaying all errors till both the current {@code Observable} and allIf {@code true}, errors from the current {@code Observable} or any of theof them terminate. If {@code false}, an error from the current{@code Observable} is delayed until the current innerThe number of upstream items expected to be buffered so that fresh items areReturns an {@code Observable} that concatenate each item emitted by the current {@code Observable} with the values in an<img width="640" height="275" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png" alt="">the type of item emitted by the resulting {@code Observable}current {@code Observable}either the current {@code Observable} or the current inner {@code MaybeSource} fail.till both the current {@code Observable} and all inner {@code MaybeSource}s terminate.either the current {@code Observable} or the current inner {@code SingleSource} fail.till both the current {@code Observable} and all inner {@code SingleSource}s terminate.other succeeds or fails, emits their success values and optionally delays  errorsReturns an {@code Observable} that first emits the items emitted from the current {@code Observable}, then itemsfrom the {@code other} {@link ObservableSource} without interleaving them.an {@code ObservableSource} to be concatenated after the currentReturns an {@code Observable} that emits the items from the current {@code Observable} followed by the success item or error eventof the {@code other} {@link SingleSource}.the {@code SingleSource} whose signal should be emitted after the current {@code Observable} completes normally.Returns an {@code Observable} that emits the items from the current {@code Observable} followed by the success item or terminal eventsthe {@code MaybeSource} whose signal should be emitted after the current {@code Observable} completes normally.Returns an {@code Observable} that emits items from the current {@code Observable} and when it completes normally, theother {@link CompletableSource} is subscribed to and the returned {@code Observable} emits its terminal events.the {@code CompletableSource} to subscribe to once the current {@code Observable} completes normallyReturns a {@link Single} that emits a {@link Boolean} that indicates whether the current {@code Observable} emitted a<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/contains.2.v3.png" alt="">the item to search for in the emissions from the current {@code Observable}Returns a {@link Single} that counts the total number of items emitted by the current {@code Observable} and emits<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/count.2.v3.png" alt="">Returns an {@code Observable} that mirrors the current {@code Observable}, except that it drops items emitted by thecurrent {@code Observable} that are followed by another item within a computed debounce durationdenoted by an item emission or completion from a generated inner {@link ObservableSource} for that original item.signal of the generated {@code ObservableSource} sequence,generated sequence to get disposed, which may also interrupt any downstream blocking operationfunction to return a sequence that indicates the throttle duration for each item via its own emission or completioncurrent {@code Observable} that are followed by newer items before a timeout value expires. The timer resets on<em>Note:</em> If items keep being emitted by the current {@code Observable} faster than the timeout then no itemswill be emitted by the resulting {@code Observable}.{@code Observable} in which the {@code Observable} emits no items in order for the item to be emitted by thecurrent {@code Observable} that are followed by newer items before a timeout value expires on a specifiedthe time each item has to be "the most recent" of those emitted by the current {@code Observable} toReturns an {@code Observable} that emits the items emitted by the current {@code Observable} or a specified default itemif the current {@code Observable} is empty.the item to emit if the current {@code Observable} emits no itemsReturns an {@code Observable} that delays the emissions of the current {@code Observable} viaa per-item derived {@link ObservableSource}'s item emission or termination, on a per source item basis.<em>Note:</em> the resulting {@code Observable} will immediately propagate any {@code onError} notificationfrom the current {@code Observable}.a function that returns an {@code ObservableSource} for each item emitted by the current {@code Observable}, which isthen used to delay the emission of that item by the resulting {@code Observable} until the {@code ObservableSource}Returns an {@code Observable} that emits the items emitted by the current {@code Observable} shifted forward in time by aspecified delay. An error notification from the current {@code Observable} is not delayed.#delay(long, TimeUnit, boolean)Returns an {@code Observable} that delays the subscription to and emissions from the current {@code Observable} via{@link ObservableSource}s for the subscription itself and on a per-item basis.a function that returns an {@code ObservableSource} that triggers the subscription to the current {@code Observable}if {@code subscriptionIndicator} or {@code itemDelayIndicator} is {@code null}Returns an {@code Observable} that delays the subscription to the current {@code Observable}until the other {@link ObservableSource} emits an element or completes normally.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.o.v3.png" alt="">the value type of the other {@code Observable}, irrelevantthe other {@code ObservableSource} that should trigger the subscriptionto the current {@code Observable}.Returns an {@code Observable} that delays the subscription to the current {@code Observable} by a given amount of time.Returns an {@code Observable} that delays the subscription to the current {@code Observable} by a given amount of time,Returns an {@code Observable} that reverses the effect of {@link #materialize materialize} by transforming theinto their respective {@link Observer} signal types.returned {@code Observable} disposes of the flow and terminates with that type of terminal event:Observable.just(createOnNext(1), createOnComplete(), createOnNext(2)).doOnDispose(() -&gt; System.out.println("Disposed!"));Observable.just(createOnNext(1), createOnNext(2))If this behavior is not desired, the completion can be suppressed by applying {@link #concatWith(ObservableSource)}the corresponding {@code Observer} event to the downstream.Returns an {@code Observable} that emits all items emitted by the current {@code Observable} that are distinctIt is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()}and {@link Object#hashCode()} to provide meaningful comparison between items as the default Javaimplementation only considers reference equivalence.By default, {@code distinct()} uses an internal {@link HashSet} per {@link Observer} to rememberNote that this internal {@code HashSet} may grow unbounded as items won't be removed from it byReturns an {@code Observable} that emits all items emitted by the current {@code Observable} that are distinct accordingIt is recommended the keys' class {@code K} overrides the default {@code Object.equals()}and {@link Object#hashCode()} to provide meaningful comparison between the key objects as the defaultJava implementation only considers reference equivalence.Note that this internal {@code HashSet} may grow unbounded as keys won't be removed from it byand {@link Object#hashCode()}  to provide meaningful comparison between the key objects asthe default Java implementation only considers reference equivalence.function called for each individual {@link Observer} to return a {@link Collection} subtype for holding the extractedkeys and whose {@code add()} method's return indicates uniqueness.Returns an {@code Observable} that emits all items emitted by the current {@code Observable} that are distinct from theirmeaningful comparison between items as the default Java implementation only considers reference equivalence.meaningful comparison between the key objects as the default Java implementation only considers reference equivalence.Calls the specified {@link Consumer} with the current item after this item has been emitted to the downstream.Note that the {@code onAfterNext} action is shared between subscriptions and as such<img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterNext.o.v3.png" alt=""><dd>This operator supports boundary-limited synchronous or asynchronous queue-fusion.</dd>Registers an {@link Action} to be called when the current {@code Observable} invokes either{@link Observer#onComplete onComplete} or {@link Observer#onError onError}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterTerminate.v3.png" alt="">an {@code Action} to be invoked after the current {@code Observable} finishesCalls the specified action after the current {@code Observable} signals {@code onError} or {@code onCompleted} or gets disposed by<p>In case of a race between a terminal event and a dispose call, the provided {@code onFinally} action<img width="640" height="282" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png" alt="">the action called when the current {@code Observable} terminates or gets disposedCalls the given shared {@link Action} if the downstream disposes the sequence.threads; the action must be thread safe.If the action throws a runtime exception, that exception is rethrown by the {@code dispose()} call,<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnDispose.v3.png" alt="">the action that gets called when the current {@code Observable}'s {@link Disposable} is disposedReturns an {@code Observable} that invokes an {@link Action} when the current {@code Observable} calls {@code onComplete}.<img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.v3.png" alt="">the action to invoke when the current {@code Observable} calls {@code onComplete}Calls the appropriate {@code onXXX} consumer (shared between all {@link Observer}s) whenever a signal with the same typepasses through, before forwarding them to the downstream.Returns an {@code Observable} that invokes a {@link Consumer} with the appropriate {@link Notification}object when the current {@code Observable} signals an item or terminates.the action to invoke for each item emitted by the current {@code Observable}Returns an {@code Observable} that forwards the items and terminal events of the current{@code Observable} to its {@link Observer}s and to the given shared {@code Observer} instance.In case the {@code onError} of the supplied observer throws, the downstream will receive a composite{@code onNext} or the {@code onComplete} method of the supplied observer throws, the downstream will bethe observer to be notified about {@code onNext}, {@code onError} and {@code onComplete} events on itsrespective methods before the actual downstream {@code Observer} gets notified.Calls the given {@link Consumer} with the error {@link Throwable} if the current {@code Observable} failed before forwarding it to<img width="640" height="355" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.v3.png" alt="">the action to invoke if the current {@code Observable} calls {@code onError}Calls the appropriate {@code onXXX} method (shared between all {@link Observer}s) for the lifecycle events of<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnLifecycle.o.v3.png" alt="">a {@link Consumer} called with the {@link Disposable} sent via {@link Observer#onSubscribe(Disposable)}Calls the given {@link Consumer} with the value emitted by the current {@code Observable} before forwarding it to the downstream.<img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnNext.o.v3.png" alt="">the action to invoke when the current {@code Observable} calls {@code onNext}Returns an {@code Observable} so that it invokes the given {@link Consumer} when the current {@code Observable} is subscribed fromits {@link Observer}s. Each subscription will result in an invocation of the given action except when thecurrent {@code Observable} is reference counted, in which case the current {@code Observable} will invokethe given action for the first subscription.the {@code Consumer} that gets called when an {@code Observer} subscribes to the current {@code Observable}Returns an {@code Observable} so that it invokes an action when the current {@code Observable} calls {@code onComplete} or{@code onError}.<img width="640" height="327" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png" alt="">the action to invoke when the current {@code Observable} calls {@code onComplete} or {@code onError}the current {@code Observable} or completes if the current {@code Observable} signals fewer elements than index.<img width="640" height="363" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png" alt="">the current {@code Observable}, or a default item if that index is out of range.<img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png" alt="">Returns a {@link Single} that emits the item found at a specified index in a sequence of emissions from the current {@code Observable}or signals a {@link NoSuchElementException} if the current {@code Observable} signals fewer elements than index.<img width="640" height="362" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png" alt="">Filters items emitted by the current {@code Observable} by only emitting those that satisfy a specified {@link Predicate}.a function that evaluates each item emitted by the current {@code Observable}, returning {@code true}Returns a {@link Maybe} that emits only the very first item emitted by the current {@code Observable}, orcompletes if the current {@code Observable} is empty.Returns a {@link Single} that emits only the very first item emitted by the current {@code Observable}, or a default itemif the current {@code Observable} completes without emitting any items.the default item to emit if the current {@code Observable} doesn't emit anythingReturns a {@link Single} that emits only the very first item emitted by the current {@code Observable} orsignals a {@link NoSuchElementException} if the current {@code Observable} is empty.<img width="640" height="435" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png" alt="">Returns an {@code Observable} that emits items based on applying a function that you supply to each item emittedby the current {@code Observable}, where that function returns an {@link ObservableSource}, and then merging those returned{@code ObservableSource}s and emitting the results of this merger.the value type of the inner {@code ObservableSource}s and the output type<img width="640" height="356" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png" alt="">if {@code true}, exceptions from the current {@code Observable} and all inner {@code ObservableSource}s are delayed until all of them terminate{@code ObservableSource}s and emitting the results of this merger, while limiting the maximum number of concurrent<img width="640" height="442" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png" alt="">Returns an {@code Observable} that applies a function to each item emitted or notification raised by the current{@code Observable} and then flattens the {@link ObservableSource}s returned from these functions and emits the resulting items.a function that returns an {@code ObservableSource} to merge for each item emitted by the current {@code Observable}a function that returns an {@code ObservableSource} to merge for an {@code onError} notification from the current{@code Observable}a function that returns an {@code ObservableSource} to merge for an {@code onComplete} notification from the currentif {@code onNextMapper} or {@code onErrorMapper} or {@code onCompleteSupplier} is {@code null}{@code Observable} and then flattens the {@link ObservableSource}s returned from these functions and emits the resulting items,while limiting the maximum number of concurrent subscriptions to these {@code ObservableSource}s.Returns an {@code Observable} that emits the results of a specified function to the pair of values emitted by thecurrent {@code Observable} and the mapped inner {@link ObservableSource}.the type of items emitted by the collection {@code ObservableSource}the type of items emitted by the resulting {@code Observable}a function that returns an {@code ObservableSource} for each item emitted by the current {@code Observable}a function that combines one item emitted by each of the source and collection {@code ObservableSource}s andreturns an item to be emitted by the resulting {@code Observable}current {@code Observable} and the mapped inner {@link ObservableSource}, while limiting the maximum number of concurrentthe number of elements expected from the inner {@code ObservableSource} to be bufferedMaps each element of the current {@code Observable} into {@link CompletableSource}s, subscribes to them and<img width="640" height="424" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletable.o.png" alt=""><img width="640" height="362" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletableDelayError.o.png" alt="">if {@code true}, errors from the upstream and inner {@code CompletableSource}s are delayed until all of themterminate.the current {@code Observable} into a single {@code Observable} sequence.<img width="640" height="343" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.o.png" alt="">the current {@code Observable} into a single {@code Observable} sequence where the resulting items will<img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.o.r.png" alt="">a function that returns an item based on the item emitted by the current {@code Observable} and thenext item of the {@code Iterable} returned for that original item by the {@code mapper}Maps each element of the current {@code Observable} into {@link MaybeSource}s, subscribes to all of themand merges their {@code onSuccess} values, in no particular order, into a single {@code Observable} sequence.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaybe.v3.png" alt="">Maps each element of the current {@code Observable} into {@link MaybeSource}s, subscribes to themand merges their {@code onSuccess} values, in no particular order, into a single {@code Observable} sequence,optionally delaying all errors.if {@code true}, errors from the upstream and inner {@code MaybeSource}s are delayed until all of themMaps each element of the current {@code Observable} into {@link SingleSource}s, subscribes to all of them<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapSingle.v3.png" alt="">Maps each element of the current {@code Observable} into {@link SingleSource}s, subscribes to themif {@code true}, errors from the upstream and inner {@code SingleSource}s are delayed until each of themSubscribes to the {@link ObservableSource} and calls a {@link Consumer} for each item of the current {@code Observable}on its emission thread.<img width="640" height="264" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEach.o.png" alt="">the {@code Consumer} to execute for each item.a {@link Disposable} that allows disposing the sequence if the current {@code Observable} runs asynchronouslySubscribes to the {@link ObservableSource} and calls a {@link Predicate} for each item of the current {@code Observable},on its emission thread, until the predicate returns {@code false}.<img width="640" height="273" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEachWhile.o.png" alt="">the {@code Predicate} to execute for each item.Subscribes to the {@link ObservableSource} and calls a {@link Predicate} for each item or a {@link Consumer} with the errorof the current {@code Observable}, on their original emission threads, until the predicate returns {@code false}.the {@code Consumer} to execute when an error is emitted.Subscribes to the {@link ObservableSource} and calls a {@link Predicate} for each item, a {@link Consumer} with the erroror an {@link Action} upon completion of the current {@code Observable}, on their original emission threads,until the predicate returns {@code false}.the {@code Action} to execute when completion is signaled.if {@code onNext} or {@code onError} or {@code onComplete} is {@code null}Groups the items emitted by the current {@code Observable} according to a specified criterion, and emits thesegrouped items as {@link GroupedObservable}s.Each emitted {@code GroupedObservable} allows only a single {@link Observer} to subscribe to it during itslifetime and if this {@code Observer} calls {@code dispose()} before the{@code GroupedObservable} emission.<em>Note:</em> A {@code GroupedObservable} will cache the items it is to emit until such time as it{@code GroupedObservable}s that do not concern you. Instead, you can signal to them that they mayif {@code true}, the exception from the current {@code Observable} is delayed in each group until that specific group emittedthe hint for how many {@code GroupedObservable}s and element in each {@code GroupedObservable} should be bufferedReturns an {@code Observable} that correlates two {@link ObservableSource}s when they overlap in time and groups the results.items from one or both source {@code ObservableSource}s overlap.the value type of the right {@code ObservableSource} sourcethe element type of the left duration {@code ObservableSource}sthe element type of the right duration {@code ObservableSource}sthe other {@code ObservableSource} to correlate items from the current {@code Observable} witha function that returns an {@code ObservableSource} whose emissions indicate the duration of the values ofthe current {@code Observable}the {@code right} {@code ObservableSource}a function that takes an item emitted by each {@code ObservableSource} and returns the value to be emittedby the resulting {@code Observable}Hides the identity of the current {@code Observable} and its {@link Disposable}.Allows hiding extra features such as {@link io.reactivex.rxjava3.subjects.Subject}'s{@link Observer} methods or preventing certain identity-based<img width="640" height="283" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/hide.o.png" alt="">Ignores all items emitted by the current {@code Observable} and only calls {@code onComplete} or {@code onError}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ignoreElements.2.v3.png" alt="">Returns a {@link Single} that emits {@code true} if the current {@code Observable} is empty, otherwise {@code false}.In Rx.Net this is negated as the {@code any} {@link Observer} but we renamed this in RxJava to better match Java<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/isEmpty.2.v3.png" alt="">Correlates the items emitted by two {@link ObservableSource}s based on overlapping durations.the second {@code ObservableSource} to join items froma function to select a duration for each item emitted by the current {@code Observable}, used toa function to select a duration for each item emitted by the {@code right} {@code ObservableSource}, used toa function that computes an item to be emitted by the resulting {@code Observable} for any twooverlapping items emitted by the two {@code ObservableSource}sReturns a {@link Maybe} that emits the last item emitted by the current {@code Observable} or<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastElement.v3.png" alt="">Returns a {@link Single} that emits only the last item emitted by the current {@code Observable}, or a default item<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/last.2.v3.png" alt="">the default item to emit if the current {@code Observable} is emptyReturns a {@link Single} that emits only the last item emitted by the current {@code Observable} orReturns an {@code Observable} which, when subscribed to, invokes the {@link ObservableOperator#apply(Observer) apply(Observer)} methodof the provided {@link ObservableOperator} for each individual downstream {@link Observer} and allows theinsertion of a custom operator by accessing the downstream's {@code Observer} during this subscription phaseand providing a new {@code Observer}, containing the custom operator's intended business logic, that will beGenerally, such a new {@code Observer} will wrap the downstream's {@code Observer} and forwards the// Step 1: Create the consumer type that will be returned by the ObservableOperator.apply():public final class CustomObserver&lt;T&gt; implements Observer&lt;T&gt;, Disposable {// The downstream's Observer that will receive the onXXX eventsfinal Observer&lt;? super String&gt; downstream;public CustomObserver(Observer&lt;? super String&gt; downstream) {// Observable doesn't support backpressure, therefore, there is no// need or opportunity to call upstream.request(1) if an item// is not produced to the downstream// Step 2: Create a class that implements the ObservableOperator interface andfinal class CustomOperator&lt;T&gt; implements ObservableOperator&lt;String, T&gt; {public Observer&lt;T&gt; apply(Observer&lt;? super String&gt; downstream) {return new CustomObserver&lt;T&gt;(downstream);Observable.range(5, 10)an additional allocation and indirection per assembled flows. Instead, extending the abstract {@code Observable}class and creating an {@link ObservableTransformer} with it is recommended.requires a non-{@code null} {@code Observer} instance to be returned, which is then unconditionally subscribed tothe current {@code Observable}. For example, if the operator decided there is no reason to subscribe to thereturn an {@code Observer} that should immediately dispose the upstream's {@link Disposable} in its{@code onSubscribe} method. Again, using an {@code ObservableTransformer} and extending the {@code Observable} is{@code ObservableOperator} may use a {@code Scheduler} to support its own asynchronous behavior.</dd>the {@code ObservableOperator} that receives the downstream's {@code Observer} and should returnan {@code Observer} with custom behavior to be used as the consumer for the current#compose(ObservableTransformer)Returns an {@code Observable} that applies a specified function to each item emitted by the current {@code Observable} anda function to apply to each item emitted by the current {@code Observable}Returns an {@code Observable} that represents all of the emissions <em>and</em> notifications from the current{@code Observable} into emissions marked with their original types within {@link Notification} objects.Flattens the current {@code Observable} and another {@link ObservableSource} into a single {@code Observable} sequence, without any transformation.Merges the sequence of items of the current {@code Observable} with the success value of the other {@link SingleSource}.The success value of the other {@code SingleSource} can get interleaved at any point of the currentMerges the sequence of items of the current {@code Observable} with the success value of the other {@link MaybeSource}or waits both to complete normally if the {@code MaybeSource} is empty.The success value of the other {@code MaybeSource} can get interleaved at any point of the currentRelays the items of the current {@code Observable} and completes only when the other {@link CompletableSource} completesReturns an {@code Observable} to perform the current {@code Observable}'s emissions and notifications on a specified {@link Scheduler},asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size".This operator keeps emitting as many signals as it can on the given {@code Scheduler}'s worker thread,<p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumedon the other side of the asynchronous boundary.the {@code Scheduler} to notify {@link Observer}s onasynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays {@code onError} notifications.from the current {@code Observable}asynchronously with an unbounded buffer of configurable "island size" and optionally delays {@code onError} notifications.on the other side of the asynchronous boundary. Values below 16 are not recommended in performance sensitive scenarios.scheduling boundary. If {@code true} a sequence ending in {@code onError} will be replayed in the same order as was receivedFilters the items emitted by the current {@code Observable}, only emitting those of the specified type.the class type to filter the items emitted by the current {@code Observable}Returns an {@code Observable} instance that if the current {@code Observable} emits an error, it will emit an {@code onComplete}<img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.onErrorComplete.png" alt="">Returns an {@code Observable} instance that if the current {@code Observable} emits an error and the predicate returns<img width="640" height="215" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.onErrorComplete.f.png" alt="">Resumes the flow with an {@link ObservableSource} returned for the failure {@link Throwable} of the current {@code Observable} by aBy default, when an {@code ObservableSource} encounters an error that prevents it from emitting the expected item toits {@link Observer}, the {@code ObservableSource} invokes its {@code Observer}'s {@code onError} method, and then quitswithout invoking any more of its {@code Observer}'s methods. The {@code onErrorResumeNext} method changes thisbehavior. If you pass a function that returns an {@code ObservableSource} ({@code resumeFunction}) to{@code onErrorResumeNext}, if the original {@code ObservableSource} encounters an error, instead of invoking its{@code Observer}'s {@code onError} method, it will instead relinquish control to the {@code ObservableSource} returned from{@code resumeFunction}, which will invoke the {@code Observer}'s {@link Observer#onNext onNext} method if it isable to do so. In such a case, because no {@code ObservableSource} necessarily invokes {@code onError}, the {@code Observer}a function that returns an {@code ObservableSource} that will take over if the current {@code Observable} encountersResumes the flow with the given {@link ObservableSource} when the current {@code Observable} fails instead ofwithout invoking any more of its {@code Observer}'s methods. The {@code onErrorResumeWith} method changes thisbehavior. If you pass another {@code ObservableSource} ({@code next}) to an {@code ObservableSource}'s{@code onErrorResumeWith} method, if the original {@code ObservableSource} encounters an error, instead of invoking its{@code Observer}'s {@code onError} method, it will instead relinquish control to {@code next} whichwill invoke the {@code Observer}'s {@link Observer#onNext onNext} method if it is able to do so. In such a case,because no {@code ObservableSource} necessarily invokes {@code onError}, the {@code Observer} may never know that an errorthe next {@code ObservableSource} source that will take over if the current {@code Observable} encounters{@code Observable} instead of signaling the error via {@code onError}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.v3.png" alt="">By default, when an {@link ObservableSource} encounters an error that prevents it from emitting the expected item towithout invoking any more of its {@code Observer}'s methods. The {@code onErrorReturn} method changes thisbehavior. If you pass a function ({@code resumeFunction}) to an {@code ObservableSource}'s {@code onErrorReturn}method, if the original {@code ObservableSource} encounters an error, instead of invoking its {@code Observer}'sthe current {@code Observable} signals an {@code onError} eventEnds the flow with the given last item when the current {@code Observable} fails instead of signaling the error via {@code onError}.<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.v3.png" alt="">{@code Observable} signals an exceptionNulls out references to the upstream producer and downstream {@link Observer} if<img width="640" height="247" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png" alt="">Returns a {@link ConnectableObservable}, which is a variety of {@link ObservableSource} that waits until its{@link ConnectableObservable#connect connect} method is called before it begins emitting items to those{@link Observer}s that have subscribed to it.the new {@code ConnectableObservable} instanceReturns an {@code Observable} that emits the results of invoking a specified selector on items emitted by a{@link ConnectableObservable} that shares a single subscription to the current {@code Observable} sequence.<img width="640" height="647" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png" alt="">causing multiple subscriptions to the source sequence. {@link Observer}s to the given source will{@code Observable}, then feeds the result of that function along with the second item emitted by the current{@code Observable} into the same function, and so on until all items have been emitted by the current and finite {@code Observable},<img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduce.2.v3.png" alt="">an accumulator function to be invoked on each item emitted by the current {@code Observable}, whose{@code Observable} and a specified seed value, then feeds the result of that function along with the second itememitted by the current {@code Observable} into the same function, and so on until all items have been emitted by thecurrent and finite {@code Observable}, emitting the final result from the final call to your function as its sole item.<img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.v3.png" alt="">Note that the {@code seed} is shared among all subscribers to the resulting {@code Observable}ObservableSource&lt;T&gt; source = ...Observable.defer(() -&gt; o.reduce(new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item)).toObservable())an accumulator function to be invoked on each item emitted by the current {@code Observable}, the{@code Observable} and a seed value derived from calling a specified {@code seedSupplier}, then feeds the resultof that function along with the second item emitted by the current {@code Observable} into the same function,and so on until all items have been emitted by the current and finite {@code Observable}, emitting the final resultfrom the final call to your function as its sole item.<img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.v3.png" alt="">the {@link Supplier} that provides the initial (seed) accumulator value for each individual {@link Observer}Returns an {@code Observable} that repeats the sequence of items emitted by the current {@code Observable} indefinitely.<img width="640" height="287" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png" alt="">Returns an {@code Observable} that repeats the sequence of items emitted by the current {@code Observable} at most<img width="640" height="336" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png" alt="">the number of times the current {@code Observable} items are repeated, a count of 0 will yield an emptyReturns an {@code Observable} that repeats the sequence of items emitted by the current {@code Observable} until<img width="640" height="263" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png" alt="">a boolean supplier that is called when the current {@code Observable} completes;if it returns {@code true}, the returned {@code Observable} completes; if it returns {@code false},the current {@code Observable} is resubscribed.Returns an {@code Observable} that emits the same values as the current {@code Observable} with the exception of ana {@code void} item to the {@link ObservableSource} provided as an argument to the {@code notificationHandler}function. If that {@code ObservableSource} calls {@code onComplete} or {@code onError} then {@code repeatWhen} willcall {@code onComplete} or {@code onError} on the child subscription. Otherwise, the current {@code Observable}will be resubscribed.receives an {@code ObservableSource} of notifications with which a user can complete or error, aborting the repeat.Returns a {@link ConnectableObservable} that shares a single subscription to the current {@code Observable}that will replay all of its items and notifications to any future {@link Observer}. A connectable{@code Observable} resembles an ordinary {@code Observable}, except that it does not begin emitting items when it is<img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.v3.png" alt="">Returns an {@code Observable} that emits items that are the results of invoking a specified selector on the itemsemitted by a {@link ConnectableObservable} that shares a single subscription to the current {@code Observable}.<img width="640" height="449" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png" alt="">causing multiple subscriptions to the current {@code Observable}Returns an {@code Observable} that emits items that are the results of invoking a specified selector on itemsemitted by a {@link ConnectableObservable} that shares a single subscription to the current {@code Observable},<img width="640" height="392" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png" alt="">the buffer size that limits the number of items the connectable {@code Observable} can replay<img width="640" height="350" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png" alt=""><img width="640" height="329" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png" alt=""><img width="640" height="394" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png" alt=""><img width="640" height="367" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png" alt="">Returns a {@link ConnectableObservable} that shares a single subscription to the current {@code Observable} thatreplays at most {@code bufferSize} items emitted by the current {@code Observable}. A connectable {@code Observable} resemblesan ordinary {@code Observable}, except that it does not begin emitting items when it is subscribed to, but only<img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.n.v3.png" alt="">Returns a {@link ConnectableObservable} that shares a single subscription to the current {@code Observable} and<img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nt.v3.png" alt="">that replays a maximum of {@code bufferSize} items that are emitted within a specified time window. Aconnectable {@code Observable} resembles an ordinary {@code Observable}, except that it does not begin emitting items<img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.nts.v3.png" alt="">To ensure no out-of-date or beyond-bufferSize itemsreplays all items emitted by the current {@code Observable} within a specified time window. A connectable {@code Observable}resembles an ordinary {@code Observable}, except that it does not begin emitting items when it is subscribed to,<img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.t.v3.png" alt=""><img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ts.v3.png" alt="">Returns an {@code Observable} that mirrors the current {@code Observable}, resubscribing to it if it calls {@code onError}If the current {@code Observable} calls {@link Observer#onError}, this method will resubscribe to the current{@code Observable} rather than propagating the {@code onError} call.Any and all items emitted by the current {@code Observable} will be emitted by the resulting {@code Observable}, eventhose emitted during failed subscriptions. For example, if the current {@code Observable} fails at first but emits<img width="640" height="236" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png" alt=""><img width="640" height="327" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.v3.png" alt="">{@code Observable} for a maximum of {@code count} resubscriptions rather than propagating thethe number of times to resubscribe if the current {@code Observable} fails<img width="640" height="270" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png" alt="">Retries the current {@code Observable} if the predicate returns {@code true}.<img width="640" height="249" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png" alt=""><img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png" alt="">{@link Throwable} item to the {@code Observable} provided as an argument to the {@code notificationHandler}function. If that {@code Observable} calls {@code onComplete} or {@code onError} then {@code retry} will call{@code onComplete} or {@code onError} on the child subscription. Otherwise, the current {@code Observable}Observable.create((ObservableEmitter&lt;? super String&gt; s) -&gt; {}).retryWhen(attempts -&gt; {return attempts.zipWith(Observable.range(1, 3), (n, i) -&gt; i).flatMap(i -&gt; {return Observable.timer(i, TimeUnit.SECONDS);Note that the inner {@link ObservableSource} returned by the handler function should signal{@code ObservableSource} signals {@code onError} or {@code onComplete} while the upstream isObservable.timer(1, TimeUnit.SECONDS)return Observable.timer(counter.get(), TimeUnit.SECONDS);receives an {@code Observable} of notifications with which a user can complete or error, aborting theSubscribes to the current {@code Observable} and wraps the given {@link Observer} into a {@link SafeObserver}(if not already a {@code SafeObserver}) thatdeals with exceptions thrown by a misbehaving {@code Observer} (that doesn't follow thethe incoming {@code Observer} instanceReturns an {@code Observable} that emits the most recently emitted item (if any) emitted by the current {@code Observable}Returns an {@code Observable} that, when the specified {@code sampler} {@link ObservableSource} emits an item or completes,emits the most recently emitted item (if any) emitted by the current {@code Observable} since the previousemission from the {@code sampler} {@code ObservableSource}.the element type of the sampler {@code ObservableSource}the {@code ObservableSource} to use for sampling the current {@code Observable}emission from the {@code sampler} {@code ObservableSource}and optionally emit the very last upstream item when the upstream or other {@code ObservableSource} complete.Returns an {@code Observable} that emits the first value emitted by the current {@code Observable}, then emits one valuefor each subsequent value emitted by the current {@code Observable}. Each emission after the first is the result ofapplying the specified accumulator function to the previous emission and the corresponding value from the current {@code Observable}.result will be emitted to {@link Observer}s via {@link Observer#onNext onNext} and used in theReturns an {@code Observable} that emits the provided initial (seed) value, then emits one value for each value emittedby the current {@code Observable}. Each emission after the first is the result of applying the specified accumulatorfunction to the previous emission and the corresponding value from the current {@code Observable}.Note that the {@code Observable} that results from this method will emit {@code initialValue} as its firstNote that the {@code initialValue} is shared among all subscribers to the resulting {@code Observable}Observable.defer(() -&gt; source.scan(new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item)));Observable.defer(() -&gt; o.scan(new ArrayList&lt;&gt;(), (list, item) -&gt; list.add(item)))Note that the {@code Observable} that results from this method will emit the value returnedby the {@code seedSupplier} as its first item.a {@link Supplier} that returns the initial (seed) accumulator item for each individual {@link Observer}result will be emitted to {@code Observer}s via {@link Observer#onNext onNext} and used in theForces the current {@code Observable}'s emissions and notifications to be serialized and for it to obey<a href="http://reactivex.io/documentation/contract.html">the {@code ObservableSource} contract</a> in other ways.It is possible for an {@code Observable} to invoke its {@link Observer}s' methods asynchronously, perhaps fromdifferent threads. This could make such an {@code Observable} poorly-behaved, in that it might try to invoke{@code onNext} from two different threads concurrently. You can force such an {@code Observable} to beReturns a new {@code Observable} that multicasts (and shares a single subscription to) the current {@code Observable}. As long asthere is at least one {@link Observer}, the current {@code Observable} will stay subscribed and keep emitting signals.When all observers have disposed, the operator will dispose the subscription to the current {@code Observable}.This is an alias for {@link #publish()}.{@link ConnectableObservable#refCount() refCount()}.<img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.v3.png" alt="">Returns a {@link Maybe} that completes if the current {@code Observable} is empty or emits the single itememitted by the current {@code Observable}, or signals an {@link IllegalArgumentException} if the current{@code Observable} emits more than one item.<img width="640" height="217" src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/singleElement.o.v3.png" alt="">Returns a {@link Single} that emits the single item emitted by the current {@code Observable}, if the current {@code Observable}emits only a single item, or a default item if the current {@code Observable} emits no items. If the current{@code Observable} emits more than one item, an {@link IllegalArgumentException} is signaled instead.<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/single.2.v3.png" alt="">a default value to emit if the current {@code Observable} emits no itemReturns a {@link Single} that emits the single item emitted by the current {@code Observable} if itif the current {@code Observable} completes without emitting any items or emits more than one item a{@link NoSuchElementException} or {@link IllegalArgumentException} will be signaled respectively.Returns an {@code Observable} that skips the first {@code count} items emitted by the current {@code Observable} and emitsReturns an {@code Observable} that skips values emitted by the current {@code Observable} before a specified time windowReturns an {@code Observable} that drops a specified number of items from the end of the sequence emitted by thecurrent {@code Observable}.This {@link Observer} accumulates a queue long enough to store the first {@code count} items. As more items arereceived, items are taken from the front of the queue and emitted by the returned {@code Observable}. This causesReturns an {@code Observable} that drops items emitted by the current {@code Observable} during a specified time windowfrom the {@code trampoline} {@link Scheduler}.</dd>if {@code true}, an exception signaled by the current {@code Observable} is delayed until the regular elements are consumedReturns an {@code Observable} that skips items emitted by the current {@code Observable} until a second {@link ObservableSource} emitsthe element type of the other {@code ObservableSource}the second {@code ObservableSource} that has to emit an item before the current {@code Observable}'s elements beginto be mirrored by the resulting {@code Observable}Returns an {@code Observable} that skips all items emitted by the current {@code Observable} as long as a specifieda function to test each item emitted from the current {@code Observable}Returns an {@code Observable} that emits the events emitted by the current {@code Observable}, in asorted order. Each item emitted by the current {@code Observable} must implement {@link Comparable} with respect to all<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sorted.png" alt="">If any item emitted by the current {@code Observable} does not implement {@code Comparable} with respect toall other items emitted by the current {@code Observable}, no items will be emitted and thea function that compares two items emitted by the current {@code Observable} and returns an {@code int}Returns an {@code Observable} that emits the items in a specified {@link Iterable} before it begins to emit itemsemitted by the current {@code Observable}.an {@code Iterable} that contains the items you want the resulting {@code Observable} to emit firstReturns an {@code Observable} which first runs the other {@link CompletableSource}then the current {@code Observable} if the other completed normally.<img width="640" height="268" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.startWith.c.png" alt="">Returns an {@code Observable} which first runs the other {@link SingleSource}then the current {@code Observable} if the other succeeded normally.<img width="640" height="248" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.startWith.s.png" alt="">Returns an {@code Observable} which first runs the other {@link MaybeSource}then the current {@code Observable} if the other succeeded or completed normally.<img width="640" height="168" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.startWith.m.png" alt="">Returns an {@code Observable} that emits the items in a specified {@link ObservableSource} before it begins to emititems emitted by the current {@code Observable}.an {@code ObservableSource} that contains the items you want the modified {@code ObservableSource} to emit firstReturns an {@code Observable} that emits a specified item before it begins to emit items emitted by the current<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.item.png" alt="">Returns an {@code Observable} that emits the specified items before it begins to emit items emitted by the current<img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWithArray.v3.png" alt="">Subscribes to the current {@code Observable} and ignores {@code onNext} and {@code onComplete} emissions.the new {@link Disposable} instance that can be used to dispose the subscription at any timeSubscribes to the current {@code Observable} and provides a callback to handle the items it emits.the {@code Consumer<T>} you have designed to accept emissions from the current {@code Observable}Subscribes to the current {@code Observable} and provides callbacks to handle the items it emits and any errornotification it signals.the {@code Consumer<Throwable>} you have designed to accept any error notification from the currentSubscribes to the current {@code Observable} and provides callbacks to handle the items it emits and any error orcompletion notification it signals.the {@link Action} you have designed to accept a completion notification from the current can't call onError because no way to know if a Disposable has been set or notperforms the necessary business logic and handles the incoming {@link Observer}s.<p>There is no need to call any of the plugin hooks on the current {@code Observable} instance orthe {@code Observer}; all hooks and basic safeguards have beenapplied by {@link #subscribe(Observer)} before this method gets called.the incoming {@code Observer}, never {@code null}Subscribes a given {@link Observer} (subclass) to the current {@code Observable} and returns the given{@code Observer} instance as is.Observable&lt;Integer&gt; source = Observable.range(1, 10);DisposableObserver&lt;Integer&gt; ds = new DisposableObserver&lt;&gt;() {the type of the {@code Observer} to use and returnthe {@code Observer} (subclass) to use and return, not {@code null}Asynchronously subscribes {@link Observer}s to the current {@code Observable} on the specified {@link Scheduler}.Returns an {@code Observable} that emits the items emitted by the current {@code Observable} or the items of an alternate{@link ObservableSource} if the current {@code Observable} is empty.the alternate {@code ObservableSource} to subscribe to if the source does not emit any itemsReturns a new {@code Observable} by applying a function that you supply to each item emitted by the current{@code Observable} that returns an {@link ObservableSource}, and then emitting the items emitted by the most recently emittedof these {@code ObservableSource}s.The resulting {@code Observable} completes if both the current {@code Observable} and the last inner {@code ObservableSource}, if any, complete.If the current {@code Observable} signals an {@code onError}, the inner {@code ObservableSource} is disposed and the error delivered in-sequence.the element type of the inner {@code ObservableSource}s and the outputthe number of elements expected from the current active inner {@code ObservableSource} to be bufferedMaps the items of the current {@code Observable} into {@link CompletableSource}s, subscribes to the newer one while<dd>If either the current {@code Observable} or the active {@code CompletableSource} signals an {@code onError},every inner {@code CompletableSource}s and the main {@code Observable} terminates in some fashion.{@link CompositeException}<dd>The errors of the current {@code Observable} and all the {@code CompletableSource}s, who had the chance{@link Throwable} is emitted to the downstream. It there were more than one failures, theoperator combines all {@code Throwable}s into a {@link CompositeException}Maps the items of the current {@code Observable} into {@link MaybeSource}s and switches (subscribes) to the newer onesavailable while failing immediately if the current {@code Observable} or any of the<img width="640" height="531" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapMaybe.o.png" alt=""><dd>This operator terminates with an {@code onError} if the current {@code Observable} or any of(i.e., inactive or switched out) {@code onError} from the current {@code Observable} or from any of{@link RxJavaPlugins#onError(Throwable)} as{@link UndeliverableException}</dd>available, delaying errors from the current {@code Observable} or the inner {@code MaybeSource}s until all terminate.<img width="640" height="469" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapMaybeDelayError.o.png" alt="">{@code Observable} that returns a {@link SingleSource}, and then emitting the item emitted by the most recently emittedof these {@code SingleSource}s.The resulting {@code Observable} completes if both the current {@code Observable} and the last inner {@code SingleSource}, if any, complete.If the current {@code Observable} signals an {@code onError}, the inner {@code SingleSource} is disposed and the error delivered in-sequence.<img width="640" height="532" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png" alt="">the element type of the inner {@code SingleSource}s and the outputa function that, when applied to an item emitted by the current {@code Observable}, returns a{@code SingleSource}of these {@code SingleSource}s and delays any error until all {@code SingleSource}s terminate.If the current {@code Observable} signals an {@code onError}, the termination of the last inner {@code SingleSource} will emit that error as isor wrapped into a {@link CompositeException} along with the other possible errors the former inner {@code SingleSource}s signaled.<img width="640" height="467" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png" alt="">of these {@code ObservableSource}s and delays any error until all {@code ObservableSource}s terminate.If the current {@code Observable} signals an {@code onError}, the termination of the last inner {@code ObservableSource} will emit that error as isReturns an {@code Observable} that emits only the first {@code count} items emitted by the current {@code Observable}.This method returns an {@code Observable} that will invoke a subscribing {@link Observer}'s{@link Observer#onNext onNext} function a maximum of {@code count} times before invoking{@link Observer#onComplete onComplete}.Taking {@code 0} items from the current {@code Observable} will still subscribe to it, allowing thesubscription-time side-effects to happen there, but will be immediately disposed and the downstream completedwithout any item emission.Returns an {@code Observable} that emits those items emitted by the current {@code Observable} before a specified time runsIf time runs out before the {@code Observable} completes normally, the {@code onComplete} event will beReturns an {@code Observable} that emits those items emitted by the current {@code Observable} before a specified time (on aReturns an {@code Observable} that emits at most the last {@code count} items emitted by the current {@code Observable}.Returns an {@code Observable} that emits at most a specified number of items from the current {@code Observable} that wereemitted in a specified window of time before the current {@code Observable} completed.emitted in a specified window of time before the current {@code Observable} completed, where the timing information isReturns an {@code Observable} that emits the items from the current {@code Observable} that were emitted in a specifiedwindow of time before the current {@code Observable} completed.window of time before the current {@code Observable} completed, where the timing information is provided by a specifiedReturns an {@code Observable} that emits the items emitted by the current {@code Observable} until a second {@link ObservableSource}the {@code ObservableSource} whose first emitted item will cause {@code takeUntil} to stop emitting itemsReturns an {@code Observable} that emits items emitted by the current {@code Observable}, checks the specified predicatea function that evaluates an item emitted by the current {@code Observable} and returns a {@link Boolean}Observable#takeWhile(Predicate)Returns an {@code Observable} that emits items emitted by the current {@code Observable} so long as each item satisfied aObservable#takeUntil(Predicate)Returns an {@code Observable} that emits only the first item emitted by the current {@code Observable} during sequentialThis differs from {@link #throttleLast} in that this only tracks passage of time whereas{@code throttleLast} ticks at scheduled intervals.Returns an {@code Observable} that emits only the last item emitted by the current {@code Observable} during sequential{@code throttleFirst} does not tick, it just tracks passage of time.duration of windows within which the last item emitted by the current {@code Observable} will beThrottles items from the current {@code Observable} by first emitting the nexteach emission (alias to {@link #debounce(long, TimeUnit, Scheduler)}).{@code Observable}, in which the current {@code Observable} emits no items, in order for the item to be emitted by the{@link Scheduler}. The timer resets on each emission (Alias to {@link #debounce(long, TimeUnit, Scheduler)}).Returns an {@code Observable} that emits records of the time interval between consecutive items emitted by thecurrent {@code Observable}, where this interval is computed on a specified {@link Scheduler}.<dd>The operator does not operate on any particular scheduler but uses the current timeReturns an {@code Observable} that mirrors the current {@code Observable}, but notifies observers of a{@link TimeoutException} if an item emitted by the current {@code Observable} doesn't arrive within a window oftime after the emission of the previous item, where that period of time is measured by an {@link ObservableSource} thata function that returns an {@code ObservableSource} for each item emitted by the current{@code Observable} and that determines the timeout window for the subsequent itemReturns an {@code Observable} that mirrors the current {@code Observable}, but that switches to a fallback {@link ObservableSource} ifan item emitted by the current {@code Observable} doesn't arrive within a window of time after the emission of theprevious item, where that period of time is measured by an {@code ObservableSource} that is a function of the previousa function that returns an {@code ObservableSource}, for each item emitted by the current {@code Observable}, thatthe fallback {@code ObservableSource} to switch to if the current {@code Observable} times outReturns an {@code Observable} that mirrors the current {@code Observable} but applies a timeout policy for each emittedthe resulting {@code Observable} terminates and notifies observers of a {@link TimeoutException}.the current {@code Observable} is disposed and the resulting {@code Observable} begins insteadto mirror a fallback {@link ObservableSource}.the fallback {@code ObservableSource} to use in case of a timeoutstarting from its predecessor, the current {@code Observable} is disposed and returned {@code Observable}begins instead to mirror a fallback {@link ObservableSource}.the {@code ObservableSource} to use as the fallback in case of a timeoutspecified timeout duration starting from its predecessor, the resulting {@code Observable} terminates andnotifies observers of a {@link TimeoutException}.{@link TimeoutException} if either the first item emitted by the current {@code Observable} or any subsequent itemdoesn't arrive within time windows defined by indicator {@link ObservableSource}s.a function that returns an {@code ObservableSource} that determines the timeout window for the first sourcea function that returns an {@code ObservableSource} for each item emitted by the current {@code Observable} and thatReturns an {@code Observable} that mirrors the current {@code Observable}, but switches to a fallback {@link ObservableSource} if eitherthe first item emitted by the current {@code Observable} or any subsequent item doesn't arrive within time windowsdefined by indicator {@code ObservableSource}s.a function that returns an {@code ObservableSource} which determines the timeout window for the first sourceReturns an {@code Observable} that emits each item emitted by the current {@code Observable}, wrapped in athe function that receives the current {@code Observable} instance and returns a valueReturns a {@link Single} that emits a single item, a {@link List} composed of all the items emitted by thecurrent and finite {@code Observable}.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.2.v3.png" alt="">Normally, an {@link ObservableSource} that returns multiple items will do so by invoking its {@link Observer}'s{@link Observer#onNext onNext} method for each such item. You can change this behavior by having theoperator to compose a list of all of these items and then to invoke the {@link SingleObserver}'s {@code onSuccess}method once, passing it the entire list, by calling the {@code Observable}'s {@code toList} method prior tothe number of elements expected from the current {@code Observable}Returns a {@link Single} that emits a single item, a {@link Collection} (subclass) composed of all the items emitted by thefinite upstream {@code Observable}.<img width="640" height="365" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png" alt="">operator to compose a collection of all of these items and then to invoke the {@link SingleObserver}'s {@code onSuccess}method once, passing it the entire collection, by calling the {@code Observable}'s {@code toList} method prior tothe {@link Supplier} returning the collection (for each individual {@code Observer}) to be filled inReturns a {@link Single} that emits a single {@link HashMap} containing all items emitted by thecurrent and finite {@code Observable}, mapped by the keys returned by a specified{@code keySelector} function.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMap.2.v3.png" alt="">Note that this operator requires the upstream to signal {@code onComplete} for the accumulated {@code HashMap} tocurrent and finite {@code Observable}, mapped by the keys and values returned by the given selector functions.the key type of the {@code HashMap}the value type of the {@code HashMap}Returns a {@link Single} that emits a single {@link Map} (subclass), returned by a specified {@code mapFactory} function, thatcontains keys and values extracted from the items, via selector functions, emitted by the current and finite {@code Observable}.Note that this operator requires the upstream to signal {@code onComplete} for the accumulated {@code Map} tothe function that extracts the key from a source item to be used in the {@code Map}the function that extracts the value from the source items to be used as value in the {@code Map}current and finite {@code Observable} keyed by a specified {@code keySelector} function.<img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toMultiMap.2.v3.png" alt="">specified {@code valueSelector} function from items emitted by the current and finite {@code Observable},keyed by a specified {@code keySelector} function.Returns a {@link Single} that emits a single {@code Map} (subclass), returned by a specified {@code mapFactory} function, thatcontains a custom {@link Collection} of values, extracted by a specified {@code valueSelector} function fromitems emitted by the current and finite {@code Observable}, and keyed by the {@code keySelector} function.the function that returns a {@code Collection} instance for a particular key to be used in the {@code Map}emitted by the current and finite {@code Observable} and keyed by the {@code keySelector} function.Converts the current {@code Observable} into a {@link Flowable} by applying the specified backpressure strategy.<img width="640" height="274" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png" alt=""><img width="640" height="389" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png" alt=""><img width="640" height="297" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png" alt=""><img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png" alt=""><img width="640" height="412" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.missing.png" alt="">if {@code strategy} is {@code null}Returns a {@link Single} that emits a {@link List} that contains the items emitted by the current and finite {@code Observable}, in a<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.2.v3.png" alt="">Note that this operator requires the upstream to signal {@code onComplete} for the accumulated {@code List} to#toSortedList(int)#toSortedList(Comparator)<img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toSortedList.f.2.v3.png" alt="">the initial capacity of the {@code List} used to accumulate items before sorting#toSortedList(Comparator, int)Return an {@code Observable} that schedules the downstream {@link Observer}s' {@code dispose} callsaimed at the current {@code Observable} on the given {@link Scheduler}.<img width="640" height="453" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/unsubscribeOn.o.png" alt="">the {@code Scheduler} to perform the call to {@code dispose()} of the upstream {@link Disposable}Returns an {@code Observable} that emits windows of items it collects from the current {@code Observable}. The resulting{@code Observable} emits connected, non-overlapping windows, each containing {@code count} items. When the current{@code Observable} completes or encounters an error, the resulting {@code Observable} emits the current window andpropagates the notification from the current {@code Observable}.{@code Observable} emits windows every {@code skip} items, each containing no more than {@code count} items. Whenthe current {@code Observable} completes or encounters an error, the resulting {@code Observable} emits the current windowand propagates the notification from the current {@code Observable}.{@code Observable} starts a new window periodically, as determined by the {@code timeskip} argument. It emits{@code Observable} completes or encounters an error, the resulting {@code Observable} emits thecurrent window and propagates the notification from the current {@code Observable}.if {@code timespan} or {@code timeskip} is non-positive{@code Observable} emits connected, non-overlapping windows, each of a fixed duration specified by the{@code timespan} argument. When the current {@code Observable} completes or encounters an error, the resulting{@code Observable} emits the current window and propagates the notification from the current {@code Observable}.{@code Observable} emits connected, non-overlapping windows, each of a fixed duration as specified by thereached first). When the current {@code Observable} completes or encounters an error, the resulting {@code Observable}emits the current window and propagates the notification from the current {@code Observable}.first). When the current {@code Observable} completes or encounters an error, the resulting {@code Observable} emits theif {@code count} or {@code bufferSize} is non-positiveReturns an {@code Observable} that emits non-overlapping windows of items it collects from the current {@code Observable}{@link ObservableSource}.an {@code ObservableSource} whose emitted items close and open windows{@code Observable} emits windows that contain those items emitted by the current {@code Observable} between the time whenthe {@code openingIndicator} {@link ObservableSource} emits an item and when the {@code ObservableSource} returned by{@code closingIndicator} emits an item.the element type of the window-opening {@code ObservableSource}the element type of the window-closing {@code ObservableSource}san {@code ObservableSource} that, when it emits an item, causes another window to be createda {@link Function} that produces an {@code ObservableSource} for every window created. When this indicator {@code ObservableSource}emits an item, the associated window is completedMerges the specified {@link ObservableSource} into the current {@code Observable} sequence by using the {@code resultSelector}function only when the current {@code Observable} emits an item.the other {@code ObservableSource}the function to call when the current {@code Observable} emits an item and the other {@code ObservableSource} has alreadyemitted an item, to generate the item to be emitted by the resulting {@code Observable}Combines the value emission from the current {@code Observable} with the latest emissions from theother {@link ObservableSource}s via a function to produce the output item.least one value. The resulting emission only happens when the current {@code Observable} emits (andnot when any of the other sources emit, unlike {@code combineLatest}).the first other {@code ObservableSource}the second other {@code ObservableSource}the function called with an array of values from each participating {@code ObservableSource}the third other {@code ObservableSource}the fourth other {@code ObservableSource}Returns an {@code Observable} that emits items that are the result of applying a specified function to pairs ofvalues, one each from the current {@code Observable} and a specified {@link Iterable} sequence.Note that the {@code other} {@code Iterable} is evaluated as items are observed from the current {@code Observable}; it isa function that combines the pairs of items from the current {@code Observable} and the {@code Iterable} to generatethe items to be emitted by the resulting {@code Observable}values, one each from the current {@code Observable} and another specified {@link ObservableSource}.the type of items emitted by the {@code other} {@code ObservableSource}a function that combines the pairs of items from the current {@code Observable} and the other {@code ObservableSource} to generate the items tobe emitted by the resulting {@code Observable}if {@code true}, errors from the current {@code Observable} or the other {@code ObservableSource} is delayed until both terminateCreates a {@link TestObserver} and subscribes it to the current {@code Observable}.Creates a {@link TestObserver}, optionally disposes it and then subscribesit to the current {@code Observable}.indicates if the {@code TestObserver} should be disposed beforeit is subscribed to the current {@code Observable}or an empty optional into an {@link #empty()} {@code Observable} instance.<img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromOptional.o.png" alt="">Observable.defer(() -&gt; Observable.fromOptional(createOptional()));the optional value to convert into an {@code Observable}<img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCompletionStage.o.png" alt="">Observable.defer(() -&gt; Observable.fromCompletionStage(createCompletionStage()));the {@code CompletionStage} to convert to {@code Observable} and signal its terminal value or errorConverts a {@link Stream} into a finite {@code Observable} and emits its items in the sequence.<img width="640" height="407" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromStream.o.png" alt="">Observable.fromIterable(stream::iterator);Observable.fromStream(intStream.boxed());<img width="640" height="306" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mapOptional.o.png" alt="">it as the success result as a {@link Single}.<img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collector.o.png" alt=""><img width="640" height="313" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstStage.o.png" alt=""><img width="640" height="227" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleStage.o.png" alt=""><img width="640" height="313" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastStage.o.png" alt=""><img width="640" height="341" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrErrorStage.o.png" alt=""><img width="640" height="227" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrErrorStage.o.png" alt=""><img width="640" height="343" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrErrorStage.o.png" alt="">Creates a sequential {@link Stream} to consume or process the current {@code Observable} in a blocking manner via<img width="640" height="399" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingStream.o.png" alt="">Observable&lt;Integer&gt; source = Observable.range(1, 10)<img width="640" height="399" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingStream.oi.png" alt=""><img width="640" height="299" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapStream.o.png" alt="">#flatMapStream(Function)<img width="640" height="299" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapStream.o.png" alt="">C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableConverter.javaConvenience interface and callback used by the {@link Observable#to} operator to turn an {@link Observable} into anotherApplies a function to the upstream {@link Observable} and returns a converted value of type {@code R}.the upstream {@code Observable} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableEmitter.javaObservableEmitter<>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableEmitter.classAbstraction over an RxJava {@link Observer} that allows associatingand {@link #onComplete()} methods should be called in a sequential manner, just like the{@link Observer}'s methods should be.Use the {@code ObservableEmitter} the {@link #serialize()} method returns instead of the original{@code ObservableEmitter} instance provided by the generator routine if you want to ensure this.the {@code Disposable}, {@code null} is allowedthe serialized {@link ObservableEmitter}C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableOnSubscribe.javaObservableEmitter<T>an instance of an {@link ObservableEmitter} instance that allows pushingevents in a cancellation-safe manner.Called for each {@link Observer} that subscribes.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableOperator.javaObserver<? super Downstream>Observer<? super Upstream>Interface to map/wrap a downstream {@link Observer} to an upstream {@code Observer}.Applies a function to the child {@link Observer} and returns a new parent {@code Observer}.the child {@code Observer} instancethe parent {@code Observer} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableSource.javaRepresents a basic, non-backpressured {@link Observable} source base interface,consumable via an {@link Observer}.Subscribes the given {@link Observer} to this {@link ObservableSource} instance.the {@code Observer}, not {@code null}C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/ObservableTransformer.javaInterface to compose {@link Observable}s.Applies a function to the upstream {@link Observable} and returns an {@link ObservableSource} withthe transformed {@code ObservableSource} instanceC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Observer.javaProvides a mechanism for receiving push-based notifications.When an {@code Observer} is subscribed to an {@link ObservableSource} through the {@link ObservableSource#subscribe(Observer)} method,the {@code ObservableSource} calls {@link #onSubscribe(Disposable)}  with a {@link Disposable} that allowsdisposing the sequence at any time, then the{@code ObservableSource} may call the Observer's {@link #onNext} method any number of timesto provide notifications. A well-behaved{@code ObservableSource} will call an {@code Observer}'s {@link #onComplete} method exactly once or the {@code Observer}'s{@link #onError} method exactly once.Calling the {@code Observer}'s method must happen in a serialized fashion, that is, they must not<pre><code>    onSubscribe onNext* (onError | onComplete)?</code></pre>Subscribing an {@code Observer} to multiple {@code ObservableSource}s is not recommended. If such reusehappens, it is the duty of the {@code Observer} implementation to be ready to receive multiple calls toCalling {@link #onSubscribe(Disposable)}, {@link #onNext(Object)} or {@link #onError(Throwable)} with aThe implementations of the {@code onXXX} methods should avoid throwing runtime exceptions other than the following cases(see <a href="https://github.com/reactive-streams/reactive-streams-jvm#2.13">Rule 2.13</a> of the Reactive Streams specification):Violating Rule 2.13 results in undefined flow behavior. Generally, the following can happen:<li>An upstream operator turns it into an {@link #onError} call.</li><li>If the flow is synchronous, the {@link ObservableSource#subscribe(Observer)} throws instead of returning normally.</li><li>If the flow is asynchronous, the exception propagates up to the component ({@link Scheduler} or {@link java.util.concurrent.Executor})providing the asynchronous boundary the code is running and either routes the exception to the global{@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable)} handler or the current thread's{@link java.lang.Thread.UncaughtExceptionHandler#uncaughtException(Thread, Throwable)} handler.</li>From the {@code Observable}'s perspective, an {@code Observer} is the end consumer thus it is the {@code Observer}'sresponsibility to handle the error case and signal it "further down". This means unreliable code in the {@code onXXX}methods should be wrapped into `try-catch`es, specifically in {@link #onError(Throwable)} or {@link #onComplete()}, and handled there(for example, by logging it or presenting the user with an error dialog). However, if the error would be thrown from{@link #onNext(Object)}, <a href="https://github.com/reactive-streams/reactive-streams-jvm#2.13">Rule 2.13</a> mandatesthe implementation calls {@link Disposable#dispose()} and signals the exception in a way that is adequate to the target context,for example, by calling {@link #onError(Throwable)} on the same {@code Observer} instance.If, for some reason, the {@code Observer} won't follow Rule 2.13, the {@link Observable#safeSubscribe(Observer)} can wrap itwith the necessary safeguards and route exceptions thrown from {@code onNext} into {@code onError} and route exceptions thrownfrom {@code onError} and {@code onComplete} into the global error handler via {@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onError(Throwable)}.the type of item the Observer expects to observeProvides the {@link Observer} with the means of cancelling (disposing) theconnection (channel) with the {@link Observable} in bothsynchronous (from within {@link #onNext(Object)}) and asynchronous manner.Provides the {@link Observer} with a new item to observe.The {@link Observable} may call this method 0 or more times.The {@code Observable} will not call this method again after it calls either {@link #onComplete} or{@link #onError}.the item emitted by the ObservableNotifies the {@link Observer} that the {@link Observable} has experienced an error condition.If the {@code Observable} calls this method, it will not thereafter call {@link #onNext} or{@link #onComplete}.the exception encountered by the ObservableNotifies the {@link Observer} that the {@link Observable} has finished sending push-based notifications.The {@code Observable} will not call this method if it calls {@link #onError}.C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Scheduler.javaSchedulerio.reactivex.rxjava3.internal.disposablesio.reactivex.rxjava3.internal.schedulerscomputeClockDriftcomputeClockDrift(long,java.lang.String)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Scheduler.classCLOCK_DRIFT_TOLERANCE_NANOSECONDScomputeNowcomputeNow(java.util.concurrent.TimeUnit)IS_DRIFT_USE_NANOTIME"rx3.scheduler.use-nanotime"rx3.scheduler.use-nanotime"rx3.scheduler.drift-tolerance"rx3.scheduler.drift-tolerance15"rx3.scheduler.drift-tolerance-unit"rx3.scheduler.drift-tolerance-unit"minutes"minutestimeUnit"seconds"seconds"milliseconds"millisecondswdecoratedRuntaskperiodicTaskFlowable<Completable>Publisher<Completable>Flowable<Flowable<Completable>>Publisher<Flowable<Completable>>Function<Flowable<Flowable<Completable>>,Completable>combine"combine is null"combine is nullsdperiodInNanosecondsfirstNowNanosecondsfirstStartInNanosecondsPeriodicTaskPeriodicTask(long,java.lang.Runnable,long,io.reactivex.rxjava3.internal.disposables.SequentialDisposable,long)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Scheduler$Worker$PeriodicTask.classScheduler$Worker$PeriodicTaskstartInNanosecondslastNowNanosecondsnextTicknowNanosecondsPeriodicDirectTaskPeriodicDirectTask(java.lang.Runnable,io.reactivex.rxjava3.core.Scheduler.Worker)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Scheduler$PeriodicDirectTask.classScheduler$PeriodicDirectTaskdisposedworkerDisposeTaskDisposeTask(java.lang.Runnable,io.reactivex.rxjava3.core.Scheduler.Worker)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Scheduler$DisposeTask.classScheduler$DisposeTaskrunnerA {@code Scheduler} is an object that specifies an API for schedulingunits of work provided in the form of {@link Runnable}s to beexecuted without delay (effectively as soon as possible), after a specified time delay or periodicallyand represents an abstraction over an asynchronous boundary that ensuresthese units of work get executed by some underlying task-execution scheme(such as custom Threads, event loop, {@link java.util.concurrent.Executor Executor} or Actor system)with some uniform properties and guarantees regardless of the particular underlyingscheme.You can get various standard, RxJava-specific instances of this class viathe static methods of the {@link io.reactivex.rxjava3.schedulers.Schedulers} utility class.The so-called {@link Worker}s of a {@code Scheduler} can be created via the {@link #createWorker()} method which allow the schedulingof multiple {@link Runnable} tasks in an isolated manner. {@code Runnable} tasks scheduled on a {@code Worker} are guaranteed to beexecuted sequentially and in a non-overlapping fashion. Non-delayed {@code Runnable} tasks are guaranteed to execute in aFirst-In-First-Out order but their execution may be interleaved with delayed tasks.In addition, outstanding or running tasks can be cancelled together via{@link Worker#dispose()} without affecting any other {@code Worker} instances of the same {@code Scheduler}.Implementations of the {@link #scheduleDirect} and {@link Worker#schedule} methods are encouraged to call the {@link io.reactivex.rxjava3.plugins.RxJavaPlugins#onSchedule(Runnable)}method to allow a scheduler hook to manipulate (wrap or replace) the original {@code Runnable} task before it is submitted to theunderlying task-execution scheme.The default implementations of the {@code scheduleDirect} methods provided by this abstract classdelegate to the respective {@code schedule} methods in the {@link Worker} instance created via {@link #createWorker()}for each individual {@link Runnable} task submitted. Implementors of this class are encouraged to providea more efficient direct scheduling implementation to avoid the time and memory overhead of creating such {@code Worker}sfor every task.This delegation is done via special wrapper instances around the original {@code Runnable} before calling the respective{@code Worker.schedule} method. Note that this can lead to multiple {@code RxJavaPlugins.onSchedule} calls and potentiallymultiple hooks applied. Therefore, the default implementations of {@code scheduleDirect} (and the {@link Worker#schedulePeriodically(Runnable, long, long, TimeUnit)})wrap the incoming {@code Runnable} into a class that implements the {@link io.reactivex.rxjava3.schedulers.SchedulerRunnableIntrospection}interface which can grant access to the original or hooked {@code Runnable}, thus, a repeated {@code RxJavaPlugins.onSchedule}can detect the earlier hook and not apply a new one over again.The default implementation of {@link #now(TimeUnit)} and {@link Worker#now(TimeUnit)} methods to return current {@link System#currentTimeMillis()}value in the desired time unit, unless {@code rx3.scheduler.use-nanotime} (boolean) is set. When the property is set to{@code true}, the method uses {@link System#nanoTime()} as its basis instead. Custom {@code Scheduler} implementations can override thisto provide specialized time accounting (such as virtual time to be advanced programmatically).Note that operators requiring a {@code Scheduler} may rely on either of the {@code now()} calls provided by{@code Scheduler} or {@code Worker} respectively, therefore, it is recommended they represent a logicallyconsistent source of the current time.The default implementation of the {@link Worker#schedulePeriodically(Runnable, long, long, TimeUnit)} method usesthe {@link Worker#schedule(Runnable, long, TimeUnit)} for scheduling the {@code Runnable} task periodically.The algorithm calculates the next absolute time when the task should run again and schedules this executionbased on the relative time between it and {@link Worker#now(TimeUnit)}. However, drifts or changes in thesystem clock could affect this calculation either by scheduling subsequent runs too frequently or too far apart.Therefore, the default implementation uses the {@link #clockDriftTolerance()} value (set via{@code rx3.scheduler.drift-tolerance} and {@code rx3.scheduler.drift-tolerance-unit}) to detect adrift in {@link Worker#now(TimeUnit)} and re-adjust the absolute/relative time calculation accordingly.The default implementations of {@link #start()} and {@link #shutdown()} do nothing and should be overridden if theunderlying task-execution scheme supports stopping and restarting itself.If the {@code Scheduler} is shut down or a {@code Worker} is disposed, the {@code schedule} methodsshould return the {@link Disposable#disposed()} singleton instance indicating the shut down/disposedstate to the caller. Since the shutdown or dispose can happen from any thread, the {@code schedule} implementationsshould make best effort to cancel tasks immediately after those tasks have been submitted to theunderlying task-execution scheme if the shutdown/dispose was detected after this submission.All methods on the {@code Scheduler} and {@code Worker} classes should be thread safe.Value representing whether to use {@link System#nanoTime()}, or default as clock for {@link #now(TimeUnit)}and {@link Scheduler.Worker#now(TimeUnit)}Associated system parameter:<li>{@code rx3.scheduler.use-nanotime}, boolean, default {@code false}Returns the current clock time depending on state of {@link Scheduler#IS_DRIFT_USE_NANOTIME} in given {@code unit}By default {@link System#currentTimeMillis()} will be used as the clock. When the property is set{@link System#nanoTime()} will be used.the 'current time' in given unitThe tolerance for a clock drift in nanoseconds where the periodic scheduler will rebase.Associated system parameters:<li>{@code rx3.scheduler.drift-tolerance}, long, default {@code 15}</li><li>{@code rx3.scheduler.drift-tolerance-unit}, string, default {@code minutes},supports {@code seconds} and {@code milliseconds}.Returns the clock drift tolerance in nanoseconds based on the input selection.the time valuethe time unit stringthe time amount in nanosecondsReturns the clock drift tolerance in nanoseconds.<p>Related system properties:the tolerance in nanosecondsRetrieves or creates a new {@link Scheduler.Worker} that represents sequential execution of actions.When work is completed, the {@code Worker} instance should be releasedby calling {@link Scheduler.Worker#dispose()} to avoid potential resource leaks in theWork on a {@link Scheduler.Worker} is guaranteed to be sequential and non-overlapping.a Worker representing a serial queue of actions to be executedReturns the 'current time' of the Scheduler in the specified time unit.the 'current time'Allows the Scheduler instance to start threadsand accept tasks on them.Implementations should make sure the call is idempotent, thread-safe andshould not throw any {@code RuntimeException} if it doesn't support thisfunctionality.Instructs the Scheduler instance to stop threads,stop accepting tasks on any outstanding {@link Worker} instancesand clean up any associated resources with this Scheduler.Schedules the given task on this Scheduler without any time delay.This method is safe to be called from multiple threads but there are noordering or non-overlapping guarantees between tasks.the task to executethe Disposable instance that let's one cancel this particular task.Schedules the execution of the given task with the given time delay.ordering guarantees between tasks.the task to schedulethe delay amount, non-positive values indicate non-delayed schedulingthe unit of measure of the delay amountthe Disposable that let's one cancel this particular delayed task.if {@code run} or {@code unit} is {@code null}Schedules a periodic execution of the given task with the given initial time delay and repeat period.The periodic execution is at a fixed rate, that is, the first execution will be after the{@code initialDelay}, the second after {@code initialDelay + period}, the third after{@code initialDelay + 2 * period}, and so on.the initial delay amount, non-positive values indicate non-delayed schedulingthe period at which the task should be re-executedAllows the use of operators for controlling the timing around whenactions scheduled on workers are actually done. This makes it possible tolayer additional behavior on this {@link Scheduler}. The only parameteris a function that flattens an {@link Flowable} of {@link Flowable}of {@link Completable}s into just one {@link Completable}. There must bea chain of operators connecting the returned value to the source{@link Flowable} otherwise any work scheduled on the returned{@link Scheduler} will not be executed.When {@link Scheduler#createWorker()} is invoked a {@link Flowable} of{@link Completable}s is onNext'd to the combinator to be flattened. Ifthe inner {@link Flowable} is not immediately subscribed to an calls to{@link Worker#schedule} are buffered. Once the {@link Flowable} issubscribed to actions are then onNext'd as {@link Completable}s.Finally the actions scheduled on the parent {@link Scheduler} when theinner most {@link Completable}s are subscribed to.When the {@link Worker} is unsubscribed the {@link Completable} emits anonComplete and triggers any behavior in the flattening operator. The{@link Flowable} and all {@link Completable}s give to the flatteningfunction never onError.Limit the amount concurrency two at a time without creating a new fixsize thread pool:<pre>Scheduler limitScheduler = Schedulers.computation().when(workers -&gt; {// use merge max concurrent to limit the number of concurrent// callbacks two at a timereturn Completable.merge(Flowable.merge(workers), 2);</pre>This is a slightly different way to limit the concurrency but it has someinteresting benefits and drawbacks to the method above. It works bylimited the number of concurrent {@link Worker}s rather than individualactions. Generally each {@link Flowable} uses its own {@link Worker}.This means that this will essentially limit the number of concurrentsubscribes. The danger comes from using operators like{@link Flowable#zip(org.reactivestreams.Publisher, org.reactivestreams.Publisher, io.reactivex.rxjava3.functions.BiFunction)} wheresubscribing to the first {@link Flowable} could deadlock thesubscription to the second.// Flowables two at a timereturn Completable.merge(Flowable.merge(workers, 2));Slowing down the rate to no more than than 1 a second. This suffers fromthe same problem as the one above I could find an {@link Flowable}operator that limits the rate without dropping the values (aka leakybucket algorithm).Scheduler slowScheduler = Schedulers.computation().when(workers -&gt; {// use concatenate to make each worker happen one at a time.return Completable.concat(workers.map(actions -&gt; {// delay the starting of the next worker by 1 second.return Completable.merge(actions.delaySubscription(1, TimeUnit.SECONDS));}));a Scheduler and a Subscriptionthe function that takes a two-level nested Flowable sequence of a Completable and returnsthe Completable that will be subscribed to and should trigger the execution of the scheduled Actions.the Scheduler with the customized execution behaviorif {@code combine} is {@code null}Represents an isolated, sequential worker of a parent Scheduler for executing {@code Runnable} tasks onan underlying task-execution scheme (such as custom Threads, event loop, {@link java.util.concurrent.Executor Executor} or Actor system).Disposing the {@link Worker} should cancel all outstanding work and allows resource cleanup.The default implementations of {@link #schedule(Runnable)} and {@link #schedulePeriodically(Runnable, long, long, TimeUnit)}delegate to the abstract {@link #schedule(Runnable, long, TimeUnit)} method. Its implementation is encouraged totrack the individual {@code Runnable} tasks while they are waiting to be executed (with or without delay) so that{@link #dispose()} can prevent their execution or potentially interrupt them if they are currently running.The default implementation of the {@link #now(TimeUnit)} method returns current {@link System#currentTimeMillis()}{@code true}, the method uses {@link System#nanoTime()} as its basis instead. Custom {@code Worker} implementations can override thisNote that operators requiring a scheduler may rely on either of the {@code now()} calls provided byThe default implementation of the {@link #schedulePeriodically(Runnable, long, long, TimeUnit)} method usesthe {@link #schedule(Runnable, long, TimeUnit)} for scheduling the {@code Runnable} task periodically.based on the relative time between it and {@link #now(TimeUnit)}. However, drifts or changes in thesystem clock would affect this calculation either by scheduling subsequent runs too frequently or too far apart.{@code rx3.scheduler.drift-tolerance} and {@code rx3.scheduler.drift-tolerance-unit}) to detect a drift in {@link #now(TimeUnit)} andre-adjust the absolute/relative time calculation accordingly.If the {@code Worker} is disposed, the {@code schedule} methodsshould return the {@link Disposable#disposed()} singleton instance indicating the disposedstate to the caller. Since the {@link #dispose()} call can happen on any thread, the {@code schedule} implementationsunderlying task-execution scheme if the dispose was detected after this submission.All methods on the {@code Worker} class should be thread safe.Schedules a Runnable for execution without any time delay.<p>The default implementation delegates to {@link #schedule(Runnable, long, TimeUnit)}.Runnable to schedulea Disposable to be able to unsubscribe the action (cancel it if not executed)Schedules an Runnable for execution at some point in the future specified by a time delayrelative to the current time.Note to implementors: non-positive {@code delayTime} should be regarded as non-delayed schedule, i.e.,as if the {@link #schedule(Runnable)} was called.the Runnable to scheduletime to "wait" before executing the action; non-positive values indicate an non-delayedschedulethe time unit of {@code delayTime}The default implementation schedules and reschedules the {@code Runnable} task via the{@link #schedule(Runnable, long, TimeUnit)}method over and over and at a fixed rate, that is, the first execution will be after theNote to implementors: non-positive {@code initialTime} and {@code period} should be regarded asnon-delayed scheduling of the first and any subsequent executions.In addition, a more specific {@code Worker} implementation should override this methodif it can perform the periodic task execution with less overhead (such as by avoiding thecreation of the wrapper and tracker objects upon each periodic invocation of thecommon {@link #schedule(Runnable, long, TimeUnit)} method).the Runnable to execute periodicallytime to wait before executing the action for the first time; non-positive values indicatean non-delayed schedulethe time interval to wait each time in between executing the action; non-positive valuesindicate no delay between repeated schedulesthe time unit of {@code period}Returns the 'current time' of the Worker in the specified time unit.Holds state and logic to calculate when the next delayed invocationof this task has to happen (accounting for clock drifts). If the clock moved in a direction quite a bit, rebase the repetition periodShift the start point back by the drift as if the whole thingstarted count periods ago. Exceptions.throwIfFatal(ex); nowhere to go Exceptions.throwIfFatal(e); nowhere to goC:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/core/Single.javatoSingle(io.reactivex.rxjava3.core.Flowable)timeout0(long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.SingleSource)SingleAmb<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleAmb.classSingleAmbSingleAmb<T>(io.reactivex.rxjava3.core.SingleSource[],java.lang.Iterable)SingleAmb(io.reactivex.rxjava3.core.SingleSource[],java.lang.Iterable)Supplier<NoSuchElementException>Flowable<? extends SingleSource<? extends T>>? super ? extends SingleSource<? extends T>Function<? super ? extends SingleSource<? extends T>,? extends SingleSource<? extends R>>Subscriber<? super ? extends SingleSource<? extends T>>Function<? super ? extends SingleSource<? extends T>,? extends Stream<? extends R>>Stream<? extends SingleSource<? extends T>>BaseStream<? extends SingleSource<? extends T>,Stream<? extends SingleSource<? extends T>>>CompletionStage<? extends SingleSource<? extends T>>lastStage(io.reactivex.rxjava3.core.SingleSource)singleStage(io.reactivex.rxjava3.core.SingleSource)firstStage(io.reactivex.rxjava3.core.SingleSource)Collector<? super ? extends SingleSource<? extends T>,A,R>Function<? super ? extends SingleSource<? extends T>,Optional<? extends R>>TestSubscriber<? extends SingleSource<? extends T>>BaseTestConsumer<? extends SingleSource<? extends T>,TestSubscriber<? extends SingleSource<? extends T>>>FlowableSubscriber<? extends SingleSource<? extends T>>Subscriber<? extends SingleSource<? extends T>>BiFunction<? super ? extends SingleSource<? extends T>,? super U,? extends R>Function5<? super ? extends SingleSource<? extends T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super ? extends SingleSource<? extends T>,? super T1,? super T2,? super T3,R>Function3<? super ? extends SingleSource<? extends T>,? super T1,? super T2,R>Flowable<Flowable<? extends SingleSource<? extends T>>>Publisher<Flowable<? extends SingleSource<? extends T>>>List<? extends SingleSource<? extends T>>Collection<? extends SingleSource<? extends T>>Single<List<? extends SingleSource<? extends T>>>SingleSource<List<? extends SingleSource<? extends T>>>Comparator<? super ? extends SingleSource<? extends T>>Observable<? extends SingleSource<? extends T>>Function<? super ? extends SingleSource<? extends T>,? extends K>Function<? super ? extends SingleSource<? extends T>,? extends V>Map<K,Collection<? extends SingleSource<? extends T>>>Single<Map<K,Collection<? extends SingleSource<? extends T>>>>SingleSource<Map<K,Collection<? extends SingleSource<? extends T>>>>Map<K,? extends SingleSource<? extends T>>Single<Map<K,? extends SingleSource<? extends T>>>SingleSource<Map<K,? extends SingleSource<? extends T>>>FlowableConverter<? extends SingleSource<? extends T>,? extends R>Timed<? extends SingleSource<? extends T>>Flowable<Timed<? extends SingleSource<? extends T>>>Publisher<Timed<? extends SingleSource<? extends T>>>Function<? super ? extends SingleSource<? extends T>,? extends Publisher<V>>? extends ? extends SingleSource<? extends T>Publisher<? extends ? extends SingleSource<? extends T>>Predicate<? super ? extends SingleSource<? extends T>>Function<? super ? extends SingleSource<? extends T>,? extends MaybeSource<? extends R>>Function<? super ? extends SingleSource<? extends T>,? extends Publisher<? extends R>>Function<? super ? extends SingleSource<? extends T>,? extends CompletableSource>FlowableSubscriber<? super ? extends SingleSource<? extends T>>Consumer<? super ? extends SingleSource<? extends T>>? extends SingleSource<? extends T>[]startWithArray(io.reactivex.rxjava3.core.SingleSource[])startWithItem(io.reactivex.rxjava3.core.SingleSource)MaybeSource<? extends SingleSource<? extends T>>Iterable<? extends ? extends SingleSource<? extends T>>Single<? extends SingleSource<? extends T>>single(io.reactivex.rxjava3.core.SingleSource)Maybe<? extends SingleSource<? extends T>>BiFunction<R,? super ? extends SingleSource<? extends T>,R>BiFunction<? extends SingleSource<? extends T>,? extends SingleSource<? extends T>,? extends SingleSource<? extends T>>ConnectableFlowable<? extends SingleSource<? extends T>>? super Flowable<? extends SingleSource<? extends T>>Function<? super Flowable<? extends SingleSource<? extends T>>,? extends Publisher<R>>Function<? super Flowable<? extends SingleSource<? extends T>>,? extends Publisher<? extends R>>ParallelFlowable<? extends SingleSource<? extends T>>onErrorReturnItem(io.reactivex.rxjava3.core.SingleSource)Function<? super Throwable,? extends ? extends SingleSource<? extends T>>? extends Publisher<? extends ? extends SingleSource<? extends T>>Function<? super Throwable,? extends Publisher<? extends ? extends SingleSource<? extends T>>>MaybeSource<? extends ? extends SingleSource<? extends T>>SingleSource<? extends ? extends SingleSource<? extends T>>Notification<? extends SingleSource<? extends T>>Flowable<Notification<? extends SingleSource<? extends T>>>Publisher<Notification<? extends SingleSource<? extends T>>>Function<? super ? extends SingleSource<? extends T>,? extends R>FlowableOperator<? extends R,? super ? extends SingleSource<? extends T>>last(io.reactivex.rxjava3.core.SingleSource)Function<? super ? extends SingleSource<? extends T>,? extends Publisher<TLeftEnd>>BiFunction<? super ? extends SingleSource<? extends T>,? super TRight,? extends R>BiFunction<? super ? extends SingleSource<? extends T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,? extends SingleSource<? extends T>>Flowable<GroupedFlowable<K,? extends SingleSource<? extends T>>>Publisher<GroupedFlowable<K,? extends SingleSource<? extends T>>>Function<? super ? extends SingleSource<? extends T>,? extends Iterable<? extends U>>BiFunction<? super ? extends SingleSource<? extends T>,? super U,? extends V>Function<? super ? extends SingleSource<? extends T>,? extends Publisher<? extends U>>first(io.reactivex.rxjava3.core.SingleSource)elementAt(long,io.reactivex.rxjava3.core.SingleSource)? super Notification<? extends SingleSource<? extends T>>Consumer<? super Notification<? extends SingleSource<? extends T>>>BiPredicate<? super ? extends SingleSource<? extends T>,? super ? extends SingleSource<? extends T>>Function<? super ? extends SingleSource<? extends T>,K>Function<? super ? extends SingleSource<? extends T>,Notification<R>>Function<? super ? extends SingleSource<? extends T>,? extends Publisher<U>>defaultIfEmpty(io.reactivex.rxjava3.core.SingleSource)FlowableTransformer<? super ? extends SingleSource<? extends T>,? extends R>BiConsumer<? super U,? super ? extends SingleSource<? extends T>>Flowable<List<? extends SingleSource<? extends T>>>Publisher<List<? extends SingleSource<? extends T>>>Future<? extends SingleSource<? extends T>>blockingSingle(io.reactivex.rxjava3.core.SingleSource)blockingMostRecent(io.reactivex.rxjava3.core.SingleSource)blockingLast(io.reactivex.rxjava3.core.SingleSource)blockingFirst(io.reactivex.rxjava3.core.SingleSource)Flowable<? extends SingleSource<? extends T>>()Function<? extends SingleSource<? extends T>,? extends SingleSource<? extends T>>ObservableConcatMapSingle<? extends SingleSource<? extends T>,T>FlowableConcatMapSinglePublisher<? extends SingleSource<? extends T>,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableConcatMapSinglePublisher.classFlowableConcatMapSinglePublisherFlowableConcatMapSinglePublisher<T,R>FlowableConcatMapSinglePublisher<T,R>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)FlowableConcatMapSinglePublisher(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.internal.util.ErrorMode,int)Flowable<SingleSource<? extends T>>Publisher<SingleSource<? extends T>>? super SingleSource<? extends T>Function<? super SingleSource<? extends T>,? extends SingleSource<? extends R>>Subscriber<? super SingleSource<? extends T>>Function<? super SingleSource<? extends T>,? extends Stream<? extends R>>Stream<SingleSource<? extends T>>BaseStream<SingleSource<? extends T>,Stream<SingleSource<? extends T>>>CompletionStage<SingleSource<? extends T>>Collector<? super SingleSource<? extends T>,A,R>Function<? super SingleSource<? extends T>,Optional<? extends R>>TestSubscriber<SingleSource<? extends T>>BaseTestConsumer<SingleSource<? extends T>,TestSubscriber<SingleSource<? extends T>>>FlowableSubscriber<SingleSource<? extends T>>Subscriber<SingleSource<? extends T>>BiFunction<? super SingleSource<? extends T>,? super U,? extends R>Function5<? super SingleSource<? extends T>,? super T1,? super T2,? super T3,? super T4,R>Function4<? super SingleSource<? extends T>,? super T1,? super T2,? super T3,R>Function3<? super SingleSource<? extends T>,? super T1,? super T2,R>Flowable<Flowable<SingleSource<? extends T>>>Publisher<Flowable<SingleSource<? extends T>>>List<SingleSource<? extends T>>Collection<SingleSource<? extends T>>Iterable<SingleSource<? extends T>>Single<List<SingleSource<? extends T>>>SingleSource<List<SingleSource<? extends T>>>Comparator<? super SingleSource<? extends T>>Observable<SingleSource<? extends T>>ObservableSource<SingleSource<? extends T>>Function<? super SingleSource<? extends T>,? extends K>Function<? super SingleSource<? extends T>,? extends V>Map<K,Collection<SingleSource<? extends T>>>Single<Map<K,Collection<SingleSource<? extends T>>>>SingleSource<Map<K,Collection<SingleSource<? extends T>>>>Map<K,SingleSource<? extends T>>Single<Map<K,SingleSource<? extends T>>>SingleSource<Map<K,SingleSource<? extends T>>>FlowableConverter<SingleSource<? extends T>,? extends R>Timed<SingleSource<? extends T>>Flowable<Timed<SingleSource<? extends T>>>Publisher<Timed<SingleSource<? extends T>>>Function<? super SingleSource<? extends T>,? extends Publisher<V>>Predicate<? super SingleSource<? extends T>>Function<? super SingleSource<? extends T>,? extends MaybeSource<? extends R>>Function<? super SingleSource<? extends T>,? extends Publisher<? extends R>>Function<? super SingleSource<? extends T>,? extends CompletableSource>FlowableSubscriber<? super SingleSource<? extends T>>Consumer<? super SingleSource<? extends T>>MaybeSource<SingleSource<? extends T>>SingleSource<SingleSource<? extends T>>Single<SingleSource<? extends T>>Maybe<SingleSource<? extends T>>BiFunction<R,? super SingleSource<? extends T>,R>BiFunction<SingleSource<? extends T>,SingleSource<? extends T>,SingleSource<? extends T>>ConnectableFlowable<SingleSource<? extends T>>? super Flowable<SingleSource<? extends T>>Function<? super Flowable<SingleSource<? extends T>>,? extends Publisher<R>>Function<? super Flowable<SingleSource<? extends T>>,? extends Publisher<? extends R>>ParallelFlowable<SingleSource<? extends T>>? extends Publisher<? extends SingleSource<? extends T>>Function<? super Throwable,? extends Publisher<? extends SingleSource<? extends T>>>Notification<SingleSource<? extends T>>Flowable<Notification<SingleSource<? extends T>>>Publisher<Notification<SingleSource<? extends T>>>Function<? super SingleSource<? extends T>,? extends R>FlowableOperator<? extends R,? super SingleSource<? extends T>>Function<? super SingleSource<? extends T>,? extends Publisher<TLeftEnd>>BiFunction<? super SingleSource<? extends T>,? super TRight,? extends R>BiFunction<? super SingleSource<? extends T>,? super Flowable<TRight>,? extends R>GroupedFlowable<K,SingleSource<? extends T>>Flowable<GroupedFlowable<K,SingleSource<? extends T>>>Publisher<GroupedFlowable<K,SingleSource<? extends T>>>Function<? super SingleSource<? extends T>,? extends Iterable<? extends U>>BiFunction<? super SingleSource<? extends T>,? super U,? extends V>Function<? super SingleSource<? extends T>,? extends Publisher<? extends U>>? super Notification<SingleSource<? extends T>>Consumer<? super Notification<SingleSource<? extends T>>>BiPredicate<? super SingleSource<? extends T>,? super SingleSource<? extends T>>Function<? super SingleSource<? extends T>,K>Function<? super SingleSource<? extends T>,Notification<R>>Function<? super SingleSource<? extends T>,? extends Publisher<U>>FlowableTransformer<? super SingleSource<? extends T>,? extends R>BiConsumer<? super U,? super SingleSource<? extends T>>Flowable<List<SingleSource<? extends T>>>Publisher<List<SingleSource<? extends T>>>Future<SingleSource<? extends T>>Flowable<SingleSource<? extends T>>()Function<SingleSource<? extends T>,SingleSource<? extends T>>Function<SingleSource<? extends T>,Publisher<? extends T>>SingleCreate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleCreate.classSingleCreateSingleCreate<T>(io.reactivex.rxjava3.core.SingleOnSubscribe)SingleCreate(io.reactivex.rxjava3.core.SingleOnSubscribe)SingleDefer<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDefer.classSingleDeferSingleDefer<T>(io.reactivex.rxjava3.functions.Supplier)SingleDefer(io.reactivex.rxjava3.functions.Supplier)singleSupplierSingleError<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleError.classSingleErrorSingleError<T>(io.reactivex.rxjava3.functions.Supplier)SingleError(io.reactivex.rxjava3.functions.Supplier)SingleFromCallable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFromCallable.classSingleFromCallableSingleFromCallable<T>(java.util.concurrent.Callable)SingleFromCallable(java.util.concurrent.Callable)SingleFromPublisher<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFromPublisher.classSingleFromPublisherSingleFromPublisher<T>(org.reactivestreams.Publisher)SingleFromPublisher(org.reactivestreams.Publisher)SingleFromSupplier<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFromSupplier.classSingleFromSupplierSingleFromSupplier<T>(io.reactivex.rxjava3.functions.Supplier)SingleFromSupplier(io.reactivex.rxjava3.functions.Supplier)SingleJust<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleJust.classSingleJustSingleJust<T>(java.lang.Object)SingleJust(java.lang.Object)FlowableFlatMapSinglePublisher<? extends SingleSource<? extends T>,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableFlatMapSinglePublisher.classFlowableFlatMapSinglePublisherFlowableFlatMapSinglePublisher<T,R>FlowableFlatMapSinglePublisher<T,R>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean,int)FlowableFlatMapSinglePublisher(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean,int)SingleFlatMap<SingleSource<? extends T>,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMap.classSingleFlatMapFunction<? super SingleSource<? extends T>,? extends SingleSource<? extends T>>SingleFlatMap<SingleSource<? extends T>,T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMap(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleEquals<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleEquals.classSingleEqualsSingleEquals<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)SingleEquals(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)FlowableSwitchMapSinglePublisher<? extends SingleSource<? extends T>,T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/FlowableSwitchMapSinglePublisher.classFlowableSwitchMapSinglePublisherFlowableSwitchMapSinglePublisher<T,R>FlowableSwitchMapSinglePublisher<T,R>(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean)FlowableSwitchMapSinglePublisher(org.reactivestreams.Publisher,io.reactivex.rxjava3.functions.Function,boolean)"unsafeCreate(Single) should be upgraded"unsafeCreate(Single) should be upgradedSingleFromUnsafeSource<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFromUnsafeSource.classSingleFromUnsafeSourceSingleFromUnsafeSource<T>(io.reactivex.rxjava3.core.SingleSource)SingleFromUnsafeSource(io.reactivex.rxjava3.core.SingleSource)SingleUsing<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleUsing.classSingleUsingSingleUsing<T,U>(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)SingleUsing(io.reactivex.rxjava3.functions.Supplier,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Consumer,boolean)singleFunctionSingleZipIterable<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleZipIterable.classSingleZipIterableSingleZipIterable<T,R>(java.lang.Iterable,io.reactivex.rxjava3.functions.Function)SingleZipIterable(java.lang.Iterable,io.reactivex.rxjava3.functions.Function)SingleZipArray<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleZipArray.classSingleZipArraySingleZipArray<T,R>(io.reactivex.rxjava3.core.SingleSource[],io.reactivex.rxjava3.functions.Function)SingleZipArray(io.reactivex.rxjava3.core.SingleSource[],io.reactivex.rxjava3.functions.Function)SingleHide<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleHide.classSingleHideSingleHide<T>(io.reactivex.rxjava3.core.SingleSource)SingleHide(io.reactivex.rxjava3.core.SingleSource)SingleTransformer<T,R>Single<Upstream>SingleSource<Upstream>apply(io.reactivex.rxjava3.core.Single)SingleSource<Downstream>SingleCache<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleCache.classSingleCacheSingleCache<T>(io.reactivex.rxjava3.core.SingleSource)C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleCache$CacheDisposable.classSingleCache$CacheDisposableSingleCache<>remove(io.reactivex.rxjava3.internal.operators.single.SingleCache.CacheDisposable)add(io.reactivex.rxjava3.internal.operators.single.SingleCache.CacheDisposable)SingleCache(io.reactivex.rxjava3.core.SingleSource)wipSingleFlatMap<T,R>SingleFlatMap<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleDelay<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDelay.classSingleDelaySingleDelay<T>(io.reactivex.rxjava3.core.SingleSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)SingleDelay(io.reactivex.rxjava3.core.SingleSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)SingleDelayWithSingle<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDelayWithSingle.classSingleDelayWithSingleSingleDelayWithSingle<T,U>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)SingleDelayWithSingle(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleSource)SingleDelayWithObservable<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDelayWithObservable.classSingleDelayWithObservableSingleDelayWithObservable<T,U>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.ObservableSource)SingleDelayWithObservable(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.ObservableSource)SingleDelayWithPublisher<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDelayWithPublisher.classSingleDelayWithPublisherSingleDelayWithPublisher<T,U>(io.reactivex.rxjava3.core.SingleSource,org.reactivestreams.Publisher)SingleDelayWithPublisher(io.reactivex.rxjava3.core.SingleSource,org.reactivestreams.Publisher)SingleDematerialize<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDematerialize.classSingleDematerializeSingleDematerialize<T,R>(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Function)SingleDematerialize(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Function)SingleDoAfterSuccess<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoAfterSuccess.classSingleDoAfterSuccessSingleDoAfterSuccess<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Consumer)SingleDoAfterSuccess(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Consumer)SingleDoAfterTerminate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoAfterTerminate.classSingleDoAfterTerminateSingleDoAfterTerminate<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Action)SingleDoAfterTerminate(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Action)SingleDoFinally<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoFinally.classSingleDoFinallySingleDoFinally<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Action)SingleDoFinally(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Action)SingleDoOnLifecycle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoOnLifecycle.classSingleDoOnLifecycleSingleDoOnLifecycle<T>(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)SingleDoOnLifecycle(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Action)SingleDoOnSubscribe<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoOnSubscribe.classSingleDoOnSubscribeSingleDoOnSubscribe<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Consumer)SingleDoOnSubscribe(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Consumer)SingleDoOnTerminate<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoOnTerminate.classSingleDoOnTerminateSingleDoOnTerminate<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Action)SingleDoOnTerminate(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Action)SingleDoOnSuccess<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoOnSuccess.classSingleDoOnSuccessSingleDoOnSuccess<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Consumer)SingleDoOnSuccess(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Consumer)SingleDoOnEvent<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoOnEvent.classSingleDoOnEventSingleDoOnEvent<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.BiConsumer)SingleDoOnEvent(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.BiConsumer)SingleDoOnError<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoOnError.classSingleDoOnErrorSingleDoOnError<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Consumer)SingleDoOnError(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Consumer)SingleDoOnDispose<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDoOnDispose.classSingleDoOnDisposeSingleDoOnDispose<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Action)SingleDoOnDispose(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Action)MaybeFilterSingle<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeFilterSingle.classMaybeFilterSingleMaybeFilterSingle<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Predicate)MaybeFilterSingle(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Predicate)SingleFlatMapBiSelector<T,U,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMapBiSelector.classSingleFlatMapBiSelectorSingleFlatMapBiSelector<T,U,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)SingleFlatMapBiSelector(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.BiFunction)SingleFlatMapNotification<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMapNotification.classSingleFlatMapNotificationSingleFlatMapNotification<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function)SingleFlatMapNotification(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function,io.reactivex.rxjava3.functions.Function)SingleFlatMapMaybe<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMapMaybe.classSingleFlatMapMaybeSingleFlatMapMaybe<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapMaybe(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapPublisher<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMapPublisher.classSingleFlatMapPublisherSingleFlatMapPublisher<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapPublisher(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapIterableFlowable<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMapIterableFlowable.classSingleFlatMapIterableFlowableSingleFlatMapIterableFlowable<T,R>SingleFlatMapIterableFlowable<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapIterableFlowable(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapIterableObservable<T,U>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMapIterableObservable.classSingleFlatMapIterableObservableSingleFlatMapIterableObservable<T,R>SingleFlatMapIterableObservable<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapIterableObservable(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapObservable<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/mixed/SingleFlatMapObservable.classSingleFlatMapObservableSingleFlatMapObservable<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapObservable(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapCompletable<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleFlatMapCompletable.classSingleFlatMapCompletableSingleFlatMapCompletable<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleFlatMapCompletable(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleLift<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleLift.classSingleLiftSingleLift<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleOperator)SingleLift(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.SingleOperator)SingleMap<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleMap.classSingleMapSingleMap<T,R>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleMap(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleMaterialize<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleMaterialize.classSingleMaterializeSingleMaterialize<T>(io.reactivex.rxjava3.core.Single)SingleMaterialize(io.reactivex.rxjava3.core.Single)SingleContains<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleContains.classSingleContainsSingleContains<T>(io.reactivex.rxjava3.core.SingleSource,java.lang.Object,io.reactivex.rxjava3.functions.BiPredicate)SingleContains(io.reactivex.rxjava3.core.SingleSource,java.lang.Object,io.reactivex.rxjava3.functions.BiPredicate)SingleObserveOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleObserveOn.classSingleObserveOnSingleObserveOn<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.Scheduler)SingleObserveOn(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.Scheduler)SingleOnErrorReturn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleOnErrorReturn.classSingleOnErrorReturnSingleOnErrorReturn<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function,java.lang.Object)SingleOnErrorReturn(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function,java.lang.Object)Function<Throwable,SingleSource<? extends T>>SingleOnErrorComplete<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleOnErrorComplete.classSingleOnErrorCompleteSingleOnErrorComplete<T>(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Predicate)SingleOnErrorComplete(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Predicate)SingleResumeNext<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleResumeNext.classSingleResumeNextSingleResumeNext<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)SingleResumeNext(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.functions.Function)nextFunctionSingleDetach<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleDetach.classSingleDetachSingleDetach<T>(io.reactivex.rxjava3.core.SingleSource)SingleDetach(io.reactivex.rxjava3.core.SingleSource)SafeSingleObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/SafeSingleObserver.classSafeSingleObserverSafeSingleObserver<T>(io.reactivex.rxjava3.core.SingleObserver)SafeSingleObserver(io.reactivex.rxjava3.core.SingleObserver)onCallbackBiConsumerSingleObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/BiConsumerSingleObserver.classBiConsumerSingleObserverBiConsumerSingleObserver<T>(io.reactivex.rxjava3.functions.BiConsumer)BiConsumerSingleObserver(io.reactivex.rxjava3.functions.BiConsumer)"onCallback is null"onCallback is nullConsumerSingleObserver<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/observers/ConsumerSingleObserver.classConsumerSingleObserverConsumerSingleObserver<T>(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer)ConsumerSingleObserver(io.reactivex.rxjava3.functions.Consumer,io.reactivex.rxjava3.functions.Consumer)"The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins"The RxJavaPlugins.onSubscribe hook returned a null SingleObserver. Please check the handler provided to RxJavaPlugins.setOnSingleSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/PluginsSingleSubscribeOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleSubscribeOn.classSingleSubscribeOnSingleSubscribeOn<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.Scheduler)SingleSubscribeOn(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.Scheduler)SingleTimeInterval<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeInterval.classSingleTimeIntervalSingleTimeInterval<T>(io.reactivex.rxjava3.core.SingleSource,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)SingleObserver<? super Timed<T>>SingleConverter<Timed<T>,? extends R>Single<Timed<Timed<T>>>SingleSource<Timed<Timed<T>>>? extends SingleSource<? extends Timed<T>>Function<? super Throwable,? extends SingleSource<? extends Timed<T>>>Function<Throwable,? extends Timed<T>>SingleOperator<? extends R,? super Timed<T>>Function<? super Timed<T>,? extends SingleSource<? extends U>>SingleTransformer<? super Timed<T>,? extends R>Single<Timed<T>>()SingleTimeInterval(io.reactivex.rxjava3.core.SingleSource,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,boolean)SingleTakeUntil<T,E>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleTakeUntil.classSingleTakeUntilSingleTakeUntil<T,U>SingleTakeUntil<T,U>(io.reactivex.rxjava3.core.SingleSource,org.reactivestreams.Publisher)SingleTakeUntil(io.reactivex.rxjava3.core.SingleSource,org.reactivestreams.Publisher)SingleToFlowable<E>Flowable<E>SingleToFlowable<E>(io.reactivex.rxjava3.core.SingleSource)Subscriber<? super E>Function<? super E,? extends Stream<? extends R>>Stream<E>BaseStream<E,Stream<E>>CompletionStage<E>Collector<? super E,A,R>Function<? super E,Optional<? extends R>>TestSubscriber<E>BaseTestConsumer<E,TestSubscriber<E>>FlowableSubscriber<E>Subscriber<E>BiFunction<? super E,? super U,? extends R>Function5<? super E,? super T1,? super T2,? super T3,? super T4,R>Function4<? super E,? super T1,? super T2,? super T3,R>Function3<? super E,? super T1,? super T2,R>Flowable<Flowable<E>>Publisher<Flowable<E>>List<E>Collection<E>Iterable<E>Single<List<E>>SingleSource<List<E>>Comparator<? super E>Observable<E>ObservableSource<E>Function<? super E,? extends K>Function<? super E,? extends V>Map<K,Collection<E>>Single<Map<K,Collection<E>>>SingleSource<Map<K,Collection<E>>>Map<K,E>Single<Map<K,E>>SingleSource<Map<K,E>>FlowableConverter<E,? extends R>Timed<E>Flowable<Timed<E>>Publisher<Timed<E>>Function<? super E,? extends Publisher<V>>Publisher<? extends E>Predicate<? super E>Function<? super E,? extends SingleSource<? extends R>>Function<? super E,? extends MaybeSource<? extends R>>Function<? super E,? extends Publisher<? extends R>>Function<? super E,? extends CompletableSource>FlowableSubscriber<? super E>E[]MaybeSource<E>SingleSource<E>Iterable<? extends E>Single<E>Maybe<E>BiFunction<R,? super E,R>BiFunction<E,E,E>ConnectableFlowable<E>? super Flowable<E>Function<? super Flowable<E>,? extends Publisher<R>>Function<? super Flowable<E>,? extends Publisher<? extends R>>ParallelFlowable<E>Function<? super Throwable,? extends E>? extends Publisher<? extends E>Function<? super Throwable,? extends Publisher<? extends E>>MaybeSource<? extends E>Notification<E>Flowable<Notification<E>>Publisher<Notification<E>>Function<? super E,? extends R>FlowableOperator<? extends R,? super E>Function<? super E,? extends Publisher<TLeftEnd>>BiFunction<? super E,? super TRight,? extends R>BiFunction<? super E,? super Flowable<TRight>,? extends R>GroupedFlowable<K,E>Flowable<GroupedFlowable<K,E>>Publisher<GroupedFlowable<K,E>>Function<? super E,? extends Iterable<? extends U>>BiFunction<? super E,? super U,? extends V>Function<? super E,? extends Publisher<? extends U>>? super Notification<E>Consumer<? super Notification<E>>BiPredicate<? super E,? super E>Function<? super E,K>Function<? super E,Notification<R>>Function<? super E,? extends Publisher<U>>FlowableTransformer<? super E,? extends R>BiConsumer<? super U,? super E>Flowable<List<E>>Publisher<List<E>>Future<E>Flowable<E>()SingleTimeout<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleTimeout.classSingleTimeoutSingleTimeout<T>(io.reactivex.rxjava3.core.SingleSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.SingleSource)SingleTimeout(io.reactivex.rxjava3.core.SingleSource,long,java.util.concurrent.TimeUnit,io.reactivex.rxjava3.core.Scheduler,io.reactivex.rxjava3.core.SingleSource)SingleUnsubscribeOn<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleUnsubscribeOn.classSingleUnsubscribeOnSingleUnsubscribeOn<T>(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.Scheduler)SingleUnsubscribeOn(io.reactivex.rxjava3.core.SingleSource,io.reactivex.rxjava3.core.Scheduler)SingleFromCompletionStage<T>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/SingleFromCompletionStage.classSingleFromCompletionStageSingleFromCompletionStage<T>(java.util.concurrent.CompletionStage)SingleFromCompletionStage(java.util.concurrent.CompletionStage)SingleMapOptional<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/SingleMapOptional.classSingleMapOptionalSingleMapOptional<T,R>(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Function)SingleMapOptional(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Function)SingleFlattenStreamAsFlowable<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/SingleFlattenStreamAsFlowable.classSingleFlattenStreamAsFlowableSingleFlattenStreamAsFlowable<T,R>(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Function)SingleFlattenStreamAsFlowable(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Function)SingleFlattenStreamAsObservable<T,R>C:/Users/Semiu/Java/ReactiveX_RxJava/src/main/java/io/reactivex/rxjava3/internal/jdk8/SingleFlattenStreamAsObservable.classSingleFlattenStreamAsObservableSingleFlattenStreamAsObservable<T,R>(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Function)SingleFlattenStreamAsObservable(io.reactivex.rxjava3.core.Single,io.reactivex.rxjava3.functions.Function)The {@code Single} class implements the Reactive Pattern for a single value response.{@code Single} behaves similarly to {@link Observable} except that it can only emit either a single successfulvalue or an error (there is no {@code onComplete} notification as there is for an {@code Observable}).The {@code Single} class implements the {@link SingleSource} base interface and the default consumertype it interacts with is the {@link SingleObserver} via the {@link #subscribe(SingleObserver)} method.The {@code Single} operates with the following sequential protocol:<code>onSubscribe (onSuccess | onError)?</code>Note that {@code onSuccess} and {@code onError} are mutually exclusive events; unlike {@code Observable},{@code onSuccess} is never followed by {@code onError}.Like {@code Observable}, a running {@code Single} can be stopped through the {@link Disposable} instanceLike an {@code Observable}, a {@code Single} is lazy, can be either "hot" or "cold", synchronous orasynchronous. {@code Single} instances returned by the methods of this class are <em>cold</em>{@link io.reactivex.rxjava3.subjects.SingleSubject SingleSubject}.<img width="640" height="301" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.legend.v3.png" alt="">For more information see the <a href="http://reactivex.io/documentation/single.html">ReactiveXdocumentation</a>.Disposable d = Single.just("Hello World").subscribeWith(new DisposableSingleObserver&lt;String&gt;() {Note that by design, subscriptions via {@link #subscribe(SingleObserver)} can't be disposed{@code void} return of the {@link #subscribe(SingleObserver)} method) and it is theresponsibility of the implementor of the {@code SingleObserver} to allo    
S    