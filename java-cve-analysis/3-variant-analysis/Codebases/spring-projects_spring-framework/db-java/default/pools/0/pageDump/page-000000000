C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/config/AopNamespaceHandlerAdviceOrderIntegrationTests.javaAopNamespaceHandlerAdviceOrderIntegrationTestsjavaC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/configconfigC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aopaopC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframeworkspringframeworkC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/orgorgC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/javaC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/testtestC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/srcsrcC:/Users/Semiu/Java/spring-projects_spring-framework/integration-testsintegration-testsC:/Users/Semiu/Java/spring-projects_spring-frameworkspring-projects_spring-frameworkC:/Users/Semiu/JavaJavaC:/Users/SemiuSemiuC:/UsersUsersC:/org.springframework.aop.configassertThatassertThatExceptionOfTypevoidAopNamespaceHandlerAdviceOrderIntegrationTests()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/config/AopNamespaceHandlerAdviceOrderIntegrationTests.classclassafterAdviceIsInvokedFirstafterAdviceIsInvokedFirst(org.springframework.aop.config.AopNamespaceHandlerAdviceOrderIntegrationTests.Echo,org.springframework.aop.config.AopNamespaceHandlerAdviceOrderIntegrationTests.InvocationTrackingAspect)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/config/AopNamespaceHandlerAdviceOrderIntegrationTests$AfterAdviceFirstTests.classAopNamespaceHandlerAdviceOrderIntegrationTests$AfterAdviceFirstTestsbooleantrueAfterAdviceFirstTestsAfterAdviceFirstTests()String[]lengthpublicfinalcloneclone()"AopNamespaceHandlerAdviceOrderIntegrationTests-afterFirst.xml"AopNamespaceHandlerAdviceOrderIntegrationTests-afterFirst.xmlechoaspectorg.assertj.core.apiListAssert<String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jarassertj-core-3.19.0jarC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452df64cb5690b85e68d5e1e6c6152bfb6e3840a452dC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.03.19.0C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-coreassertj-coreC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertjorg.assertjC:/Users/Semiu/.gradle/caches/modules-2/files-2.1files-2.1C:/Users/Semiu/.gradle/caches/modules-2modules-2C:/Users/Semiu/.gradle/cachescachesC:/Users/Semiu/.gradle.gradleC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/orgC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertjassertjC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/corecoreC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/apiapiC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/ListAssert.classListAssert? extends Stringjava.utilList<? extends String>C:/modules/java.base/java/util/List.classListC:/modules/java.base/java/utilutilC:/modules/java.base/javaC:/modules/java.basejava.baseC:/modulesmodulesCollection<? extends String>C:/modules/java.base/java/util/Collection.classCollectionjava.langIterable<? extends String>C:/modules/java.base/java/lang/Iterable.classIterableC:/modules/java.base/java/langlangabstractObjectAssert<String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/ObjectAssert.classObjectAssertAbstractObjectAssert<ObjectAssert<String>,String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractObjectAssert.classAbstractObjectAssertAbstractAssert<ObjectAssert<String>,String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractAssert.classAbstractAssertAssert<ObjectAssert<String>,String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/Assert.classAssertDescriptable<ObjectAssert<String>>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/Descriptable.classDescriptableExtensionPoints<ObjectAssert<String>,String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/ExtensionPoints.classExtensionPointsFactoryBasedNavigableListAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/FactoryBasedNavigableListAssert.classFactoryBasedNavigableListAssertAbstractListAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractListAssert.classAbstractListAssertAbstractIterableAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractIterableAssert.classAbstractIterableAssertAbstractAssert<ListAssert<String>,List<? extends String>>Assert<ListAssert<String>,List<? extends String>>Descriptable<ListAssert<String>>ExtensionPoints<ListAssert<String>,List<? extends String>>ObjectEnumerableAssert<ListAssert<String>,String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/ObjectEnumerableAssert.classObjectEnumerableAssertEnumerableAssert<ListAssert<String>,String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/EnumerableAssert.classEnumerableAssertIndexedObjectEnumerableAssert<ListAssert<String>,String>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/IndexedObjectEnumerableAssert.classIndexedObjectEnumerableAssertisEmptyisEmpty()describedAsdescribedAs(org.assertj.core.description.Description)ListAssert<>FactoryBasedNavigableListAssert<>AbstractListAssert<>AbstractIterableAssert<>AbstractAssert<>Assert<>Descriptable<>ExtensionPoints<>ObjectEnumerableAssert<>EnumerableAssert<>IndexedObjectEnumerableAssert<>Object[]describedAs(java.lang.String,java.lang.Object[])defaultasas(org.assertj.core.description.Description)java.util.functionSupplier<String>C:/modules/java.base/java/util/function/Supplier.classSupplierC:/modules/java.base/java/util/functionfunctionas(java.util.function.Supplier)as(java.lang.String,java.lang.Object[])? super ACTUALCondition<? super ACTUAL>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/Condition.classConditionDescriptable<Condition<? super ACTUAL>>satisfiessatisfies(org.assertj.core.api.Condition)? super List<? extends String>Condition<? super List<? extends String>>Descriptable<Condition<? super List<? extends String>>>doesNotHavedoesNotHave(org.assertj.core.api.Condition)hashas(org.assertj.core.api.Condition)isNotisNot(org.assertj.core.api.Condition)isis(org.assertj.core.api.Condition)doesNotHaveSameHashCodeAsdoesNotHaveSameHashCodeAs(java.lang.Object)hasSameHashCodeAshasSameHashCodeAs(java.lang.Object)withRepresentationwithRepresentation(org.assertj.core.presentation.Representation)withThreadDumpOnErrorwithThreadDumpOnError()equalsequals(java.lang.Object)AbstractCharSequenceAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractCharSequenceAssert.classAbstractCharSequenceAssert?AbstractCharSequenceAssert<?,String>AbstractAssert<?,String>Assert<?,String>Descriptable<?>ExtensionPoints<?,String>EnumerableAssert<?,Character>asStringasString()List<?>Collection<?>Iterable<?>ObjectAssert<Object>AbstractObjectAssert<ObjectAssert<Object>,Object>AbstractAssert<ObjectAssert<Object>,Object>Assert<ObjectAssert<Object>,Object>Descriptable<ObjectAssert<Object>>ExtensionPoints<ObjectAssert<Object>,Object>AbstractListAssert<?,List<?>,Object,ObjectAssert<Object>>AbstractIterableAssert<?,List<?>,Object,ObjectAssert<Object>>AbstractAssert<?,List<?>>Assert<?,List<?>>ExtensionPoints<?,List<?>>ObjectEnumerableAssert<?,Object>EnumerableAssert<?,Object>IndexedObjectEnumerableAssert<?,Object>asListasList()Class[]Class<?>C:/modules/java.base/java/lang/Class.classClassjava.lang.invokeOfField<Class<?>>C:/modules/java.base/java/lang/invoke/TypeDescriptor$OfField.classTypeDescriptor$OfFieldC:/modules/java.base/java/lang/invokeinvokestaticClass<?>[]isNotOfAnyClassInisNotOfAnyClassIn(java.lang.Class[])isOfAnyClassInisOfAnyClassIn(java.lang.Class[])isNotExactlyInstanceOfisNotExactlyInstanceOf(java.lang.Class)isExactlyInstanceOfisExactlyInstanceOf(java.lang.Class)doesNotHaveSameClassAsdoesNotHaveSameClassAs(java.lang.Object)doesNotHaveToStringdoesNotHaveToString(java.lang.String)hasToStringhasToString(java.lang.String)hasSameClassAshasSameClassAs(java.lang.Object)isNotInstanceOfAnyisNotInstanceOfAny(java.lang.Class[])isNotInstanceOfisNotInstanceOf(java.lang.Class)isInstanceOfAnyisInstanceOfAny(java.lang.Class[])Class<>OfField<>Consumer<>C:/modules/java.base/java/util/function/Consumer.classConsumerTisInstanceOfSatisfyingisInstanceOfSatisfying(java.lang.Class,java.util.function.Consumer)Class<T>Consumer<T>isInstanceOfisInstanceOf(java.lang.Class)InstanceOfAssertFactory<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/InstanceOfAssertFactory.classInstanceOfAssertFactoryAssertFactory<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AssertFactory.classAssertFactoryASSERTAbstractAssert<?,?>Assert<?,?>ExtensionPoints<?,?>asInstanceOfasInstanceOf(org.assertj.core.api.InstanceOfAssertFactory)InstanceOfAssertFactory<?,ASSERT>AssertFactory<Object,ASSERT>usingDefaultComparatorusingDefaultComparator()Comparator<? super ACTUAL>C:/modules/java.base/java/util/Comparator.classComparatorusingComparatorusingComparator(java.util.Comparator,java.lang.String)Comparator<? super List<? extends String>>usingComparator(java.util.Comparator)isNotInisNotIn(java.lang.Iterable)isInisIn(java.lang.Iterable)isNotIn(java.lang.Object[])isIn(java.lang.Object[])isNotSameAsisNotSameAs(java.lang.Object)isSameAsisSameAs(java.lang.Object)isNotNullisNotNull()isNullisNull()isNotEqualToisNotEqualTo(java.lang.Object)isEqualToisEqualTo(java.lang.Object)<clinit><clinit>()Function<>C:/modules/java.base/java/util/function/Function.classFunctionextractingextracting(java.util.function.Function,org.assertj.core.api.AssertFactory)protected? extends TFunction<? super ACTUAL,? extends T>AssertFactory<T,ASSERT>Function<? super List<? extends String>,? extends T>extracting(java.lang.String,org.assertj.core.api.AssertFactory)RecursiveComparisonAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/RecursiveComparisonAssert.classRecursiveComparisonAssertRecursiveComparisonAssert<?>AbstractAssert<?,Object>Assert<?,Object>ExtensionPoints<?,Object>usingRecursiveComparisonusingRecursiveComparison()usingRecursiveComparison(org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration)withAssertionStatewithAssertionState(org.assertj.core.api.AbstractAssert)List<>Collection<>Iterable<>E? extends EList<? extends E>Collection<? extends E>Iterable<? extends E>ObjectAssert<E>AbstractObjectAssert<ObjectAssert<E>,E>AbstractAssert<ObjectAssert<E>,E>Assert<ObjectAssert<E>,E>Descriptable<ObjectAssert<E>>ExtensionPoints<ObjectAssert<E>,E>AbstractListAssert<?,List<? extends E>,E,ObjectAssert<E>>AbstractIterableAssert<?,List<? extends E>,E,ObjectAssert<E>>AbstractAssert<?,List<? extends E>>Assert<?,List<? extends E>>ExtensionPoints<?,List<? extends E>>ObjectEnumerableAssert<?,E>EnumerableAssert<?,E>IndexedObjectEnumerableAssert<?,E>newListAssertInstancenewListAssertInstance(java.util.List)Consumer<Description>setDescriptionConsumersetDescriptionConsumer(java.util.function.Consumer)setPrintAssertionsDescriptionsetPrintAssertionsDescription(boolean)setCustomRepresentationsetCustomRepresentation(org.assertj.core.presentation.Representation)Consumer<ACTUAL>satisfiesAnyOfsatisfiesAnyOf(java.util.function.Consumer,java.util.function.Consumer,java.util.function.Consumer,java.util.function.Consumer)Consumer<List<? extends String>>satisfiesAnyOf(java.util.function.Consumer,java.util.function.Consumer,java.util.function.Consumer)satisfiesAnyOf(java.util.function.Consumer,java.util.function.Consumer)satisfies(java.util.function.Consumer)Predicate<? super ACTUAL>C:/modules/java.base/java/util/function/Predicate.classPredicatematchesmatches(java.util.function.Predicate,java.lang.String)Predicate<? super List<? extends String>>matches(java.util.function.Predicate)inthashCodehashCode()withFailMessagewithFailMessage(java.util.function.Supplier)withFailMessage(java.lang.String,java.lang.Object[])overridingErrorMessageoverridingErrorMessage(java.util.function.Supplier)overridingErrorMessage(java.lang.String,java.lang.Object[])descriptionTextdescriptionText()AbstractStringAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractStringAssert.classAbstractStringAssertAbstractStringAssert<?>inBinaryinBinary()inHexadecimalinHexadecimal()isElementOfCustomAssertisElementOfCustomAssert(java.lang.StackTraceElement)assertionErrorassertionError(org.assertj.core.error.ErrorMessageFactory)throwAssertionErrorthrowAssertionError(org.assertj.core.error.ErrorMessageFactory)failureWithActualExpectedfailureWithActualExpected(java.lang.Object,java.lang.Object,java.lang.String,java.lang.Object[])failWithActualExpectedAndMessagefailWithActualExpectedAndMessage(java.lang.Object,java.lang.Object,java.lang.String,java.lang.Object[])failurefailure(java.lang.String,java.lang.Object[])failWithMessagefailWithMessage(java.lang.String,java.lang.Object[])getWritableAssertionInfogetWritableAssertionInfo()AbstractAssert(java.lang.Object,java.lang.Class)AbstractAssert<ListAssert<String>,List<? extends String>>(java.util.List,java.lang.Class)assertionErrorCreatormyselfactualinfoconditionsobjectsthrowUnsupportedExceptionOnEqualsusingDefaultElementComparatorusingDefaultElementComparator()? super ELEMENTComparator<? super ELEMENT>usingElementComparatorusingElementComparator(java.util.Comparator)? super StringComparator<? super String>hasSameSizeAshasSameSizeAs(java.lang.Object)hasSameSizeAs(java.lang.Iterable)hasSizeBetweenhasSizeBetween(int,int)hasSizeLessThanOrEqualTohasSizeLessThanOrEqualTo(int)hasSizeLessThanhasSizeLessThan(int)hasSizeGreaterThanOrEqualTohasSizeGreaterThanOrEqualTo(int)hasSizeGreaterThanhasSizeGreaterThan(int)hasSizehasSize(int)isNotEmptyisNotEmpty()isNullOrEmptyisNullOrEmpty()Predicate<? super ELEMENT>noneMatchnoneMatch(java.util.function.Predicate)Predicate<? super String>? extends ELEMENTIterable<? extends ELEMENT>containsAnyElementsOfcontainsAnyElementsOf(java.lang.Iterable)ELEMENT[]containsAnyOfcontainsAnyOf(java.lang.Object[])containsAnyOf(java.lang.String[])Consumer<? super ELEMENT>noneSatisfynoneSatisfy(java.util.function.Consumer)Consumer<? super String>anySatisfyanySatisfy(java.util.function.Consumer)anyMatchanyMatch(java.util.function.Predicate)Consumer[]Consumer<? super ELEMENT>[]satisfiesExactlyInAnyOrdersatisfiesExactlyInAnyOrder(java.util.function.Consumer[])Consumer<? super String>[]satisfiesExactlysatisfiesExactly(java.util.function.Consumer[])allSatisfyallSatisfy(java.util.function.Consumer)allMatchallMatch(java.util.function.Predicate,java.lang.String)allMatch(java.util.function.Predicate)isSubsetOfisSubsetOf(java.lang.Object[])isSubsetOf(java.lang.String[])isSubsetOf(java.lang.Iterable)doesNotContainAnyElementsOfdoesNotContainAnyElementsOf(java.lang.Iterable)hasSameElementsAshasSameElementsAs(java.lang.Iterable)containsOnlyOnceElementsOfcontainsOnlyOnceElementsOf(java.lang.Iterable)containsOnlyElementsOfcontainsOnlyElementsOf(java.lang.Iterable)containsExactlyElementsOfcontainsExactlyElementsOf(java.lang.Iterable)doesNotHaveAnyElementsOfTypesdoesNotHaveAnyElementsOfTypes(java.lang.Class[])hasOnlyElementsOfTypehasOnlyElementsOfType(java.lang.Class)hasAtLeastOneElementOfTypehasAtLeastOneElementOfType(java.lang.Class)hasOnlyElementsOfTypeshasOnlyElementsOfTypes(java.lang.Class[])hasOnlyOneElementSatisfyinghasOnlyOneElementSatisfying(java.util.function.Consumer)containsAllcontainsAll(java.lang.Iterable)Condition<? super ELEMENT>Descriptable<Condition<? super ELEMENT>>haveExactlyhaveExactly(int,org.assertj.core.api.Condition)Condition<? super String>Descriptable<Condition<? super String>>haveAtMosthaveAtMost(int,org.assertj.core.api.Condition)haveAtLeasthaveAtLeast(int,org.assertj.core.api.Condition)haveAtLeastOnehaveAtLeastOne(org.assertj.core.api.Condition)areExactlyareExactly(int,org.assertj.core.api.Condition)areAtMostareAtMost(int,org.assertj.core.api.Condition)areAtLeastOneareAtLeastOne(org.assertj.core.api.Condition)areAtLeastareAtLeast(int,org.assertj.core.api.Condition)doNotHavedoNotHave(org.assertj.core.api.Condition)havehave(org.assertj.core.api.Condition)areNotareNot(org.assertj.core.api.Condition)areare(org.assertj.core.api.Condition)doesNotContainNulldoesNotContainNull()containsNullcontainsNull()endsWithendsWith(java.lang.Object[])endsWith(java.lang.String[])endsWith(java.lang.Object,java.lang.Object[])endsWith(java.lang.String,java.lang.String[])startsWithstartsWith(java.lang.Object[])startsWith(java.lang.String[])doesNotHaveDuplicatesdoesNotHaveDuplicates()doesNotContaindoesNotContain(java.lang.Object[])doesNotContain(java.lang.String[])doesNotContainSubsequencedoesNotContainSubsequence(java.lang.Iterable)doesNotContainSubsequence(java.lang.Object[])doesNotContainSubsequence(java.lang.String[])containsSubsequencecontainsSubsequence(java.lang.Iterable)containsSubsequence(java.lang.Object[])containsSubsequence(java.lang.String[])doesNotContainSequencedoesNotContainSequence(java.lang.Iterable)doesNotContainSequence(java.lang.Object[])doesNotContainSequence(java.lang.String[])containsSequencecontainsSequence(java.lang.Iterable)containsSequence(java.lang.Object[])containsSequence(java.lang.String[])containsExactlyInAnyOrderElementsOfcontainsExactlyInAnyOrderElementsOf(java.lang.Iterable)containsExactlyInAnyOrdercontainsExactlyInAnyOrder(java.lang.Object[])containsExactlyInAnyOrder(java.lang.String[])containsExactlycontainsExactly(java.lang.Object[])containsExactly(java.lang.String[])containsOnlyOncecontainsOnlyOnce(java.lang.Object[])containsOnlyOnce(java.lang.String[])containsOnlyNullscontainsOnlyNulls()containsOnlycontainsOnly(java.lang.Object[])containsOnly(java.lang.String[])containscontains(java.lang.Object[])contains(java.lang.String[])withComparatorsForElementPropertyOrFieldTypeswithComparatorsForElementPropertyOrFieldTypes(org.assertj.core.internal.TypeComparators)Comparator<?>Map<String,Comparator<?>>C:/modules/java.base/java/util/Map.classMapwithComparatorsForElementPropertyOrFieldNameswithComparatorsForElementPropertyOrFieldNames(java.util.Map)withTypeComparatorswithTypeComparators(org.assertj.core.internal.TypeComparators)withIterableswithIterables(org.assertj.core.internal.Iterables)newAbstractIterableAssertnewAbstractIterableAssert(java.lang.Iterable)getComparatorsForElementPropertyOrFieldTypesgetComparatorsForElementPropertyOrFieldTypes()getComparatorsByTypegetComparatorsByType()AbstractIterableSizeAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractIterableSizeAssert.classAbstractIterableSizeAssertAbstractIntegerAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractIntegerAssert.classAbstractIntegerAssertAbstractComparableAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractComparableAssert.classAbstractComparableAssertAbstractObjectAssert<>ComparableAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/ComparableAssert.classComparableAssertNumberAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/NumberAssert.classNumberAssertAbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>AbstractIntegerAssert<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>>AbstractComparableAssert<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>,Integer>AbstractObjectAssert<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>,Integer>AbstractAssert<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>,Integer>Assert<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>,Integer>Descriptable<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>>ExtensionPoints<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>,Integer>ComparableAssert<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>,Integer>NumberAssert<AbstractIterableSizeAssert<SELF,ACTUAL,ELEMENT,ELEMENT_ASSERT>,Integer>sizesize()AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>AbstractIntegerAssert<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>>AbstractComparableAssert<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>,Integer>AbstractObjectAssert<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>,Integer>AbstractAssert<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>,Integer>Assert<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>,Integer>Descriptable<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>>ExtensionPoints<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>,Integer>ComparableAssert<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>,Integer>NumberAssert<AbstractIterableSizeAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>,Integer>BiConsumer<>C:/modules/java.base/java/util/function/BiConsumer.classBiConsumerOTHER_ELEMENTzipSatisfyzipSatisfy(java.lang.Iterable,java.util.function.BiConsumer)Iterable<OTHER_ELEMENT>BiConsumer<? super ELEMENT,OTHER_ELEMENT>BiConsumer<? super String,OTHER_ELEMENT>filteredOnfilteredOn(java.util.function.Predicate)navigationDescriptionnavigationDescription(java.lang.String)toAsserttoAssert(java.lang.Object,java.lang.String)ObjectAssert<>toAssert(java.lang.String,java.lang.String)singleElementsingleElement(org.assertj.core.api.InstanceOfAssertFactory)singleElement()elementelement(int,org.assertj.core.api.InstanceOfAssertFactory)element(int)lastlast(org.assertj.core.api.InstanceOfAssertFactory)last()firstfirst(org.assertj.core.api.InstanceOfAssertFactory)first()filteredOnAssertionsfilteredOnAssertions(java.util.function.Consumer)filteredOn(java.util.function.Function,java.lang.Object)Function<? super ELEMENT,T>Function<? super String,T>filteredOn(org.assertj.core.api.Condition)org.assertj.core.api.filterFilterOperator<?>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/filterfilterC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/filter/FilterOperator.classFilterOperatorfilteredOn(java.lang.String,org.assertj.core.api.filter.FilterOperator)filteredOnNullfilteredOnNull(java.lang.String)filteredOn(java.lang.String,java.lang.Object)usingElementComparatorIgnoringFieldsusingElementComparatorIgnoringFields(java.lang.String[])usingComparisonStrategyusingComparisonStrategy(org.assertj.core.internal.ComparisonStrategy)usingElementComparatorOnFieldsusingElementComparatorOnFields(java.lang.String[])usingRecursiveFieldByFieldElementComparatorusingRecursiveFieldByFieldElementComparator(org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration)usingRecursiveFieldByFieldElementComparator()usingFieldByFieldElementComparatorusingFieldByFieldElementComparator()Comparator<>usingComparatorForTypeusingComparatorForType(java.util.Comparator,java.lang.Class)Comparator<T>usingComparatorForElementFieldsWithTypeusingComparatorForElementFieldsWithType(java.util.Comparator,java.lang.Class)usingComparatorForElementFieldsWithNamesusingComparatorForElementFieldsWithNames(java.util.Comparator,java.lang.String[])? extends ObjectList<? extends Object>Collection<? extends Object>Iterable<? extends Object>AbstractListAssert<?,List<? extends Object>,Object,ObjectAssert<Object>>AbstractIterableAssert<?,List<? extends Object>,Object,ObjectAssert<Object>>AbstractAssert<?,List<? extends Object>>Assert<?,List<? extends Object>>ExtensionPoints<?,List<? extends Object>>flatExtractingflatExtracting(java.lang.String[])Function[]Function<? super ELEMENT,?>Function<? super ELEMENT,?>[]? extends TupleList<? extends Tuple>Collection<? extends Tuple>Iterable<? extends Tuple>ObjectAssert<Tuple>AbstractObjectAssert<ObjectAssert<Tuple>,Tuple>AbstractAssert<ObjectAssert<Tuple>,Tuple>Assert<ObjectAssert<Tuple>,Tuple>Descriptable<ObjectAssert<Tuple>>ExtensionPoints<ObjectAssert<Tuple>,Tuple>AbstractListAssert<?,List<? extends Tuple>,Tuple,ObjectAssert<Tuple>>AbstractIterableAssert<?,List<? extends Tuple>,Tuple,ObjectAssert<Tuple>>AbstractAssert<?,List<? extends Tuple>>Assert<?,List<? extends Tuple>>ExtensionPoints<?,List<? extends Tuple>>ObjectEnumerableAssert<?,Tuple>EnumerableAssert<?,Tuple>IndexedObjectEnumerableAssert<?,Tuple>mapmap(java.util.function.Function[])Function<? super String,?>Function<? super String,?>[]extracting(java.util.function.Function[])flatExtracting(java.lang.String)ThrowingExtractor[]org.assertj.core.api.iterableThrowingExtractor<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/iterableiterableC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/iterable/ThrowingExtractor.classThrowingExtractorThrowingExtractor<>[]EXCEPTIONflatMapflatMap(org.assertj.core.api.iterable.ThrowingExtractor[])ThrowingExtractor<? super ELEMENT,?,EXCEPTION>ThrowingExtractor<? super ELEMENT,?,EXCEPTION>[]ThrowingExtractor<? super String,?,EXCEPTION>ThrowingExtractor<? super String,?,EXCEPTION>[]flatExtracting(org.assertj.core.api.iterable.ThrowingExtractor[])flatMap(java.util.function.Function[])flatExtracting(java.util.function.Function[])V? extends VList<? extends V>Collection<? extends V>Iterable<? extends V>ObjectAssert<V>AbstractObjectAssert<ObjectAssert<V>,V>AbstractAssert<ObjectAssert<V>,V>Assert<ObjectAssert<V>,V>Descriptable<ObjectAssert<V>>ExtensionPoints<ObjectAssert<V>,V>AbstractListAssert<?,List<? extends V>,V,ObjectAssert<V>>AbstractIterableAssert<?,List<? extends V>,V,ObjectAssert<V>>AbstractAssert<?,List<? extends V>>Assert<?,List<? extends V>>ExtensionPoints<?,List<? extends V>>ObjectEnumerableAssert<?,V>EnumerableAssert<?,V>IndexedObjectEnumerableAssert<?,V>flatMap(org.assertj.core.api.iterable.ThrowingExtractor)Collection<V>Iterable<V>? extends Collection<V>ThrowingExtractor<? super ELEMENT,? extends Collection<V>,EXCEPTION>Function<? super ELEMENT,? extends Collection<V>>ThrowingExtractor<? super String,? extends Collection<V>,EXCEPTION>Function<? super String,? extends Collection<V>>flatExtracting(org.assertj.core.api.iterable.ThrowingExtractor)flatMap(java.util.function.Function)flatExtracting(java.util.function.Function)map(org.assertj.core.api.iterable.ThrowingExtractor)ThrowingExtractor<? super ELEMENT,V,EXCEPTION>Function<? super ELEMENT,V>ThrowingExtractor<? super String,V,EXCEPTION>Function<? super String,V>extracting(org.assertj.core.api.iterable.ThrowingExtractor)map(java.util.function.Function)extracting(java.util.function.Function)extracting(java.lang.String[])P? extends PList<? extends P>Collection<? extends P>Iterable<? extends P>ObjectAssert<P>AbstractObjectAssert<ObjectAssert<P>,P>AbstractAssert<ObjectAssert<P>,P>Assert<ObjectAssert<P>,P>Descriptable<ObjectAssert<P>>ExtensionPoints<ObjectAssert<P>,P>AbstractListAssert<?,List<? extends P>,P,ObjectAssert<P>>AbstractIterableAssert<?,List<? extends P>,P,ObjectAssert<P>>AbstractAssert<?,List<? extends P>>Assert<?,List<? extends P>>ExtensionPoints<?,List<? extends P>>ObjectEnumerableAssert<?,P>EnumerableAssert<?,P>IndexedObjectEnumerableAssert<?,P>extracting(java.lang.String,java.lang.Class)Class<P>extractingResultOfextractingResultOf(java.lang.String,java.lang.Class)extractingResultOf(java.lang.String)extracting(java.lang.String)AbstractIterableAssert(java.lang.Iterable,java.lang.Class)AbstractIterableAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>(java.util.List,java.lang.Class)iterablesList<String>Collection<String>Iterable<String>? super ObjectCondition<? super Object>Descriptable<Condition<? super Object>>Comparator<? super Object>Function<? super Object,? extends T>Consumer<Object>Predicate<? super Object>AbstractAssert<ObjectAssert<Object>,Object>(java.lang.Object,java.lang.Class)42doesNotContain(java.lang.Object,org.assertj.core.data.Index)doesNotContain(java.lang.String,org.assertj.core.data.Index)contains(java.lang.Object,org.assertj.core.data.Index)contains(java.lang.String,org.assertj.core.data.Index)satisfies(java.util.function.Consumer,org.assertj.core.data.Index)isSortedAccordingToisSortedAccordingTo(java.util.Comparator)isSortedisSorted()is(org.assertj.core.api.Condition,org.assertj.core.data.Index)has(org.assertj.core.api.Condition,org.assertj.core.data.Index)AbstractListAssert(java.util.List,java.lang.Class)AbstractListAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>(java.util.List,java.lang.Class)listsAssertFactory<ELEMENT,ELEMENT_ASSERT>FactoryBasedNavigableListAssert(java.util.List,java.lang.Class,org.assertj.core.api.AssertFactory)AssertFactory<String,ObjectAssert<String>>FactoryBasedNavigableListAssert<ListAssert<String>,List<? extends String>,String,ObjectAssert<String>>(java.util.List,java.lang.Class,org.assertj.core.api.AssertFactory)ListAssert(java.util.stream.DoubleStream)ListAssert<String>(java.util.stream.DoubleStream)ListAssert(java.util.stream.LongStream)ListAssert<String>(java.util.stream.LongStream)ListAssert(java.util.stream.IntStream)ListAssert<String>(java.util.stream.IntStream)java.util.streamStream<? extends ELEMENT>C:/modules/java.base/java/util/stream/Stream.classStreamC:/modules/java.base/java/util/streamstreamBaseStream<? extends ELEMENT,Stream<? extends ELEMENT>>C:/modules/java.base/java/util/stream/BaseStream.classBaseStreamListAssert(java.util.stream.Stream)Stream<? extends String>BaseStream<? extends String,Stream<? extends String>>ListAssert<String>(java.util.stream.Stream)List<? extends ELEMENT>Collection<? extends ELEMENT>ListAssert(java.util.List)ListAssert<String>(java.util.List)"around - start"around - start"before"before"around - end"around - end"after"after"after returning"after returningclearclear()Spliterator<>C:/modules/java.base/java/util/Spliterator.classSpliteratorSpliterator<T>spliteratorspliterator()Spliterator<String>? super TConsumer<? super T>forEachforEach(java.util.function.Consumer)Iterator<>C:/modules/java.base/java/util/Iterator.classIteratorIterator<T>iteratoriterator()Iterator<String>Stream<>BaseStream<>Stream<E>BaseStream<E,Stream<E>>parallelStreamparallelStream()Stream<String>BaseStream<String,Stream<String>>stream()Spliterator<E>retainAllretainAll(java.util.Collection)? super EPredicate<? super E>removeIfremoveIf(java.util.function.Predicate)removeAllremoveAll(java.util.Collection)addAlladdAll(java.util.Collection)containsAll(java.util.Collection)removeremove(java.lang.Object)addadd(java.lang.Object)add(java.lang.String)IntFunction<>C:/modules/java.base/java/util/function/IntFunction.classIntFunctionT[]toArraytoArray(java.util.function.IntFunction)IntFunction<T[]>toArray(java.lang.Object[])toArray()Iterator<E>contains(java.lang.Object)List<E>Collection<E>Iterable<E>copyOfcopyOf(java.util.Collection)ofof(java.lang.Object[])E[]of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object)of(java.lang.Object)of()subListsubList(int,int)ListIterator<>C:/modules/java.base/java/util/ListIterator.classListIteratorListIterator<E>listIteratorlistIterator(int)ListIterator<String>listIterator()lastIndexOflastIndexOf(java.lang.Object)indexOfindexOf(java.lang.Object)remove(int)add(int,java.lang.Object)add(int,java.lang.String)setset(int,java.lang.Object)set(int,java.lang.String)getget(int)Comparator<? super E>sortsort(java.util.Comparator)UnaryOperator<E>C:/modules/java.base/java/util/function/UnaryOperator.classUnaryOperatorFunction<E,E>replaceAllreplaceAll(java.util.function.UnaryOperator)UnaryOperator<String>Function<String,String>addAll(int,java.util.Collection)ThrowableAssertAlternative<Exception>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/ThrowableAssertAlternative.classThrowableAssertAlternativeAbstractAssert<ThrowableAssertAlternative<Exception>,Exception>Assert<ThrowableAssertAlternative<Exception>,Exception>Descriptable<ThrowableAssertAlternative<Exception>>ExtensionPoints<ThrowableAssertAlternative<Exception>,Exception>ThrowableTypeAssert<Exception>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/ThrowableTypeAssert.classThrowableTypeAssertDescriptable<ThrowableTypeAssert<Exception>>ThrowableAssertAlternative<>isThrownByisThrownBy(org.assertj.core.api.ThrowableAssert.ThrowingCallable)ThrowableTypeAssert<>ThrowableAssertAlternative<T>AbstractAssert<ThrowableAssertAlternative<T>,T>Assert<ThrowableAssertAlternative<T>,T>Descriptable<ThrowableAssertAlternative<T>>ExtensionPoints<ThrowableAssertAlternative<T>,T>Class<? extends T>ThrowableTypeAssert(java.lang.Class)? extends ExceptionClass<? extends Exception>ThrowableTypeAssert<Exception>(java.lang.Class)descriptionexpectedThrowableTypeClass<Exception>()callcall()"after throwing"after throwingafterAdviceIsInvokedLastafterAdviceIsInvokedLast(org.springframework.aop.config.AopNamespaceHandlerAdviceOrderIntegrationTests.Echo,org.springframework.aop.config.AopNamespaceHandlerAdviceOrderIntegrationTests.InvocationTrackingAspect)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/config/AopNamespaceHandlerAdviceOrderIntegrationTests$AfterAdviceLastTests.classAopNamespaceHandlerAdviceOrderIntegrationTests$AfterAdviceLastTestsAfterAdviceLastTestsAfterAdviceLastTests()"AopNamespaceHandlerAdviceOrderIntegrationTests-afterLast.xml"AopNamespaceHandlerAdviceOrderIntegrationTests-afterLast.xmlecho(java.lang.Object)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/config/AopNamespaceHandlerAdviceOrderIntegrationTests$Echo.classAopNamespaceHandlerAdviceOrderIntegrationTests$EchoEchoEcho()objafter()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/config/AopNamespaceHandlerAdviceOrderIntegrationTests$InvocationTrackingAspect.classAopNamespaceHandlerAdviceOrderIntegrationTests$InvocationTrackingAspectafterThrowingafterThrowing()afterReturningafterReturning()before()aroundaround(org.aspectj.lang.ProceedingJoinPoint)invocationsInvocationTrackingAspectInvocationTrackingAspect()<obinit><obinit>()privateArrayList<String>C:/modules/java.base/java/util/ArrayList.classArrayListAbstractList<String>C:/modules/java.base/java/util/AbstractList.classAbstractListAbstractCollection<String>C:/modules/java.base/java/util/AbstractCollection.classAbstractCollectionArrayList<String>()toStringtoString()AbstractCollection()AbstractCollection<String>()removeRangeremoveRange(int,int)subListRangeChecksubListRangeCheck(int,int,int)AbstractList()AbstractList<String>()modCounttransientcheckInvariantscheckInvariants()removeIf(java.util.function.Predicate,int,int)Consumer<? super E>batchRemovebatchRemove(java.util.Collection,boolean,int,int)hashCodeRangehashCodeRange(int,int)equalsRangeequalsRange(java.util.List,int,int)elementAtelementAt(java.lang.Object[],int)elementDataelementData(int)lastIndexOfRangelastIndexOfRange(java.lang.Object,int,int)indexOfRangeindexOfRange(java.lang.Object,int,int)ensureCapacityensureCapacity(int)trimToSizetrimToSize()ArrayList(java.util.Collection)ArrayList<String>(java.util.Collection)ArrayList()ArrayList(int)ArrayList<String>(int)joinPointCopyright 2002-2020 the original author or authors.Licensed under the Apache License, Version 2.0 (the "License");you may not use this file except in compliance with the License.You may obtain a copy of the License athttps://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an "AS IS" BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.Integration tests for advice invocation order for advice configured via theAOP namespace.@authorSam Brannen@since5.2.7@seeorg.springframework.aop.framework.autoproxy.AspectJAutoProxyAdviceOrderIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/config/AopNamespaceHandlerScopeIntegrationTests.javaAopNamespaceHandlerScopeIntegrationTeststestSessionScopingtestSessionScoping()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/config/AopNamespaceHandlerScopeIntegrationTests.classtestRequestScopingtestRequestScoping()testSingletonScopingtestSingletonScoping()testBeansessionScopedAliassessionScopedrequestScopedsingletonScopedAopNamespaceHandlerScopeIntegrationTests()conditionrob"Rob Harrop"Rob Harropbram"Bram Smeets"Bram SmeetsdeserializedAbstractBooleanAssert<?>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractBooleanAssert.classAbstractBooleanAssertAbstractAssert<?,Boolean>Assert<?,Boolean>ExtensionPoints<?,Boolean>AbstractBooleanAssert<>isTrueisTrue()? super BooleanCondition<? super Boolean>Descriptable<Condition<? super Boolean>>Comparator<? super Boolean>Function<? super Boolean,? extends T>Consumer<Boolean>Predicate<? super Boolean>AbstractAssert<?,Boolean>(java.lang.Boolean,java.lang.Class)isNotEqualTo(boolean)isEqualTo(boolean)isFalseisFalse()AbstractBooleanAssert(java.lang.Boolean,java.lang.Class)AbstractBooleanAssert<?>(java.lang.Boolean,java.lang.Class)booleans"Should be AOP proxy"Should be AOP proxy"Should be target class proxy"Should be target class proxyisEqualTo(java.lang.String)Function<? super String,? extends T>Consumer<String>AbstractAssert<?,String>(java.lang.String,java.lang.Class)? super CharacterComparator<? super Character>isEqualToNormalizingUnicodeisEqualToNormalizingUnicode(java.lang.CharSequence)isUpperCaseisUpperCase()isLowerCaseisLowerCase()isEqualToIgnoringNewLinesisEqualToIgnoringNewLines(java.lang.CharSequence)isEqualToNormalizingNewlinesisEqualToNormalizingNewlines(java.lang.CharSequence)containsPatterncontainsPattern(java.util.regex.Pattern)containsPattern(java.lang.CharSequence)isSubstringOfisSubstringOf(java.lang.CharSequence)isEqualToNormalizingPunctuationAndWhitespaceisEqualToNormalizingPunctuationAndWhitespace(java.lang.CharSequence)isNotEqualToNormalizingWhitespaceisNotEqualToNormalizingWhitespace(java.lang.CharSequence)isEqualToNormalizingWhitespaceisEqualToNormalizingWhitespace(java.lang.CharSequence)isNotEqualToIgnoringWhitespaceisNotEqualToIgnoringWhitespace(java.lang.CharSequence)isEqualToIgnoringWhitespaceisEqualToIgnoringWhitespace(java.lang.CharSequence)inUnicodeinUnicode()isXmlEqualToContentOfisXmlEqualToContentOf(java.io.File)isXmlEqualToisXmlEqualTo(java.lang.CharSequence)doesNotMatchdoesNotMatch(java.util.regex.Pattern)matches(java.util.regex.Pattern)doesNotMatch(java.lang.CharSequence)matches(java.lang.CharSequence)doesNotEndWithdoesNotEndWith(java.lang.CharSequence)endsWith(java.lang.CharSequence)doesNotStartWithdoesNotStartWith(java.lang.CharSequence)startsWith(java.lang.CharSequence)doesNotContainPatterndoesNotContainPattern(java.util.regex.Pattern)doesNotContainPattern(java.lang.CharSequence)CharSequence[]doesNotContainIgnoringCasedoesNotContainIgnoringCase(java.lang.CharSequence[])? extends CharSequenceIterable<? extends CharSequence>doesNotContain(java.lang.Iterable)doesNotContain(java.lang.CharSequence[])containsIgnoringCasecontainsIgnoringCase(java.lang.CharSequence)containsSubsequence(java.lang.CharSequence[])containsSequence(java.lang.CharSequence[])contains(java.lang.Iterable)contains(java.lang.CharSequence[])containsOnlyOnce(java.lang.CharSequence)containsOnlyDigitscontainsOnlyDigits()isNotEqualToIgnoringCaseisNotEqualToIgnoringCase(java.lang.CharSequence)isEqualToIgnoringCaseisEqualToIgnoringCase(java.lang.CharSequence)hasSameSizeAs(java.lang.CharSequence)hasLineCounthasLineCount(int)isNotJavaBlankisNotJavaBlank()isJavaBlankisJavaBlank()doesNotContainOnlyWhitespacesdoesNotContainOnlyWhitespaces()doesNotContainAnyWhitespacesdoesNotContainAnyWhitespaces()containsOnlyWhitespacescontainsOnlyWhitespaces()containsWhitespacescontainsWhitespaces()isNotBlankisNotBlank()isBlankisBlank()AbstractCharSequenceAssert(java.lang.CharSequence,java.lang.Class)AbstractCharSequenceAssert<?,String>(java.lang.String,java.lang.Class)stringsisEqualTo(java.lang.String,java.lang.Object[])AbstractByteArrayAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractByteArrayAssert.classAbstractByteArrayAssertAbstractArrayAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractArrayAssert.classAbstractArrayAssertAbstractEnumerableAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractEnumerableAssert.classAbstractEnumerableAssertArraySortedAssert<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/ArraySortedAssert.classArraySortedAssertAbstractByteArrayAssert<?>bytebyte[]AbstractArrayAssert<?,byte[],Byte>AbstractEnumerableAssert<?,byte[],Byte>AbstractAssert<?,byte[]>Assert<?,byte[]>ExtensionPoints<?,byte[]>EnumerableAssert<AbstractEnumerableAssert<?,byte[],Byte>,Byte>ArraySortedAssert<AbstractArrayAssert<?,byte[],Byte>,Byte>decodedAsBase64decodedAsBase64()isBase64isBase64()isStrictlyBetweenisStrictlyBetween(java.lang.String,java.lang.String)isBetweenisBetween(java.lang.String,java.lang.String)isGreaterThanOrEqualToisGreaterThanOrEqualTo(java.lang.String)isGreaterThanisGreaterThan(java.lang.String)isLessThanOrEqualToisLessThanOrEqualTo(java.lang.String)isLessThanisLessThan(java.lang.String)AbstractStringAssert(java.lang.String,java.lang.Class)AbstractStringAssert<?>(java.lang.String,java.lang.Class)comparablesoldRequestnewRequestcondition1"Regular bean should be JDK proxy"Regular bean should be JDK proxyAdvisor[]0"Should have advisors"Should have advisorsoldSessionnewSessionrequest"Should not be target class proxy"Should not be target class proxyObjectAssert<ITestBean>AbstractObjectAssert<ObjectAssert<ITestBean>,ITestBean>AbstractAssert<ObjectAssert<ITestBean>,ITestBean>Assert<ObjectAssert<ITestBean>,ITestBean>Descriptable<ObjectAssert<ITestBean>>ExtensionPoints<ObjectAssert<ITestBean>,ITestBean>? super ITestBeanCondition<? super ITestBean>Descriptable<Condition<? super ITestBean>>Comparator<? super ITestBean>Function<? super ITestBean,? extends T>Consumer<ITestBean>Predicate<? super ITestBean>AbstractAssert<ObjectAssert<ITestBean>,ITestBean>(org.springframework.beans.testfixture.beans.ITestBean,java.lang.Class)Copyright 2002-2019 the original author or authors.Integration tests for scoped proxy use in conjunction with aop: namespace.Deemed an integration test because .web mocks and application contexts are required.Juergen HoellerChris Beamsorg.springframework.aop.config.AopNamespaceHandlerTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AdvisorAutoProxyCreatorIntegrationTests.javaAdvisorAutoProxyCreatorIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxyautoproxyC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/frameworkframeworkorg.springframework.aop.framework.autoproxytestProgrammaticRollbacktestProgrammaticRollback()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AdvisorAutoProxyCreatorIntegrationTests.classtestRollbackRulesOnMethodPreventRollbacktestRollbackRulesOnMethodPreventRollback()testRollbackRulesOnMethodCauseRollbacktestRollbackRulesOnMethodCauseRollback()testTransactionAttributeOnMethodtestTransactionAttributeOnMethod()testRegexpAppliedtestRegexpApplied()testTxIsProxiedtestTxIsProxied()testNoProxytestNoProxy()testDefaultExclusionPrefixtestDefaultExclusionPrefix()TXMANAGER_BEAN_NAMEADVISOR_APC_BEAN_NAMEDEFAULT_CONTEXTCLASSNAMECLASSAdvisorAutoProxyCreatorIntegrationTests()Class<AdvisorAutoProxyCreatorIntegrationTests>getSimpleNamegetSimpleName()arrayTypearrayType()componentTypecomponentType()isPrimitiveisPrimitive()isArrayisArray()isSealedisSealed()ClassDesc[]permittedSubclassespermittedSubclasses()isHiddenisHidden()nativeOptional<>C:/modules/java.base/java/util/Optional.classOptionalOptional<ClassDesc>describeConstabledescribeConstable()descriptorStringdescriptorString()Class<>[]getNestMembersgetNestMembers()isNestmateOfisNestmateOf(java.lang.Class)getNestHostgetNestHost()AnnotatedType[]getAnnotatedInterfacesgetAnnotatedInterfaces()getAnnotatedSuperclassgetAnnotatedSuperclass()Map<>? extends AnnotationClass<? extends Annotation>Map<Class<? extends Annotation>,Annotation>getDeclaredAnnotationMapgetDeclaredAnnotationMap()getAnnotationTypegetAnnotationType()casAnnotationTypecasAnnotationType(sun.reflect.annotation.AnnotationType,sun.reflect.annotation.AnnotationType)Annotation[]getDeclaredAnnotationsgetDeclaredAnnotations()AA[]getDeclaredAnnotationsByTypegetDeclaredAnnotationsByType(java.lang.Class)Class<A>getDeclaredAnnotationgetDeclaredAnnotation(java.lang.Class)getAnnotationsgetAnnotations()getAnnotationsByTypegetAnnotationsByType(java.lang.Class)isAnnotationPresentisAnnotationPresent(java.lang.Class)getAnnotationgetAnnotation(java.lang.Class)U? extends UClass<? extends U>asSubclassasSubclass(java.lang.Class)Class<U>castcast(java.lang.Object)Map<String,T>enumConstantDirectoryenumConstantDirectory()Map<String,?>getEnumConstantsSharedgetEnumConstantsShared()?[]getEnumConstantsgetEnumConstants()isRecordisRecord()isEnumisEnum()desiredAssertionStatusdesiredAssertionStatus()getConstantPoolgetConstantPool()getExecutableTypeAnnotationBytesgetExecutableTypeAnnotationBytes(java.lang.reflect.Executable)getRawTypeAnnotationsgetRawTypeAnnotations()getRawAnnotationsgetRawAnnotations()getPrimitiveClassgetPrimitiveClass(java.lang.String)protectionDomainprotectionDomain()getProtectionDomaingetProtectionDomain()getResourcegetResource(java.lang.String)getResourceAsStreamgetResourceAsStream(java.lang.String)java.lang.reflectConstructor<>C:/modules/java.base/java/lang/reflect/Constructor.classConstructorC:/modules/java.base/java/lang/reflectreflectConstructor<T>getDeclaredConstructorgetDeclaredConstructor(java.lang.Class[])Constructor<?>List<Method>Collection<Method>Iterable<Method>getDeclaredPublicMethodsgetDeclaredPublicMethods(java.lang.String,java.lang.Class[])getDeclaredMethodgetDeclaredMethod(java.lang.String,java.lang.Class[])getDeclaredFieldgetDeclaredField(java.lang.String)Constructor[]Constructor<>[]Constructor<?>[]getDeclaredConstructorsgetDeclaredConstructors()Method[]getDeclaredMethodsgetDeclaredMethods()RecordComponent[]getRecordComponentsgetRecordComponents()Field[]getDeclaredFieldsgetDeclaredFields()getDeclaredClassesgetDeclaredClasses()getConstructorgetConstructor(java.lang.Class[])getMethodgetMethod(java.lang.String,java.lang.Class[])getFieldgetField(java.lang.String)getConstructorsgetConstructors()getMethodsgetMethods()getFieldsgetFields()getClassesgetClasses()isMemberClassisMemberClass()isLocalClassisLocalClass()isAnonymousClassisAnonymousClass()getCanonicalNamegetCanonicalName()getTypeNamegetTypeName()getEnclosingClassgetEnclosingClass()getDeclaringClassgetDeclaringClass()getEnclosingConstructorgetEnclosingConstructor()getEnclosingMethodgetEnclosingMethod()setSignerssetSigners(java.lang.Object[])getSignersgetSigners()getModifiersgetModifiers()getComponentTypegetComponentType()Type[]getGenericInterfacesgetGenericInterfaces()getInterfacesgetInterfaces()getPackageNamegetPackageName()getPackagegetPackage()getGenericSuperclassgetGenericSuperclass()Class<? super T>getSuperclassgetSuperclass()? super ?Class<? super ?>TypeVariable[]TypeVariable<>C:/modules/java.base/java/lang/reflect/TypeVariable.classTypeVariableTypeVariable<>[]TypeVariable<Class>TypeVariable<Class>[]getTypeParametersgetTypeParameters()TypeVariable<Class<?>>TypeVariable<Class<?>>[]getClassDatagetClassData()getModulegetModule()getClassLoader0getClassLoader0()getClassLoadergetClassLoader()getNamegetName()isSyntheticisSynthetic()isAnnotationisAnnotation()isInterfaceisInterface()isAssignableFromisAssignableFrom(java.lang.Class)isInstanceisInstance(java.lang.Object)newInstancenewInstance()forNameforName(java.lang.Module,java.lang.String)forName(java.lang.String,boolean,java.lang.ClassLoader)forName(java.lang.String)TypeVariable<?>typeVarBoundstypeVarBounds(java.lang.reflect.TypeVariable)toGenericStringtoGenericString()classValueMap"-context.xml"-context.xml"aapc"aapc"txManager"txManagerbfo"noSetters"noSetters"test"counter"countingAdvice"countingAdviceAbstractIntegerAssert<?>AbstractComparableAssert<?,Integer>AbstractObjectAssert<?,Integer>AbstractAssert<?,Integer>Assert<?,Integer>ExtensionPoints<?,Integer>ComparableAssert<?,Integer>NumberAssert<?,Integer>isEqualTo(int)? super IntegerCondition<? super Integer>Descriptable<Condition<? super Integer>>Comparator<? super Integer>Function<? super Integer,? extends T>Consumer<Integer>Predicate<? super Integer>AbstractAssert<?,Integer>(java.lang.Integer,java.lang.Class)withComparatorByPropertyOrFieldwithComparatorByPropertyOrField(java.util.Map)withTypeComparatorwithTypeComparator(org.assertj.core.internal.TypeComparators)AbstractObjectAssert<?,T>AbstractAssert<?,T>Assert<?,T>ExtensionPoints<?,T>newObjectAssertnewObjectAssert(java.lang.Object)returnsreturns(java.lang.Object,java.util.function.Function)Function<ACTUAL,T>Function<Integer,T>isEqualToComparingFieldByFieldRecursivelyisEqualToComparingFieldByFieldRecursively(java.lang.Object)extracting(java.util.function.Function,org.assertj.core.api.InstanceOfAssertFactory)Function<? super ACTUAL,T>Function<? super Integer,T>Function<? super ACTUAL,?>Function<? super ACTUAL,?>[]Function<? super Integer,?>Function<? super Integer,?>[]extracting(java.lang.String,org.assertj.core.api.InstanceOfAssertFactory)AbstractObjectAssert<?,?>hasOnlyFieldshasOnlyFields(java.lang.String[])hasFieldOrPropertyWithValuehasFieldOrPropertyWithValue(java.lang.String,java.lang.Object)hasFieldOrPropertyhasFieldOrProperty(java.lang.String)Comparator<? super T>usingComparatorForFieldsusingComparatorForFields(java.util.Comparator,java.lang.String[])isEqualToComparingFieldByFieldisEqualToComparingFieldByField(java.lang.Object)hasAllNullFieldsOrPropertiesExcepthasAllNullFieldsOrPropertiesExcept(java.lang.String[])hasNoNullFieldsOrPropertiesExcepthasNoNullFieldsOrPropertiesExcept(java.lang.String[])hasAllNullFieldsOrPropertieshasAllNullFieldsOrProperties()hasNoNullFieldsOrPropertieshasNoNullFieldsOrProperties()isEqualToIgnoringGivenFieldsisEqualToIgnoringGivenFields(java.lang.Object,java.lang.String[])isEqualToComparingOnlyGivenFieldsisEqualToComparingOnlyGivenFields(java.lang.Object,java.lang.String[])isEqualToIgnoringNullFieldsisEqualToIgnoringNullFields(java.lang.Object)AbstractObjectAssert(java.lang.Object,java.lang.Class)AbstractObjectAssert<?,Integer>(java.lang.Integer,java.lang.Class)isStrictlyBetween(java.lang.Comparable,java.lang.Comparable)isStrictlyBetween(java.lang.Integer,java.lang.Integer)isBetween(java.lang.Comparable,java.lang.Comparable)isBetween(java.lang.Integer,java.lang.Integer)isGreaterThanOrEqualTo(java.lang.Comparable)isGreaterThanOrEqualTo(java.lang.Integer)isGreaterThan(java.lang.Comparable)isGreaterThan(java.lang.Integer)isLessThanOrEqualTo(java.lang.Comparable)isLessThanOrEqualTo(java.lang.Integer)isLessThan(java.lang.Comparable)isLessThan(java.lang.Integer)isNotEqualByComparingToisNotEqualByComparingTo(java.lang.Comparable)isNotEqualByComparingTo(java.lang.Integer)isEqualByComparingToisEqualByComparingTo(java.lang.Comparable)isEqualByComparingTo(java.lang.Integer)AbstractComparableAssert(java.lang.Comparable,java.lang.Class)AbstractComparableAssert<?,Integer>(java.lang.Integer,java.lang.Class)isNotCloseToisNotCloseTo(java.lang.Number,org.assertj.core.data.Percentage)isNotCloseTo(java.lang.Integer,org.assertj.core.data.Percentage)isCloseToisCloseTo(java.lang.Number,org.assertj.core.data.Percentage)isCloseTo(java.lang.Integer,org.assertj.core.data.Percentage)org.assertj.core.dataOffset<ACTUAL>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/datadataC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/data/Offset.classOffsetisNotCloseTo(java.lang.Number,org.assertj.core.data.Offset)Offset<Integer>isNotCloseTo(java.lang.Integer,org.assertj.core.data.Offset)isCloseTo(java.lang.Number,org.assertj.core.data.Offset)isCloseTo(java.lang.Integer,org.assertj.core.data.Offset)isStrictlyBetween(java.lang.Number,java.lang.Number)isBetween(java.lang.Number,java.lang.Number)isNotPositiveisNotPositive()isNotNegativeisNotNegative()isNegativeisNegative()isPositiveisPositive()isOneisOne()isNotZeroisNotZero()isZeroisZero()isNotCloseTo(int,org.assertj.core.data.Percentage)isCloseTo(int,org.assertj.core.data.Percentage)isNotCloseTo(int,org.assertj.core.data.Offset)isCloseTo(int,org.assertj.core.data.Offset)isGreaterThanOrEqualTo(int)isGreaterThan(int)isLessThanOrEqualTo(int)isLessThan(int)isOddisOdd()isEvenisEven()isNotEqualTo(int)longisEqualTo(long)AbstractIntegerAssert(java.lang.Integer,java.lang.Class)AbstractIntegerAssert<?>(java.lang.Integer,java.lang.Class)integers1txMantxc"orderedBeforeTransaction"orderedBeforeTransactionnewAge5"Initial value was correct"Initial value was correct4"New value set correctly"New value set correctly"Transaction counts match"Transaction counts matchrb"rollback"rollbackex<nulltype>? extends ThrowableAbstractThrowableAssert<?,? extends Throwable>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractThrowableAssert.classAbstractThrowableAssertAbstractObjectAssert<?,? extends Throwable>AbstractAssert<?,? extends Throwable>Assert<?,? extends Throwable>ExtensionPoints<?,? extends Throwable>AbstractThrowableAssert<>? super ? extends ThrowableCondition<? super ? extends Throwable>Descriptable<Condition<? super ? extends Throwable>>Comparator<? super ? extends Throwable>Function<? super ? extends Throwable,? extends T>Consumer<? extends Throwable>Predicate<? super ? extends Throwable>AbstractAssert<?,? extends Throwable>(java.lang.Throwable,java.lang.Class)beanfalse"serial"seriallmtargetClassNoSettersNoSetters()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/NoSetters.classrequireTransactionContextC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/OrderedTxCheckAdvisor.classOrderedTxCheckAdvisorOrderedTxCheckAdvisor()method"setAge"setAgeTxCountingBeforeAdviceTxCountingBeforeAdvice()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/OrderedTxCheckAdvisor$TxCountingBeforeAdvice.classOrderedTxCheckAdvisor$TxCountingBeforeAdviceargstarget"Shouldn't have a transaction"Shouldn't have a transactionRollbackRollback()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/Rollback.classrollbackOnlyIntegration tests for auto proxy creation by advisor recognition working inconjunction with transaction management resources.org.springframework.aop.framework.autoproxy.AdvisorAutoProxyCreatorTestsRod JohnsonReturn a bean factory with attributes and EnterpriseServices configured.If no pointcuts match (no attrs) there should be proxying.Should not roll back on servlet exception. Fires only on setters Should NOT roll back on ServletException Will cause rollback onlyThis method is solely to allow us to create a mixture of dependencies inthe bean definitions. The dependencies don't have any meaning, and don't<b>do</b> anything.org.springframework.aop.MethodMatcher#matches(java.lang.reflect.Method, java.lang.Class)Should we insist on the presence of a transaction attribute or refuse to accept one? do transaction checks this is OkInherits transaction attribute.Illustrates programmatic rollback.Extracted in a protected method to facilitate testing@org.springframework.transaction.interceptor.RuleBasedTransaction( timeout=-1 )@org.springframework.transaction.interceptor.RollbackRule( "java.lang.Exception" )@org.springframework.transaction.interceptor.NoRollbackRule( "ServletException" )C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests.javaAspectJAutoProxyAdviceOrderIntegrationTestsAspectJAutoProxyAdviceOrderIntegrationTests()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests.classafterAdviceIsInvokedLast(org.springframework.aop.framework.autoproxy.AspectJAutoProxyAdviceOrderIntegrationTests.Echo,org.springframework.aop.framework.autoproxy.AspectJAutoProxyAdviceOrderIntegrationTests.AfterAdviceFirstAspect)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceFirstTests.classAspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceFirstTestsClass<AfterAdviceFirstConfig>afterAdviceIsInvokedLast(org.springframework.aop.framework.autoproxy.AspectJAutoProxyAdviceOrderIntegrationTests.Echo,org.springframework.aop.framework.autoproxy.AspectJAutoProxyAdviceOrderIntegrationTests.AfterAdviceLastAspect)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceLastTests.classAspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceLastTestsClass<AfterAdviceLastConfig>echo()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceFirstConfig.classAspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceFirstConfig"""(inferred)"(inferred)echoAspectechoAspect()AfterAdviceFirstConfigAfterAdviceFirstConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceLastConfig.classAspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceLastConfigAfterAdviceLastConfigAfterAdviceLastConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests$Echo.classAspectJAutoProxyAdviceOrderIntegrationTests$EchoC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceFirstAspect.classAspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceFirstAspect"echo()""execution(* echo(*))"execution(* echo(*))AfterAdviceFirstAspectAfterAdviceFirstAspect()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/aop/framework/autoproxy/AspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceLastAspect.classAspectJAutoProxyAdviceOrderIntegrationTests$AfterAdviceLastAspectAfterAdviceLastAspectAfterAdviceLastAspect()Integration tests for advice invocation order for advice configured viaAspectJ auto-proxy support.org.springframework.aop.config.AopNamespaceHandlerAdviceOrderIntegrationTests{@link After @After} advice declared as first <em>after</em> method in source code.This test class uses {@link AfterAdviceLastAspect} which declares its{@link After @After} advice as the last <em>after advice type</em> methodin its source code.<p>On Java versions prior to JDK 7, we would have expected the {@code @After}advice method to be invoked before {@code @AfterThrowing} and{@code @AfterReturning} advice methods due to the AspectJ precedencerules implemented in{@link org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparator}.{@link After @After} advice declared as last <em>after</em> method in source code.C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/Component.javaComponentC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xmlxmlC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factoryfactoryC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beansbeansorg.springframework.beans.factory.xmlList<Component>Collection<Component>Iterable<Component>componentsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/Component.classnameArrayList<Component>AbstractList<Component>AbstractCollection<Component>ArrayList<Component>()Spliterator<Component>? super ComponentConsumer<? super Component>Iterator<Component>Stream<Component>BaseStream<Component,Stream<Component>>Predicate<? super Component>? extends ComponentCollection<? extends Component>Iterable<? extends Component>add(org.springframework.beans.factory.xml.Component)AbstractCollection<Component>()ListIterator<Component>add(int,org.springframework.beans.factory.xml.Component)set(int,org.springframework.beans.factory.xml.Component)Comparator<? super Component>UnaryOperator<Component>Function<Component,Component>AbstractList<Component>()ArrayList<Component>(java.util.Collection)ArrayList<Component>(int)component mmm, there is no setter method for the 'components'C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/ComponentBeanDefinitionParser.javaComponentBeanDefinitionParserList<Element>Collection<Element>Iterable<Element>parseChildComponentsparseChildComponents(java.util.List,org.springframework.beans.factory.support.BeanDefinitionBuilder)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/ComponentBeanDefinitionParser.classparseComponentparseComponent(org.w3c.dom.Element)parseComponentElementparseComponentElement(org.w3c.dom.Element)parserContextClass<ComponentFactoryBean>childElements"component""parent"parentClass<Component>"name"org.springframework.beans.factory.supportManagedList<BeanDefinition>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libs/spring-beans-5.3.4-SNAPSHOT.jarspring-beans-5.3.4-SNAPSHOTC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libslibsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/buildbuildC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beansspring-beansC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libs/spring-beans-5.3.4-SNAPSHOT.jar/orgC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libs/spring-beans-5.3.4-SNAPSHOT.jar/org/springframeworkC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libs/spring-beans-5.3.4-SNAPSHOT.jar/org/springframework/beansC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libs/spring-beans-5.3.4-SNAPSHOT.jar/org/springframework/beans/factoryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libs/spring-beans-5.3.4-SNAPSHOT.jar/org/springframework/beans/factory/supportsupportC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libs/spring-beans-5.3.4-SNAPSHOT.jar/org/springframework/beans/factory/support/ManagedList.classManagedListArrayList<BeanDefinition>AbstractList<BeanDefinition>AbstractCollection<BeanDefinition>Collection<BeanDefinition>Iterable<BeanDefinition>List<BeanDefinition>childrenManagedList<BeanDefinition>(int)Spliterator<BeanDefinition>? super BeanDefinitionConsumer<? super BeanDefinition>Iterator<BeanDefinition>Stream<BeanDefinition>BaseStream<BeanDefinition,Stream<BeanDefinition>>Predicate<? super BeanDefinition>? extends BeanDefinitionCollection<? extends BeanDefinition>Iterable<? extends BeanDefinition>add(org.springframework.beans.factory.config.BeanDefinition)AbstractCollection<BeanDefinition>()ListIterator<BeanDefinition>add(int,org.springframework.beans.factory.config.BeanDefinition)set(int,org.springframework.beans.factory.config.BeanDefinition)Comparator<? super BeanDefinition>UnaryOperator<BeanDefinition>Function<BeanDefinition,BeanDefinition>AbstractList<BeanDefinition>()ArrayList<BeanDefinition>(java.util.Collection)ArrayList<BeanDefinition>()ArrayList<BeanDefinition>(int)mergemerge(java.lang.Object)isMergeEnabledisMergeEnabled()setMergeEnabledsetMergeEnabled(boolean)getElementTypeNamegetElementTypeName()setElementTypeNamesetElementTypeName(java.lang.String)getSourcegetSource()setSourcesetSource(java.lang.Object)ManagedList(int)ManagedList()ManagedList<BeanDefinition>()Spliterator<Element>? super ElementConsumer<? super Element>Iterator<Element>Stream<Element>BaseStream<Element,Stream<Element>>Predicate<? super Element>? extends ElementCollection<? extends Element>Iterable<? extends Element>add(org.w3c.dom.Element)ListIterator<Element>add(int,org.w3c.dom.Element)set(int,org.w3c.dom.Element)Comparator<? super Element>UnaryOperator<Element>Function<Element,Element>"children"C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/ComponentBeanDefinitionParserTests.javaComponentBeanDefinitionParserTestsgetBionicFamilygetBionicFamily()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/ComponentBeanDefinitionParserTests.classtestBionicSecondLevelChildrentestBionicSecondLevelChildren()testBionicFirstLevelChildrentestBionicFirstLevelChildren()testBionicBasictestBionicBasic()tearDowntearDown()setUpsetUp()ComponentBeanDefinitionParserTests()Class<ComponentBeanDefinitionParserTests>"component-config.xml"component-config.xmlcp"Bionic-1"Bionic-12"Mother-1"Mother-1"Rock-1"Rock-1"Karate-1"Karate-1"Sport-1"Sport-1"bionic-family"bionic-familyCostin LeauC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/ComponentFactoryBean.javaComponentFactoryBeanC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/ComponentFactoryBean.classorg.springframework.beans.factoryFactoryBean<Component>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/libs/spring-beans-5.3.4-SNAPSHOT.jar/org/springframework/beans/factory/FactoryBean.classFactoryBeanchildC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/beans/factory/xml/ComponentNamespaceHandler.javaComponentNamespaceHandlerC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/cache/annotation/EnableCachingIntegrationTests.javaEnableCachingIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/cache/annotationannotationC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/cachecacheorg.springframework.cache.annotationisCacheProxyisCacheProxy(org.springframework.cache.annotation.EnableCachingIntegrationTests.FooRepository)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/cache/annotation/EnableCachingIntegrationTests.classassertCacheProxyingassertCacheProxying(org.springframework.context.annotation.AnnotationConfigApplicationContext)repositoryUsesAspectJAdviceModerepositoryUsesAspectJAdviceMode()repositoryIsClassBasedCacheProxyrepositoryIsClassBasedCacheProxy()EnableCachingIntegrationTests()"resource"resourcectxClass<Config>Class<ProxyTargetClassCachingConfig>Class<FooRepository>Class<AspectJCacheConfig>withMessageContainingwithMessageContaining(java.lang.String)? super ExceptionCondition<? super Exception>Descriptable<Condition<? super Exception>>Comparator<? super Exception>Function<? super Exception,? extends T>Consumer<Exception>Predicate<? super Exception>AbstractAssert<ThrowableAssertAlternative<Exception>,Exception>(java.lang.Exception,java.lang.Class)ThrowableAssertAlternative<?>AbstractAssert<ThrowableAssertAlternative<?>,?>Assert<ThrowableAssertAlternative<?>,?>Descriptable<ThrowableAssertAlternative<?>>ExtensionPoints<ThrowableAssertAlternative<?>,?>havingRootCausehavingRootCause()havingCausehavingCause()Class<? extends Throwable>withRootCauseExactlyInstanceOfwithRootCauseExactlyInstanceOf(java.lang.Class)withRootCauseInstanceOfwithRootCauseInstanceOf(java.lang.Class)withCauseExactlyInstanceOfwithCauseExactlyInstanceOf(java.lang.Class)withCauseInstanceOfwithCauseInstanceOf(java.lang.Class)withMessageEndingWithwithMessageEndingWith(java.lang.String,java.lang.Object[])withMessageEndingWith(java.lang.String)withMessageMatchingwithMessageMatching(java.lang.String)withStackTraceContainingwithStackTraceContaining(java.lang.String,java.lang.Object[])withStackTraceContaining(java.lang.String)withMessageNotContainingAnywithMessageNotContainingAny(java.lang.CharSequence[])withMessageNotContainingwithMessageNotContaining(java.lang.String)withMessageContainingAllwithMessageContainingAll(java.lang.CharSequence[])withMessageContaining(java.lang.String,java.lang.Object[])withMessageStartingWithwithMessageStartingWith(java.lang.String,java.lang.Object[])withMessageStartingWith(java.lang.String)withNoCausewithNoCause()withCausewithCause(java.lang.Throwable)withMessagewithMessage(java.lang.String,java.lang.Object[])withMessage(java.lang.String)ThrowableAssertAlternative(java.lang.Throwable)ThrowableAssertAlternative<Exception>(java.lang.Exception)"AspectJCachingConfiguration"AspectJCachingConfigurationrepoadvisormgrmgr()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/cache/annotation/EnableCachingIntegrationTests$ProxyTargetClassCachingConfig.classEnableCachingIntegrationTests$ProxyTargetClassCachingConfigProxyTargetClassCachingConfigProxyTargetClassCachingConfig()fooRepositoryfooRepository()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/cache/annotation/EnableCachingIntegrationTests$Config.classEnableCachingIntegrationTests$ConfigConfigConfig()cacheManagercacheManager()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/cache/annotation/EnableCachingIntegrationTests$AspectJCacheConfig.classEnableCachingIntegrationTests$AspectJCacheConfigAspectJCacheConfigAspectJCacheConfig()List<Object>Collection<Object>Iterable<Object>DummyFooRepositoryDummyFooRepository()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/cache/annotation/EnableCachingIntegrationTests$DummyFooRepository.classEnableCachingIntegrationTests$DummyFooRepository"primary"primaryIntegration tests for the @EnableCaching annotation.3.1 this test is a bit fragile, but gets the job done, proving that an attempt was made to look up the AJ aspect. It's due to classpath issues in .integration-tests that it's not found.C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/jsr330/ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests.javaClassPathBeanDefinitionScannerJsr330ScopeIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/jsr330jsr330C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotationC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/contextcontextorg.springframework.context.annotation.jsr330createContextcreateContext(org.springframework.context.annotation.ScopedProxyMode)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/jsr330/ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests.classtestSessionScopeWithProxiedTargetClasstestSessionScopeWithProxiedTargetClass()testSessionScopeWithProxiedInterfacestestSessionScopeWithProxiedInterfaces()testSessionScopeWithNoProxytestSessionScopeWithNoProxy()testRequestScopeWithProxiedTargetClasstestRequestScopeWithProxiedTargetClass()testRequestScopeWithProxiedInterfacestestRequestScopeWithProxiedInterfaces()testRequestScopeWithNoProxytestRequestScopeWithNoProxy()testSingletonScopeIgnoresProxyTargetClasstestSingletonScopeIgnoresProxyTargetClass()testSingletonScopeIgnoresProxyInterfacestestSingletonScopeIgnoresProxyInterfaces()testSingletonScopeWithNoProxytestSingletonScopeWithNoProxy()testPrototypetestPrototype()resetreset()setupsetup()newRequestAttributesWithSessionoldRequestAttributesWithSessionnewRequestAttributesoldRequestAttributesMODIFIED_NAMEDEFAULT_NAMEClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests()"default""modified"modifiedoldRequestWithSessionnewRequestWithSession"prototype"prototypeObjectAssert<ScopedTestBean>AbstractObjectAssert<ObjectAssert<ScopedTestBean>,ScopedTestBean>AbstractAssert<ObjectAssert<ScopedTestBean>,ScopedTestBean>Assert<ObjectAssert<ScopedTestBean>,ScopedTestBean>Descriptable<ObjectAssert<ScopedTestBean>>ExtensionPoints<ObjectAssert<ScopedTestBean>,ScopedTestBean>? super ScopedTestBeanCondition<? super ScopedTestBean>Descriptable<Condition<? super ScopedTestBean>>Comparator<? super ScopedTestBean>Function<? super ScopedTestBean,? extends T>Consumer<ScopedTestBean>Predicate<? super ScopedTestBean>AbstractAssert<ObjectAssert<ScopedTestBean>,ScopedTestBean>(org.springframework.context.annotation.jsr330.ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests.ScopedTestBean,java.lang.Class)"singleton"singletonbean2"request""session"sessionscopedProxyModescannerC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/jsr330/ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests$1.classClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests$1resolveScopeMetadataresolveScopeMetadata(org.springframework.beans.factory.config.BeanDefinition)definitionmetadataannDeftypeSet<String>C:/modules/java.base/java/util/Set.classSetSet<>Class<Singleton>Map<String,Singleton>Singleton[]Constructor<Singleton>? super SingletonClass<? super Singleton>TypeVariable<Class<Singleton>>TypeVariable<Class<Singleton>>[]Set<E>Class<Scope>Map<String,Scope>Scope[]Constructor<Scope>? super ScopeClass<? super Scope>TypeVariable<Class<Scope>>TypeVariable<Class<Scope>>[]136"javax.inject"javax.inject? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTestsClass<? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests>Map<String,? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests>ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests[]? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests[]Constructor<? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests>? super ? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTestsClass<? super ? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests>TypeVariable<Class<? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests>>TypeVariable<Class<? extends ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests>>[]"classPathBeanDefinitionScannerJsr330ScopeIntegrationTests.SessionScopedTestBean"classPathBeanDefinitionScannerJsr330ScopeIntegrationTests.SessionScopedTestBeanC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/jsr330/ClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests$ScopedTestBean.classClassPathBeanDefinitionScannerJsr330ScopeIntegrationTests$ScopedTestBeanElementType[]Mark Fisher should not be a proxy not a proxy so this should not have changed singleton bean, so name should be modified even after lookup but a newly retrieved bean should have the default name should be dynamic proxy, implementing both interfaces this is a proxy so it should be reset to default should be a class-based proxy Scan twice in order to find errors in the bean definition compatibility check.C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/scope/ClassPathBeanDefinitionScannerScopeIntegrationTests.javaClassPathBeanDefinitionScannerScopeIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/scopescopeorg.springframework.context.annotation.scopeDEFAULTINTERFACESNOTARGET_CLASSC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/scope/ClassPathBeanDefinitionScannerScopeIntegrationTests.classsessionScopeWithProxiedTargetClasssessionScopeWithProxiedTargetClass()sessionScopeWithProxiedInterfacessessionScopeWithProxiedInterfaces()sessionScopeWithNoProxysessionScopeWithNoProxy()requestScopeWithProxiedTargetClassrequestScopeWithProxiedTargetClass()requestScopeWithProxiedInterfacesrequestScopeWithProxiedInterfaces()requestScopeWithNoProxyrequestScopeWithNoProxy()singletonScopeIgnoresProxyTargetClasssingletonScopeIgnoresProxyTargetClass()singletonScopeIgnoresProxyInterfacessingletonScopeIgnoresProxyInterfaces()singletonScopeWithNoProxysingletonScopeWithNoProxy()ClassPathBeanDefinitionScannerScopeIntegrationTests()generateBeanNamegenerateBeanName(org.springframework.beans.factory.config.BeanDefinition,org.springframework.beans.factory.support.BeanDefinitionRegistry)registry? extends ClassPathBeanDefinitionScannerScopeIntegrationTestsClass<? extends ClassPathBeanDefinitionScannerScopeIntegrationTests>Map<String,? extends ClassPathBeanDefinitionScannerScopeIntegrationTests>ClassPathBeanDefinitionScannerScopeIntegrationTests[]? extends ClassPathBeanDefinitionScannerScopeIntegrationTests[]Constructor<? extends ClassPathBeanDefinitionScannerScopeIntegrationTests>? super ? extends ClassPathBeanDefinitionScannerScopeIntegrationTestsClass<? super ? extends ClassPathBeanDefinitionScannerScopeIntegrationTests>TypeVariable<Class<? extends ClassPathBeanDefinitionScannerScopeIntegrationTests>>TypeVariable<Class<? extends ClassPathBeanDefinitionScannerScopeIntegrationTests>>[]C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/scope/ClassPathBeanDefinitionScannerScopeIntegrationTests$ScopedTestBean.classClassPathBeanDefinitionScannerScopeIntegrationTests$ScopedTestBeanScopedTestBeanScopedTestBean()SingletonScopedTestBeanSingletonScopedTestBean()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/scope/ClassPathBeanDefinitionScannerScopeIntegrationTests$SingletonScopedTestBean.classClassPathBeanDefinitionScannerScopeIntegrationTests$SingletonScopedTestBeanRequestScopedTestBeanRequestScopedTestBean()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/scope/ClassPathBeanDefinitionScannerScopeIntegrationTests$RequestScopedTestBean.classClassPathBeanDefinitionScannerScopeIntegrationTests$RequestScopedTestBeanSessionScopedTestBeanSessionScopedTestBean()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/context/annotation/scope/ClassPathBeanDefinitionScannerScopeIntegrationTests$SessionScopedTestBean.classClassPathBeanDefinitionScannerScopeIntegrationTests$SessionScopedTestBeanC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests.javaEnvironmentSystemIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/envenvC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/coreorg.springframework.core.envrootBeanDefinitionENVIRONMENT_BEAN_NAMEDERIVED_DEV_BEAN_NAMEDERIVED_DEV_ENV_NAMEDEV_BEAN_NAMEDEV_ENV_NAMEENVIRONMENT_AWARE_BEAN_NAMEPROD_BEAN_NAMEPROD_ENV_NAMETRANSITIVE_BEAN_NAMEXML_PATHassertEnvironmentAwareInvokedassertEnvironmentAwareInvoked(org.springframework.context.ConfigurableApplicationContext,org.springframework.core.env.Environment)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests.classassertHasEnvironmentassertHasEnvironment(org.springframework.context.ApplicationContext,org.springframework.core.env.Environment)assertHasStandardServletEnvironmentassertHasStandardServletEnvironment(org.springframework.web.context.WebApplicationContext)assertHasStandardEnvironmentassertHasStandardEnvironment(org.springframework.context.ApplicationContext)assertEnvironmentBeanRegisteredassertEnvironmentBeanRegistered(org.springframework.context.ConfigurableApplicationContext)registerEnvironmentBeanDefinitionregisterEnvironmentBeanDefinition(org.springframework.beans.factory.support.BeanDefinitionRegistry)newBeanFactoryWithEnvironmentAwareBeannewBeanFactoryWithEnvironmentAwareBean()abstractApplicationContextValidatesRequiredPropertiesOnRefreshabstractApplicationContextValidatesRequiredPropertiesOnRefresh()resourceAdapterApplicationContextresourceAdapterApplicationContext()registerServletParamPropertySources_StaticWebApplicationContextregisterServletParamPropertySources_StaticWebApplicationContext()registerServletParamPropertySources_GenericWebApplicationContextregisterServletParamPropertySources_GenericWebApplicationContext()registerServletParamPropertySources_AbstractRefreshableWebApplicationContextregisterServletParamPropertySources_AbstractRefreshableWebApplicationContext()annotationConfigWebApplicationContextannotationConfigWebApplicationContext()staticWebApplicationContextstaticWebApplicationContext()staticApplicationContextstaticApplicationContext()xmlWebApplicationContextxmlWebApplicationContext()webApplicationContextwebApplicationContext()testProfileExpressiontestProfileExpression(boolean,java.lang.String[])annotationConfigApplicationContext_withProfileExpressionNoMatchNoneannotationConfigApplicationContext_withProfileExpressionNoMatchNone()annotationConfigApplicationContext_withProfileExpressionNoMatchAndannotationConfigApplicationContext_withProfileExpressionNoMatchAnd()annotationConfigApplicationContext_withProfileExpressionMatchAndannotationConfigApplicationContext_withProfileExpressionMatchAnd()annotationConfigApplicationContext_withProfileExpressionMatchOrannotationConfigApplicationContext_withProfileExpressionMatchOr()mostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClassmostSpecificDerivedClassDrivesEnvironment_withDevEnvAndDerivedDevConfigClass()mostSpecificDerivedClassDrivesEnvironment_withDerivedDevEnvAndDerivedDevConfigClassmostSpecificDerivedClassDrivesEnvironment_withDerivedDevEnvAndDerivedDevConfigClass()annotationConfigApplicationContext_withImportedConfigClassesannotationConfigApplicationContext_withImportedConfigClasses()annotationConfigApplicationContext_withDevEnvAndDevConfigClassannotationConfigApplicationContext_withDevEnvAndDevConfigClass()annotationConfigApplicationContext_withProdEnvAndDevConfigClassannotationConfigApplicationContext_withProdEnvAndDevConfigClass()annotationConfigApplicationContext_withProdEnvAndProdConfigClassannotationConfigApplicationContext_withProdEnvAndProdConfigClass()annotationConfigApplicationContext_withPojosannotationConfigApplicationContext_withPojos()fileSystemXmlApplicationContextfileSystemXmlApplicationContext()classPathXmlApplicationContextclassPathXmlApplicationContext()genericXmlApplicationContextgenericXmlApplicationContext()classPathBeanDefinitionScanner_inheritsEnvironmentFromEnvironmentCapableBDR_scanProfileAnnotatedComponentsclassPathBeanDefinitionScanner_inheritsEnvironmentFromEnvironmentCapableBDR_scanProfileAnnotatedComponents()classPathBeanDefinitionScanner_inheritsEnvironmentFromEnvironmentCapableBDR_scanProfileAnnotatedConfigClassesclassPathBeanDefinitionScanner_inheritsEnvironmentFromEnvironmentCapableBDR_scanProfileAnnotatedConfigClasses()annotatedBeanDefinitionReader_inheritsEnvironmentFromEnvironmentCapableBDRannotatedBeanDefinitionReader_inheritsEnvironmentFromEnvironmentCapableBDR()xmlBeanDefinitionReader_inheritsEnvironmentFromEnvironmentCapableBDRxmlBeanDefinitionReader_inheritsEnvironmentFromEnvironmentCapableBDR()genericApplicationContext_customEnvgenericApplicationContext_customEnv()genericApplicationContext_standardEnvgenericApplicationContext_standardEnv()prodWebEnvdevEnvprodEnv"org.springframework.core.env.scan1"org.springframework.core.env.scan1"org.springframework.core.env.scan2"org.springframework.core.env.scan2ObjectAssert<Environment>AbstractObjectAssert<ObjectAssert<Environment>,Environment>AbstractAssert<ObjectAssert<Environment>,Environment>Assert<ObjectAssert<Environment>,Environment>Descriptable<ObjectAssert<Environment>>ExtensionPoints<ObjectAssert<Environment>,Environment>? super EnvironmentCondition<? super Environment>Descriptable<Condition<? super Environment>>Comparator<? super Environment>Function<? super Environment,? extends T>Consumer<Environment>Predicate<? super Environment>AbstractAssert<ObjectAssert<Environment>,Environment>(org.springframework.core.env.Environment,java.lang.Class)tmpFile"xml""file:"file:Class<EnvironmentAwareBean>Class<ProdConfig>Class<DevConfig>derivedDevEnvClass<DerivedDevConfig>"p3"p3"p1"p1"p2"p2"p4"p4expectedactiveProfilesenvironmentClass<ProfileExpressionConfig>"expressionBean"expressionBean"classpath:"classpath:Map<String,EnvironmentAwareBean>EnvironmentAwareBean[]Constructor<EnvironmentAwareBean>? super EnvironmentAwareBeanClass<? super EnvironmentAwareBean>TypeVariable<Class<EnvironmentAwareBean>>TypeVariable<Class<EnvironmentAwareBean>>[]servletContextservletConfigpropertySourcesmockSystemProperties"pCommon"pCommon"pCommonContextValue"pCommonContextValue"pContext1"pContext1"pContext1Value"pContext1Value"pCommonConfigValue"pCommonConfigValue"pConfig1"pConfig1"pConfig1Value"pConfig1ValueObjectAssert<ConfigurableEnvironment>AbstractObjectAssert<ObjectAssert<ConfigurableEnvironment>,ConfigurableEnvironment>AbstractAssert<ObjectAssert<ConfigurableEnvironment>,ConfigurableEnvironment>Assert<ObjectAssert<ConfigurableEnvironment>,ConfigurableEnvironment>Descriptable<ObjectAssert<ConfigurableEnvironment>>ExtensionPoints<ObjectAssert<ConfigurableEnvironment>,ConfigurableEnvironment>? super ConfigurableEnvironmentCondition<? super ConfigurableEnvironment>Descriptable<Condition<? super ConfigurableEnvironment>>Comparator<? super ConfigurableEnvironment>Function<? super ConfigurableEnvironment,? extends T>Consumer<ConfigurableEnvironment>Predicate<? super ConfigurableEnvironment>AbstractAssert<ObjectAssert<ConfigurableEnvironment>,ConfigurableEnvironment>(org.springframework.core.env.ConfigurableEnvironment,java.lang.Class)Class<StandardServletEnvironment>PropertySource<?>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jarspring-core-5.3.4-SNAPSHOTC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/buildC:/Users/Semiu/Java/spring-projects_spring-framework/spring-corespring-coreC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/orgC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframeworkC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/coreC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/envC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/env/PropertySource.classPropertySourcePropertySource<>namednamed(java.lang.String)getPropertygetProperty(java.lang.String)containsPropertycontainsProperty(java.lang.String)PropertySource(java.lang.String)PropertySource<>(java.lang.String)PropertySource(java.lang.String,java.lang.Object)PropertySource<>(java.lang.String,java.lang.Object)sourcelogger"pCommonSysPropsValue"pCommonSysPropsValue"pSysProps1"pSysProps1"pSysProps1Value"pSysProps1Value"foo"foo"bar"barThrowableAssertAlternative<MissingRequiredPropertiesException>AbstractAssert<ThrowableAssertAlternative<MissingRequiredPropertiesException>,MissingRequiredPropertiesException>Assert<ThrowableAssertAlternative<MissingRequiredPropertiesException>,MissingRequiredPropertiesException>Descriptable<ThrowableAssertAlternative<MissingRequiredPropertiesException>>ExtensionPoints<ThrowableAssertAlternative<MissingRequiredPropertiesException>,MissingRequiredPropertiesException>ThrowableTypeAssert<MissingRequiredPropertiesException>Descriptable<ThrowableTypeAssert<MissingRequiredPropertiesException>>? extends MissingRequiredPropertiesExceptionClass<? extends MissingRequiredPropertiesException>ThrowableTypeAssert<MissingRequiredPropertiesException>(java.lang.Class)Class<MissingRequiredPropertiesException>"fooValue"fooValuedefaultEnvClass<StandardEnvironment>expectedEnvactualEnvEnvironmentAwareBeanEnvironmentAwareBean()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests$EnvironmentAwareBean.classEnvironmentSystemIntegrationTests$EnvironmentAwareBeanC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests$Config.classEnvironmentSystemIntegrationTests$ConfigDevConfigDevConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests$DevConfig.classEnvironmentSystemIntegrationTests$DevConfigClass<TransitiveConfig>ProdConfigProdConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests$ProdConfig.classEnvironmentSystemIntegrationTests$ProdConfigTransitiveConfigTransitiveConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests$TransitiveConfig.classEnvironmentSystemIntegrationTests$TransitiveConfigDerivedDevConfigDerivedDevConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests$DerivedDevConfig.classEnvironmentSystemIntegrationTests$DerivedDevConfigProfileExpressionConfigProfileExpressionConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/EnvironmentSystemIntegrationTests$ProfileExpressionConfig.classEnvironmentSystemIntegrationTests$ProfileExpressionConfig"(p1 & p2) | p3"(p1 & p2) | p3"org/springframework/core/env/EnvironmentSystemIntegrationTests-context.xml"org/springframework/core/env/EnvironmentSystemIntegrationTests-context.xml"envAwareBean"envAwareBean"prodBean"prodBean"devBean"devBean"derivedDevBean"derivedDevBean"transitiveBean"transitiveBean"prod"prod"dev"dev"derivedDev"derivedDevSystem integration tests for container support of the {@link Environment} API.<p>Tests all existing BeanFactory and ApplicationContext implementations to ensure that:<ul><li>a standard environment object is always present<li>a custom environment object can be set and retrieved against the factory/context<li>the {@link EnvironmentAware} interface is respected<li>the environment object is registered with the container as a singleton bean (if anApplicationContext)<li>bean definition files (if any, and whether XML or @Configuration) are registeredconditionally based on environment metadata</ul>org.springframework.context.support.EnvironmentIntegrationTests it's actually ConfigurationClassPostProcessor's Environment that gets the job done here. strange - FSXAC strips leading '/' unless prefixed with 'file:' ServletConfig gets precedence but all params are available Servlet* PropertySources have precedence over System* PropertySources Replace system properties with a mock property source for convenience assert that servletconfig params resolve with higher precedence than sysprops ServletContext params are available assert that servletcontext init params resolve with higher precedence than sysprops should succeed ensure environment is registered as a bean ensure a default servlet environment exists ensure the custom environment tookMirrors the structure of beans and environment-specific config files inEnvironmentSystemIntegrationTests-context.xmlConstants used both locally and in scan* sub-packagesC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/PropertyPlaceholderConfigurerEnvironmentIntegrationTests.javaPropertyPlaceholderConfigurerEnvironmentIntegrationTeststest()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/PropertyPlaceholderConfigurerEnvironmentIntegrationTests.class"deprecation"deprecationPropertyPlaceholderConfigurerEnvironmentIntegrationTests()"ppc"ppcClass<PropertyPlaceholderConfigurer>"searchSystemEnvironment"searchSystemEnvironmentC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan1/Config.javaC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan1scan1C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan1/Config.classC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan1/DevConfig.javaC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan1/DevConfig.classC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan1/ProdConfig.javaC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan1/ProdConfig.classC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan2/DevBean.javaDevBeanC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan2scan2DevBean()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan2/DevBean.classC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan2/ProdBean.javaProdBeanProdBean()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/core/env/scan2/ProdBean.classC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expression/spel/support/BeanFactoryTypeConverter.javaBeanFactoryTypeConverterC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expression/spel/supportC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expression/spelspelC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expressionexpressionorg.springframework.expression.spel.supportconversionServiceC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expression/spel/support/BeanFactoryTypeConverter.classdefaultConversionServicedelegatebeanFactorytypeConvertersourceTypetargetTypeClass<String>Map<String,String>Constructor<String>Class<? super String>TypeVariable<Class<String>>TypeVariable<Class<String>>[]sourceTypeDescriptortargetTypeDescriptorvalueClass<Void>editorCopyright 2002-2012 the original author or authors.Copied from Spring Integration for purposes of reproducing{@link Spr7538Tests}. PropertyEditor cannot convert non-Strings TODO: what does this mean? This method is not used in SpEL so probably ignorable?C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expression/spel/support/Spr7538Tests.javaSpr7538Testsreprorepro()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expression/spel/support/Spr7538Tests.classSpr7538Tests()converterList<Foo>Collection<Foo>Iterable<Foo>argumentsList<TypeDescriptor>Collection<TypeDescriptor>Iterable<TypeDescriptor>paramDescriptorsArrayList<TypeDescriptor>AbstractList<TypeDescriptor>AbstractCollection<TypeDescriptor>ArrayList<TypeDescriptor>()Spliterator<TypeDescriptor>? super TypeDescriptorConsumer<? super TypeDescriptor>Iterator<TypeDescriptor>Stream<TypeDescriptor>BaseStream<TypeDescriptor,Stream<TypeDescriptor>>Predicate<? super TypeDescriptor>? extends TypeDescriptorCollection<? extends TypeDescriptor>Iterable<? extends TypeDescriptor>add(org.springframework.core.convert.TypeDescriptor)AbstractCollection<TypeDescriptor>()ListIterator<TypeDescriptor>add(int,org.springframework.core.convert.TypeDescriptor)set(int,org.springframework.core.convert.TypeDescriptor)Comparator<? super TypeDescriptor>UnaryOperator<TypeDescriptor>Function<TypeDescriptor,TypeDescriptor>AbstractList<TypeDescriptor>()ArrayList<TypeDescriptor>(java.util.Collection)ArrayList<TypeDescriptor>(int)Class<AlwaysTrueReleaseStrategy>Map<String,AlwaysTrueReleaseStrategy>AlwaysTrueReleaseStrategy[]Constructor<AlwaysTrueReleaseStrategy>? super AlwaysTrueReleaseStrategyClass<? super AlwaysTrueReleaseStrategy>TypeVariable<Class<AlwaysTrueReleaseStrategy>>TypeVariable<Class<AlwaysTrueReleaseStrategy>>[]Class<List<>>"checkCompleteness"checkCompletenessargumentTypesresolverexecutorresult"Result: "Result: AlwaysTrueReleaseStrategyAlwaysTrueReleaseStrategy()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expression/spel/support/Spr7538Tests$AlwaysTrueReleaseStrategy.classSpr7538Tests$AlwaysTrueReleaseStrategymessagesFooFoo()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/expression/spel/support/Spr7538Tests$Foo.classSpr7538Tests$FooC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests.javaScheduledAndTransactionalAnnotationIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotationC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/schedulingschedulingorg.springframework.scheduling.annotationmockLONG_RUNNINGwithAspectConfigwithAspectConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests.classsucceedsWhenJdkProxyAndScheduledMethodIsPresentOnInterfacesucceedsWhenJdkProxyAndScheduledMethodIsPresentOnInterface()succeedsWhenSubclassProxyAndScheduledMethodNotPresentOnInterfacesucceedsWhenSubclassProxyAndScheduledMethodNotPresentOnInterface()failsWhenJdkProxyAndScheduledMethodNotPresentOnInterfacefailsWhenJdkProxyAndScheduledMethodNotPresentOnInterface()ScheduledAndTransactionalAnnotationIntegrationTests()TestGroup[]Class<JdkProxyTxConfig>Class<RepoConfigA>ThrowableAssertAlternative<BeanCreationException>AbstractAssert<ThrowableAssertAlternative<BeanCreationException>,BeanCreationException>Assert<ThrowableAssertAlternative<BeanCreationException>,BeanCreationException>Descriptable<ThrowableAssertAlternative<BeanCreationException>>ExtensionPoints<ThrowableAssertAlternative<BeanCreationException>,BeanCreationException>? super BeanCreationExceptionCondition<? super BeanCreationException>Descriptable<Condition<? super BeanCreationException>>Comparator<? super BeanCreationException>Function<? super BeanCreationException,? extends T>Consumer<BeanCreationException>Predicate<? super BeanCreationException>AbstractAssert<ThrowableAssertAlternative<BeanCreationException>,BeanCreationException>(org.springframework.beans.factory.BeanCreationException,java.lang.Class)ThrowableAssertAlternative<BeanCreationException>(org.springframework.beans.factory.BeanCreationException)Class<IllegalStateException>ThrowableTypeAssert<BeanCreationException>Descriptable<ThrowableTypeAssert<BeanCreationException>>? extends BeanCreationExceptionClass<? extends BeanCreationException>ThrowableTypeAssert<BeanCreationException>(java.lang.Class)Class<BeanCreationException>repositoryClass<MyRepository>Class<CallCountingTransactionManager>Class<SubclassProxyTxConfig>100Class<MyRepositoryWithScheduledMethod>Class<RepoConfigB>Class<AspectConfig>Class<MyRepositoryWithScheduledMethodImpl>JdkProxyTxConfigJdkProxyTxConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$JdkProxyTxConfig.classScheduledAndTransactionalAnnotationIntegrationTests$JdkProxyTxConfigSubclassProxyTxConfigSubclassProxyTxConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$SubclassProxyTxConfig.classScheduledAndTransactionalAnnotationIntegrationTests$SubclassProxyTxConfigrepository()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$RepoConfigA.classScheduledAndTransactionalAnnotationIntegrationTests$RepoConfigARepoConfigARepoConfigA()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$RepoConfigB.classScheduledAndTransactionalAnnotationIntegrationTests$RepoConfigBRepoConfigBRepoConfigB()peTranslationPostProcessorpeTranslationPostProcessor()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$Config.classScheduledAndTransactionalAnnotationIntegrationTests$ConfigpeTranslatorpeTranslator()txManager()Class<PersistenceExceptionTranslator>myAspectmyAspect()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$AspectConfig.classScheduledAndTransactionalAnnotationIntegrationTests$AspectConfigautoProxyCreatorautoProxyCreator()AspectConfigAspectConfig()apccountC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$MyAspect.classScheduledAndTransactionalAnnotationIntegrationTests$MyAspect"execution(* scheduled())"execution(* scheduled())C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$MyRepositoryImpl.classScheduledAndTransactionalAnnotationIntegrationTests$MyRepositoryImplMyRepositoryImplMyRepositoryImpl()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/scheduling/annotation/ScheduledAndTransactionalAnnotationIntegrationTests$MyRepositoryWithScheduledMethodImpl.classScheduledAndTransactionalAnnotationIntegrationTests$MyRepositoryWithScheduledMethodImplMyRepositoryWithScheduledMethodImplMyRepositoryWithScheduledMethodImpl()Integration tests cornering bug SPR-8651, which revealed that @Scheduled methods maynot work well with beans that have already been proxied for other reasons suchas @Transactional or @Async processing. allow @Scheduled method to be called several timesC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests.javaEnableTransactionManagementIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotationC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transactiontransactionorg.springframework.transaction.annotationisTxProxyisTxProxy(org.springframework.transaction.annotation.EnableTransactionManagementIntegrationTests.FooRepository)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests.classassertTxProxyingassertTxProxying(org.springframework.context.annotation.AnnotationConfigApplicationContext)apcEscalationapcEscalation()explicitTxManagerexplicitTxManager()implicitTxManagerimplicitTxManager()repositoryIsClassBasedTxProxyrepositoryIsClassBasedTxProxy()repositoryIsTxProxy_withNonConventionalTxManagerName_fallsBackToByTypeLookuprepositoryIsTxProxy_withNonConventionalTxManagerName_fallsBackToByTypeLookup()repositoryIsTxProxy_withCustomTxManagerNamerepositoryIsTxProxy_withCustomTxManagerName()repositoryIsTxProxy_withDefaultTxManagerNamerepositoryIsTxProxy_withDefaultTxManagerName()repositoryIsNotTxProxyrepositoryIsNotTxProxy()EnableTransactionManagementIntegrationTests()Class<DefaultTxManagerNameConfig>Class<CustomTxManagerNameConfig>Class<NonConventionalTxManagerNameConfig>Class<ProxyTargetClassTxConfig>Class<AspectJTxConfig>"AspectJJtaTransactionManagementConfiguration"AspectJJtaTransactionManagementConfigurationClass<ImplicitTxManagerConfig>Class<ExplicitTxManagerConfig>txManager1"txManager1"txManager2"txManager2"Class<EnableTxAndCachingConfig>Stream<Advisor>BaseStream<Advisor,Stream<Advisor>>? super AdvisorPredicate<? super Advisor>Predicate<? super T>closeclose()onCloseonClose(java.lang.Runnable)unorderedunordered()parallelparallel()sequentialsequential()isParallelisParallel()Spliterator<Advisor>Iterator<Advisor>Stream<T>BaseStream<T,Stream<T>>concatconcat(java.util.stream.Stream,java.util.stream.Stream)Stream<? extends T>BaseStream<? extends T,Stream<? extends T>>Supplier<>generategenerate(java.util.function.Supplier)Supplier<? extends T>Predicate<>UnaryOperator<>iterateiterate(java.lang.Object,java.util.function.Predicate,java.util.function.UnaryOperator)UnaryOperator<T>Function<T,T>iterate(java.lang.Object,java.util.function.UnaryOperator)ofNullableofNullable(java.lang.Object)emptyempty()Builder<>C:/modules/java.base/java/util/stream/Stream$Builder.classStream$BuilderBuilder<T>builderbuilder()Optional<T>findAnyfindAny()Optional<Advisor>findFirstfindFirst()count()maxmax(java.util.Comparator)Comparator<? super Advisor>minmin(java.util.Comparator)Collector<>C:/modules/java.base/java/util/stream/Collector.classCollectorRcollectcollect(java.util.stream.Collector)Collector<? super T,A,R>Collector<? super Advisor,A,R>collect(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BiConsumer)Supplier<R>BiConsumer<R,? super T>BiConsumer<R,R>BiConsumer<R,? super Advisor>BiFunction<>C:/modules/java.base/java/util/function/BiFunction.classBiFunctionBinaryOperator<>C:/modules/java.base/java/util/function/BinaryOperator.classBinaryOperatorreducereduce(java.lang.Object,java.util.function.BiFunction,java.util.function.BinaryOperator)BiFunction<U,? super T,U>BinaryOperator<U>BiFunction<U,U,U>BiFunction<U,? super Advisor,U>BinaryOperator<T>BiFunction<T,T,T>reduce(java.util.function.BinaryOperator)BinaryOperator<Advisor>BiFunction<Advisor,Advisor,Advisor>reduce(java.lang.Object,java.util.function.BinaryOperator)reduce(org.springframework.aop.Advisor,java.util.function.BinaryOperator)IntFunction<A[]>forEachOrderedforEachOrdered(java.util.function.Consumer)Consumer<? super Advisor>dropWhiledropWhile(java.util.function.Predicate)takeWhiletakeWhile(java.util.function.Predicate)skipskip(long)limitlimit(long)peekpeek(java.util.function.Consumer)sortedsorted(java.util.Comparator)sorted()distinctdistinct()? extends DoubleStreamFunction<? super T,? extends DoubleStream>flatMapToDoubleflatMapToDouble(java.util.function.Function)Function<? super Advisor,? extends DoubleStream>? extends LongStreamFunction<? super T,? extends LongStream>flatMapToLongflatMapToLong(java.util.function.Function)Function<? super Advisor,? extends LongStream>? extends IntStreamFunction<? super T,? extends IntStream>flatMapToIntflatMapToInt(java.util.function.Function)Function<? super Advisor,? extends IntStream>Stream<R>BaseStream<R,Stream<R>>? extends RStream<? extends R>BaseStream<? extends R,Stream<? extends R>>? extends Stream<? extends R>Function<? super T,? extends Stream<? extends R>>Function<? super Advisor,? extends Stream<? extends R>>ToDoubleFunction<? super T>C:/modules/java.base/java/util/function/ToDoubleFunction.classToDoubleFunctionmapToDoublemapToDouble(java.util.function.ToDoubleFunction)ToDoubleFunction<? super Advisor>ToLongFunction<? super T>C:/modules/java.base/java/util/function/ToLongFunction.classToLongFunctionmapToLongmapToLong(java.util.function.ToLongFunction)ToLongFunction<? super Advisor>ToIntFunction<? super T>C:/modules/java.base/java/util/function/ToIntFunction.classToIntFunctionmapToIntmapToInt(java.util.function.ToIntFunction)ToIntFunction<? super Advisor>Function<? super T,? extends R>Function<? super Advisor,? extends R>filter(java.util.function.Predicate)Predicate<Advisor>Predicate<T>notnot(java.util.function.Predicate)isEqualisEqual(java.lang.Object)oror(java.util.function.Predicate)negatenegate()andand(java.util.function.Predicate)test(java.lang.Object)test(org.springframework.aop.Advisor)arg0Class<BeanFactoryTransactionAttributeSourceAdvisor>EnableTxAndCachingConfigEnableTxAndCachingConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$EnableTxAndCachingConfig.classEnableTransactionManagementIntegrationTests$EnableTxAndCachingConfig"org/springframework/transaction/annotation/enable-caching.xml"org/springframework/transaction/annotation/enable-caching.xmlArrayList<Cache>AbstractList<Cache>AbstractCollection<Cache>Collection<Cache>Iterable<Cache>List<Cache>ArrayList<Cache>()Spliterator<Cache>? super CacheConsumer<? super Cache>Iterator<Cache>Stream<Cache>BaseStream<Cache,Stream<Cache>>Predicate<? super Cache>? extends CacheCollection<? extends Cache>Iterable<? extends Cache>add(org.springframework.cache.Cache)AbstractCollection<Cache>()ListIterator<Cache>add(int,org.springframework.cache.Cache)set(int,org.springframework.cache.Cache)Comparator<? super Cache>UnaryOperator<Cache>Function<Cache,Cache>AbstractList<Cache>()ArrayList<Cache>(java.util.Collection)ArrayList<Cache>(int)ImplicitTxManagerConfigImplicitTxManagerConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$ImplicitTxManagerConfig.classEnableTransactionManagementIntegrationTests$ImplicitTxManagerConfigExplicitTxManagerConfigExplicitTxManagerConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$ExplicitTxManagerConfig.classEnableTransactionManagementIntegrationTests$ExplicitTxManagerConfigtransactionManagertransactionManager(javax.sql.DataSource)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$DefaultTxManagerNameConfig.classEnableTransactionManagementIntegrationTests$DefaultTxManagerNameConfigDefaultTxManagerNameConfigDefaultTxManagerNameConfig()dataSourcetxManager(javax.sql.DataSource)C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$CustomTxManagerNameConfig.classEnableTransactionManagementIntegrationTests$CustomTxManagerNameConfigCustomTxManagerNameConfigCustomTxManagerNameConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$NonConventionalTxManagerNameConfig.classEnableTransactionManagementIntegrationTests$NonConventionalTxManagerNameConfigNonConventionalTxManagerNameConfigNonConventionalTxManagerNameConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$ProxyTargetClassTxConfig.classEnableTransactionManagementIntegrationTests$ProxyTargetClassTxConfigProxyTargetClassTxConfigProxyTargetClassTxConfig()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$AspectJTxConfig.classEnableTransactionManagementIntegrationTests$AspectJTxConfigAspectJTxConfigAspectJTxConfig()dataSource()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$Config.classEnableTransactionManagementIntegrationTests$ConfigreposJdbcFooRepositoryJdbcFooRepository()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$JdbcFooRepository.classEnableTransactionManagementIntegrationTests$JdbcFooRepositoryC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/EnableTransactionManagementIntegrationTests$DummyFooRepository.classEnableTransactionManagementIntegrationTests$DummyFooRepositoryIntegration tests for the @EnableTransactionManagement annotation. trigger a transactionC:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/ProxyAnnotationDiscoveryTests.javaProxyAnnotationDiscoveryTestsannotatedService_PTC_falseannotatedService_PTC_false()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/ProxyAnnotationDiscoveryTests.classannotatedService_PTC_trueannotatedService_PTC_true()nonAnnotatedService_PTC_falsenonAnnotatedService_PTC_false()nonAnnotatedService_PTC_truenonAnnotatedService_PTC_true()annotatedServiceWithoutInterface_PTC_falseannotatedServiceWithoutInterface_PTC_false()annotatedServiceWithoutInterface_PTC_trueannotatedServiceWithoutInterface_PTC_true()ProxyAnnotationDiscoveryTests()sClass<AnnotatedServiceWithoutInterface>Class<PTCTrue>ObjectAssert<AnnotatedServiceWithoutInterface>AbstractObjectAssert<ObjectAssert<AnnotatedServiceWithoutInterface>,AnnotatedServiceWithoutInterface>AbstractAssert<ObjectAssert<AnnotatedServiceWithoutInterface>,AnnotatedServiceWithoutInterface>Assert<ObjectAssert<AnnotatedServiceWithoutInterface>,AnnotatedServiceWithoutInterface>Descriptable<ObjectAssert<AnnotatedServiceWithoutInterface>>ExtensionPoints<ObjectAssert<AnnotatedServiceWithoutInterface>,AnnotatedServiceWithoutInterface>? super AnnotatedServiceWithoutInterfaceCondition<? super AnnotatedServiceWithoutInterface>Descriptable<Condition<? super AnnotatedServiceWithoutInterface>>Comparator<? super AnnotatedServiceWithoutInterface>Function<? super AnnotatedServiceWithoutInterface,? extends T>Consumer<AnnotatedServiceWithoutInterface>Predicate<? super AnnotatedServiceWithoutInterface>AbstractAssert<ObjectAssert<AnnotatedServiceWithoutInterface>,AnnotatedServiceWithoutInterface>(org.springframework.transaction.annotation.AnnotatedServiceWithoutInterface,java.lang.Class)Class<PTCFalse>Class<NonAnnotatedService>Class<AnnotatedServiceImpl>ObjectAssert<NonAnnotatedService>AbstractObjectAssert<ObjectAssert<NonAnnotatedService>,NonAnnotatedService>AbstractAssert<ObjectAssert<NonAnnotatedService>,NonAnnotatedService>Assert<ObjectAssert<NonAnnotatedService>,NonAnnotatedService>Descriptable<ObjectAssert<NonAnnotatedService>>ExtensionPoints<ObjectAssert<NonAnnotatedService>,NonAnnotatedService>? super NonAnnotatedServiceCondition<? super NonAnnotatedService>Descriptable<Condition<? super NonAnnotatedService>>Comparator<? super NonAnnotatedService>Function<? super NonAnnotatedService,? extends T>Consumer<NonAnnotatedService>Predicate<? super NonAnnotatedService>AbstractAssert<ObjectAssert<NonAnnotatedService>,NonAnnotatedService>(org.springframework.transaction.annotation.NonAnnotatedService,java.lang.Class)Class<AnnotatedService>Class<NonAnnotatedServiceImpl>ObjectAssert<AnnotatedService>AbstractObjectAssert<ObjectAssert<AnnotatedService>,AnnotatedService>AbstractAssert<ObjectAssert<AnnotatedService>,AnnotatedService>Assert<ObjectAssert<AnnotatedService>,AnnotatedService>Descriptable<ObjectAssert<AnnotatedService>>ExtensionPoints<ObjectAssert<AnnotatedService>,AnnotatedService>? super AnnotatedServiceCondition<? super AnnotatedService>Descriptable<Condition<? super AnnotatedService>>Comparator<? super AnnotatedService>Function<? super AnnotatedService,? extends T>Consumer<AnnotatedService>Predicate<? super AnnotatedService>AbstractAssert<ObjectAssert<AnnotatedService>,AnnotatedService>(org.springframework.transaction.annotation.AnnotatedService,java.lang.Class)PTCFalsePTCFalse()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/PTCFalse.classPTCTruePTCTrue()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/PTCTrue.classNonAnnotatedServiceImplNonAnnotatedServiceImpl()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/NonAnnotatedServiceImpl.classAnnotatedServiceImplAnnotatedServiceImpl()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/AnnotatedServiceImpl.classAnnotatedServiceWithoutInterfaceAnnotatedServiceWithoutInterface()C:/Users/Semiu/Java/spring-projects_spring-framework/integration-tests/src/test/java/org/springframework/transaction/annotation/AnnotatedServiceWithoutInterface.classTests proving that regardless the proxy strategy used (JDK interface-based vs. CGLIBsubclass-based), discovery of advice-oriented annotations is consistent.For example, Spring's @Transactional may be declared at the interface or class level,and whether interface or subclass proxies are used, the @Transactional annotation mustbe discovered in a consistent fashion.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/aop/Advice.javaAdviceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/aopC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopallianceaopallianceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/orgC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/mainmainC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/srcC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aopspring-aoporg.aopalliance.aopCopyright 2002-2016 the original author or authors.Tag interface for Advice. Implementations can be any typeof advice, such as Interceptors.@version$Id: Advice.java,v 1.1 2004/03/19 17:02:16 johnsonr Exp $C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/aop/AspectException.javaAspectExceptionmessagecauseCopyright 2002-2018 the original author or authors.Superclass for all AOP infrastructure exceptions.Unchecked, as such exceptions are fatal and end usercode shouldn't be forced to catch them.Bob LeeConstructor for AspectException.@paramthe exception messagethe root cause, if anyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/intercept/ConstructorInterceptor.javaConstructorInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/interceptinterceptorg.aopalliance.interceptinvocationIntercepts the construction of a new object.<p>The user should implement the {@link#construct(ConstructorInvocation)} method to modify the originalbehavior. E.g. the following class implements a singletoninterceptor (allows only one unique instance for the interceptedclass):<pre class=code>class DebuggingInterceptor implements ConstructorInterceptor {Object instance=null;Object construct(ConstructorInvocation i) throws Throwable {if(instance==null) {return instance=i.proceed();} else {throw new Exception("singleton does not allow multiple instance");}</pre>Implement this method to perform extra treatments before andafter the construction of a new object. Polite implementationswould certainly like to invoke {@link Joinpoint#proceed()}.the construction joinpoint@returnthe newly created object, which is also the result ofthe call to {@link Joinpoint#proceed()}; might be replaced bythe interceptor@throwsThrowableif the interceptors or the target objectthrows an exceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/intercept/ConstructorInvocation.javaConstructorInvocationDescription of an invocation to a constructor, given to aninterceptor upon constructor-call.<p>A constructor invocation is a joinpoint and can be interceptedby a constructor interceptor.Get the constructor being called.<p>This method is a friendly implementation of the{@link Joinpoint#getStaticPart()} method (same result).the constructor being calledC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/intercept/Interceptor.javaInterceptorThis interface represents a generic interceptor.<p>A generic interceptor can intercept runtime events that occurwithin a base program. Those events are materialized by (reifiedin) joinpoints. Runtime joinpoints can be invocations, fieldaccess, exceptions...<p>This interface is not used directly. Use the sub-interfacesto intercept specific events. For instance, the following classimplements some specific interceptors in order to implement adebugger:class DebuggingInterceptor implements MethodInterceptor,ConstructorInterceptor {Object invoke(MethodInvocation i) throws Throwable {debug(i.getMethod(), i.getThis(), i.getArgs());return i.proceed();debug(i.getConstructor(), i.getThis(), i.getArgs());void debug(AccessibleObject ao, Object this, Object value) {...JoinpointC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/intercept/Invocation.javaInvocationThis interface represents an invocation in the program.<p>An invocation is a joinpoint and can be intercepted by aninterceptor.Get the arguments as an array object.It is possible to change element values within thisarray to change the arguments.the argument of the invocationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/intercept/Joinpoint.javaThis interface represents a generic runtime joinpoint (in the AOPterminology).<p>A runtime joinpoint is an <i>event</i> that occurs on a staticjoinpoint (i.e. a location in a the program). For instance, aninvocation is the runtime joinpoint on a method (static joinpoint).The static part of a given joinpoint can be generically retrievedusing the {@link #getStaticPart()} method.<p>In the context of an interception framework, a runtime joinpointis then the reification of an access to an accessible object (amethod, a constructor, a field), i.e. the static part of thejoinpoint. It is passed to the interceptors that are installed onthe static joinpoint.Proceed to the next interceptor in the chain.<p>The implementation and the semantics of this method dependson the actual joinpoint type (see the children interfaces).see the children interfaces' proceed definitionif the joinpoint throws an exceptionReturn the object that holds the current joinpoint's static part.<p>For instance, the target object for an invocation.the object (can be null if the accessible object is static)Return the static part of this joinpoint.<p>The static part is an accessible object on which a chain ofinterceptors are installed.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/intercept/MethodInterceptor.javaMethodInterceptorIntercepts calls on an interface on its way to the target. Theseare nested "on top" of the target.<p>The user should implement the {@link #invoke(MethodInvocation)}method to modify the original behavior. E.g. the following classimplements a tracing interceptor (traces all the calls on theintercepted method(s)):class TracingInterceptor implements MethodInterceptor {System.out.println("method "+i.getMethod()+" is called on "+i.getThis()+" with args "+i.getArguments());Object ret=i.proceed();System.out.println("method "+i.getMethod()+" returns "+ret);return ret;after the invocation. Polite implementations would certainlylike to invoke {@link Joinpoint#proceed()}.the method invocation joinpointthe result of the call to {@link Joinpoint#proceed()};might be intercepted by the interceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/aopalliance/intercept/MethodInvocation.javaMethodInvocationDescription of an invocation to a method, given to an interceptorupon method-call.<p>A method invocation is a joinpoint and can be intercepted by amethod interceptor.Get the method being called.the method being calledC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/Advisor.javaAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aopC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframeworkorg.springframework.aopC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/Advisor$1.classAdvisor$1Copyright 2002-2017 the original author or authors.Base interface holding AOP <b>advice</b> (action to take at a joinpoint)and a filter determining the applicability of the advice (such asa pointcut). <i>This interface is not for use by Spring users, but toallow for commonality in support for different types of advice.</i><p>Spring AOP is based around <b>around advice</b> delivered via method<b>interception</b>, compliant with the AOP Alliance interception API.The Advisor interface allows support for different types of advice,such as <b>before</b> and <b>after</b> advice, which need not beimplemented using interception.Common placeholder for an empty {@code Advice} to be returned from{@link #getAdvice()} if no proper advice has been configured (yet).5.0Return the advice part of this aspect. An advice may be aninterceptor, a before advice, a throws advice, etc.the advice that should apply if the pointcut matchesorg.aopalliance.intercept.MethodInterceptorBeforeAdviceThrowsAdviceAfterReturningAdviceReturn whether this advice is associated with a particular instance(for example, creating a mixin) or shared with all instances ofthe advised class obtained from the same Spring bean factory.<p><b>Note that this method is not currently used by the framework.</b>Typical Advisor implementations always return {@code true}.Use singleton/prototype bean definitions or appropriate programmaticproxy creation to ensure that Advisors have the correct lifecycle model.whether this advice is associated with a particular target instanceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/AfterAdvice.javaAfterAdviceCopyright 2002-2007 the original author or authors.Common marker interface for after advice,such as {@link AfterReturningAdvice} and {@link ThrowsAdvice}.2.0.3C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/AfterReturningAdvice.javareturnValueAfter returning advice is invoked only on normal method return, not if anexception is thrown. Such advice can see the return value, but cannot change it.MethodBeforeAdviceCallback after a given method successfully returned.the value returned by the method, if anythe method being invokedthe arguments to the methodthe target of the method invocation. May be {@code null}.if this object wishes to abort the call.Any exception thrown will be returned to the caller if it'sallowed by the method signature. Otherwise the exceptionwill be wrapped as a runtime exception.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/AopInvocationException.javaAopInvocationExceptionmsgException that gets thrown when an AOP invocation failedbecause of misconfiguration or unexpected runtime issues.2.0Constructor for AopInvocationException.the detail messagethe root causeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/BeforeAdvice.javaCommon marker interface for before advice, such as {@link MethodBeforeAdvice}.<p>Spring supports only method before advice. Although this is unlikely to change,this API is designed to allow field advice in future if desired.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/ClassFilter.javaClassFilterclazzFilter that restricts matching of a pointcut or introduction toa given set of target classes.<p>Can be used as part of a {@link Pointcut} or for the entiretargeting of an {@link IntroductionAdvisor}.<p>Concrete implementations of this interface typically should provide properimplementations of {@link Object#equals(Object)} and {@link Object#hashCode()}in order to allow the filter to be used in caching scenarios &mdash; forexample, in proxies generated by CGLIB.PointcutMethodMatcherShould the pointcut apply to the given interface or target class?the candidate target classwhether the advice should apply to the given target classCanonical instance of a ClassFilter that matches all classes.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/DynamicIntroductionAdvice.javaDynamicIntroductionAdviceintfSubinterface of AOP Alliance Advice that allows additional interfacesto be implemented by an Advice, and available via a proxy using thatinterceptor. This is a fundamental AOP concept called <b>introduction</b>.<p>Introductions are often <b>mixins</b>, enabling the building of compositeobjects that can achieve many of the goals of multiple inheritance in Java.<p>Compared to {qlink IntroductionInfo}, this interface allows an advice toimplement a range of interfaces that is not necessarily known in advance.Thus an {@link IntroductionAdvisor} can be used to specify which interfaceswill be exposed in an advised object.1.1.1IntroductionInfoIntroductionAdvisorDoes this introduction advice implement the given interface?the interface to checkwhether the advice implements the specified interfaceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/IntroductionAdvisor.javaSuperinterface for advisors that perform one or more AOP <b>introductions</b>.<p>This interface cannot be implemented directly; subinterfaces mustprovide the advice type implementing the introduction.<p>Introduction is the implementation of additional interfaces(not implemented by a target) via AOP advice.04.04.2003IntroductionInterceptorReturn the filter determining which target classes this introductionshould apply to.<p>This represents the class part of a pointcut. Note that methodmatching doesn't make sense to introductions.the class filterCan the advised interfaces be implemented by the introduction advice?Invoked before adding an IntroductionAdvisor.IllegalArgumentExceptionif the advised interfaces can't beimplemented by the introduction adviceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/IntroductionAwareMethodMatcher.javaIntroductionAwareMethodMatcherhasIntroductionsA specialized type of {@link MethodMatcher} that takes into account introductionswhen matching methods. If there are no introductions on the target class,a method matcher may be able to optimize matching more effectively for example.Adrian ColyerPerform static checking whether the given method matches. This may be invokedinstead of the 2-arg {@link #matches(java.lang.reflect.Method, Class)} methodif the caller supports the extended IntroductionAwareMethodMatcher interface.the candidate methodthe target class{@code true} if the object on whose behalf we areasking is the subject on one or more introductions; {@code false} otherwisewhether or not this method matches staticallyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/IntroductionInfo.javaInterface supplying the information necessary to describe an introduction.<p>{@link IntroductionAdvisor IntroductionAdvisors} must implement thisinterface. If an {@link org.aopalliance.aop.Advice} implements this,it may be used as an introduction without an {@link IntroductionAdvisor}.In this case, the advice is self-describing, providing not only thenecessary behavior, but describing the interfaces it introduces.Return the additional interfaces introduced by this Advisor or Advice.the introduced interfacesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/IntroductionInterceptor.javaSubinterface of AOP Alliance MethodInterceptor that allows additional interfacesto be implemented by the interceptor, and available via a proxy using thatC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/MethodBeforeAdvice.javaAdvice invoked before a method is invoked. Such advices cannotprevent the method call proceeding, unless they throw a Throwable.Callback before a given method is invoked.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/MethodMatcher.javaPart of a {@link Pointcut}: Checks whether the target method is eligible for advice.<p>A MethodMatcher may be evaluated <b>statically</b> or at <b>runtime</b> (dynamically).Static matching involves method and (possibly) method attributes. Dynamic matchingalso makes arguments for a particular call available, and any effects of runningprevious advice applying to the joinpoint.<p>If an implementation returns {@code false} from its {@link #isRuntime()}method, evaluation can be performed statically, and the result will be the samefor all invocations of this method, whatever their arguments. This means thatif the {@link #isRuntime()} method returns {@code false}, the 3-arg{@link #matches(java.lang.reflect.Method, Class, Object[])} method will never be invoked.<p>If an implementation returns {@code true} from its 2-arg{@link #matches(java.lang.reflect.Method, Class)} method and its {@link #isRuntime()} methodreturns {@code true}, the 3-arg {@link #matches(java.lang.reflect.Method, Class, Object[])}method will be invoked <i>immediately before each potential execution of the related advice</i>,to decide whether the advice should run. All previous advice, such as earlier interceptorsin an interceptor chain, will have run, so any state changes they have produced inparameters or ThreadLocal state will be available at the time of evaluation.in order to allow the matcher to be used in caching scenarios &mdash; for11.11.2003Perform static checking whether the given method matches.<p>If this returns {@code false} or if the {@link #isRuntime()}method returns {@code false}, no runtime check (i.e. no{@link #matches(java.lang.reflect.Method, Class, Object[])} call)will be made.Is this MethodMatcher dynamic, that is, must a final call be made on the{@link #matches(java.lang.reflect.Method, Class, Object[])} method atruntime even if the 2-arg matches method returns {@code true}?<p>Can be invoked when an AOP proxy is created, and need not be invokedagain before each method invocation,whether or not a runtime match via the 3-arg{@link #matches(java.lang.reflect.Method, Class, Object[])} methodis required if static matching passedCheck whether there a runtime (dynamic) match for this method,which must have matched statically.<p>This method is invoked only if the 2-arg matches method returns{@code true} for the given method and target class, and if the{@link #isRuntime()} method returns {@code true}. Invokedimmediately before potential running of the advice, after anyadvice earlier in the advice chain has run.arguments to the methodwhether there's a runtime matchMethodMatcher#matches(Method, Class)Canonical instance that matches all methods.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/Pointcut.javaCore Spring pointcut abstraction.<p>A pointcut is composed of a {@link ClassFilter} and a {@link MethodMatcher}.Both these basic terms and a Pointcut itself can be combined to build up combinations(e.g. through {@link org.springframework.aop.support.ComposablePointcut}).org.springframework.aop.support.Pointcutsorg.springframework.aop.support.ClassFiltersorg.springframework.aop.support.MethodMatchersReturn the ClassFilter for this pointcut.the ClassFilter (never {@code null})Return the MethodMatcher for this pointcut.the MethodMatcher (never {@code null})Canonical Pointcut instance that always matches.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/PointcutAdvisor.javaPointcutAdvisorSuperinterface for all Advisors that are driven by a pointcut.This covers nearly all advisors except introduction advisors,for which method-level matching doesn't apply.Get the Pointcut that drives this advisor.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/ProxyMethodInvocation.javaProxyMethodInvocationkeyCopyright 2002-2015 the original author or authors.Extension of the AOP Alliance {@link org.aopalliance.intercept.MethodInvocation}interface, allowing access to the proxy that the method invocation was made through.<p>Useful to be able to substitute return values with the proxy,if necessary, for example if the invocation target returned itself.1.1.3org.springframework.aop.framework.ReflectiveMethodInvocationorg.springframework.aop.support.DelegatingIntroductionInterceptorReturn the proxy that this method invocation was made through.the original proxy objectCreate a clone of this object. If cloning is done before {@code proceed()}is invoked on this object, {@code proceed()} can be invoked once per cloneto invoke the joinpoint (and the rest of the advice chain) more than once.an invocable clone of this invocation.{@code proceed()} can be called once per clone.the arguments that the cloned invocation is supposed to use,overriding the original argumentsSet the arguments to be used on subsequent invocations in the any advicein this chain.the argument arrayAdd the specified user attribute with the given value to this invocation.<p>Such attributes are not used within the AOP framework itself. They arejust kept as part of the invocation object, for use in special interceptors.the name of the attributethe value of the attribute, or {@code null} to reset itReturn the value of the specified user attribute.the value of the attribute, or {@code null} if not set#setUserAttributeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/RawTargetAccess.javaRawTargetAccessMarker for AOP proxy interfaces (in particular: introduction interfaces)that explicitly intend to return the raw target object (which would normallyget replaced with the proxy object when returned from a method invocation).<p>Note that this is a marker interface in the style of {@link java.io.Serializable},semantically applying to a declared interface rather than to the full classof a concrete object. In other words, this marker applies to a particularinterface only (typically an introduction interface that does not serveas the primary interface of an AOP proxy), and hence does not affectother interfaces that a concrete AOP proxy may implement.2.0.5org.springframework.aop.scope.ScopedObjectC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/SpringProxy.javaSpringProxyMarker interface implemented by all AOP proxies. Used to detectwhether or not objects are Spring-generated proxies.2.0.1org.springframework.aop.support.AopUtils#isAopProxy(Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/TargetClassAware.javaTargetClassAwareMinimal interface for exposing the target class behind a proxy.<p>Implemented by AOP proxy objects and proxy factories(via {@link org.springframework.aop.framework.Advised})as well as by {@link TargetSource TargetSources}.org.springframework.aop.support.AopUtils#getTargetClass(Object)Return the target class behind the implementing object(typically a proxy configuration or an actual proxy).the target Class, or {@code null} if not knownC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/TargetSource.javaTargetSourceA {@code TargetSource} is used to obtain the current "target" ofan AOP invocation, which will be invoked via reflection if no aroundadvice chooses to end the interceptor chain itself.<p>If a {@code TargetSource} is "static", it will always returnthe same target, allowing optimizations in the AOP framework. Dynamictarget sources can support pooling, hot swapping, etc.<p>Application developers don't usually need to work with{@code TargetSources} directly: this is an AOP framework interface.Return the type of targets returned by this {@link TargetSource}.<p>Can return {@code null}, although certain usages of a {@code TargetSource}might just work with a predetermined target class.the type of targets returned by this {@link TargetSource}Will all calls to {@link #getTarget()} return the same object?<p>In that case, there will be no need to invoke {@link #releaseTarget(Object)},and the AOP framework can cache the return value of {@link #getTarget()}.{@code true} if the target is immutable#getTargetReturn a target instance. Invoked immediately before theAOP framework calls the "target" of an AOP method invocation.the target object which contains the joinpoint,or {@code null} if there is no actual target instanceExceptionif the target object can't be resolvedRelease the given target object obtained from the{@link #getTarget()} method, if any.object obtained from a call to {@link #getTarget()}if the object can't be releasedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/ThrowsAdvice.javaCopyright 2002-2008 the original author or authors.Tag interface for throws advice.<p>There are not any methods on this interface, as methods are invoked byreflection. Implementing classes must implement methods of the form:<pre class="code">void afterThrowing([Method, args, target], ThrowableSubclass);</pre><p>Some examples of valid methods would be:<pre class="code">public void afterThrowing(Exception ex)</pre><pre class="code">public void afterThrowing(RemoteException)</pre><pre class="code">public void afterThrowing(Method method, Object[] args, Object target, Exception ex)</pre><pre class="code">public void afterThrowing(Method method, Object[] args, Object target, ServletException ex)</pre>The first three arguments are optional, and only useful if we want furtherinformation about the joinpoint, as in AspectJ <b>after-throwing</b> advice.<p><b>Note:</b> If a throws-advice method throws an exception itself, it willoverride the original exception (i.e. change the exception thrown to the user).The overriding exception will typically be a RuntimeException; this is compatiblewith any method signature. However, if a throws-advice method throws a checkedexception, it will have to match the declared exceptions of the target methodand is hence to some degree coupled to specific target method signatures.<b>Do not throw an undeclared checked exception that is incompatible withthe target method's signature!</b>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/TrueClassFilter.javaTrueClassFilterreadResolvereadResolve()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/TrueClassFilter.classTrueClassFilter()"ClassFilter.TRUE"ClassFilter.TRUECanonical ClassFilter instance that matches all classes.Enforce Singleton pattern.Required to support serialization. Replaces with canonicalinstance on deserialization, protecting Singleton pattern.Alternative to overriding {@code equals()}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/TrueMethodMatcher.javaTrueMethodMatcherC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/TrueMethodMatcher.classTrueMethodMatcher()"MethodMatcher.TRUE"MethodMatcher.TRUECanonical MethodMatcher instance that matches all methods. Should never be invoked as isRuntime returns false.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/TruePointcut.javaTruePointcutC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/TruePointcut.classTruePointcut()"Pointcut.TRUE"Pointcut.TRUEC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AbstractAspectJAdvice.javaAbstractAspectJAdviceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectjaspectjorg.springframework.aop.aspectjreadObjectreadObject(java.io.ObjectInputStream)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AbstractAspectJAdvice.classconfigurePointcutParametersconfigurePointcutParameters(java.lang.String[],int)bindExplicitArgumentsbindExplicitArguments(int)bindArgumentsByNamebindArgumentsByName(int)maybeBindJoinPointStaticPartmaybeBindJoinPointStaticPart(java.lang.Class)maybeBindProceedingJoinPointmaybeBindProceedingJoinPoint(java.lang.Class)maybeBindJoinPointmaybeBindJoinPoint(java.lang.Class)isVariableNameisVariableName(java.lang.String)discoveredReturningGenericTypeargumentsIntrospectedMap<String,Integer>argumentBindingsjoinPointStaticPartArgumentIndexjoinPointArgumentIndexdiscoveredThrowingTypediscoveredReturningTypereturningNamethrowingNameargumentNamesdeclarationOrderaspectNameaspectInstanceFactorypointcutparameterTypesmethodNamedeclaringClassClass<Object>Class<JoinPoint>Map<String,JoinPoint>JoinPoint[]Constructor<JoinPoint>? super JoinPointClass<? super JoinPoint>TypeVariable<Class<JoinPoint>>TypeVariable<Class<JoinPoint>>[]mipmijp"MethodInvocation is not a Spring ProxyMethodInvocation: "MethodInvocation is not a Spring ProxyMethodInvocation: aspectJAdviceMethod"Advice method must not be null"Advice method must not be nullpcsafeMethodMatcherorderargNamestokensi"'argumentNames' property of AbstractAspectJAdvice contains an argument name '"'argumentNames' property of AbstractAspectJAdvice contains an argument name '"' that is not a valid Java identifier"' that is not a valid Java identifierfirstArgTypeClass<ProceedingJoinPoint>Class<StaticPart>oldNames"THIS_JOIN_POINT"THIS_JOIN_POINT"Only afterReturning advice can be used to bind a return value"Only afterReturning advice can be used to bind a return value"Returning name '"Returning name '"' is neither a valid argument name nor the fully-qualified " +
						"name of a Java type on the classpath. Root cause: "' is neither a valid argument name nor the fully-qualified name of a Java type on the classpath. Root cause: "Only afterThrowing advice can be used to bind a thrown exception"Only afterThrowing advice can be used to bind a thrown exception"Throwing name '"Throwing name 'numUnboundArgscandidateParameterType"ProceedingJoinPoint is only supported for around advice"ProceedingJoinPoint is only supported for around advicenumArgumentsExpectingToBind"Advice method ["Advice method ["] " +
					"requires "] requires " arguments to be bound by name, but " +
					"the argument names were not specified and could not be discovered." arguments to be bound by name, but the argument names were not specified and could not be discovered.discovereradviceParameterNameDiscoverernumArgumentsLeftToBindnumExpectedArgumentNamesargumentIndexOffset"No argument names available"No argument names availableHashMap<String,Integer>C:/modules/java.base/java/util/HashMap.classHashMapAbstractMap<String,Integer>C:/modules/java.base/java/util/AbstractMap.classAbstractMapHashMap<String,Integer>()KMap<K,V>copyOf(java.util.Map)? extends KMap<? extends K,? extends V>Entry<>C:/modules/java.base/java/util/Map$Entry.classMap$EntryEntry<K,V>entryentry(java.lang.Object,java.lang.Object)Entry[]Entry<>[]ofEntriesofEntries(java.util.Map.Entry[])Entry<? extends K,? extends V>Entry<? extends K,? extends V>[]of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)of(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)? super VBiFunction<? super V,? super V,? extends V>merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)? extends IntegerBiFunction<? super Integer,? super Integer,? extends Integer>merge(java.lang.String,java.lang.Integer,java.util.function.BiFunction)? super KBiFunction<? super K,? super V,? extends V>computecompute(java.lang.Object,java.util.function.BiFunction)BiFunction<? super String,? super Integer,? extends Integer>compute(java.lang.String,java.util.function.BiFunction)computeIfPresentcomputeIfPresent(java.lang.Object,java.util.function.BiFunction)computeIfPresent(java.lang.String,java.util.function.BiFunction)Function<? super K,? extends V>computeIfAbsentcomputeIfAbsent(java.lang.Object,java.util.function.Function)Function<? super String,? extends Integer>computeIfAbsent(java.lang.String,java.util.function.Function)replacereplace(java.lang.Object,java.lang.Object)replace(java.lang.String,java.lang.Integer)replace(java.lang.Object,java.lang.Object,java.lang.Object)replace(java.lang.String,java.lang.Integer,java.lang.Integer)remove(java.lang.Object,java.lang.Object)putIfAbsentputIfAbsent(java.lang.Object,java.lang.Object)putIfAbsent(java.lang.String,java.lang.Integer)replaceAll(java.util.function.BiFunction)BiConsumer<? super K,? super V>forEach(java.util.function.BiConsumer)BiConsumer<? super String,? super Integer>getOrDefaultgetOrDefault(java.lang.Object,java.lang.Object)getOrDefault(java.lang.Object,java.lang.Integer)Set<Entry<K,V>>Collection<Entry<K,V>>Iterable<Entry<K,V>>entrySetentrySet()Entry<String,Integer>Set<Entry<String,Integer>>Collection<Entry<String,Integer>>Iterable<Entry<String,Integer>>valuesvalues()Collection<Integer>Iterable<Integer>Set<K>Collection<K>Iterable<K>keySetkeySet()putAllputAll(java.util.Map)Map<? extends String,? extends Integer>putput(java.lang.Object,java.lang.Object)put(java.lang.String,java.lang.Integer)get(java.lang.Object)containsValuecontainsValue(java.lang.Object)containsKeycontainsKey(java.lang.Object)AbstractMap()AbstractMap<String,Integer>()internalWriteEntriesinternalWriteEntries(java.io.ObjectOutputStream)Node<K,V>C:/modules/java.base/java/util/HashMap$Node.classHashMap$NodeHashMap<>AbstractMap<>afterNodeRemovalafterNodeRemoval(java.util.HashMap.Node)Node<String,Integer>afterNodeInsertionafterNodeInsertion(boolean)afterNodeAccessafterNodeAccess(java.util.HashMap.Node)reinitializereinitialize()TreeNode<>C:/modules/java.base/java/util/HashMap$TreeNode.classHashMap$TreeNodeC:/modules/java.base/java/util/LinkedHashMap$Entry.classLinkedHashMap$EntryNode<>LinkedHashMap<>C:/modules/java.base/java/util/LinkedHashMap.classLinkedHashMapTreeNode<K,V>replacementTreeNodereplacementTreeNode(java.util.HashMap.Node,java.util.HashMap.Node)TreeNode<String,Integer>newTreeNodenewTreeNode(int,java.lang.Object,java.lang.Object,java.util.HashMap.Node)newTreeNode(int,java.lang.String,java.lang.Integer,java.util.HashMap.Node)replacementNodereplacementNode(java.util.HashMap.Node,java.util.HashMap.Node)newNodenewNode(int,java.lang.Object,java.lang.Object,java.util.HashMap.Node)newNode(int,java.lang.String,java.lang.Integer,java.util.HashMap.Node)capacitycapacity()floatloadFactorloadFactor()valuesToArrayvaluesToArray(java.lang.Object[])keysToArraykeysToArray(java.lang.Object[])prepareArrayprepareArray(java.lang.Object[])removeNoderemoveNode(int,java.lang.Object,java.lang.Object,boolean,boolean)Node[]Node<K,V>[]treeifyBintreeifyBin(java.util.HashMap.Node[],int)Node<String,Integer>[]Node<>[]resizeresize()putValputVal(int,java.lang.Object,java.lang.Object,boolean,boolean)putVal(int,java.lang.String,java.lang.Integer,boolean,boolean)getNodegetNode(java.lang.Object)putMapEntriesputMapEntries(java.util.Map,boolean)HashMap(java.util.Map)HashMap<String,Integer>(java.util.Map)HashMap()HashMap(int)HashMap<String,Integer>(int)HashMap(int,float)HashMap<String,Integer>(int,float)tableSizeFortableSizeFor(int)compareComparablescompareComparables(java.lang.Class,java.lang.Object,java.lang.Object)comparableClassForcomparableClassFor(java.lang.Object)hashhash(java.lang.Object)thresholdtableMIN_TREEIFY_CAPACITYUNTREEIFY_THRESHOLDTREEIFY_THRESHOLDDEFAULT_LOAD_FACTORMAXIMUM_CAPACITYDEFAULT_INITIAL_CAPACITY"Expecting to find "Expecting to find " arguments to bind by name in advice, but actually found " arguments to bind by name in advice, but actually found " arguments." arguments."Returning argument name '"Returning argument name '"' was not bound in advice arguments"' was not bound in advice argumentsindex"Throwing argument name '"Throwing argument name 'numParametersToRemovepointcutParameterNamespointcutParameterTypesmethodParameterTypesjpMatchadviceInvocationArgsnumBoundMap<?,?>PointcutParameter[]parameterBindingsparameter"Required to bind "Required to bind " arguments, but only bound " arguments, but only bound " (JoinPointMatch " (JoinPointMatch "was NOT"was NOT"WAS"WAS" bound in invocation)" bound in invocation)tactualArgs"Mismatch on arguments to advice method ["Mismatch on arguments to advice method ["]; pointcut expression ["]; pointcut expression ["]"]? extends AbstractAspectJAdviceClass<? extends AbstractAspectJAdvice>Map<String,? extends AbstractAspectJAdvice>AbstractAspectJAdvice[]? extends AbstractAspectJAdvice[]Constructor<? extends AbstractAspectJAdvice>? super ? extends AbstractAspectJAdviceClass<? super ? extends AbstractAspectJAdvice>TypeVariable<Class<? extends AbstractAspectJAdvice>>TypeVariable<Class<? extends AbstractAspectJAdvice>>[]": advice method [": advice method ["]; " +
				"aspect name '"]; aspect name '"'"'inputStream"Failed to find advice method on deserialization"Failed to find advice method on deserializationadviceMethodC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AbstractAspectJAdvice$AdviceExcludingMethodMatcher.classAbstractAspectJAdvice$AdviceExcludingMethodMatcherotherotherMm? extends AdviceExcludingMethodMatcherClass<? extends AdviceExcludingMethodMatcher>Map<String,? extends AdviceExcludingMethodMatcher>AdviceExcludingMethodMatcher[]? extends AdviceExcludingMethodMatcher[]Constructor<? extends AdviceExcludingMethodMatcher>? super ? extends AdviceExcludingMethodMatcherClass<? super ? extends AdviceExcludingMethodMatcher>TypeVariable<Class<? extends AdviceExcludingMethodMatcher>>TypeVariable<Class<? extends AdviceExcludingMethodMatcher>>[]": ": Base class for AOP Alliance {@link org.aopalliance.aop.Advice} classeswrapping an AspectJ aspect or an AspectJ-annotated advice method.Ramnivas LaddadKey used in ReflectiveMethodInvocation userAttributes map for the current joinpoint.Lazily instantiate joinpoint for the current invocation.Requires MethodInvocation to be bound with ExposeInvocationInterceptor.<p>Do not use if access is available to the current ReflectiveMethodInvocation(in an around advice).current AspectJ joinpoint, or through an exception if we're not in aSpring AOP invocation.The name of the aspect (ref bean) in which this advice was defined(used when determining advice precedence so that we can determinewhether two pieces of advice come from the same aspect).The order of declaration of this advice within the aspect.This will be non-null if the creator of this advice object knows the argument namesand sets them explicitly.Non-null if after throwing advice binds the thrown value.Non-null if after returning advice binds the return value.Index for thisJoinPoint argument (currently onlysupported at index 0 if present at all).Index for thisJoinPointStaticPart argument (currently only Note: Unlike return type, no such generic information is needed for the throwing type, since Java doesn't allow exception types to be parameterized.Create a new AbstractAspectJAdvice for the given advice method.the AspectJ-style advice methodthe AspectJ expression pointcutthe factory for aspect instancesReturn the AspectJ-style advice method.Return the AspectJ expression pointcut.Build a 'safe' pointcut that excludes the AspectJ advice method itself.a composable pointcut that builds on the original AspectJ expression pointcut#getPointcut()Return the factory for aspect instances.Return the ClassLoader for aspect instances.Set the name of the aspect (bean) in which the advice was declared.Set the declaration order of this advice within the aspect.Set by creator of this advice object if the argument names are known.<p>This could be for example because they have been explicitly specified in XML,or in an advice annotation.comma delimited list of arg names May need to add implicit join point arg name...We need to hold the returning name at this level for argument binding calculations,this method allows the afterReturning advice subclass to set the name. name could be a variable or a type... assume a typeWe need to hold the throwing name at this level for argument binding calculations,this method allows the afterThrowing advice subclass to set the name.Do as much work as we can as part of the set-up so that argument bindingon subsequent advice invocations can be as fast as possible.<p>If the first argument is of type JoinPoint or ProceedingJoinPoint then wepass a JoinPoint in that position (ProceedingJoinPoint for around advice).<p>If the first argument is of type {@code JoinPoint.StaticPart}then we pass a {@code JoinPoint.StaticPart} in that position.<p>Remaining arguments have to be bound by pointcut evaluation ata given join point. We will get back a map from argument name tovalue. We need to calculate which advice parameter needs to be boundto which argument name. There are multiple strategies for determiningthis binding, which are arranged in a ChainOfResponsibility. The simple case... nothing to bind. need to bind arguments by name as returned from the pointcut match We have been able to determine the arg names.Create a ParameterNameDiscoverer to be used for argument binding.<p>The default implementation creates a {@link DefaultParameterNameDiscoverer}and adds a specifically configured {@link AspectJAdviceParameterNameDiscoverer}. We need to discover them, or if that fails, guess, and if we can't guess with 100% accuracy, fail. Last in chain, so if we're called and we fail, that's bad... So we match in number... Check that returning and throwing were in the argument names list if specified, and find the discovered argument types. configure the pointcut expression accordingly.All parameters from argumentIndexOffset onwards are candidates forpointcut parameters - but returning and throwing vars are handled differentlyand must be removed from the list if present.Take the arguments at the method execution join point and output a set of argumentsto the advice method.the current JoinPointthe join point match that matched this execution join pointthe return value from the method execution (may be null)the exception thrown by the method execution (may be null)the empty array if there are no arguments AMC start binding from pointcut match binding from returning clause binding from thrown exceptionInvoke the advice method.the JoinPointMatch that matched this execution join pointthe invocation resultin case of invocation failure As above, but in this case we are given the join point.Overridden in around advice to return proceeding join point.Get the current join point match at the join point we are being dispatched on. Note: We can't use JoinPointMatch.getClass().getName() as the key, since Spring AOP does all the matching at a join point, and then all the invocations. Under this scenario, if we just use JoinPointMatch as the key, then 'last man wins' which is not what we want at all. Using the expression is guaranteed to be safe, since 2 identical expressions are guaranteed to bind in exactly the same way.MethodMatcher that excludes the specified advice method.AbstractAspectJAdvice#buildSafePointcut()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectInstanceFactory.javaAspectInstanceFactoryInterface implemented to provide an instance of an AspectJ aspect.Decouples from Spring's bean factory.<p>Extends the {@link org.springframework.core.Ordered} interfaceto express an order value for the underlying aspect in a chain.org.springframework.beans.factory.BeanFactory#getBeanCreate an instance of this factory's aspect.the aspect instance (never {@code null})Expose the aspect class loader that this factory uses.the aspect class loader (or {@code null} for the bootstrap loader)org.springframework.util.ClassUtils#getDefaultClassLoader()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAdviceParameterNameDiscoverer.javaAspectJAdviceParameterNameDiscovererfindAndBindfindAndBind(java.lang.Class,java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAdviceParameterNameDiscoverer.classcountNumberOfUnboundPrimitiveArgumentscountNumberOfUnboundPrimitiveArguments()countNumberOfUnboundAnnotationArgumentscountNumberOfUnboundAnnotationArguments()isSubtypeOfisSubtypeOf(java.lang.Class,int)alreadyBoundalreadyBound(java.lang.String)isUnboundisUnbound(int)maybeBindPrimitiveArgsFromPointcutExpressionmaybeBindPrimitiveArgsFromPointcutExpression()getPointcutBodygetPointcutBody(java.lang.String[],int)maybeBindReferencePointcutParametermaybeBindReferencePointcutParameter()maybeBindThisOrTargetOrArgsFromPointcutExpressionmaybeBindThisOrTargetOrArgsFromPointcutExpression()maybeExtractVariableNamesFromArgsmaybeExtractVariableNamesFromArgs(java.lang.String,java.util.List)maybeExtractVariableNamemaybeExtractVariableName(java.lang.String)bindAnnotationsFromVarNamesbindAnnotationsFromVarNames(java.util.List)maybeBindAnnotationsFromPointcutExpressionmaybeBindAnnotationsFromPointcutExpression()maybeBindReturningVariablemaybeBindReturningVariable()maybeBindThrowingVariablemaybeBindThrowingVariable()maybeBindThisJoinPointStaticPartmaybeBindThisJoinPointStaticPart()maybeBindThisJoinPointmaybeBindThisJoinPoint()bindParameterNamebindParameterName(int,java.lang.String)numberOfRemainingUnboundArgumentsparameterNameBindingsraiseExceptionspointcutExpressionnonReferencePointcutTokenssingleValuedAnnotationPcdsSTEP_FINISHEDSTEP_REFERENCE_PCUT_BINDINGSTEP_THIS_TARGET_ARGS_BINDINGSTEP_PRIMITIVE_ARGS_BINDINGSTEP_RETURNING_BINDINGSTEP_ANNOTATION_BINDINGSTEP_THROWING_BINDINGSTEP_JOIN_POINT_BINDINGTHIS_JOIN_POINT_STATIC_PART"thisJoinPoint"thisJoinPoint"thisJoinPointStaticPart"thisJoinPointStaticPart378HashSet<String>C:/modules/java.base/java/util/HashSet.classHashSetAbstractSet<String>C:/modules/java.base/java/util/AbstractSet.classAbstractSetHashSet<String>()AbstractSet()AbstractSet<String>()HashSet(int,float,boolean)HashSet<String>(int,float,boolean)HashSet(int)HashSet<String>(int)HashSet(int,float)HashSet<String>(int,float)HashSet(java.util.Collection)HashSet<String>(java.util.Collection)HashSet()serialVersionUIDSet<PointcutPrimitive>Collection<PointcutPrimitive>Iterable<PointcutPrimitive>pointcutPrimitives"@this"@this"@target"@target"@within"@within"@withincode"@withincode"@annotation"@annotationprimitive"&&"&&"!"!"||"||"and""or""not"minimumNumberUnboundArgs"Not enough arguments in method to satisfy binding of returning and throwing variables"Not enough arguments in method to satisfy binding of returning and throwing variablesalgorithmicStep"Unknown algorithmic step: "Unknown algorithmic step: "Failed to bind all argument names: "Failed to bind all argument names: " argument(s) could not be bound" argument(s) could not be boundctor"An advice method can never be a constructor"An advice method can never be a constructorthrowableIndexClass<Throwable>"Binding of throwing parameter '"Binding of throwing parameter '"' is ambiguous: could be bound to argument "' is ambiguous: could be bound to argument " or argument " or argument "' could not be completed as no available arguments are a subtype of Throwable"' could not be completed as no available arguments are a subtype of Throwable"Algorithm assumes that there must be at least one unbound parameter on entry to this method"Algorithm assumes that there must be at least one unbound parameter on entry to this method"Binding of returning parameter '"Binding of returning parameter '"' is ambiguous, there are "' is ambiguous, there are " candidates." candidates.varNames" " toMatchfirstParenIndexchar'('(bodyvarName"@args("@args("@args"@argsnumAnnotationSlots"Found "Found " potential annotation variable(s), and " potential annotation variable(s), and " potential argument slots" potential argument slotsClass<Annotation>" candidate annotation binding variables" +
							" but only one potential argument binding slot" candidate annotation binding variables but only one potential argument binding slotcandidateTokenargsSpec",","Still "Still " unbound args at this(),target(),args() binding stage, with no way to determine between them" unbound args at this(),target(),args() binding stage, with no way to determine between them"this"this"this("this("target""target("target("args""args("args(candidateVarNames" candidate this(), target() or args() variables but only one unbound argument slot" candidate this(), target() or args() variables but only one unbound argument slotj" unbound args at reference pointcut binding stage, with no way to determine between them" unbound args at reference pointcut binding stage, with no way to determine between themnextToken" candidate reference pointcut variables but only one unbound argument slot" candidate reference pointcut variables but only one unbound argument slotstartIndexnumTokensConsumedcurrentTokenbodyStart')')sbcurrentIndextoAppend"("")"numUnboundPrimitives"Found '"Found '"' unbound primitive arguments with no way to distinguish between them."' unbound primitive arguments with no way to distinguish between them." candidate variable names but only one candidate binding slot when matching primitive args" candidate variable names but only one candidate binding slot when matching primitive argssupertypeargumentNumberargumentType"Expected to find an unbound argument of type '"Expected to find an unbound argument of type 'textC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAdviceParameterNameDiscoverer$PointcutBody.classAspectJAdviceParameterNameDiscoverer$PointcutBody{@link ParameterNameDiscoverer} implementation that tries to deduce parameter namesfor an advice method from the pointcut expression, returning, and throwing clauses.If an unambiguous interpretation is not available, it returns {@code null}.<p>This class interprets arguments in the following way:<ol><li>If the first parameter of the method is of type {@link JoinPoint}or {@link ProceedingJoinPoint}, it is assumed to be for passing{@code thisJoinPoint} to the advice, and the parameter name willbe assigned the value {@code "thisJoinPoint"}.</li><li>If the first parameter of the method is of type{@code JoinPoint.StaticPart}, it is assumed to be for passing{@code "thisJoinPointStaticPart"} to the advice, and the parameter namewill be assigned the value {@code "thisJoinPointStaticPart"}.</li><li>If a {@link #setThrowingName(String) throwingName} has been set, andthere are no unbound arguments of type {@code Throwable+}, then an{@link IllegalArgumentException} is raised. If there is more than oneunbound argument of type {@code Throwable+}, then an{@link AmbiguousBindingException} is raised. If there is exactly oneunbound argument of type {@code Throwable+}, then the correspondingparameter name is assigned the value &lt;throwingName&gt;.</li><li>If there remain unbound arguments, then the pointcut expression isexamined. Let {@code a} be the number of annotation-based pointcutexpressions (&#64;annotation, &#64;this, &#64;target, &#64;args,&#64;within, &#64;withincode) that are used in binding form. Usage inbinding form has itself to be deduced: if the expression inside thepointcut is a single string literal that meets Java variable nameconventions it is assumed to be a variable name. If {@code a} iszero we proceed to the next stage. If {@code a} &gt; 1 then an{@code AmbiguousBindingException} is raised. If {@code a} == 1,and there are no unbound arguments of type {@code Annotation+},then an {@code IllegalArgumentException} is raised. if there isexactly one such argument, then the corresponding parameter name isassigned the value from the pointcut expression.</li><li>If a returningName has been set, and there are no unbound argumentsthen an {@code IllegalArgumentException} is raised. If there ismore than one unbound argument then an{@code AmbiguousBindingException} is raised. If there is exactlyone unbound argument then the corresponding parameter name is assignedthe value &lt;returningName&gt;.</li>examined once more for {@code this}, {@code target}, and{@code args} pointcut expressions used in the binding form (bindingforms are deduced as described for the annotation based pointcuts). Ifthere remains more than one unbound argument of a primitive type (whichcan only be bound in {@code args}) then anone argument of a primitive type, then if exactly one {@code args}bound variable was found, we assign the corresponding parameter namethe variable name. If there were no {@code args} bound variablesfound an {@code IllegalStateException} is raised. If there aremultiple {@code args} bound variables, an{@code AmbiguousBindingException} is raised. At this point, ifthere remains more than one unbound argument we raise an{@code AmbiguousBindingException}. If there are no unbound argumentsremaining, we are done. If there is exactly one unbound argumentremaining, and only one candidate variable name unbound from{@code this}, {@code target}, or {@code args}, it isassigned as the corresponding parameter name. If there are multiplepossibilities, an {@code AmbiguousBindingException} is raised.</li></ol><p>The behavior on raising an {@code IllegalArgumentException} or{@code AmbiguousBindingException} is configurable to allow this discovererto be used as part of a chain-of-responsibility. By default the condition willbe logged and the {@code getParameterNames(..)} method will simply return{@code null}. If the {@link #setRaiseExceptions(boolean) raiseExceptions}property is set to {@code true}, the conditions will be thrown as{@code IllegalArgumentException} and {@code AmbiguousBindingException},respectively.<p>Was that perfectly clear? ;)<p>Short version: If an unambiguous binding can be deduced, then it is.If the advice requirements cannot possibly be satisfied, then {@code null}is returned. By setting the {@link #setRaiseExceptions(boolean) raiseExceptions}property to {@code true}, descriptive exceptions will be thrown instead ofreturning {@code null} in the case that the parameter names cannot be discovered. Steps in the binding algorithm...The pointcut expression associated with the advice, as a simple String.If the advice is afterReturning, and binds the return value, this is the parameter name used.If the advice is afterThrowing, and binds the thrown value, this is the parameter name used.Create a new discoverer that attempts to discover parameter names.from the given pointcut expression.Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException}must be thrown as appropriate in the case of failing to deduce advice parameter names.{@code true} if exceptions are to be thrownIf {@code afterReturning} advice binds the return value, thereturning variable name must be specified.the name of the returning variableIf {@code afterThrowing} advice binds the thrown value, thethrowing variable name must be specified.the name of the throwing variableDeduce the parameter names for an advice method.<p>See the {@link AspectJAdviceParameterNameDiscoverer class level javadoc}for this class for details of the algorithm used.the target {@link Method}the parameter names convention for failing is to return null, allowing participation in a chain of responsibilityAn advice method can never be a constructor in Spring.{@code null}UnsupportedOperationExceptionif{@link #setRaiseExceptions(boolean) raiseExceptions} has been set to {@code true} we return null rather than throw an exception so that we behave well in a chain-of-responsibility.If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" asparameter name and return true, else return false.If a throwing name was specified and there is exactly one choice remaining(argument that is a subtype of Throwable) then bind it. So there is binding work to do... Second candidate we've found - ambiguous bindingIf a returning variable was specified and there is only one choice remaining, bind it. We're all set... find the unbound parameter, and bind it.Parse the string pointcut expression looking for:&#64;this, &#64;target, &#64;args, &#64;within, &#64;withincode, &#64;annotation.If we find one of these pointcut expressions, try and extract a candidate variablename (or variable names, in the case of args).<p>Some more support from AspectJ in doing this exercise would be nice... :)Match the given list of extracted variable names to argument slots. we have work to do... it's a match multiple candidate vars, but only one slot no slots so presume those candidate vars were actually type namesIf the token starts meets Java identifier conventions, it's in.Given an args pointcut body (could be {@code args} or {@code at_args}),add any candidate variable names to the given list.Parse the string pointcut expression looking for this(), target() and args() expressions.If we find one, try and extract a candidate variable name and bind it. we may have found some var names that were bound in previous primitive args binding step, filter them out... else varNames.size must be 0 and we have nothing to bind. no "(" and nothing following next token is not "(" either, can't be a pc... eat the body then it could be a reference pointcutWe've found the start of a binding pointcut at the given index into thetoken array. Now we need to extract the pointcut body and return it. It's an all in one... get the text between the first (and the last) We looked and failed...Match up args against unbound arguments of primitive types. Look for arg variable and bind it if we find exactly one... 1 primitive arg, and one candidate...Return true if the parameter name binding for the given parameterindex has not yet been assigned.Return {@code true} if the given argument type is a subclassof the given supertype.Find the argument index with the given type, and bind the given{@code varName} in that position.Simple struct to hold the extracted text from a pointcut body, togetherwith the number of tokens consumed in extracting it.Thrown in response to an ambiguous binding being detected whentrying to resolve a method's parameter names.Construct a new AmbiguousBindingException with the specified message.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAfterAdvice.javaAspectJAfterAdviceaspectJBeforeAdviceMethodaifSpring AOP advice wrapping an AspectJ after advice method.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAfterReturningAdvice.javaAspectJAfterReturningAdvicematchesReturnValuematchesReturnValue(java.lang.Class,java.lang.reflect.Method,java.lang.Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAfterReturningAdvice.classshouldInvokeOnReturnValueOfshouldInvokeOnReturnValueOf(java.lang.reflect.Method,java.lang.Object)genericTypeSpring AOP advice wrapping an AspectJ after-returning advice method.Following AspectJ semantics, if a returning clause was specified, then theadvice is only invoked if the returned value is an instance of the givenreturning type and generic type parameters, if any, match the assignmentrules. If the returning type is Object, the advice is *always* invoked.the return value of the target methodwhether to invoke the advice method for the given return value If we aren't dealing with a raw type, check if generic parameters are assignable.Following AspectJ semantics, if a return value is null (or return type is void),then the return type of target method should be used to determine whether adviceis invoked or not. Also, even if the return type is void, if the type of argumentdeclared in the advice method is Object, then the advice must still get invoked.the type of argument declared in advice methodthe advice methodwhether to invoke the advice method for the given return value and typeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAfterThrowingAdvice.javaAspectJAfterThrowingAdviceshouldInvokeOnThrowingshouldInvokeOnThrowing(java.lang.Throwable)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAfterThrowingAdvice.classSpring AOP advice wrapping an AspectJ after-throwing advice method.In AspectJ semantics, after throwing advice that specifies a throwing clauseis only invoked if the thrown exception is a subtype of the given throwing type.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAopUtils.javaAspectJAopUtilsanAdvisorprecedenceInfoadviceUtility methods for dealing with AspectJ advisors.Return {@code true} if the advisor is a form of before advice.Return {@code true} if the advisor is a form of after advice.Return the AspectJPrecedenceInformation provided by this advisor or its advice.If neither the advisor nor the advice have precedence information, this methodwill return {@code null}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJAroundAdvice.javaAspectJAroundAdviceaspectJAroundAdviceMethodpjpjpmrmiSpring AOP around advice (MethodInterceptor) that wrapsan AspectJ advice method. Exposes ProceedingJoinPoint.Return the ProceedingJoinPoint for the current invocation,instantiating it lazily if it hasn't been bound to the thread already.the current Spring AOP ReflectiveMethodInvocation,which we'll use for attribute bindingthe ProceedingJoinPoint to make available to advice methodsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.javaAspectJExpressionPointcutC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut.classgetShadowMatchgetShadowMatch(java.lang.reflect.Method,java.lang.reflect.Method)getTargetShadowMatchgetTargetShadowMatch(java.lang.reflect.Method,java.lang.Class)bindParametersbindParameters(org.springframework.aop.ProxyMethodInvocation,org.aspectj.weaver.tools.JoinPointMatch)getRuntimeTestWalkergetRuntimeTestWalker(org.aspectj.weaver.tools.ShadowMatch)getFallbackPointcutExpressiongetFallbackPointcutExpression(java.lang.Class)replaceBooleanOperatorsreplaceBooleanOperators(java.lang.String)initializePointcutParserinitializePointcutParser(java.lang.ClassLoader)resolveExpressionresolveExpression()buildPointcutExpressionbuildPointcutExpression(java.lang.ClassLoader)determinePointcutClassLoaderdeterminePointcutClassLoader()obtainPointcutExpressionobtainPointcutExpression()Map<Method,ShadowMatch>shadowMatchCachepointcutClassLoaderpointcutDeclarationScopeSUPPORTED_PRIMITIVESjava.util.concurrentConcurrentHashMap<Method,ShadowMatch>C:/modules/java.base/java/util/concurrent/ConcurrentHashMap.classConcurrentHashMapC:/modules/java.base/java/util/concurrentconcurrentAbstractMap<Method,ShadowMatch>ConcurrentMap<Method,ShadowMatch>C:/modules/java.base/java/util/concurrent/ConcurrentMap.classConcurrentMapConcurrentHashMap<Method,ShadowMatch>(int)? super ShadowMatch? extends ShadowMatchBiFunction<? super ShadowMatch,? super ShadowMatch,? extends ShadowMatch>merge(java.lang.reflect.Method,org.aspectj.weaver.tools.ShadowMatch,java.util.function.BiFunction)? super MethodBiFunction<? super Method,? super ShadowMatch,? extends ShadowMatch>compute(java.lang.reflect.Method,java.util.function.BiFunction)computeIfPresent(java.lang.reflect.Method,java.util.function.BiFunction)Function<? super Method,? extends ShadowMatch>computeIfAbsent(java.lang.reflect.Method,java.util.function.Function)replace(java.lang.reflect.Method,org.aspectj.weaver.tools.ShadowMatch)replace(java.lang.reflect.Method,org.aspectj.weaver.tools.ShadowMatch,org.aspectj.weaver.tools.ShadowMatch)putIfAbsent(java.lang.reflect.Method,org.aspectj.weaver.tools.ShadowMatch)BiConsumer<? super Method,? super ShadowMatch>getOrDefault(java.lang.Object,org.aspectj.weaver.tools.ShadowMatch)Entry<Method,ShadowMatch>Set<Entry<Method,ShadowMatch>>Collection<Entry<Method,ShadowMatch>>Iterable<Entry<Method,ShadowMatch>>Collection<ShadowMatch>Iterable<ShadowMatch>Set<Method>? extends MethodMap<? extends Method,? extends ShadowMatch>put(java.lang.reflect.Method,org.aspectj.weaver.tools.ShadowMatch)AbstractMap<Method,ShadowMatch>()ToIntFunction<Entry<K,V>>reduceEntriesToIntreduceEntriesToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<Entry<Method,ShadowMatch>>ToLongFunction<Entry<K,V>>reduceEntriesToLongreduceEntriesToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<Entry<Method,ShadowMatch>>ToDoubleFunction<Entry<K,V>>doublereduceEntriesToDoublereduceEntriesToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<Entry<Method,ShadowMatch>>reduceEntriesreduceEntries(long,java.util.function.Function,java.util.function.BiFunction)Function<Entry<K,V>,? extends U>? super UBiFunction<? super U,? super U,? extends U>Function<Entry<Method,ShadowMatch>,? extends U>? extends Entry<K,V>BiFunction<Entry<K,V>,Entry<K,V>,? extends Entry<K,V>>reduceEntries(long,java.util.function.BiFunction)? extends Entry<Method,ShadowMatch>BiFunction<Entry<Method,ShadowMatch>,Entry<Method,ShadowMatch>,? extends Entry<Method,ShadowMatch>>searchEntriessearchEntries(long,java.util.function.Function)forEachEntryforEachEntry(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super U>? super Entry<K,V>Consumer<? super Entry<K,V>>forEachEntry(long,java.util.function.Consumer)? super Entry<Method,ShadowMatch>Consumer<? super Entry<Method,ShadowMatch>>ToIntFunction<? super V>reduceValuesToIntreduceValuesToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<? super ShadowMatch>ToLongFunction<? super V>reduceValuesToLongreduceValuesToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<? super ShadowMatch>ToDoubleFunction<? super V>reduceValuesToDoublereduceValuesToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<? super ShadowMatch>reduceValuesreduceValues(long,java.util.function.Function,java.util.function.BiFunction)Function<? super V,? extends U>Function<? super ShadowMatch,? extends U>reduceValues(long,java.util.function.BiFunction)searchValuessearchValues(long,java.util.function.Function)forEachValueforEachValue(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super V>forEachValue(long,java.util.function.Consumer)Consumer<? super ShadowMatch>ToIntFunction<? super K>reduceKeysToIntreduceKeysToInt(long,java.util.function.ToIntFunction,int,java.util.function.IntBinaryOperator)ToIntFunction<? super Method>ToLongFunction<? super K>reduceKeysToLongreduceKeysToLong(long,java.util.function.ToLongFunction,long,java.util.function.LongBinaryOperator)ToLongFunction<? super Method>ToDoubleFunction<? super K>reduceKeysToDoublereduceKeysToDouble(long,java.util.function.ToDoubleFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleFunction<? super Method>reduceKeysreduceKeys(long,java.util.function.Function,java.util.function.BiFunction)Function<? super K,? extends U>Function<? super Method,? extends U>BiFunction<? super K,? super K,? extends K>reduceKeys(long,java.util.function.BiFunction)BiFunction<? super Method,? super Method,? extends Method>searchKeyssearchKeys(long,java.util.function.Function)forEachKeyforEachKey(long,java.util.function.Function,java.util.function.Consumer)Consumer<? super K>forEachKey(long,java.util.function.Consumer)Consumer<? super Method>ToIntBiFunction<? super K,? super V>C:/modules/java.base/java/util/function/ToIntBiFunction.classToIntBiFunctionreduceToIntreduceToInt(long,java.util.function.ToIntBiFunction,int,java.util.function.IntBinaryOperator)ToIntBiFunction<? super Method,? super ShadowMatch>ToLongBiFunction<? super K,? super V>C:/modules/java.base/java/util/function/ToLongBiFunction.classToLongBiFunctionreduceToLongreduceToLong(long,java.util.function.ToLongBiFunction,long,java.util.function.LongBinaryOperator)ToLongBiFunction<? super Method,? super ShadowMatch>ToDoubleBiFunction<? super K,? super V>C:/modules/java.base/java/util/function/ToDoubleBiFunction.classToDoubleBiFunctionreduceToDoublereduceToDouble(long,java.util.function.ToDoubleBiFunction,double,java.util.function.DoubleBinaryOperator)ToDoubleBiFunction<? super Method,? super ShadowMatch>reduce(long,java.util.function.BiFunction,java.util.function.BiFunction)BiFunction<? super K,? super V,? extends U>BiFunction<? super Method,? super ShadowMatch,? extends U>searchsearch(long,java.util.function.BiFunction)forEach(long,java.util.function.BiFunction,java.util.function.Consumer)forEach(long,java.util.function.BiConsumer)batchForbatchFor(long)C:/modules/java.base/java/util/concurrent/ConcurrentHashMap$Node.classConcurrentHashMap$NodeConcurrentHashMap<>ConcurrentMap<>untreeifyuntreeify(java.util.concurrent.ConcurrentHashMap.Node)sumCountsumCount()helpTransferhelpTransfer(java.util.concurrent.ConcurrentHashMap.Node[],java.util.concurrent.ConcurrentHashMap.Node)Node<Method,ShadowMatch>Node<Method,ShadowMatch>[]resizeStampresizeStamp(int)KeySetView<>C:/modules/java.base/java/util/concurrent/ConcurrentHashMap$KeySetView.classConcurrentHashMap$KeySetViewCollectionView<>C:/modules/java.base/java/util/concurrent/ConcurrentHashMap$CollectionView.classConcurrentHashMap$CollectionViewKeySetView<K,V>CollectionView<K,V,K>keySet(java.lang.Object)KeySetView<Method,ShadowMatch>CollectionView<Method,ShadowMatch,Method>keySet(org.aspectj.weaver.tools.ShadowMatch)KeySetView<K,Boolean>CollectionView<K,Boolean,K>newKeySetnewKeySet(int)newKeySet()mappingCountmappingCount()Enumeration<>C:/modules/java.base/java/util/Enumeration.classEnumerationEnumeration<V>elementselements()Enumeration<ShadowMatch>Enumeration<K>keyskeys()Enumeration<Method>Predicate<? super V>removeValueIfremoveValueIf(java.util.function.Predicate)Predicate<? super ShadowMatch>Predicate<? super Entry<K,V>>removeEntryIfremoveEntryIf(java.util.function.Predicate)Predicate<? super Entry<Method,ShadowMatch>>replaceNodereplaceNode(java.lang.Object,java.lang.Object,java.lang.Object)replaceNode(java.lang.Object,org.aspectj.weaver.tools.ShadowMatch,java.lang.Object)putVal(java.lang.Object,java.lang.Object,boolean)putVal(java.lang.reflect.Method,org.aspectj.weaver.tools.ShadowMatch,boolean)ConcurrentHashMap(int,float,int)ConcurrentHashMap<Method,ShadowMatch>(int,float,int)ConcurrentHashMap(int,float)ConcurrentHashMap<Method,ShadowMatch>(int,float)ConcurrentHashMap(java.util.Map)ConcurrentHashMap<Method,ShadowMatch>(java.util.Map)ConcurrentHashMap(int)ConcurrentHashMap()ConcurrentHashMap<Method,ShadowMatch>()setTabAtsetTabAt(java.util.concurrent.ConcurrentHashMap.Node[],int,java.util.concurrent.ConcurrentHashMap.Node)casTabAtcasTabAt(java.util.concurrent.ConcurrentHashMap.Node[],int,java.util.concurrent.ConcurrentHashMap.Node,java.util.concurrent.ConcurrentHashMap.Node)tabAttabAt(java.util.concurrent.ConcurrentHashMap.Node[],int)spreadspread(int)volatileNCPUHASH_BITSRESERVEDTREEBINMOVEDMAX_ARRAY_SIZE32HashSet<PointcutPrimitive>AbstractSet<PointcutPrimitive>AbstractCollection<PointcutPrimitive>HashSet<PointcutPrimitive>()Spliterator<PointcutPrimitive>? super PointcutPrimitiveConsumer<? super PointcutPrimitive>Iterator<PointcutPrimitive>Stream<PointcutPrimitive>BaseStream<PointcutPrimitive,Stream<PointcutPrimitive>>Predicate<? super PointcutPrimitive>? extends PointcutPrimitiveCollection<? extends PointcutPrimitive>Iterable<? extends PointcutPrimitive>add(org.aspectj.weaver.tools.PointcutPrimitive)AbstractCollection<PointcutPrimitive>()AbstractSet<PointcutPrimitive>()HashSet<PointcutPrimitive>(int,float,boolean)HashSet<PointcutPrimitive>(int)HashSet<PointcutPrimitive>(int,float)HashSet<PointcutPrimitive>(java.util.Collection)Class<AspectJExpressionPointcut>declarationScopeparamNamesparamTypes"Number of pointcut parameter names must match number of pointcut parameter types"Number of pointcut parameter names must match number of pointcut parameter typesnamestypes"Must set property 'expression' before attempting to match"Must set property 'expression' before attempting to matchclassLoaderparserpointcutParameters"No expression set"No expression setpcExpr" and " and " && " && " or " or " || " || " not " not " ! " ! fallbackExpression"PointcutExpression matching rejected target class - trying fallback expression"PointcutExpression matching rejected target class - trying fallback expression"PointcutExpression matching rejected target class"PointcutExpression matching rejected target classshadowMatchwalkertargetObjectthisObject"Could not access current invocation - matching with limited context: "Could not access current invocation - matching with limited context: joinPointMatchoriginalMethodResidueTestClass<? extends Object>"Failed to evaluate join point for arguments "Failed to evaluate join point for arguments " - falling back to non-match" - falling back to non-match"Failed to create fallback PointcutExpression"Failed to create fallback PointcutExpressiontargetMethodSet<Class<?>>Collection<Class<?>>Iterable<Class<?>>ifcsSpliterator<Class<?>>? super Class<?>Consumer<? super Class<?>>Iterator<Class<?>>Stream<Class<?>>BaseStream<Class<?>,Stream<Class<?>>>Predicate<? super Class<?>>? extends Class<?>Collection<? extends Class<?>>Iterable<? extends Class<?>>add(java.lang.Class)compositeInterfaceoriginalMethodmethodToMatchex2"PointcutExpression matching rejected target method"PointcutExpression matching rejected target methodotherPc31"AspectJExpressionPointcut: ("AspectJExpressionPointcut: (", ", ") ") "<pointcut expression not set>"<pointcut expression not set>oisBEAN_DESIGNATOR_NAMEC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut$BeanPointcutDesignatorHandler.classAspectJExpressionPointcut$BeanPointcutDesignatorHandlerBeanPointcutDesignatorHandlerBeanPointcutDesignatorHandler()"bean"matchesBeanmatchesBean(java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut$BeanContextMatcher.classAspectJExpressionPointcut$BeanContextMatchercontextMatchcontextMatch(java.lang.Class)expressionPattern"rawtypes"rawtypessomeClassadvisedBeanNameisFactoryFactoryBean<>Class<FactoryBean<>>Map<String,FactoryBean<>>FactoryBean[]FactoryBean<>[]Constructor<FactoryBean<>>? super FactoryBean<>Class<? super FactoryBean<>>TypeVariable<Class<FactoryBean<>>>TypeVariable<Class<FactoryBean<>>>[]Predicate<String>test(java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcut$DefensiveShadowMatch.classAspectJExpressionPointcut$DefensiveShadowMatchaMatchContextSpring {@link org.springframework.aop.Pointcut} implementationthat uses the AspectJ weaver to evaluate a pointcut expression.<p>The pointcut expression value is an AspectJ expression. This canreference other pointcuts and use composition and other operations.<p>Naturally, as this is to be processed by Spring AOP's proxy-based model,only method execution pointcuts are supported.Dave SyerCreate a new default AspectJExpressionPointcut.Create a new AspectJExpressionPointcut with the given settings.the declaration scope for the pointcutthe parameter names for the pointcutthe parameter types for the pointcutSet the declaration scope for the pointcut.Set the parameter names for the pointcut.Set the parameter types for the pointcut.Check whether this pointcut is ready to match,lazily building the underlying AspectJ pointcut expression.Determine the ClassLoader to use for pointcut evaluation.Build the underlying AspectJ pointcut expression.Initialize the underlying AspectJ pointcut parser.If a pointcut expression has been specified in XML, the user cannotwrite {@code and} as "&&" (though &amp;&amp; will work).We also allow {@code and} between two pointcut sub-expressions.<p>This method converts back to {@code &&} for the AspectJ pointcut parser.Return the underlying AspectJ pointcut expression. Actually this is still a "maybe" - treat the pointcut as dynamic if we don't know enough yet Special handling for this, target, @this, @target, @annotation in Spring - we can optimize since we know we have exactly this class, and there will never be matching subclass at runtime. the maybe case A match test returned maybe - if there are any subtype sensitive variables involved in the test (this, target, at_this, at_target, at_annotation) then we say this is not a match as in Spring there will never be a different runtime subtype. Bind Spring AOP proxy to AspectJ "this" and Spring AOP target to AspectJ target, consistent with return of MethodInvocationProceedingJoinPoint No current invocation...Do a final check to see if any this(TYPE) kind of residue match. Forthis purpose, we use the original method's (proxy method's) shadow toensure that 'this' is correctly checked against. Without this check,we get incorrect match on this(TYPE) where TYPE matches the targettype but not 'this' (as would be the case of JDK dynamic proxies).<p>See SPR-2979 for the original bug. there is a current invocationGet a new pointcut expression based on a target class's loader rather than the default. Note: Can't use JoinPointMatch.getClass().getName() as the key, since Spring AOP does all the matching at a join point, and then all the invocations under this scenario, if we just use JoinPointMatch as the key, then Try to build the most specific interface possible for inherited methods to be considered for sub-interface matches as well, in particular for proxy classes. Note: AspectJ is only going to take Method.getDeclaringClass() into account. Implemented interfaces probably expose conflicting method signatures... Proceed with original target method. Avoid lock contention for known Methods through concurrent access... Not found - now check again with full lock... Failed to introspect target method, probably because it has been loaded in a special ClassLoader. Let's try the declaring ClassLoader instead... Fall back to the plain original method in case of no resolvable match or a negative match on a proxy class (which doesn't carry any annotations on its redeclared methods). Could neither introspect the target class nor the proxy class -> let's try the original method's declaring class before we give up... Possibly AspectJ 1.8.10 encountering an invalid signature--------------------------------------------------------------------- Serialization support Rely on default serialization, just initialize state after deserialization. Initialize transient fields. pointcutExpression will be initialized lazily by checkReadyToMatch()Handler for the Spring-specific {@code bean()} pointcut designatorextension to AspectJ.<p>This handler must be added to each pointcut object that needs tohandle the {@code bean()} PCD. Matching context is obtainedautomatically by examining a thread local variable and therefore a matchingcontext need not be set on the pointcut.Matcher class for the BeanNamePointcutDesignatorHandler.<p>Dynamic match tests for this matcher always return true,since the matching decision is made at the proxy creation time.For static match tests, this matcher abstains to allow the overallpointcut to match even when negation is used with the bean() pointcut. no proxy creation in progress abstain; can't return YES, since that will make pointcut with negation failC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcutAdvisor.javaAspectJExpressionPointcutAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJExpressionPointcutAdvisor.classlocationSpring AOP Advisor that can be used for any AspectJ pointcut expression.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJMethodBeforeAdvice.javaAspectJMethodBeforeAdviceSpring AOP advice that wraps an AspectJ before method.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJPointcutAdvisor.javaAspectJPointcutAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJPointcutAdvisor.class"Advice must not be null"Advice must not be nullotherAdvisorClass<AspectJPointcutAdvisor>29AspectJPointcutAdvisor that adapts an {@link AbstractAspectJAdvice}to the {@link org.springframework.aop.PointcutAdvisor} interface.Create a new AspectJPointcutAdvisor for the given advice.the AbstractAspectJAdvice to wrapReturn the name of the aspect (bean) in which the advice was declared.4.3.15AbstractAspectJAdvice#getAspectName()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJPrecedenceInformation.javaAspectJPrecedenceInformationInterface to be implemented by types that can supply the informationneeded to sort advice/advisors by AspectJ's precedence rules.org.springframework.aop.aspectj.autoproxy.AspectJPrecedenceComparator Implementation note: We need the level of indirection this interface provides as otherwise the AspectJPrecedenceComparator must ask an Advisor for its Advice in all cases in order to sort advisors. This causes problems with the InstantiationModelAwarePointcutAdvisor which needs to delay creating its advice for aspects with non-singleton instantiation models.Return the declaration order of the advice member within the aspect.Return whether this is a before advice.Return whether this is an after advice.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJProxyUtils.javaAspectJProxyUtilsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJProxyUtils.classisAspectJAdviceisAspectJAdvice(org.springframework.aop.Advisor)List<Advisor>Collection<Advisor>Iterable<Advisor>advisors? extends AdvisorCollection<? extends Advisor>Iterable<? extends Advisor>add(org.springframework.aop.Advisor)ListIterator<Advisor>add(int,org.springframework.aop.Advisor)set(int,org.springframework.aop.Advisor)UnaryOperator<Advisor>Function<Advisor,Advisor>foundAspectJAdviceUtility methods for working with AspectJ proxies.Add special advisors if necessary to work with a proxy chain that contains AspectJ advisors:concretely, {@link ExposeInvocationInterceptor} at the beginning of the list.<p>This will expose the current Spring AOP invocation (necessary for some AspectJ pointcutmatching) and make available the current AspectJ JoinPoint. The call will have no effectif there are no AspectJ advisors in the advisor chain.the advisors available{@code true} if an {@link ExposeInvocationInterceptor} was added to the list,otherwise {@code false} Don't add advisors to an empty list; may indicate that proxying is just not required Be careful not to get the Advice without a guard, as this might eagerly instantiate a non-singleton AspectJ aspect...Determine whether the given Advisor contains an AspectJ advice.the Advisor to checkC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJWeaverMessageHandler.javaAspectJWeaverMessageHandlermakeMessageFormakeMessageFor(org.aspectj.bridge.IMessage)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/AspectJWeaverMessageHandler.classAJ_ID"[AspectJ] "[AspectJ] "AspectJ Weaver"AspectJ WeavermessageKindaMessagekindCopyright 2002-2013 the original author or authors.Implementation of AspectJ's {@link IMessageHandler} interface thatroutes AspectJ weaving messages through the same logging system as theregular Spring messages.<p>Pass the option...<p><code class="code">-XmessageHandlerClass:org.springframework.aop.aspectj.AspectJWeaverMessageHandler</code><p>to the weaver; for example, specifying the following in a"{@code META-INF/aop.xml} file:<p><code class="code">&lt;weaver options="..."/&gt;</code> We want to see everything, and allow configuration of log levels dynamically. We weren't ignoring anything anyway...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/DeclareParentsAdvisor.javaDeclareParentsAdvisorDeclareParentsAdvisor(java.lang.Class,java.lang.String,org.springframework.aop.IntroductionInterceptor)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/DeclareParentsAdvisor.classtypePatternClassFilterintroducedInterfaceinterfaceTypetypePatterndefaultImpldelegateRefinterceptortypePatternFilterexclusionmatches(java.lang.Class)Introduction advisor delegating to the given object.Implements AspectJ annotation-style behavior for the DeclareParents annotation.Create a new advisor for this DeclareParents field.static field defining the introductiontype pattern the introduction is restricted tothe default implementation classthe delegate implementation objectPrivate constructor to share common code between impl-based delegate and reference-based delegate(cannot use method such as init() to share common code, due the use of final fields).the delegation advice as {@link IntroductionInterceptor} Excludes methods implemented. Do nothingC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/InstantiationModelAwarePointcutAdvisor.javaInstantiationModelAwarePointcutAdvisorCopyright 2002-2006 the original author or authors.Interface to be implemented by Spring AOP Advisors wrapping AspectJaspects that may have a lazy initialization strategy. For example,a perThis instantiation model would mean lazy initialization of the advice.Return whether this advisor is lazily initializing its underlying advice.Return whether this advisor has already instantiated its advice.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint.javaMethodInvocationProceedingJoinPointsourceLocationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint.classsignaturemethodInvocationparameterNameDiscoverer"MethodInvocation must not be null"MethodInvocation must not be nullaroundClosure"Argument array passed to proceed cannot be null"Argument array passed to proceed cannot be null"Expecting "Expecting " arguments to proceed, " +
					"but was passed " arguments to proceed, but was passed " arguments" arguments"execution("execution(appendTypeappendType(java.lang.StringBuilder,java.lang.Class,boolean)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint$MethodSignatureImpl.classMethodInvocationProceedingJoinPoint$MethodSignatureImplappendTypesappendTypes(java.lang.StringBuilder,java.lang.Class[],boolean,boolean)toString(boolean,boolean,boolean,boolean)parameterNamesMethodSignatureImplMethodSignatureImpl()includeModifierincludeReturnTypeAndArgsuseLongReturnAndArgumentTypeNameuseLongTypeNameparametersTypes".".includeArgs"..".."[]"[]SourceLocationImplSourceLocationImpl()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint$SourceLocationImpl.classMethodInvocationProceedingJoinPoint$SourceLocationImpl"No source location joinpoint available: target is null"No source location joinpoint available: target is nullAn implementation of the AspectJ {@link ProceedingJoinPoint} interfacewrapping an AOP Alliance {@link org.aopalliance.intercept.MethodInvocation}.<p><b>Note</b>: The {@code getThis()} method returns the current Spring AOP proxy.The {@code getTarget()} method returns the current Spring AOP target (which may be{@code null} if there is no target instance) as a plain POJO without any advice.<b>If you want to call the object and have the advice take effect, use {@code getThis()}.</b>A common example is casting the object to an introduced interface in the implementation ofan introduction. There is no such distinction between target and proxy in AspectJ itself.Lazily initialized signature object.Lazily initialized source location object.Create a new MethodInvocationProceedingJoinPoint, wrapping the givenSpring ProxyMethodInvocation object.the Spring ProxyMethodInvocation objectReturns the Spring AOP proxy. Cannot be {@code null}.Returns the Spring AOP target. May be {@code null} if there is no target. TODO: It's just an adapter but returning 0 might still have side effects...Lazily initialized MethodSignature.Lazily initialized SourceLocation.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/RuntimeTestWalker.javaRuntimeTestWalkerruntimeTestC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/RuntimeTestWalker.classmyClassFieldvarTypeFieldresidualTestFieldClass<ShadowMatchImpl>Map<String,ShadowMatchImpl>ShadowMatchImpl[]Constructor<ShadowMatchImpl>? super ShadowMatchImplClass<? super ShadowMatchImpl>TypeVariable<Class<ShadowMatchImpl>>TypeVariable<Class<ShadowMatchImpl>>[]"residualTest"residualTestClass<ReflectionVar>Map<String,ReflectionVar>ReflectionVar[]Constructor<ReflectionVar>? super ReflectionVarClass<? super ReflectionVar>TypeVariable<Class<ReflectionVar>>TypeVariable<Class<ReflectionVar>>[]"varType"varTypeClass<ReflectionBasedReferenceTypeDelegate>Map<String,ReflectionBasedReferenceTypeDelegate>ReflectionBasedReferenceTypeDelegate[]Constructor<ReflectionBasedReferenceTypeDelegate>? super ReflectionBasedReferenceTypeDelegateClass<? super ReflectionBasedReferenceTypeDelegate>TypeVariable<Class<ReflectionBasedReferenceTypeDelegate>>TypeVariable<Class<ReflectionBasedReferenceTypeDelegate>>[]"myClass"myClass"The version of aspectjtools.jar / aspectjweaver.jar " +
					"on the classpath is incompatible with this version of Spring: "The version of aspectjtools.jar / aspectjweaver.jar on the classpath is incompatible with this version of Spring: thisClassTestVisitorAdapterTestVisitorAdapter()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/RuntimeTestWalker$TestVisitorAdapter.classRuntimeTestWalker$TestVisitorAdaptereliteralfieldGetCallhasAnnotationmatchingContextTestvmatchVarTypeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/RuntimeTestWalker$InstanceOfResidueTestVisitor.classRuntimeTestWalker$InstanceOfResidueTestVisitormatchClassdefaultMatchestypeClasstestsSubtypeSensitiveVarsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/RuntimeTestWalker$SubtypeSensitiveVarTypeTestVisitor.classRuntimeTestWalker$SubtypeSensitiveVarTypeTestVisitorargsObjstargetObjthisObjSubtypeSensitiveVarTypeTestVisitorSubtypeSensitiveVarTypeTestVisitor()aTestvarUnderTesthasAnnThis class encapsulates some AspectJ internal knowledge that should bepushed back into the AspectJ project in a future release.<p>It relies on implementation specific knowledge in AspectJ to breakencapsulation and do something AspectJ was not designed to do: querythe types of runtime tests that will be performed. The code here shouldmigrate to {@code ShadowMatch.getVariablesInvolvedInRuntimeTest()}or some similar operation.<p>See <a href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=151593">Bug 151593</a>If the test uses any of the this, target, at_this, at_target, and at_annotation vars,then it tests subtype sensitive vars. Don't use ResolvedType.isAssignableFrom() as it won't be aware of (Spring) mixinsCheck if residue of target(TYPE) kind. See SPR-3783 for more details.Check if residue of this(TYPE) kind. See SPR-2979 for more details. TODO: Optimization: Process only if this() specifies a type and not an identifier. If you thought things were bad before, now we sink to new levels of horror...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/SimpleAspectInstanceFactory.javaSimpleAspectInstanceFactoryaspectClassC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/SimpleAspectInstanceFactory.class"Aspect class must not be null"Aspect class must not be nullnewInstance(java.lang.Object[])getAnnotatedReceiverTypegetAnnotatedReceiverType()getAnnotatedReturnTypegetAnnotatedReturnType()handleParameterNumberMismatchhandleParameterNumberMismatch(int,int)Annotation[][]getParameterAnnotationsgetParameterAnnotations()getRawParameterAnnotationsgetRawParameterAnnotations()getSignaturegetSignature()getSlotgetSlot()setConstructorAccessorsetConstructorAccessor(jdk.internal.reflect.ConstructorAccessor)getConstructorAccessorgetConstructorAccessor()isVarArgsisVarArgs()newInstanceWithCallernewInstanceWithCaller(java.lang.Object[],boolean,java.lang.Class)specificToGenericStringHeaderspecificToGenericStringHeader(java.lang.StringBuilder)toShortStringtoShortString()specificToStringHeaderspecificToStringHeader(java.lang.StringBuilder)getGenericExceptionTypesgetGenericExceptionTypes()getExceptionTypesgetExceptionTypes()getGenericParameterTypesgetGenericParameterTypes()getParameterCountgetParameterCount()getParameterTypesgetParameterTypes()getSharedExceptionTypesgetSharedExceptionTypes()getSharedParameterTypesgetSharedParameterTypes()TypeVariable<Constructor>TypeVariable<Constructor>[]TypeVariable<Constructor<?>>TypeVariable<Constructor<?>>[]getAnnotationBytesgetAnnotationBytes()hasGenericInformationhasGenericInformation()checkCanSetAccessiblecheckCanSetAccessible(java.lang.Class)setAccessiblesetAccessible(boolean)copycopy()Constructor(java.lang.Class,java.lang.Class[],java.lang.Class[],int,int,java.lang.String,byte[],byte[])Constructor<?>(java.lang.Class,java.lang.Class[],java.lang.Class[],int,int,java.lang.String,byte[],byte[])getRootgetRoot()getGenericInfogetGenericInfo()"No default constructor on aspect class: "No default constructor on aspect class: "Unable to instantiate aspect class: "Unable to instantiate aspect class: "Could not access aspect constructor: "Could not access aspect constructor: "Failed to invoke aspect constructor: "Failed to invoke aspect constructor: Implementation of {@link AspectInstanceFactory} that creates a new instanceof the specified aspect class for every {@link #getAspectInstance()} call.2.0.4Create a new SimpleAspectInstanceFactory for the given aspect class.the aspect classReturn the specified aspect class (never {@code null}).Determine the order for this factory's aspect instance,either an instance-specific order expressed through implementingthe {@link org.springframework.core.Ordered} interface,or a fallback order.org.springframework.core.Ordered#getOrderForAspectClassDetermine a fallback order for the case that the aspect instancedoes not express an instance-specific order through implementingthe {@link org.springframework.core.Ordered} interface.<p>The default implementation simply returns {@code Ordered.LOWEST_PRECEDENCE}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/SingletonAspectInstanceFactory.javaSingletonAspectInstanceFactoryaspectInstanceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/SingletonAspectInstanceFactory.class"Aspect instance must not be null"Aspect instance must not be nullMap<String,? extends Object>? extends Object[]Constructor<? extends Object>? super ? extends ObjectClass<? super ? extends Object>TypeVariable<Class<? extends Object>>TypeVariable<Class<? extends Object>>[]Implementation of {@link AspectInstanceFactory} that is backed by aspecified singleton object, returning the same instance for every{@link #getAspectInstance()} call.Create a new SingletonAspectInstanceFactory for the given aspect instance.the singleton aspect instanceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/TypePatternClassFilter.javaTypePatternClassFilterC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/TypePatternClassFilter.classaspectJTypePatternMatcher"Type pattern must not be null"Type pattern must not be null"No type pattern has been set"No type pattern has been set? extends TypePatternClassFilterClass<? extends TypePatternClassFilter>Map<String,? extends TypePatternClassFilter>TypePatternClassFilter[]? extends TypePatternClassFilter[]Constructor<? extends TypePatternClassFilter>? super ? extends TypePatternClassFilterClass<? super ? extends TypePatternClassFilter>TypeVariable<Class<? extends TypePatternClassFilter>>TypeVariable<Class<? extends TypePatternClassFilter>>[]Spring AOP {@link ClassFilter} implementation using AspectJ type matching.Creates a new instance of the {@link TypePatternClassFilter} class.<p>This is the JavaBean constructor; be sure to set the{@link #setTypePattern(String) typePattern} property, else ano doubt fatal {@link IllegalStateException} will be thrownwhen the {@link #matches(Class)} method is first invoked.Create a fully configured {@link TypePatternClassFilter} using thegiven type pattern.the type pattern that AspectJ weaver should parseSet the AspectJ type pattern to match.<p>Examples include:<code class="code">org.springframework.beans.*</code>This will match any class or interface in the given package.org.springframework.beans.ITestBean+This will match the {@code ITestBean} interface and any classthat implements it.<p>These conventions are established by AspectJ, not Spring AOP.Return the AspectJ type pattern to match.candidate target classwhether the advice should apply to this candidate target classIllegalStateExceptionif no {@link #setTypePattern(String)} has been setIf a type pattern has been specified in XML, the user cannotWe also allow {@code and} between two sub-expressions.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactory.javaAbstractAspectJAdvisorFactoryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotationorg.springframework.aop.aspectj.annotationAspectJAnnotation<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactory$AspectJAnnotation.classAbstractAspectJAdvisorFactory$AspectJAnnotationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactory.classAspectJAnnotation<A>findAnnotationfindAnnotation(java.lang.reflect.Method,java.lang.Class)compiledByAjccompiledByAjc(java.lang.Class)hasAspectAnnotationhasAspectAnnotation(java.lang.Class)ASPECTJ_ANNOTATION_CLASSESAJC_MAGIC? extends AbstractAspectJAdvisorFactoryClass<? extends AbstractAspectJAdvisorFactory>"ajc$"ajc$Class<Pointcut>Class<Around>Class<Before>Class<After>Class<AfterReturning>Class<AfterThrowing>Class<Aspect>fieldorg.aspectj.lang.reflectAjType<?>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.6/ee3b73aa16df35179255f17354d9dfd8e7822835/aspectjweaver-1.9.6.jaraspectjweaver-1.9.6C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.6/ee3b73aa16df35179255f17354d9dfd8e7822835ee3b73aa16df35179255f17354d9dfd8e7822835C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.61.9.6C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaveraspectjweaverC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectjorg.aspectjC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.6/ee3b73aa16df35179255f17354d9dfd8e7822835/aspectjweaver-1.9.6.jar/orgC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.6/ee3b73aa16df35179255f17354d9dfd8e7822835/aspectjweaver-1.9.6.jar/org/aspectjC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.6/ee3b73aa16df35179255f17354d9dfd8e7822835/aspectjweaver-1.9.6.jar/org/aspectj/langC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.6/ee3b73aa16df35179255f17354d9dfd8e7822835/aspectjweaver-1.9.6.jar/org/aspectj/lang/reflectC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.aspectj/aspectjweaver/1.9.6/ee3b73aa16df35179255f17354d9dfd8e7822835/aspectjweaver-1.9.6.jar/org/aspectj/lang/reflect/AjType.classAjTypeajTypeAjType<>Map<String,? super ?>? super ?[]Constructor<? super ?>? super ? super ?Class<? super ? super ?>TypeVariable<Class<? super ?>>TypeVariable<Class<? super ?>>[]"["["] cannot extend concrete aspect ["] cannot extend concrete aspect [isAspectisAspect()isPrivilegedisPrivileged()isMemberAspectisMemberAspect()TypeVariable<Class<T>>TypeVariable<Class<T>>[]DeclarePrecedence[]getDeclarePrecedencegetDeclarePrecedence()DeclareAnnotation[]getDeclareAnnotationsgetDeclareAnnotations()DeclareSoft[]getDeclareSoftsgetDeclareSofts()DeclareParents[]getDeclareParentsgetDeclareParents()DeclareErrorOrWarning[]getDeclareErrorOrWarningsgetDeclareErrorOrWarnings()InterTypeFieldDeclaration[]getITDFieldsgetITDFields()getITDFieldgetITDField(java.lang.String,org.aspectj.lang.reflect.AjType)getDeclaredITDFieldsgetDeclaredITDFields()getDeclaredITDFieldgetDeclaredITDField(java.lang.String,org.aspectj.lang.reflect.AjType)InterTypeConstructorDeclaration[]getITDConstructorsgetITDConstructors()AjType[]AjType<?>[]getITDConstructorgetITDConstructor(org.aspectj.lang.reflect.AjType,org.aspectj.lang.reflect.AjType[])getDeclaredITDConstructorsgetDeclaredITDConstructors()getDeclaredITDConstructorgetDeclaredITDConstructor(org.aspectj.lang.reflect.AjType,org.aspectj.lang.reflect.AjType[])InterTypeMethodDeclaration[]getITDMethodsgetITDMethods()getITDMethodgetITDMethod(java.lang.String,org.aspectj.lang.reflect.AjType,org.aspectj.lang.reflect.AjType[])getDeclaredITDMethodsgetDeclaredITDMethods()getDeclaredITDMethodgetDeclaredITDMethod(java.lang.String,org.aspectj.lang.reflect.AjType,org.aspectj.lang.reflect.AjType[])getDeclaredAdvicegetDeclaredAdvice(java.lang.String)getAdvicegetAdvice(java.lang.String)AdviceKind[]Advice[]getAdvice(org.aspectj.lang.reflect.AdviceKind[])getDeclaredAdvice(org.aspectj.lang.reflect.AdviceKind[])Pointcut[]getPointcutsgetPointcuts()getDeclaredPointcutsgetDeclaredPointcuts()getPointcutgetPointcut(java.lang.String)getDeclaredPointcutgetDeclaredPointcut(java.lang.String)getMethod(java.lang.String,org.aspectj.lang.reflect.AjType[])getDeclaredMethod(java.lang.String,org.aspectj.lang.reflect.AjType[])getDeclaredConstructor(org.aspectj.lang.reflect.AjType[])getConstructor(org.aspectj.lang.reflect.AjType[])AjType<>[]getDeclaredAjTypesgetDeclaredAjTypes()getAjTypesgetAjTypes()getPerClausegetPerClause()getDeclaringTypegetDeclaringType()getEnclosingTypegetEnclosingType()getGenericSupertypegetGenericSupertype()getSupertypegetSupertype()getJavaClassgetJavaClass()" uses percflow instantiation model: " +
					"This is not supported in Spring AOP." uses percflow instantiation model: This is not supported in Spring AOP." uses percflowbelow instantiation model: " +
					"This is not supported in Spring AOP." uses percflowbelow instantiation model: This is not supported in Spring AOP."unchecked"uncheckedAspectJAnnotation<?>foundAnnotationAspectJAnnotation<Annotation>toLookForAspectJAnnotation<A>(java.lang.annotation.Annotation)getArgumentNamesgetArgumentNames()getPointcutExpressiongetPointcutExpression()getAnnotation()AspectJAnnotationAspectJAnnotation(java.lang.annotation.Annotation)AspectJAnnotationTypeAspectJAnnotationType()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactory$AspectJAnnotationType.classAbstractAspectJAdvisorFactory$AspectJAnnotationTyperesolveExpression(java.lang.annotation.Annotation)determineAnnotationTypedetermineAnnotationType(java.lang.annotation.Annotation)annotationTypeMap<Class<?>,AspectJAnnotationType>annotationTypeMapEXPRESSION_ATTRIBUTES"pointcut""value"HashMap<Class<?>,AspectJAnnotationType>AbstractMap<Class<?>,AspectJAnnotationType>HashMap<Class<?>,AspectJAnnotationType>(int)? super AspectJAnnotationType? extends AspectJAnnotationTypeBiFunction<? super AspectJAnnotationType,? super AspectJAnnotationType,? extends AspectJAnnotationType>merge(java.lang.Class,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType,java.util.function.BiFunction)BiFunction<? super Class<?>,? super AspectJAnnotationType,? extends AspectJAnnotationType>compute(java.lang.Class,java.util.function.BiFunction)computeIfPresent(java.lang.Class,java.util.function.BiFunction)Function<? super Class<?>,? extends AspectJAnnotationType>computeIfAbsent(java.lang.Class,java.util.function.Function)replace(java.lang.Class,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType)replace(java.lang.Class,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType)putIfAbsent(java.lang.Class,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType)BiConsumer<? super Class<?>,? super AspectJAnnotationType>getOrDefault(java.lang.Object,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType)Entry<Class<?>,AspectJAnnotationType>Set<Entry<Class<?>,AspectJAnnotationType>>Collection<Entry<Class<?>,AspectJAnnotationType>>Iterable<Entry<Class<?>,AspectJAnnotationType>>Collection<AspectJAnnotationType>Iterable<AspectJAnnotationType>Map<? extends Class<?>,? extends AspectJAnnotationType>put(java.lang.Class,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType)AbstractMap<Class<?>,AspectJAnnotationType>()Node<Class<?>,AspectJAnnotationType>TreeNode<Class<?>,AspectJAnnotationType>newTreeNode(int,java.lang.Class,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType,java.util.HashMap.Node)newNode(int,java.lang.Class,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType,java.util.HashMap.Node)Node<Class<?>,AspectJAnnotationType>[]putVal(int,java.lang.Class,org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory.AspectJAnnotationType,boolean,boolean)HashMap<Class<?>,AspectJAnnotationType>(java.util.Map)HashMap<Class<?>,AspectJAnnotationType>()HashMap<Class<?>,AspectJAnnotationType>(int,float)"argNames"" is not a valid AspectJ annotation" is not a valid AspectJ annotation"Unknown annotation type: "Unknown annotation type: attributeNamevalstr"Failed to resolve expression: "Failed to resolve expression: AspectJAnnotationParameterNameDiscovererAspectJAnnotationParameterNameDiscoverer()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactory$AspectJAnnotationParameterNameDiscoverer.classAbstractAspectJAdvisorFactory$AspectJAnnotationParameterNameDiscoverernameTokensAspectJAnnotation<?>(java.lang.annotation.Annotation)"Spring AOP cannot handle constructor advice"Spring AOP cannot handle constructor adviceAbstract base class for factories that can create Spring AOP Advisorsgiven AspectJ classes from classes honoring the AspectJ 5 annotation syntax.<p>This class handles annotation parsing and validation functionality.It does not actually generate Spring AOP Advisors, which is deferred to subclasses.Logger available to subclasses.We consider something to be an AspectJ aspect suitable for use by the Spring AOP systemif it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter testis that aspects written in the code-style (AspectJ language) also have the annotation presentwhen compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.We need to detect this as "code-style" AspectJ aspects should not beinterpreted by Spring AOP. The AJTypeSystem goes to great lengths to provide a uniform appearance between code-style and annotation-style aspects. Therefore there is no 'clean' way to tell them apart. Here we rely on an implementation detail of the AspectJ compiler. If the parent has the annotation and isn't abstract it's an errorFind and return the first AspectJ annotation on the given method(there <i>should</i> only be one anyway...).Enum for AspectJ annotation types.AspectJAnnotation#getAnnotationType()Class modelling an AspectJ annotation, exposing its type enumeration andpointcut String.<A>the annotation typeParameterNameDiscoverer implementation that analyzes the arg namesspecified at the AspectJ annotation level.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AnnotationAwareAspectJAutoProxyCreator.javaAnnotationAwareAspectJAutoProxyCreatoraspectJAdvisorsBuilderC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AnnotationAwareAspectJAutoProxyCreator.classaspectJAdvisorFactoryList<Pattern>Collection<Pattern>Iterable<Pattern>includePatternspatternsArrayList<Pattern>AbstractList<Pattern>AbstractCollection<Pattern>ArrayList<Pattern>(int)Spliterator<Pattern>? super PatternConsumer<? super Pattern>Iterator<Pattern>Stream<Pattern>BaseStream<Pattern,Stream<Pattern>>Predicate<? super Pattern>? extends PatternCollection<? extends Pattern>Iterable<? extends Pattern>add(java.util.regex.Pattern)AbstractCollection<Pattern>()ListIterator<Pattern>add(int,java.util.regex.Pattern)set(int,java.util.regex.Pattern)Comparator<? super Pattern>UnaryOperator<Pattern>Function<Pattern,Pattern>AbstractList<Pattern>()ArrayList<Pattern>(java.util.Collection)ArrayList<Pattern>()patternText"AspectJAdvisorFactory must not be null"AspectJAdvisorFactory must not be nullbeanClassbeanNamepatternadvisorFactory{@link AspectJAwareAdvisorAutoProxyCreator} subclass that processes all AspectJannotation aspects in the current application context, as well as Spring Advisors.<p>Any AspectJ annotated classes will automatically be recognized, and theiradvice applied if Spring AOP's proxy-based model is capable of applying it.This covers method execution joinpoints.<p>If the &lt;aop:include&gt; element is used, only @AspectJ beans with names matched byan include pattern will be considered as defining aspects to use for Spring auto-proxying.<p>Processing of Spring Advisors follows the rules established in{@link org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator}.org.springframework.aop.aspectj.annotation.AspectJAdvisorFactorySet a list of regex patterns, matching eligible @AspectJ bean names.<p>Default is to consider all @AspectJ beans as eligible. Add all the Spring advisors found according to superclass rules. Build Advisors for all AspectJ aspects in the bean factory. Previously we setProxyTargetClass(true) in the constructor, but that has too broad an impact. Instead we now override isInfrastructureClass to avoid proxying aspects. I'm not entirely happy with that as there is no good reason not to advise aspects, except that it causes advice invocation to go through a proxy, and if the aspect implements e.g the Ordered interface it will be proxied by that interface and fail at runtime as the advice method is not defined on the interface. We could potentially relax the restriction about not advising aspects in the future.Check whether the given aspect bean is eligible for auto-proxying.<p>If no &lt;aop:include&gt; elements were used then "includePatterns" will be{@code null} and all beans are included. If "includePatterns" is non-null,then one of the patterns must match.Subclass of BeanFactoryAspectJAdvisorsBuilderAdapter that delegates tosurrounding AnnotationAwareAspectJAutoProxyCreator facilities.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AspectJAdvisorFactory.javaAspectJAdvisorFactorycandidateAdviceMethodexpressionPointcutInterface for factories that can create Spring AOP Advisors from classesannotated with AspectJ annotation syntax.AspectMetadataorg.aspectj.lang.reflect.AjTypeSystemDetermine whether or not the given class is an aspect, as reportedby AspectJ's {@link org.aspectj.lang.reflect.AjTypeSystem}.<p>Will simply return {@code false} if the supposed aspect isinvalid (such as an extension of a concrete aspect class).Will return true for some aspects that Spring AOP cannot process,such as those with unsupported instantiation models.Use the {@link #validate} method to handle these cases if necessary.the supposed annotation-style AspectJ classwhether or not this class is recognized by AspectJ as an aspect classIs the given class a valid AspectJ aspect class?the supposed AspectJ annotation-style class to validateAopConfigExceptionif the class is an invalid aspect(which can never be legal)NotAnAtAspectExceptionif the class is not an aspect at all(which may or may not be legal, depending on the context)Build Spring AOP Advisors for all annotated At-AspectJ methodson the specified aspect instance.the aspect instance factory(not the aspect instance itself in order to avoid eager instantiation)a list of advisors for this classBuild a Spring AOP Advisor for the given AspectJ advice method.the candidate advice methodthe declaration order within the aspectthe name of the aspect{@code null} if the method is not an AspectJ advice methodor if it is a pointcut that will be used by other advice but will notcreate a Spring advice in its own rightBuild a Spring AOP Advice for the given AspectJ advice method.org.springframework.aop.aspectj.AspectJAroundAdviceorg.springframework.aop.aspectj.AspectJMethodBeforeAdviceorg.springframework.aop.aspectj.AspectJAfterAdviceorg.springframework.aop.aspectj.AspectJAfterReturningAdviceorg.springframework.aop.aspectj.AspectJAfterThrowingAdviceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.javaAspectJProxyFactorygetSingletonAspectInstancegetSingletonAspectInstance(java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.classcreateAspectInstanceFactorycreateAspectInstanceFactory(org.springframework.aop.aspectj.annotation.AspectMetadata,java.lang.Class,java.lang.String)createAspectMetadatacreateAspectMetadata(java.lang.Class,java.lang.String)addAdvisorsFromAspectInstanceFactoryaddAdvisorsFromAspectInstanceFactory(org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory)aspectFactoryMap<Class<?>,Object>aspectCacheConcurrentHashMap<Class<?>,Object>AbstractMap<Class<?>,Object>ConcurrentMap<Class<?>,Object>ConcurrentHashMap<Class<?>,Object>()BiFunction<? super Object,? super Object,? extends Object>merge(java.lang.Class,java.lang.Object,java.util.function.BiFunction)BiFunction<? super Class<?>,? super Object,? extends Object>Function<? super Class<?>,? extends Object>replace(java.lang.Class,java.lang.Object)replace(java.lang.Class,java.lang.Object,java.lang.Object)putIfAbsent(java.lang.Class,java.lang.Object)BiConsumer<? super Class<?>,? super Object>Entry<Class<?>,Object>Set<Entry<Class<?>,Object>>Collection<Entry<Class<?>,Object>>Iterable<Entry<Class<?>,Object>>Map<? extends Class<?>,? extends Object>put(java.lang.Class,java.lang.Object)AbstractMap<Class<?>,Object>()ToIntFunction<Entry<Class<?>,Object>>ToLongFunction<Entry<Class<?>,Object>>ToDoubleFunction<Entry<Class<?>,Object>>Function<Entry<Class<?>,Object>,? extends U>? extends Entry<Class<?>,Object>BiFunction<Entry<Class<?>,Object>,Entry<Class<?>,Object>,? extends Entry<Class<?>,Object>>? super Entry<Class<?>,Object>Consumer<? super Entry<Class<?>,Object>>ToIntFunction<? super Object>ToLongFunction<? super Object>ToDoubleFunction<? super Object>Function<? super Object,? extends U>Consumer<? super Object>ToIntFunction<? super Class<?>>ToLongFunction<? super Class<?>>ToDoubleFunction<? super Class<?>>Function<? super Class<?>,? extends U>BiFunction<? super Class<?>,? super Class<?>,? extends Class<?>>ToIntBiFunction<? super Class<?>,? super Object>ToLongBiFunction<? super Class<?>,? super Object>ToDoubleBiFunction<? super Class<?>,? super Object>BiFunction<? super Class<?>,? super Object,? extends U>Node<Class<?>,Object>Node<Class<?>,Object>[]KeySetView<Class<?>,Object>CollectionView<Class<?>,Object,Class<?>>Enumeration<Object>Enumeration<Class<?>>Predicate<? super Entry<Class<?>,Object>>putVal(java.lang.Class,java.lang.Object,boolean)ConcurrentHashMap<Class<?>,Object>(int,float,int)ConcurrentHashMap<Class<?>,Object>(int,float)ConcurrentHashMap<Class<?>,Object>(java.util.Map)ConcurrentHashMap<Class<?>,Object>(int)"Target object must not be null"Target object must not be nullinterfacesam"Aspect class ["Aspect class ["] does not define a singleton aspect"] does not define a singleton aspectinstanceFactory"Unresolvable target class"Unresolvable target class"Class ["Class ["] is not a valid aspect type"] is not a valid aspect typeinstanceFunction<Class<?>,Object>identityidentity()Function<T,V>andThenandThen(java.util.function.Function)? super RFunction<? super R,? extends V>Function<Class<?>,V>Function<? super Object,? extends V>Function<V,R>composecompose(java.util.function.Function)Function<? super V,? extends T>Function<V,Object>Function<? super V,? extends Class<?>>applyapply(java.lang.Object)apply(java.lang.Class)AspectJ-based proxy factory, allowing for programmatic buildingof proxies which include AspectJ aspects (code style as wellJava 5 annotation style).#addAspect(Object)#addAspect(Class)#getProxy()#getProxy(ClassLoader)org.springframework.aop.framework.ProxyFactoryCache for singleton aspect instances.Create a new AspectJProxyFactory.<p>Will proxy all interfaces that the given target implements.the target object to be proxiedCreate a new {@code AspectJProxyFactory}.No target, only interfaces. Must add interceptors.Add the supplied aspect instance to the chain. The type of the aspect instancesupplied must be a singleton aspect. True singleton lifecycle is not honoured whenusing this method - the caller is responsible for managing the lifecycle of anyaspects added in this way.the AspectJ aspect instanceAdd an aspect of the supplied type to the end of the advice chain.the AspectJ aspect classAdd all {@link Advisor Advisors} from the supplied {@link MetadataAwareAspectInstanceFactory}to the current chain. Exposes any special purpose {@link Advisor Advisors} if needed.AspectJProxyUtils#makeAdvisorChainAspectJCapableIfNecessary(List)Create an {@link AspectMetadata} instance for the supplied aspect type.Create a {@link MetadataAwareAspectInstanceFactory} for the supplied aspect type. If the aspect typehas no per clause, then a {@link SingletonMetadataAwareAspectInstanceFactory} is returned, otherwisea {@link PrototypeAspectInstanceFactory} is returned. Create a shared aspect instance. Create a factory for independent aspect instances.Get the singleton aspect instance for the supplied aspect type.An instance is created if one cannot be found in the instance cache.Create a new proxy according to the settings in this factory.<p>Can be called repeatedly. Effect will vary if we've addedor removed interfaces. Can add and remove interceptors.<p>Uses a default class loader: Usually, the thread context class loader(if necessary for proxy creation).the new proxy<p>Uses the given class loader (if necessary for proxy creation).the class loader to create the proxy withC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AspectMetadata.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AspectMetadata.classfindPerClausefindPerClause(java.lang.Class)perClausePointcutcurrClassajTypeToCheck"Class '"Class '"' is not an @AspectJ aspect"' is not an @AspectJ aspect"DeclarePrecedence not presently supported in Spring AOP"DeclarePrecedence not presently supported in Spring AOPajexp"PerClause "PerClause " not supported by Spring AOP for " not supported by Spring AOP for beginIndexendIndexMetadata for an AspectJ aspect class, with an additional Spring AOP pointcutfor the per clause.<p>Uses AspectJ 5 AJType reflection API, enabling us to work with differentAspectJ instantiation models such as "singleton", "pertarget" and "perthis".org.springframework.aop.aspectj.AspectJExpressionPointcutThe name of this aspect as defined to Spring (the bean name) -allows us to determine if two pieces of advice come from thesame aspect and hence their relative precedence.The aspect class, stored separately for re-resolution of thecorresponding AjType on deserialization.AspectJ reflection information (AspectJ 5 / Java 5 specific).Re-resolved on deserialization since it isn't serializable itself.Spring AOP pointcut corresponding to the per clause of theaspect. Will be the Pointcut.TRUE canonical instance in thecase of a singleton, otherwise an AspectJExpressionPointcut.Create a new AspectMetadata instance for the given aspect class. Works with a type patternExtract contents from String of form {@code pertarget(contents)}.Return AspectJ reflection information.Return the aspect class.Return the aspect name.Return a Spring pointcut expression for a singleton aspect.(e.g. {@code Pointcut.TRUE} if it's a singleton).Return whether the aspect is defined as "perthis" or "pertarget".Return whether the aspect is defined as "pertypewithin".Return whether the aspect needs to be lazily instantiated.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/BeanFactoryAspectInstanceFactory.javaBeanFactoryAspectInstanceFactoryaspectMetadataC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/BeanFactoryAspectInstanceFactory.classresolvedType"BeanFactory must not be null"BeanFactory must not be null"Bean name must not be null"Bean name must not be null"Unresolvable bean type - explicitly specify the aspect class"Unresolvable bean type - explicitly specify the aspect classClass<Ordered>Map<String,Ordered>Ordered[]Constructor<Ordered>? super OrderedClass<? super Ordered>TypeVariable<Class<Ordered>>TypeVariable<Class<Ordered>>[]? extends BeanFactoryAspectInstanceFactoryClass<? extends BeanFactoryAspectInstanceFactory>Map<String,? extends BeanFactoryAspectInstanceFactory>BeanFactoryAspectInstanceFactory[]? extends BeanFactoryAspectInstanceFactory[]Constructor<? extends BeanFactoryAspectInstanceFactory>? super ? extends BeanFactoryAspectInstanceFactoryClass<? super ? extends BeanFactoryAspectInstanceFactory>TypeVariable<Class<? extends BeanFactoryAspectInstanceFactory>>TypeVariable<Class<? extends BeanFactoryAspectInstanceFactory>>[]": bean name '": bean name '{@link org.springframework.aop.aspectj.AspectInstanceFactory} implementationbacked by a Spring {@link org.springframework.beans.factory.BeanFactory}.<p>Note that this may instantiate multiple times if using a prototype,which probably won't give the semantics you expect.Use a {@link LazySingletonAspectInstanceFactoryDecorator}to wrap this to ensure only one new aspect comes back.org.springframework.beans.factory.BeanFactoryLazySingletonAspectInstanceFactoryDecoratorCreate a BeanFactoryAspectInstanceFactory. AspectJ will be called tointrospect to create AJType metadata using the type returned for thegiven bean name from the BeanFactory.the BeanFactory to obtain instance(s) fromthe name of the beanCreate a BeanFactoryAspectInstanceFactory, providing a type that AspectJ shouldintrospect to create AJType metadata. Use if the BeanFactory may consider the typeto be a subclass (as when using CGLIB), and the information should relate to a superclass.the type that should be introspected by AspectJ({@code null} indicates resolution through {@link BeanFactory#getType} via the bean name) Rely on singleton semantics provided by the factory -> no local lock. No singleton guarantees from the factory -> let's lock locally but reuse the factory's singleton lock, just in case a lazy dependency of our advice bean happens to trigger the singleton lock implicitly...Determine the order for this factory's target aspect, eitheran instance-specific order expressed through implementing the{@link org.springframework.core.Ordered} interface (onlychecked for singleton beans), or an order expressed through the{@link org.springframework.core.annotation.Order} annotationat the class level.org.springframework.core.annotation.OrderC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/BeanFactoryAspectJAdvisorsBuilder.javaBeanFactoryAspectJAdvisorsBuilderMap<String,MetadataAwareAspectInstanceFactory>aspectFactoryCacheC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/BeanFactoryAspectJAdvisorsBuilder.classMap<String,List<Advisor>>advisorsCacheaspectBeanNamesConcurrentHashMap<String,List<Advisor>>AbstractMap<String,List<Advisor>>ConcurrentMap<String,List<Advisor>>ConcurrentHashMap<String,List<Advisor>>()? super List<Advisor>? extends List<Advisor>BiFunction<? super List<Advisor>,? super List<Advisor>,? extends List<Advisor>>merge(java.lang.String,java.util.List,java.util.function.BiFunction)BiFunction<? super String,? super List<Advisor>,? extends List<Advisor>>Function<? super String,? extends List<Advisor>>replace(java.lang.String,java.util.List)replace(java.lang.String,java.util.List,java.util.List)putIfAbsent(java.lang.String,java.util.List)BiConsumer<? super String,? super List<Advisor>>getOrDefault(java.lang.Object,java.util.List)Entry<String,List<Advisor>>Set<Entry<String,List<Advisor>>>Collection<Entry<String,List<Advisor>>>Iterable<Entry<String,List<Advisor>>>Collection<List<Advisor>>Iterable<List<Advisor>>Map<? extends String,? extends List<Advisor>>put(java.lang.String,java.util.List)AbstractMap<String,List<Advisor>>()ToIntFunction<Entry<String,List<Advisor>>>ToLongFunction<Entry<String,List<Advisor>>>ToDoubleFunction<Entry<String,List<Advisor>>>Function<Entry<String,List<Advisor>>,? extends U>? extends Entry<String,List<Advisor>>BiFunction<Entry<String,List<Advisor>>,Entry<String,List<Advisor>>,? extends Entry<String,List<Advisor>>>? super Entry<String,List<Advisor>>Consumer<? super Entry<String,List<Advisor>>>ToIntFunction<? super List<Advisor>>ToLongFunction<? super List<Advisor>>ToDoubleFunction<? super List<Advisor>>Function<? super List<Advisor>,? extends U>Consumer<? super List<Advisor>>ToIntFunction<? super String>ToLongFunction<? super String>ToDoubleFunction<? super String>Function<? super String,? extends U>BiFunction<? super String,? super String,? extends String>ToIntBiFunction<? super String,? super List<Advisor>>ToLongBiFunction<? super String,? super List<Advisor>>ToDoubleBiFunction<? super String,? super List<Advisor>>BiFunction<? super String,? super List<Advisor>,? extends U>Node<String,List<Advisor>>Node<String,List<Advisor>>[]KeySetView<String,List<Advisor>>CollectionView<String,List<Advisor>,String>keySet(java.util.List)Enumeration<List<Advisor>>Enumeration<String>Predicate<? super List<Advisor>>Predicate<? super Entry<String,List<Advisor>>>replaceNode(java.lang.Object,java.util.List,java.lang.Object)putVal(java.lang.String,java.util.List,boolean)ConcurrentHashMap<String,List<Advisor>>(int,float,int)ConcurrentHashMap<String,List<Advisor>>(int,float)ConcurrentHashMap<String,List<Advisor>>(java.util.Map)ConcurrentHashMap<String,List<Advisor>>(int)ConcurrentHashMap<String,MetadataAwareAspectInstanceFactory>AbstractMap<String,MetadataAwareAspectInstanceFactory>ConcurrentMap<String,MetadataAwareAspectInstanceFactory>ConcurrentHashMap<String,MetadataAwareAspectInstanceFactory>()? super MetadataAwareAspectInstanceFactory? extends MetadataAwareAspectInstanceFactoryBiFunction<? super MetadataAwareAspectInstanceFactory,? super MetadataAwareAspectInstanceFactory,? extends MetadataAwareAspectInstanceFactory>merge(java.lang.String,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory,java.util.function.BiFunction)BiFunction<? super String,? super MetadataAwareAspectInstanceFactory,? extends MetadataAwareAspectInstanceFactory>Function<? super String,? extends MetadataAwareAspectInstanceFactory>replace(java.lang.String,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory)replace(java.lang.String,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory)putIfAbsent(java.lang.String,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory)BiConsumer<? super String,? super MetadataAwareAspectInstanceFactory>getOrDefault(java.lang.Object,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory)Entry<String,MetadataAwareAspectInstanceFactory>Set<Entry<String,MetadataAwareAspectInstanceFactory>>Collection<Entry<String,MetadataAwareAspectInstanceFactory>>Iterable<Entry<String,MetadataAwareAspectInstanceFactory>>Collection<MetadataAwareAspectInstanceFactory>Iterable<MetadataAwareAspectInstanceFactory>Map<? extends String,? extends MetadataAwareAspectInstanceFactory>put(java.lang.String,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory)AbstractMap<String,MetadataAwareAspectInstanceFactory>()ToIntFunction<Entry<String,MetadataAwareAspectInstanceFactory>>ToLongFunction<Entry<String,MetadataAwareAspectInstanceFactory>>ToDoubleFunction<Entry<String,MetadataAwareAspectInstanceFactory>>Function<Entry<String,MetadataAwareAspectInstanceFactory>,? extends U>? extends Entry<String,MetadataAwareAspectInstanceFactory>BiFunction<Entry<String,MetadataAwareAspectInstanceFactory>,Entry<String,MetadataAwareAspectInstanceFactory>,? extends Entry<String,MetadataAwareAspectInstanceFactory>>? super Entry<String,MetadataAwareAspectInstanceFactory>Consumer<? super Entry<String,MetadataAwareAspectInstanceFactory>>ToIntFunction<? super MetadataAwareAspectInstanceFactory>ToLongFunction<? super MetadataAwareAspectInstanceFactory>ToDoubleFunction<? super MetadataAwareAspectInstanceFactory>Function<? super MetadataAwareAspectInstanceFactory,? extends U>Consumer<? super MetadataAwareAspectInstanceFactory>ToIntBiFunction<? super String,? super MetadataAwareAspectInstanceFactory>ToLongBiFunction<? super String,? super MetadataAwareAspectInstanceFactory>ToDoubleBiFunction<? super String,? super MetadataAwareAspectInstanceFactory>BiFunction<? super String,? super MetadataAwareAspectInstanceFactory,? extends U>Node<String,MetadataAwareAspectInstanceFactory>Node<String,MetadataAwareAspectInstanceFactory>[]KeySetView<String,MetadataAwareAspectInstanceFactory>CollectionView<String,MetadataAwareAspectInstanceFactory,String>keySet(org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory)Enumeration<MetadataAwareAspectInstanceFactory>Predicate<? super MetadataAwareAspectInstanceFactory>Predicate<? super Entry<String,MetadataAwareAspectInstanceFactory>>replaceNode(java.lang.Object,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory,java.lang.Object)putVal(java.lang.String,org.springframework.aop.aspectj.annotation.MetadataAwareAspectInstanceFactory,boolean)ConcurrentHashMap<String,MetadataAwareAspectInstanceFactory>(int,float,int)ConcurrentHashMap<String,MetadataAwareAspectInstanceFactory>(int,float)ConcurrentHashMap<String,MetadataAwareAspectInstanceFactory>(java.util.Map)ConcurrentHashMap<String,MetadataAwareAspectInstanceFactory>(int)"ListableBeanFactory must not be null"ListableBeanFactory must not be nullaspectNamesArrayList<Advisor>AbstractList<Advisor>AbstractCollection<Advisor>ArrayList<Advisor>()AbstractCollection<Advisor>()AbstractList<Advisor>()ArrayList<Advisor>(java.util.Collection)ArrayList<Advisor>(int)beanNamesbeanTypeamdclassAdvisors"Bean with name '"Bean with name '"' is a singleton, but aspect instantiation model is not singleton"' is a singleton, but aspect instantiation model is not singletoncachedAdvisorsHelper for retrieving @AspectJ beans from a BeanFactory and buildingSpring Advisors based on them, for use with auto-proxying.2.0.2Create a new BeanFactoryAspectJAdvisorsBuilder for the given BeanFactory.the ListableBeanFactory to scanthe AspectJAdvisorFactory to build each Advisor withLook for AspectJ-annotated aspect beans in the current bean factory,and return to a list of Spring AOP Advisors representing them.<p>Creates a Spring Advisor for each AspectJ advice method.the list of {@link org.springframework.aop.Advisor} beans#isEligibleBean We must be careful not to instantiate beans eagerly as in this case they would be cached by the Spring container but would not have been weaved. Per target or per this.Return whether the aspect bean with the given name is eligible.the name of the aspect beanwhether the bean is eligibleC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl.javaInstantiationModelAwarePointcutAdvisorImplC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl.classdetermineAdviceTypedetermineAdviceType()instantiateAdviceinstantiateAdvice(org.springframework.aop.aspectj.AspectJExpressionPointcut)isAfterAdviceisBeforeAdviceinstantiatedAdvicelazydeclaredPointcutEMPTY_ADVICEC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl$1.classInstantiationModelAwarePointcutAdvisorImpl$1preInstantiationPointcutaspectJAnnotation"InstantiationModelAwarePointcutAdvisor: expression ["InstantiationModelAwarePointcutAdvisor: expression ["]; advice method ["]; advice method ["]; perClauseKind="]; perClauseKind=isAspectMaterializedisAspectMaterialized()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/InstantiationModelAwarePointcutAdvisorImpl$PerTargetInstantiationModelPointcut.classInstantiationModelAwarePointcutAdvisorImpl$PerTargetInstantiationModelPointcutInternal implementation of AspectJPointcutAdvisor.Note that there will be one instance of this advisor for each target method. Static part of the pointcut is a lazy type. Make it dynamic: must mutate from pre-instantiation to post-instantiation state. If it's not a dynamic pointcut, it may be optimized out by the Spring AOP infrastructure after the first evaluation. A singleton aspect.The pointcut for Spring AOP to use.Actual behaviour of the pointcut will change depending on the state of the advice.Lazily instantiate advice if necessary.This is only of interest for Spring AOP: AspectJ instantiation semanticsare much richer. In AspectJ terminology, all a return of {@code true}means here is that the aspect is not a SINGLETON.Return the AspectJ AspectMetadata for this advisor.Duplicates some logic from getAdvice, but importantly does not forcecreation of the advice.Pointcut implementation that changes its behaviour when the advice is instantiated.Note that this is a <i>dynamic</i> pointcut; otherwise it might be optimized outif it does not at first match statically. We're either instantiated and matching on declared pointcut, or uninstantiated matching on either pointcut... This can match only on declared pointcut.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/LazySingletonAspectInstanceFactoryDecorator.javamaterializedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/LazySingletonAspectInstanceFactoryDecorator.classmaaif"AspectInstanceFactory must not be null"AspectInstanceFactory must not be nullmutex"LazySingletonAspectInstanceFactoryDecorator: decorating "LazySingletonAspectInstanceFactoryDecorator: decorating Decorator to cause a {@link MetadataAwareAspectInstanceFactory} to instantiate only once.Create a new lazily initializing decorator for the given AspectInstanceFactory.the MetadataAwareAspectInstanceFactory to decorateC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/MetadataAwareAspectInstanceFactory.javaMetadataAwareAspectInstanceFactorySubinterface of {@link org.springframework.aop.aspectj.AspectInstanceFactory}that returns {@link AspectMetadata} associated with AspectJ-annotated classes.<p>Ideally, AspectInstanceFactory would include this method itself, but becauseAspectMetadata uses Java-5-only {@link org.aspectj.lang.reflect.AjType},we need to split out this subinterface.org.aspectj.lang.reflect.AjTypeReturn the AspectJ AspectMetadata for this factory's aspect.the aspect metadataReturn the best possible creation mutex for this factory.the mutex object (may be {@code null} for no mutex to use)4.3C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/NotAnAtAspectException.javanonAspectClassC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/NotAnAtAspectException.class" is not an @AspectJ aspect" is not an @AspectJ aspectExtension of AopConfigException thrown when trying to performan advisor generation operation on a class that is not anAspectJ annotation-style aspect.Create a new NotAnAtAspectException for the given class.the offending classReturns the offending class.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/PrototypeAspectInstanceFactory.javaPrototypeAspectInstanceFactory"Cannot use PrototypeAspectInstanceFactory with bean named '"Cannot use PrototypeAspectInstanceFactory with bean named '"': not a prototype"': not a prototype{@link org.springframework.aop.aspectj.AspectInstanceFactory} backed by a{@link BeanFactory}-provided prototype, enforcing prototype semantics.<p>Note that this may instantiate multiple times, which probably won't give thesemantics you expect. Use a {@link LazySingletonAspectInstanceFactoryDecorator}Create a PrototypeAspectInstanceFactory. AspectJ will be called toC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.javaReflectiveAspectJAdvisorFactorygetPointcut(java.lang.reflect.Method,java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactory.classgetDeclareParentsAdvisorgetDeclareParentsAdvisor(java.lang.reflect.Field)getAdvisorMethodsgetAdvisorMethods(java.lang.Class)Comparator<Method>adviceMethodComparatoradviceMethodFilterorg.springframework.utilmatches(java.lang.reflect.Method)adviceKindComparatororg.springframework.core.convert.converterConvertingComparator<Method,Annotation>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/convertconvertC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/convert/converterC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/convert/converter/ConvertingComparator.classConvertingComparatororg.springframework.util.comparatorInstanceComparator<Annotation>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/utilC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/comparatorcomparatorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/comparator/InstanceComparator.classInstanceComparatorComparator<Annotation>Converter<Method,Annotation>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/convert/converter/Converter.classConverterConverter<S,T>ConvertingComparator<Method,Annotation>(java.util.Comparator,org.springframework.core.convert.converter.Converter)ToDoubleFunction<>comparingDoublecomparingDouble(java.util.function.ToDoubleFunction)ToLongFunction<>comparingLongcomparingLong(java.util.function.ToLongFunction)ToIntFunction<>comparingIntcomparingInt(java.util.function.ToIntFunction)Comparable<? super U>C:/modules/java.base/java/lang/Comparable.classComparablecomparingcomparing(java.util.function.Function)Function<? super T,? extends U>comparing(java.util.function.Function,java.util.Comparator)Comparator<? super U>nullsLastnullsLast(java.util.Comparator)nullsFirstnullsFirst(java.util.Comparator)Comparable<? super T>naturalOrdernaturalOrder()reverseOrderreverseOrder()thenComparingDoublethenComparingDouble(java.util.function.ToDoubleFunction)thenComparingLongthenComparingLong(java.util.function.ToLongFunction)thenComparingIntthenComparingInt(java.util.function.ToIntFunction)thenComparingthenComparing(java.util.function.Function)thenComparing(java.util.function.Function,java.util.Comparator)thenComparing(java.util.Comparator)Comparator<? super Method>reversedreversed()comparecompare(java.lang.Object,java.lang.Object)compare(java.lang.reflect.Method,java.lang.reflect.Method)ConvertingComparator<>ConvertingComparator<Entry<K,V>,V>Comparator<Entry<K,V>>mapEntryValuesmapEntryValues(java.util.Comparator)Comparator<V>ConvertingComparator<Entry<K,V>,K>mapEntryKeysmapEntryKeys(java.util.Comparator)Comparator<K>ConvertingComparator(java.util.Comparator,org.springframework.core.convert.ConversionService,java.lang.Class)ConvertingComparator<Method,Annotation>(java.util.Comparator,org.springframework.core.convert.ConversionService,java.lang.Class)ConvertingComparator(java.util.Comparator,org.springframework.core.convert.converter.Converter)ConvertingComparator(org.springframework.core.convert.converter.Converter)ConvertingComparator<Method,Annotation>(org.springframework.core.convert.converter.Converter)InstanceComparator<T>InstanceComparator<T>(java.lang.Class[])InstanceComparator(java.lang.Class[])Converter<>Converter<S,U>andThen(org.springframework.core.convert.converter.Converter)Converter<? super T,? extends U>Converter<Method,U>? super AnnotationConverter<? super Annotation,? extends U>convert(java.lang.Object)convert(java.lang.reflect.Method)annmethodNameComparatorConvertingComparator<Method,String>Converter<Method,String>ConvertingComparator<Method,String>(org.springframework.core.convert.converter.Converter)Comparator<String>Class<? extends String>ConvertingComparator<Method,String>(java.util.Comparator,org.springframework.core.convert.ConversionService,java.lang.Class)ConvertingComparator<Method,String>(java.util.Comparator,org.springframework.core.convert.converter.Converter)Converter<? super String,? extends U>lazySingletonAspectInstanceFactoryinstantiationAdvisormethodsArrayList<Method>AbstractList<Method>AbstractCollection<Method>ArrayList<Method>()Spliterator<Method>Iterator<Method>Stream<Method>BaseStream<Method,Stream<Method>>Predicate<? super Method>Collection<? extends Method>Iterable<? extends Method>add(java.lang.reflect.Method)AbstractCollection<Method>()ListIterator<Method>add(int,java.lang.reflect.Method)set(int,java.lang.reflect.Method)UnaryOperator<Method>Function<Method,Method>AbstractList<Method>()ArrayList<Method>(java.util.Collection)ArrayList<Method>(int)doWithdoWith(java.lang.reflect.Method)introductionFielddeclareParentsClass<DeclareParents>"'defaultImpl' attribute must be set on DeclareParents"'defaultImpl' attribute must be set on DeclareParentsdeclarationOrderInAspectcandidateAspectClassspringAdvice"Advice must be declared inside an aspect type: " +
					"Offending method '"Advice must be declared inside an aspect type: Offending method '"' in class ["' in class ["Found AspectJ method: "Found AspectJ method: afterReturningAnnotationafterThrowingAnnotation"Processing pointcut '"Processing pointcut '"Unsupported advice type on method: "Unsupported advice type on method: before(java.lang.reflect.Method,java.lang.Object[],java.lang.Object)Factory that can create Spring AOP Advisors given AspectJ classes fromclasses honoring AspectJ's annotation syntax, using reflection to invoke thecorresponding advice methods.Phillip Webb Exclude @Pointcut methods Note: although @After is ordered before @AfterReturning and @AfterThrowing, an @After advice method will actually be invoked after @AfterReturning and @AfterThrowing methods due to the fact that AspectJAfterAdvice.invoke(MethodInvocation) invokes proceed() in a `try` block and only invokes the @After advice method in a corresponding `finally` block.Create a new {@code ReflectiveAspectJAdvisorFactory}.Create a new {@code ReflectiveAspectJAdvisorFactory}, propagating the given{@link BeanFactory} to the created {@link AspectJExpressionPointcut} instances,for bean pointcut handling as well as consistent {@link ClassLoader} resolution.the BeanFactory to propagate (may be {@code null}}4.3.6AspectJExpressionPointcut#setBeanFactoryorg.springframework.beans.factory.config.ConfigurableBeanFactory#getBeanClassLoader() We need to wrap the MetadataAwareAspectInstanceFactory with a decorator so that it will only instantiate once. Prior to Spring Framework 5.2.7, advisors.size() was supplied as the declarationOrderInAspect to getAdvisor(...) to represent the "current position" in the declared methods list. However, since Java 7 the "current position" is not valid since the JDK no longer returns declared methods in the order in which they are declared in the source code. Thus, we now hard code the declarationOrderInAspect to 0 for all advice methods discovered via reflection in order to support reliable advice ordering across JVM launches. Specifically, a value of 0 aligns with the default value used in AspectJPrecedenceComparator.getAspectDeclarationOrder(Advisor). If it's a per target aspect, emit the dummy instantiating aspect. Find introduction fields.Build a {@link org.springframework.aop.aspectj.DeclareParentsAdvisor}for the given introduction field.<p>Resulting Advisors will need to be evaluated for targets.the field to introspectthe Advisor instance, or {@code null} if not an Advisor Not an introduction field If we get here, we know we have an AspectJ method. Check that it's an AspectJ-annotated class Now to configure the advice...Synthetic advisor that instantiates the aspect.Triggered by per-clause pointcut on non-singleton aspect.The advice has no effect.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/SimpleMetadataAwareAspectInstanceFactory.javaSimpleMetadataAwareAspectInstanceFactoryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/SimpleMetadataAwareAspectInstanceFactory.classImplementation of {@link MetadataAwareAspectInstanceFactory} thatcreates a new instance of the specified aspect class for everyCreate a new SimpleMetadataAwareAspectInstanceFactory for the given aspect class.the aspect nameC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/SingletonMetadataAwareAspectInstanceFactory.javaSingletonMetadataAwareAspectInstanceFactoryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/SingletonMetadataAwareAspectInstanceFactory.classImplementation of {@link MetadataAwareAspectInstanceFactory} that is backedby a specified singleton object, returning the same instance for everyCreate a new SingletonMetadataAwareAspectInstanceFactory for the given aspect.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/package-info.javapackage-infoClasses enabling AspectJ 5 @Annotated classes to be used in Spring AOP.<p>Normally to be used through an AspectJAutoProxyCreator rather than directly.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJAwareAdvisorAutoProxyCreator.javaAspectJAwareAdvisorAutoProxyCreatorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxyorg.springframework.aop.aspectj.autoproxyComparator<Advisor>DEFAULT_PRECEDENCE_COMPARATORC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJAwareAdvisorAutoProxyCreator.classList<PartiallyComparableAdvisorHolder>Collection<PartiallyComparableAdvisorHolder>Iterable<PartiallyComparableAdvisorHolder>partiallyComparableAdvisorsArrayList<PartiallyComparableAdvisorHolder>AbstractList<PartiallyComparableAdvisorHolder>AbstractCollection<PartiallyComparableAdvisorHolder>ArrayList<PartiallyComparableAdvisorHolder>(int)Spliterator<PartiallyComparableAdvisorHolder>? super PartiallyComparableAdvisorHolderConsumer<? super PartiallyComparableAdvisorHolder>Iterator<PartiallyComparableAdvisorHolder>Stream<PartiallyComparableAdvisorHolder>BaseStream<PartiallyComparableAdvisorHolder,Stream<PartiallyComparableAdvisorHolder>>Predicate<? super PartiallyComparableAdvisorHolder>? extends PartiallyComparableAdvisorHolderCollection<? extends PartiallyComparableAdvisorHolder>Iterable<? extends PartiallyComparableAdvisorHolder>add(org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.PartiallyComparableAdvisorHolder)AbstractCollection<PartiallyComparableAdvisorHolder>()ListIterator<PartiallyComparableAdvisorHolder>add(int,org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.PartiallyComparableAdvisorHolder)set(int,org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator.PartiallyComparableAdvisorHolder)Comparator<? super PartiallyComparableAdvisorHolder>UnaryOperator<PartiallyComparableAdvisorHolder>Function<PartiallyComparableAdvisorHolder,PartiallyComparableAdvisorHolder>AbstractList<PartiallyComparableAdvisorHolder>()ArrayList<PartiallyComparableAdvisorHolder>(java.util.Collection)ArrayList<PartiallyComparableAdvisorHolder>()pcAdvisorcandidateAdvisorsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHolder.classAspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHoldercompare(org.springframework.aop.Advisor,org.springframework.aop.Advisor)Function<? super Advisor,? extends U>? extends AdviceClass<? extends Advice>appended": order = ": order = ajAdvice"aspect name = "aspect name = ", declaration order = ", declaration order = {@link org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator}subclass that exposes AspectJ's invocation context and understands AspectJ's rulesfor advice precedence when multiple pieces of advice come from the same aspect.Sort the supplied {@link Advisor} instances according to AspectJ precedence.<p>If two pieces of advice come from the same aspect, they will have the sameorder. Advice from the same aspect is then further ordered according to thefollowing rules:<li>If either of the pair is <em>after</em> advice, then the advice declaredlast gets highest precedence (i.e., runs last).</li><li>Otherwise the advice declared first gets highest precedence (i.e., runsfirst).</li><p><b>Important:</b> Advisors are sorted in precedence order, from highestprecedence to lowest. "On the way in" to a join point, the highest precedenceadvisor should run first. "On the way out" of a join point, the highestprecedence advisor should run last.Add an {@link ExposeInvocationInterceptor} to the beginning of the advice chain.<p>This additional advice is needed when using AspectJ pointcut expressionsand when using AspectJ-style advice. TODO: Consider optimization by caching the list of the aspect namesImplements AspectJ's {@link PartialComparable} interface for defining partial orderings.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.javaAspectJPrecedenceComparatorgetAspectDeclarationOrdergetAspectDeclarationOrder(org.springframework.aop.Advisor)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparator.classgetAspectNamegetAspectName(org.springframework.aop.Advisor)hasAspectNamehasAspectName(org.springframework.aop.Advisor)declaredInSameAspectdeclaredInSameAspect(org.springframework.aop.Advisor,org.springframework.aop.Advisor)comparePrecedenceWithinAspectcomparePrecedenceWithinAspect(org.springframework.aop.Advisor,org.springframework.aop.Advisor)advisorComparatorLOWER_PRECEDENCESAME_PRECEDENCEHIGHER_PRECEDENCE"Advisor comparator must not be null"Advisor comparator must not be nullo1o2advisorPrecedence? super ? super AdvisorToDoubleFunction<? super ? super Advisor>ToLongFunction<? super ? super Advisor>ToIntFunction<? super ? super Advisor>Function<? super ? super Advisor,? extends U>Comparator<? super ? super Advisor>advisor1advisor2oneOrOtherIsAfterAdviceadviceDeclarationOrderDeltaget()"Unresolvable AspectJPrecedenceInformation for "Unresolvable AspectJPrecedenceInformation for Orders AspectJ advice/advisors by precedence (<i>not</i> invocation order).<p>Given two pieces of advice, {@code A} and {@code B}:<li>If {@code A} and {@code B} are defined in different aspects, then the advicein the aspect with the lowest order value has the highest precedence.</li><li>If {@code A} and {@code B} are defined in the same aspect, if one of{@code A} or {@code B} is a form of <em>after</em> advice, then the advice declaredlast in the aspect has the highest precedence. If neither {@code A} nor {@code B}is a form of <em>after</em> advice, then the advice declared first in the aspecthas the highest precedence.</li><p>Important: This comparator is used with AspectJ's{@link org.aspectj.util.PartialOrder PartialOrder} sorting utility. Thus, unlikea normal {@link Comparator}, a return value of {@code 0} from this comparatormeans we don't care about the ordering, not that the two elements must be sortedidentically.Create a default {@code AspectJPrecedenceComparator}.Create an {@code AspectJPrecedenceComparator}, using the given {@link Comparator}for comparing {@link org.springframework.aop.Advisor} instances.the {@code Comparator} to use for advisors the advice declared last has higher precedence advice1 was declared before advice2 so advice1 has lower precedence the advice declared first has higher precedence so advice1 has higher precedence pre-condition is that hasAspectName returned trueC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/autoproxy/package-info.javaBase classes enabling auto-proxying based on AspectJ.Support for AspectJ annotation aspects resides in the "aspectj.annotation" package.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/package-info.javaAspectJ integration package. Includes Spring AOP advice implementations for AspectJ 5annotation-style methods, and an AspectJExpressionPointcut: a Spring AOP Pointcutimplementation that allows use of the AspectJ pointcut expression language with the Spring AOPruntime framework.<p>Note that use of this package does <i>not</i> require the use of the {@code ajc} compileror AspectJ load-time weaver. It is intended to enable the use of a valuable subset of AspectJfunctionality, with consistent semantics, with the proxy-based Spring AOP framework.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AbstractInterceptorDrivenBeanDefinitionDecorator.javaAbstractInterceptorDrivenBeanDefinitionDecoratorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/configisProxyFactoryBeanDefinitionisProxyFactoryBeanDefinition(org.springframework.beans.factory.config.BeanDefinition)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AbstractInterceptorDrivenBeanDefinitionDecorator.classaddInterceptorNameToListaddInterceptorNameToList(java.lang.String,org.springframework.beans.factory.config.BeanDefinition)nodedefinitionHolderexistingBeanNametargetDefinitiontargetHolder".TARGET".TARGETinterceptorDefinitioninterceptorName'.'proxyDefinitionClass<ProxyFactoryBean>ManagedList<String>"interceptorNames"interceptorNamesManagedList<String>()ManagedList<String>(int)beanDefinitionlist"Missing 'interceptorNames' property"Missing 'interceptorNames' propertyexistingDefinitionMap<String,ProxyFactoryBean>ProxyFactoryBean[]Constructor<ProxyFactoryBean>? super ProxyFactoryBeanClass<? super ProxyFactoryBean>TypeVariable<Class<ProxyFactoryBean>>TypeVariable<Class<ProxyFactoryBean>>[]beanClassNameBase implementation for{@link org.springframework.beans.factory.xml.BeanDefinitionDecorator BeanDefinitionDecorators}wishing to add an {@link org.aopalliance.intercept.MethodInterceptor interceptor}to the resulting bean.<p>This base class controls the creation of the {@link ProxyFactoryBean} bean definitionand wraps the original as an inner-bean definition for the {@code target} propertyof {@link ProxyFactoryBean}.<p>Chaining is correctly handled, ensuring that only one {@link ProxyFactoryBean} definitionis created. If a previous {@link org.springframework.beans.factory.xml.BeanDefinitionDecorator}already created the {@link org.springframework.aop.framework.ProxyFactoryBean} then theinterceptor is simply added to the existing definition.<p>Subclasses have only to create the {@code BeanDefinition} to the interceptor thatthey wish to add. get the root bean name - will be the name of the generated proxy factory bean delegate to subclass for interceptor definition generate name and register the interceptor create the proxy definition create proxy factory bean definition set the target create the interceptor names list copy autowire settings from original bean definition. wrap it in a BeanDefinitionHolder with bean nameSubclasses should implement this method to return the {@code BeanDefinition}for the interceptor they wish to apply to the bean being decorated.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AdviceEntry.javaAdviceEntryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AdviceEntry.class"Advice ("Advice ({@link ParseState} entry representing an advice element.Create a new {@code AdviceEntry} instance.the kind of advice represented by this entry (before, after, around)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AdvisorComponentDefinition.javaAdvisorComponentDefinitionbuildDescriptionbuildDescription(org.springframework.beans.factory.config.BeanReference,org.springframework.beans.factory.config.BeanReference)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AdvisorComponentDefinition.classbuildDescription(org.springframework.beans.factory.config.BeanReference,org.springframework.beans.factory.config.BeanDefinition)BeanDefinition[]beanDefinitionsBeanReference[]beanReferencesadvisorDefinitionadvisorBeanNamepointcutDefinitionpvsadviceReference"adviceBeanName"adviceBeanName"'advisorBeanName' must not be null"'advisorBeanName' must not be null"'advisorDefinition' must not be null"'advisorDefinition' must not be null"Missing 'adviceBeanName' property"Missing 'adviceBeanName' propertypointcutReference"Missing 'pointcut' property"Missing 'pointcut' property"Advisor <advice(ref)='"Advisor <advice(ref)='"', pointcut(expression)=["', pointcut(expression)=["expression""]>"]>"', pointcut(ref)='"', pointcut(ref)='"'>"'>{@link org.springframework.beans.factory.parsing.ComponentDefinition}that bridges the gap between the advisor bean definition configuredby the {@code <aop:advisor>} tag and the component definitioninfrastructure.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AdvisorEntry.javaAdvisorEntryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AdvisorEntry.class"Advisor '"Advisor '{@link ParseState} entry representing an advisor.Create a new {@code AdvisorEntry} instance.the bean name of the advisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AopConfigUtils.javaAopConfigUtilsfindPriorityForClassfindPriorityForClass(java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AopConfigUtils.classfindPriorityForClass(java.lang.Class)registerOrEscalateApcAsRequiredregisterOrEscalateApcAsRequired(java.lang.Class,org.springframework.beans.factory.support.BeanDefinitionRegistry,java.lang.Object)List<Class<?>>APC_PRIORITY_LIST"org.springframework.aop.config.internalAutoProxyCreator"org.springframework.aop.config.internalAutoProxyCreatorArrayList<Class<?>>AbstractList<Class<?>>AbstractCollection<Class<?>>ArrayList<Class<?>>(int)AbstractCollection<Class<?>>()ListIterator<Class<?>>add(int,java.lang.Class)set(int,java.lang.Class)Comparator<? super Class<?>>UnaryOperator<Class<?>>Function<Class<?>,Class<?>>AbstractList<Class<?>>()ArrayList<Class<?>>(java.util.Collection)ArrayList<Class<?>>()Class<InfrastructureAdvisorAutoProxyCreator>Class<AspectJAwareAdvisorAutoProxyCreator>Class<AnnotationAwareAspectJAutoProxyCreator>"proxyTargetClass"proxyTargetClass"exposeProxy"exposeProxycls"BeanDefinitionRegistry must not be null"BeanDefinitionRegistry must not be nullapcDefinitioncurrentPriorityrequiredPriority"order"className"Class name ["Class name ["] is not a known auto-proxy creator class"] is not a known auto-proxy creator classUtility class for handling registration of AOP auto-proxy creators.<p>Only a single auto-proxy creator should be registered yet multiple concreteimplementations are available. This class provides a simple escalation protocol,allowing a caller to request a particular auto-proxy creator and know that creator,<i>or a more capable variant thereof</i>, will be registered as a post-processor.2.5AopNamespaceUtilsThe bean name of the internally managed auto-proxy creator.Stores the auto proxy creator classes in escalation order. Set up the escalation list...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AopNamespaceHandler.javaAopNamespaceHandler"config""aspectj-autoproxy"aspectj-autoproxy"scoped-proxy"scoped-proxy"spring-configured"spring-configured{@code NamespaceHandler} for the {@code aop} namespace.<p>Provides a {@link org.springframework.beans.factory.xml.BeanDefinitionParser} for the{@code <aop:config>} tag. A {@code config} tag can include nested{@code pointcut}, {@code advisor} and {@code aspect} tags.<p>The {@code pointcut} tag allows for creation of named{@link AspectJExpressionPointcut} beans using a simple syntax:<pre class="code">&lt;aop:pointcut id=&quot;getNameCalls&quot; expression=&quot;execution(* *..ITestBean.getName(..))&quot;/&gt;<p>Using the {@code advisor} tag you can configure an {@link org.springframework.aop.Advisor}and have it applied to all relevant beans in you {@link org.springframework.beans.factory.BeanFactory}automatically. The {@code advisor} tag supports both in-line and referenced{@link org.springframework.aop.Pointcut Pointcuts}:&lt;aop:advisor id=&quot;getAgeAdvisor&quot;pointcut=&quot;execution(* *..ITestBean.getAge(..))&quot;advice-ref=&quot;getAgeCounter&quot;/&gt;&lt;aop:advisor id=&quot;getNameAdvisor&quot;pointcut-ref=&quot;getNameCalls&quot;advice-ref=&quot;getNameCounter&quot;/&gt;</pre>Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the'{@code config}', '{@code spring-configured}', '{@code aspectj-autoproxy}'and '{@code scoped-proxy}' tags. In 2.0 XSD as well as in 2.5+ XSDs Only in 2.0 XSD: moved to context namespace in 2.5+C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AopNamespaceUtils.javaregisterComponentIfNecessaryregisterComponentIfNecessary(org.springframework.beans.factory.config.BeanDefinition,org.springframework.beans.factory.xml.ParserContext)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AopNamespaceUtils.classuseClassProxyingIfNecessaryuseClassProxyingIfNecessary(org.springframework.beans.factory.support.BeanDefinitionRegistry,org.w3c.dom.Element)EXPOSE_PROXY_ATTRIBUTE"proxy-target-class"proxy-target-class"expose-proxy"expose-proxysourceElementUtility class for handling registration of auto-proxy creators used internallyby the '{@code aop}' namespace tags.<p>Only a single auto-proxy creator should be registered and multiple configurationelements may wish to register different concrete implementations. As such this classdelegates to {@link AopConfigUtils} which provides a simple escalation protocol.Callers may request a particular auto-proxy creator and know that creator,The {@code proxy-target-class} attribute as found on AOP-related XML tags.The {@code expose-proxy} attribute as found on AOP-related XML tags.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AspectComponentDefinition.javaAspectComponentDefinitionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AspectComponentDefinition.classthat holds an aspect definition, including its nested pointcuts.#getNestedComponents()PointcutComponentDefinitionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AspectEntry.javaAspectEntryrefC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AspectEntry.classid"Aspect: "Aspect: "id='"id='"ref='"ref='{@link ParseState} entry representing an aspect.Create a new {@code AspectEntry} instance.the id of the aspect elementthe bean name referenced by this aspect elementC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AspectJAutoProxyBeanDefinitionParser.javaAspectJAutoProxyBeanDefinitionParseraddIncludePatternsaddIncludePatterns(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext,org.springframework.beans.factory.config.BeanDefinition)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/AspectJAutoProxyBeanDefinitionParser.classextendBeanDefinitionextendBeanDefinition(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)AspectJAutoProxyBeanDefinitionParser()beanDefManagedList<TypedStringValue>ArrayList<TypedStringValue>AbstractList<TypedStringValue>AbstractCollection<TypedStringValue>Collection<TypedStringValue>Iterable<TypedStringValue>List<TypedStringValue>ManagedList<TypedStringValue>()Spliterator<TypedStringValue>? super TypedStringValueConsumer<? super TypedStringValue>Iterator<TypedStringValue>Stream<TypedStringValue>BaseStream<TypedStringValue,Stream<TypedStringValue>>Predicate<? super TypedStringValue>? extends TypedStringValueCollection<? extends TypedStringValue>Iterable<? extends TypedStringValue>add(org.springframework.beans.factory.config.TypedStringValue)AbstractCollection<TypedStringValue>()ListIterator<TypedStringValue>add(int,org.springframework.beans.factory.config.TypedStringValue)set(int,org.springframework.beans.factory.config.TypedStringValue)Comparator<? super TypedStringValue>UnaryOperator<TypedStringValue>Function<TypedStringValue,TypedStringValue>AbstractList<TypedStringValue>()ArrayList<TypedStringValue>(java.util.Collection)ArrayList<TypedStringValue>()ArrayList<TypedStringValue>(int)ManagedList<TypedStringValue>(int)childNodesincludeElementvalueHolder"includePatterns"{@link BeanDefinitionParser} for the {@code aspectj-autoproxy} tag,enabling the automatic application of @AspectJ-style aspects found inthe {@link org.springframework.beans.factory.BeanFactory}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/ConfigBeanDefinitionParser.javaConfigBeanDefinitionParserparsePointcutPropertyparsePointcutProperty(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/ConfigBeanDefinitionParser.classparsePointcutparsePointcut(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)getAdviceClassgetAdviceClass(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)List<BeanReference>Collection<BeanReference>Iterable<BeanReference>createAdviceDefinitioncreateAdviceDefinition(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext,java.lang.String,int,org.springframework.beans.factory.support.RootBeanDefinition,org.springframework.beans.factory.support.RootBeanDefinition,java.util.List,java.util.List)parseAdviceparseAdvice(java.lang.String,int,org.w3c.dom.Element,org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext,java.util.List,java.util.List)parseDeclareParentsparseDeclareParents(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)isAdviceNodeisAdviceNode(org.w3c.dom.Node,org.springframework.beans.factory.xml.ParserContext)createAspectComponentDefinitioncreateAspectComponentDefinition(org.w3c.dom.Element,java.lang.String,java.util.List,java.util.List,org.springframework.beans.factory.xml.ParserContext)parseAspectparseAspect(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)createAdvisorBeanDefinitioncreateAdvisorBeanDefinition(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)parseAdvisorparseAdvisor(org.w3c.dom.Element,org.springframework.beans.factory.xml.ParserContext)configureAutoProxyCreatorconfigureAutoProxyCreator(org.springframework.beans.factory.xml.ParserContext,org.w3c.dom.Element)parseStateASPECT_INSTANCE_FACTORY_INDEXPOINTCUT_INDEXMETHOD_INDEXORDER_PROPERTYDECLARATION_ORDER_PROPERTYASPECT_NAME_PROPERTYARG_NAMES_PROPERTYARG_NAMESTHROWING_PROPERTYTHROWINGRETURNING_PROPERTYRETURNINGAROUNDAFTER_THROWING_ELEMENTAFTER_RETURNING_ELEMENTAFTERIMPLEMENT_INTERFACEDELEGATE_REFDEFAULT_IMPLTYPE_PATTERNDECLARE_PARENTSBEFOREREFPOINTCUT_REFADVICE_REFADVISORADVICE_BEAN_NAMEPOINTCUTIDEXPRESSIONASPECTConfigBeanDefinitionParser()"aspect""id""advisor""advice-ref"advice-ref"pointcut-ref"pointcut-ref"ref""declare-parents"declare-parents"types-matching"types-matching"default-impl"default-impl"delegate-ref"delegate-ref"implement-interface"implement-interface"after-returning"after-returning"after-throwing"after-throwing"around""returning"returning"returningName""throwing"throwing"throwingName""arg-names"arg-names"argumentNames""aspectName""declarationOrder"compositeDefchildEltseltlocalNameadvisorElementadvisorDefClass<DefaultBeanFactoryPointcutAdvisor>adviceRef"'advice-ref' attribute contains empty value."'advice-ref' attribute contains empty value.aspectElementaspectIdArrayList<BeanReference>AbstractList<BeanReference>AbstractCollection<BeanReference>ArrayList<BeanReference>()Spliterator<BeanReference>? super BeanReferenceConsumer<? super BeanReference>Iterator<BeanReference>Stream<BeanReference>BaseStream<BeanReference,Stream<BeanReference>>Predicate<? super BeanReference>? extends BeanReferenceCollection<? extends BeanReference>Iterable<? extends BeanReference>add(org.springframework.beans.factory.config.BeanReference)AbstractCollection<BeanReference>()ListIterator<BeanReference>add(int,org.springframework.beans.factory.config.BeanReference)set(int,org.springframework.beans.factory.config.BeanReference)Comparator<? super BeanReference>UnaryOperator<BeanReference>Function<BeanReference,BeanReference>AbstractList<BeanReference>()ArrayList<BeanReference>(java.util.Collection)ArrayList<BeanReference>(int)nodeListadviceFoundAlreadyaspectComponentDefinitionpointcutsdeclareParentsElement"<aspect> tag needs aspect bean reference via 'ref' attribute when declaring advices."<aspect> tag needs aspect bean reference via 'ref' attribute when declaring advices.pointcutElementbeanDefsbeanRefsbeanDefArraybeanRefArrayaNodeClass<DeclareParentsAdvisor>"Exactly one of the "Exactly one of the " attributes must be specified" attributes must be specifiedadviceElementmethodDefinitionClass<MethodLocatingFactoryBean>aspectFactoryDefClass<SimpleBeanFactoryAwareAspectInstanceFactory>adviceDef"targetBeanName"targetBeanName"methodName""method""aspectBeanName"aspectBeanNamemethodDefadviceDefinitioncavpointcutRefelementNameClass<AspectJMethodBeforeAdvice>Class<AspectJAfterAdvice>Class<AspectJAfterReturningAdvice>Class<AspectJAfterThrowingAdvice>Class<AspectJAroundAdvice>"Unknown advice kind ["Unknown advice kind ["]."].pointcutBeanName"Cannot define both 'pointcut' and 'pointcut-ref' on <advisor> tag."Cannot define both 'pointcut' and 'pointcut-ref' on <advisor> tag."'pointcut-ref' attribute contains empty value."'pointcut-ref' attribute contains empty value."Must define one of 'pointcut' or 'pointcut-ref' on <advisor> tag."Must define one of 'pointcut' or 'pointcut-ref' on <advisor> tag.{@link BeanDefinitionParser} for the {@code <aop:config>} tag.Configures the auto proxy creator needed to support the {@link BeanDefinition BeanDefinitions}created by the '{@code <aop:config/>}' tag. Will force class proxying if the'{@code proxy-target-class}' attribute is set to '{@code true}'.Parses the supplied {@code <advisor>} element and registers the resulting{@link org.springframework.aop.Advisor} and any resulting {@link org.springframework.aop.Pointcut}with the supplied {@link BeanDefinitionRegistry}.Create a {@link RootBeanDefinition} for the advisor described in the supplied. Does <strong>not</strong>parse any associated '{@code pointcut}' or '{@code pointcut-ref}' attributes. We have to parse "advice" and all the advice kinds in one loop, to get the ordering semantics right.Return {@code true} if the supplied node describes an advice type. May be one of:'{@code before}', '{@code after}', '{@code after-returning}','{@code after-throwing}' or '{@code around}'.Parse a '{@code declare-parents}' element and register the appropriateDeclareParentsAdvisor with the BeanDefinitionRegistry encapsulated in thesupplied ParserContext.Parses one of '{@code before}', '{@code after}', '{@code after-returning}','{@code after-throwing}' or '{@code around}' and registers the resultingBeanDefinition with the supplied BeanDefinitionRegistry.the generated advice RootBeanDefinition create the method factory bean create instance factory definition register the pointcut configure the advisor register the final advisorCreates the RootBeanDefinition for a POJO advice bean. Also causes pointcutparsing to occur so that the pointcut may be associate with the advice bean.This same pointcut is also configured as the pointcut for the enclosingAdvisor definition using the supplied MutablePropertyValues.Gets the advice implementation class corresponding to the supplied {@link Element}.Parses the supplied {@code <pointcut>} and registers the resultingPointcut with the BeanDefinitionRegistry.Parses the {@code pointcut} or {@code pointcut-ref} attributes of the supplied{@link Element} and add a {@code pointcut} property as appropriate. Generates a{@link org.springframework.beans.factory.config.BeanDefinition} for the pointcut if  necessaryand returns its bean name, otherwise returns the bean name of the referred pointcut. Create a pointcut for the anonymous pc and register it.Creates a {@link BeanDefinition} for the {@link AspectJExpressionPointcut} class usingthe supplied pointcut expression.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/MethodLocatingFactoryBean.javaMethodLocatingFactoryBeanC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/MethodLocatingFactoryBean.classFactoryBean<Method>"Property 'targetBeanName' is required"Property 'targetBeanName' is required"Property 'methodName' is required"Property 'methodName' is required"Can't determine type of bean with name '"Can't determine type of bean with name '"Unable to locate method ["Unable to locate method ["] on bean ["] on bean [Class<Method>{@link FactoryBean} implementation that locates a {@link Method} on a specified bean.Set the name of the bean to locate the {@link Method} on.<p>This property is required.the name of the bean to locate the {@link Method} onSet the name of the {@link Method} to locate.the name of the {@link Method} to locateC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/PointcutComponentDefinition.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/PointcutComponentDefinition.class"Pointcut definition must not be null"Pointcut definition must not be null"Expression must not be null"Expression must not be null"Pointcut <name='"Pointcut <name='"', expression=["', expression=[implementation that holds a pointcut definition.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/PointcutEntry.javaPointcutEntryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/PointcutEntry.class"Pointcut '"Pointcut '{@link ParseState} entry representing a pointcut.Create a new {@code PointcutEntry} instance.the bean name of the pointcutC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/ScopedProxyBeanDefinitionDecorator.javaScopedProxyBeanDefinitionDecoratorPROXY_TARGET_CLASSC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/ScopedProxyBeanDefinitionDecorator.classScopedProxyBeanDefinitionDecorator()holderele{@link BeanDefinitionDecorator} responsible for parsing the{@code <aop:scoped-proxy/>} tag. Register the original bean definition as it will be referenced by the scoped proxy and is relevant for tooling (validation, navigation).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/SimpleBeanFactoryAwareAspectInstanceFactory.javaSimpleBeanFactoryAwareAspectInstanceFactoryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/SimpleBeanFactoryAwareAspectInstanceFactory.class"'aspectBeanName' is required"'aspectBeanName' is required"No BeanFactory set"No BeanFactory set"No 'aspectBeanName' set"No 'aspectBeanName' setImplementation of {@link AspectInstanceFactory} that locates the aspect from the{@link org.springframework.beans.factory.BeanFactory} using a configured bean name.Set the name of the aspect bean. This is the bean that is returned when calling{@link #getAspectInstance()}.Look up the aspect bean from the {@link BeanFactory} and returns it.#setAspectBeanNameC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/SpringConfiguredBeanDefinitionParser.javaSpringConfiguredBeanDefinitionParserBEAN_CONFIGURER_ASPECT_CLASS_NAMEC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/SpringConfiguredBeanDefinitionParser.classSpringConfiguredBeanDefinitionParser()"org.springframework.context.config.internalBeanConfigurerAspect"org.springframework.context.config.internalBeanConfigurerAspect"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspectdef"aspectOf"aspectOf{@link BeanDefinitionParser} responsible for parsing the{@code <aop:spring-configured/>} tag.<p><b>NOTE:</b> This is essentially a duplicate of Spring 2.5's{@link org.springframework.context.config.SpringConfiguredBeanDefinitionParser}for the {@code <context:spring-configured/>} tag, mirrored here for compatibility withSpring 2.0's {@code <aop:spring-configured/>} tag (avoiding a direct dependency on thecontext package).The bean name of the internally managed bean configurer aspect.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/config/package-info.javaSupport package for declarative AOP configuration,with XML schema being the primary configuration format.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AbstractAdvisingBeanPostProcessor.javaAbstractAdvisingBeanPostProcessorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/frameworkorg.springframework.aop.frameworkMap<Class<?>,Boolean>eligibleBeansC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AbstractAdvisingBeanPostProcessor.classConcurrentHashMap<Class<?>,Boolean>AbstractMap<Class<?>,Boolean>ConcurrentMap<Class<?>,Boolean>ConcurrentHashMap<Class<?>,Boolean>(int)? extends BooleanBiFunction<? super Boolean,? super Boolean,? extends Boolean>merge(java.lang.Class,java.lang.Boolean,java.util.function.BiFunction)BiFunction<? super Class<?>,? super Boolean,? extends Boolean>Function<? super Class<?>,? extends Boolean>replace(java.lang.Class,java.lang.Boolean)replace(java.lang.Class,java.lang.Boolean,java.lang.Boolean)putIfAbsent(java.lang.Class,java.lang.Boolean)BiConsumer<? super Class<?>,? super Boolean>getOrDefault(java.lang.Object,java.lang.Boolean)Entry<Class<?>,Boolean>Set<Entry<Class<?>,Boolean>>Collection<Entry<Class<?>,Boolean>>Iterable<Entry<Class<?>,Boolean>>Collection<Boolean>Iterable<Boolean>Map<? extends Class<?>,? extends Boolean>put(java.lang.Class,java.lang.Boolean)AbstractMap<Class<?>,Boolean>()ToIntFunction<Entry<Class<?>,Boolean>>ToLongFunction<Entry<Class<?>,Boolean>>ToDoubleFunction<Entry<Class<?>,Boolean>>Function<Entry<Class<?>,Boolean>,? extends U>? extends Entry<Class<?>,Boolean>BiFunction<Entry<Class<?>,Boolean>,Entry<Class<?>,Boolean>,? extends Entry<Class<?>,Boolean>>? super Entry<Class<?>,Boolean>Consumer<? super Entry<Class<?>,Boolean>>ToIntFunction<? super Boolean>ToLongFunction<? super Boolean>ToDoubleFunction<? super Boolean>Function<? super Boolean,? extends U>Consumer<? super Boolean>ToIntBiFunction<? super Class<?>,? super Boolean>ToLongBiFunction<? super Class<?>,? super Boolean>ToDoubleBiFunction<? super Class<?>,? super Boolean>BiFunction<? super Class<?>,? super Boolean,? extends U>Node<Class<?>,Boolean>Node<Class<?>,Boolean>[]KeySetView<Class<?>,Boolean>CollectionView<Class<?>,Boolean,Class<?>>keySet(java.lang.Boolean)Enumeration<Boolean>Predicate<? super Entry<Class<?>,Boolean>>replaceNode(java.lang.Object,java.lang.Boolean,java.lang.Object)putVal(java.lang.Class,java.lang.Boolean,boolean)ConcurrentHashMap<Class<?>,Boolean>(int,float,int)ConcurrentHashMap<Class<?>,Boolean>(int,float)ConcurrentHashMap<Class<?>,Boolean>(java.util.Map)ConcurrentHashMap<Class<?>,Boolean>()256beforeExistingAdvisorsadvisedproxyFactoryeligibleBase class for {@link BeanPostProcessor} implementations that apply aSpring AOP {@link Advisor} to specific beans.3.2Set whether this post-processor's advisor is supposed to apply beforeexisting advisors when encountering a pre-advised object.<p>Default is "false", applying the advisor after existing advisors, i.e.as close as possible to the target method. Switch this to "true" in orderfor this post-processor's advisor to wrap existing advisors as well.<p>Note: Check the concrete post-processor's javadoc whether it possiblychanges this flag by default, depending on the nature of its advisor. Ignore AOP infrastructure such as scoped proxies. Add our local Advisor to the existing proxy's Advisor chain... No proxy needed.Check whether the given bean is eligible for advising with thispost-processor's {@link Advisor}.<p>Delegates to {@link #isEligible(Class)} for target class checking.Can be overridden e.g. to specifically exclude certain beans by name.<p>Note: Only called for regular bean instances but not for existingproxy instances which implement {@link Advised} and allow for addingthe local {@link Advisor} to the existing proxy's {@link Advisor} chain.For the latter, {@link #isEligible(Class)} is being called directly,with the actual target class behind the existing proxy (as determinedby {@link AopUtils#getTargetClass(Object)}).the bean instance#isEligible(Class)Check whether the given class is eligible for advising with this<p>Implements caching of {@code canApply} results per bean target class.the class to check againstAopUtils#canApply(Advisor, Class)Prepare a {@link ProxyFactory} for the given bean.<p>Subclasses may customize the handling of the target instance and inparticular the exposure of the target class. The default introspectionof interfaces for non-target-class proxies and the configured advisorwill be applied afterwards; {@link #customizeProxyFactory} allows forlate customizations of those parts right before proxy creation.the bean instance to create a proxy forthe corresponding bean namethe ProxyFactory, initialized with this processor's{@link ProxyConfig} settings and the specified bean4.2.3#customizeProxyFactorySubclasses may choose to implement this: for example,to change the interfaces exposed.<p>The default implementation is empty.the ProxyFactory that is already configured withtarget, advisor and interfaces and will be used to create the proxyimmediately after this method returns#prepareProxyFactoryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.javaAbstractSingletonProxyFactoryBeanproxyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.classproxyClassLoaderadvisorAdapterRegistrypostInterceptorspreInterceptorsproxyInterfacesFactoryBean<Object>targetSource"Property 'target' is required"Property 'target' is required"'target' needs to be a bean reference, not a bean name as value"'target' needs to be a bean reference, not a bean name as valueConvenient superclass for {@link FactoryBean} types that produce singleton-scopedproxy objects.<p>Manages pre- and post-interceptors (references, rather thaninterceptor names, as in {@link ProxyFactoryBean}) and providesconsistent interface management.Default is global AdvisorAdapterRegistry.Set the target object, that is, the bean to be wrapped with a transactional proxy.<p>The target may be any object, in which case a SingletonTargetSource willbe created. If it is a TargetSource, no wrapper TargetSource is created:This enables the use of a pooling or prototype TargetSource etc.org.springframework.aop.TargetSourceorg.springframework.aop.target.SingletonTargetSourceorg.springframework.aop.target.LazyInitTargetSourceorg.springframework.aop.target.PrototypeTargetSourceorg.springframework.aop.target.CommonsPool2TargetSourceSpecify the set of interfaces being proxied.<p>If not specified (the default), the AOP infrastructure worksout which interfaces need proxying by analyzing the target,proxying all the interfaces that the target object implements.Set additional interceptors (or advisors) to be applied before theimplicit transaction interceptor, e.g. a PerformanceMonitorInterceptor.<p>You may specify any AOP Alliance MethodInterceptors or otherSpring AOP Advices, as well as Spring AOP Advisors.org.springframework.aop.interceptor.PerformanceMonitorInterceptorSet additional interceptors (or advisors) to be applied after theimplicit transaction interceptor.Specify the AdvisorAdapterRegistry to use.Default is the global AdvisorAdapterRegistry.org.springframework.aop.framework.adapter.GlobalAdvisorAdapterRegistrySet the ClassLoader to generate the proxy class in.<p>Default is the bean ClassLoader, i.e. the ClassLoader used by thecontaining BeanFactory for loading all bean classes. This can beoverridden here for specific proxies. Add the main interceptor (typically an Advisor). Rely on AOP infrastructure to tell us what interfaces to proxy.Determine a TargetSource for the given target (or TargetSource).the target. If this is an implementation of TargetSource it isused as our TargetSource; otherwise it is wrapped in a SingletonTargetSource.a TargetSource for this objectA hook for subclasses to post-process the {@link ProxyFactory}before creating the proxy instance with it.the AOP ProxyFactory about to be used4.2Create the "main" interceptor for this proxy factory bean.Typically an Advisor, but can also be any type of Advice.<p>Pre-interceptors will be applied before, post-interceptorswill be applied after this interceptor.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/Advised.javaAdvisedpreFilteredposabInterface to be implemented by classes that hold the configurationof a factory of AOP proxies. This configuration includes theInterceptors and other advice, Advisors, and the proxied interfaces.<p>Any AOP proxy obtained from Spring can be cast to this interface toallow manipulation of its AOP advice.13.03.2003org.springframework.aop.framework.AdvisedSupportReturn whether the Advised configuration is frozen,in which case no advice changes can be made.Are we proxying the full target class instead of specified interfaces?Return the interfaces proxied by the AOP proxy.<p>Will not include the target class, which may also be proxied.Determine whether the given interface is proxied.Change the {@code TargetSource} used by this {@code Advised} object.<p>Only works if the configuration isn't {@linkplain #isFrozen frozen}.new TargetSource to useReturn the {@code TargetSource} used by this {@code Advised} object.Set whether the proxy should be exposed by the AOP framework as a{@link ThreadLocal} for retrieval via the {@link AopContext} class.<p>It can be necessary to expose the proxy if an advised object needsto invoke a method on itself with advice applied. Otherwise, if anadvised object invokes a method on {@code this}, no advice will be applied.<p>Default is {@code false}, for optimal performance.Return whether the factory should expose the proxy as a {@link ThreadLocal}.<p>Getting the proxy is analogous to an EJB calling {@code getEJBObject()}.AopContextSet whether this proxy configuration is pre-filtered so that it onlycontains applicable advisors (matching this proxy's target class).<p>Default is "false". Set this to "true" if the advisors have beenpre-filtered already, meaning that the ClassFilter check can be skippedwhen building the actual advisor chain for proxy invocations.org.springframework.aop.ClassFilterReturn whether this proxy configuration is pre-filtered so that it onlyReturn the advisors applying to this proxy.a list of Advisors applying to this proxy (never {@code null})Return the number of advisors applying to this proxy.<p>The default implementation delegates to {@code getAdvisors().length}.5.3.1Add an advisor at the end of the advisor chain.<p>The Advisor may be an {@link org.springframework.aop.IntroductionAdvisor},in which new interfaces will be available when a proxy is next obtainedfrom the relevant factory.the advisor to add to the end of the chainin case of invalid adviceAdd an Advisor at the specified position in the chain.the advisor to add at the specified position in the chainposition in chain (0 is head). Must be valid.Remove the given advisor.the advisor to remove{@code true} if the advisor was removed; {@code false}if the advisor was not found and hence could not be removedRemove the advisor at the given index.the index of advisor to removeif the index is invalidReturn the index (from 0) of the given advisor,or -1 if no such advisor applies to this proxy.<p>The return value of this method can be used to index into the advisors array.the advisor to search forindex from 0 of this advisor, or -1 if there's no such advisorReplace the given advisor.<p><b>Note:</b> If the advisor is an {@link org.springframework.aop.IntroductionAdvisor}and the replacement is not or implements different interfaces, the proxy will needto be re-obtained or the old interfaces won't be supported and the new interfacewon't be implemented.the advisor to replacethe advisor to replace it withwhether it was replaced. If the advisor wasn't found in thelist of advisors, this method returns {@code false} and does nothing.Add the given AOP Alliance advice to the tail of the advice (interceptor) chain.<p>This will be wrapped in a DefaultPointcutAdvisor with a pointcut that alwaysapplies, and returned from the {@code getAdvisors()} method in this wrapped form.<p>Note that the given advice will apply to all invocations on the proxy,even to the {@code toString()} method! Use appropriate advice implementationsor specify appropriate pointcuts to apply to a narrower set of methods.the advice to add to the tail of the chain#addAdvice(int, Advice)org.springframework.aop.support.DefaultPointcutAdvisorAdd the given AOP Alliance Advice at the specified position in the advice chain.<p>This will be wrapped in a {@link org.springframework.aop.support.DefaultPointcutAdvisor}with a pointcut that always applies, and returned from the {@link #getAdvisors()}method in this wrapped form.<p>Note: The given advice will apply to all invocations on the proxy,index from 0 (head)the advice to add at the specified position in the advice chainRemove the Advisor containing the given advice.the advice to remove{@code true} of the advice was found and removed;{@code false} if there was no such adviceReturn the index (from 0) of the given AOP Alliance Advice,or -1 if no such advice is an advice for this proxy.<p>The return value of this method can be used to index intothe advisors array.the AOP Alliance advice to search forindex from 0 of this advice, or -1 if there's no such adviceAs {@code toString()} will normally be delegated to the target,this returns the equivalent for the AOP proxy.a string description of the proxy configurationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AdvisedSupport.javaAdvisedSupportC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AdvisedSupport.classgetConfigurationOnlyCopygetConfigurationOnlyCopy()addAdvisorInternaladdAdvisorInternal(int,org.springframework.aop.Advisor)validateIntroductionAdvisorvalidateIntroductionAdvisor(org.springframework.aop.IntroductionAdvisor)Map<MethodCacheKey,List<Object>>methodCacheadvisorChainFactory2651364800145442165L2651364800145442165ConcurrentHashMap<MethodCacheKey,List<Object>>AbstractMap<MethodCacheKey,List<Object>>ConcurrentMap<MethodCacheKey,List<Object>>ConcurrentHashMap<MethodCacheKey,List<Object>>(int)? super List<Object>? extends List<Object>BiFunction<? super List<Object>,? super List<Object>,? extends List<Object>>merge(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.List,java.util.function.BiFunction)? super MethodCacheKeyBiFunction<? super MethodCacheKey,? super List<Object>,? extends List<Object>>compute(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.function.BiFunction)computeIfPresent(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.function.BiFunction)Function<? super MethodCacheKey,? extends List<Object>>computeIfAbsent(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.function.Function)replace(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.List)replace(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.List,java.util.List)putIfAbsent(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.List)BiConsumer<? super MethodCacheKey,? super List<Object>>Entry<MethodCacheKey,List<Object>>Set<Entry<MethodCacheKey,List<Object>>>Collection<Entry<MethodCacheKey,List<Object>>>Iterable<Entry<MethodCacheKey,List<Object>>>Collection<List<Object>>Iterable<List<Object>>Set<MethodCacheKey>Collection<MethodCacheKey>Iterable<MethodCacheKey>? extends MethodCacheKeyMap<? extends MethodCacheKey,? extends List<Object>>put(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.List)AbstractMap<MethodCacheKey,List<Object>>()ToIntFunction<Entry<MethodCacheKey,List<Object>>>ToLongFunction<Entry<MethodCacheKey,List<Object>>>ToDoubleFunction<Entry<MethodCacheKey,List<Object>>>Function<Entry<MethodCacheKey,List<Object>>,? extends U>? extends Entry<MethodCacheKey,List<Object>>BiFunction<Entry<MethodCacheKey,List<Object>>,Entry<MethodCacheKey,List<Object>>,? extends Entry<MethodCacheKey,List<Object>>>? super Entry<MethodCacheKey,List<Object>>Consumer<? super Entry<MethodCacheKey,List<Object>>>ToIntFunction<? super List<Object>>ToLongFunction<? super List<Object>>ToDoubleFunction<? super List<Object>>Function<? super List<Object>,? extends U>Consumer<? super List<Object>>ToIntFunction<? super MethodCacheKey>ToLongFunction<? super MethodCacheKey>ToDoubleFunction<? super MethodCacheKey>Function<? super MethodCacheKey,? extends U>BiFunction<? super MethodCacheKey,? super MethodCacheKey,? extends MethodCacheKey>Consumer<? super MethodCacheKey>ToIntBiFunction<? super MethodCacheKey,? super List<Object>>ToLongBiFunction<? super MethodCacheKey,? super List<Object>>ToDoubleBiFunction<? super MethodCacheKey,? super List<Object>>BiFunction<? super MethodCacheKey,? super List<Object>,? extends U>Node<MethodCacheKey,List<Object>>Node<MethodCacheKey,List<Object>>[]KeySetView<MethodCacheKey,List<Object>>CollectionView<MethodCacheKey,List<Object>,MethodCacheKey>Enumeration<List<Object>>Enumeration<MethodCacheKey>Predicate<? super List<Object>>Predicate<? super Entry<MethodCacheKey,List<Object>>>putVal(org.springframework.aop.framework.AdvisedSupport.MethodCacheKey,java.util.List,boolean)ConcurrentHashMap<MethodCacheKey,List<Object>>(int,float,int)ConcurrentHashMap<MethodCacheKey,List<Object>>(int,float)ConcurrentHashMap<MethodCacheKey,List<Object>>(java.util.Map)ConcurrentHashMap<MethodCacheKey,List<Object>>()"AdvisorChainFactory must not be null"AdvisorChainFactory must not be null"Interfaces must not be null"Interfaces must not be nullifc"Interface must not be null"Interface must not be null"] is not an interface"] is not an interfaceproxyIntf"Cannot remove Advisor: Configuration is frozen."Cannot remove Advisor: Configuration is frozen."Advisor index "Advisor index " is out of bounds: " +
					"This configuration only has " is out of bounds: This configuration only has " advisors." advisors.ia"Advisor must not be null"Advisor must not be null"Advisor a must not be null"Advisor a must not be null"Advisor b must not be null"Advisor b must not be null"Cannot add advisor: Configuration is frozen."Cannot add advisor: Configuration is frozen."Illegal position "Illegal position " in advisor list with size " in advisor list with size "DynamicIntroductionAdvice may only be added as part of IntroductionAdvisor"DynamicIntroductionAdvice may only be added as part of IntroductionAdvisoradviceClasscacheKeycached? extends AdvisedSupportClass<? extends AdvisedSupport>Map<String,? extends AdvisedSupport>AdvisedSupport[]? extends AdvisedSupport[]Constructor<? extends AdvisedSupport>? super ? extends AdvisedSupportClass<? super ? extends AdvisedSupport>TypeVariable<Class<? extends AdvisedSupport>>TypeVariable<Class<? extends AdvisedSupport>>[]" interfaces " interfaces "; "; " advisors " advisors "targetSource ["targetSource ["]; "]; C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AdvisedSupport$MethodCacheKey.classAdvisedSupport$MethodCacheKeyComparable<MethodCacheKey>Base class for AOP proxy configuration managers.These are not themselves AOP proxies, but subclasses of this class arenormally factories from which AOP proxy instances are obtained directly.<p>This class frees subclasses of the housekeeping of Advicesand Advisors, but doesn't actually implement proxy creationmethods, which are provided by subclasses.<p>This class is serializable; subclasses need not be.This class is used to hold snapshots of proxies.org.springframework.aop.framework.AopProxyuse serialVersionUID from Spring 2.0 for interoperability.Canonical TargetSource when there's no target, and behavior issupplied by the advisors.Package-protected to allow direct access for efficiency.Whether the Advisors are already filtered for the specific target class.The AdvisorChainFactory to use.Cache with Method as key and advisor chain List as value.Interfaces to be implemented by the proxy. Held in List to keep the orderof registration, to create JDK proxy with specified order of interfaces.List of Advisors. If an Advice is added, it will be wrappedin an Advisor before being added to this List.No-arg constructor for use as a JavaBean.Create a AdvisedSupport instance with the given parameters.the proxied interfacesSet the given object as target.Will create a SingletonTargetSource for the object.#setTargetSourceSet a target class to be proxied, indicating that the proxyshould be castable to the given class.<p>Internally, an {@link org.springframework.aop.target.EmptyTargetSource}for the given target class will be used. The kind of proxy neededwill be determined on actual creation of the proxy.<p>This is a replacement for setting a "targetSource" or "target",for the case where we want a proxy based on a target class(which can be an interface or a concrete class) without havinga fully capable TargetSource available.#setTargetSet the advisor chain factory to use.<p>Default is a {@link DefaultAdvisorChainFactory}.Return the advisor chain factory to use (never {@code null}).Set the interfaces to be proxied.Add a new proxied interface.the additional interface to proxyRemove a proxied interface.<p>Does nothing if the given interface isn't proxied.the interface to remove from the proxy{@code true} if the interface was removed; {@code false}if the interface was not found and hence could not be removed We need to remove introduction interfaces.Add all of the given advisors to this proxy configuration.the advisors to register If the advisor passed validation, we can make the change.Allows uncontrolled access to the {@link List} of {@link Advisor Advisors}.<p>Use with care, and remember to {@link #adviceChanged() fire advice changed events}when making any modifications.Cannot add introductions this way unless the advice implements IntroductionInfo. We don't need an IntroductionAdvisor for this kind of introduction: It's fully self-describing. We need an IntroductionAdvisor for this kind of introduction.Is the given advice included in any advisor within this proxy configuration?the advice to check inclusion ofwhether this advice instance is includedCount advices of the given class.the advice class to checkthe count of the interceptors of this class or subclassesDetermine a list of {@link org.aopalliance.intercept.MethodInterceptor} objectsfor the given method, based on this configuration.the proxied methoda List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)Invoked when advice has changed.Call this method on a new instance created by the no-arg constructorto create an independent copy of the configuration from the given object.the AdvisedSupport object to copy configuration fromCopy the AOP configuration from the given AdvisedSupport object,but allow substitution of a fresh TargetSource and a given interceptor chain.the AdvisedSupport object to take proxy configuration fromthe new TargetSourcethe Advisors for the chainBuild a configuration-only copy of this AdvisedSupport,replacing the TargetSource. Rely on default serialization; just initialize state after deserialization.For debugging/diagnostic use.Simple wrapper class around a Method. Used as the key whencaching methods, for efficient equals and hashCode comparisons.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AdvisedSupportListener.javaAdvisedSupportListenerListener to be registered on {@link ProxyCreatorSupport} objectsAllows for receiving callbacks on activation and change of advice.ProxyCreatorSupport#addListenerInvoked when the first proxy is created.the AdvisedSupport objectInvoked when advice is changed after a proxy is created.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AdvisorChainFactory.javaAdvisorChainFactoryFactory interface for advisor chains.for the given advisor chain configuration.the AOP configuration in the form of an Advised objectthe target class (may be {@code null} to indicate a proxy withouttarget object, in which case the method's declaring class is the next best option)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AopConfigException.javaException that gets thrown on illegal AOP configuration arguments.Constructor for AopConfigException.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AopContext.javasetCurrentProxysetCurrentProxy(java.lang.Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AopContext.classAopContext()ThreadLocal<Object>C:/modules/java.base/java/lang/ThreadLocal.classThreadLocalcurrentProxyorg.springframework.coreNamedThreadLocal<Object>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/NamedThreadLocal.classNamedThreadLocalNamedThreadLocal<Object>(java.lang.String)childValuechildValue(java.lang.Object)createInheritedMapcreateInheritedMap(java.lang.ThreadLocal.ThreadLocalMap)createMapcreateMap(java.lang.Thread,java.lang.Object)getMapgetMap(java.lang.Thread)remove()set(java.lang.Object)isPresentisPresent()ThreadLocal()ThreadLocal<Object>()ThreadLocal<>SThreadLocal<S>withInitialwithInitial(java.util.function.Supplier)? extends SSupplier<? extends S>initialValueinitialValue()NamedThreadLocal(java.lang.String)"Current AOP proxy"Current AOP proxy"Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available, and " +
							"ensure that AopContext.currentProxy() is invoked in the same thread as the AOP invocation context."Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available, and ensure that AopContext.currentProxy() is invoked in the same thread as the AOP invocation context.oldClass containing static methods used to obtain information about the current AOP invocation.<p>The {@code currentProxy()} method is usable if the AOP framework is configured toexpose the current proxy (not the default). It returns the AOP proxy in use. Target objectsor advice can use this to make advised calls, in the same way as {@code getEJBObject()}can be used in EJBs. They can also use it to find advice configuration.<p>Spring's AOP framework does not expose proxies by default, as there is a performance costin doing so.<p>The functionality in this class might be used by a target object that needed accessto resources on the invocation. However, this approach should not be used when there isa reasonable alternative, as it makes application code dependent on usage under AOP andthe Spring AOP framework in particular.ThreadLocal holder for AOP proxy associated with this thread.Will contain {@code null} unless the "exposeProxy" property onthe controlling proxy configuration has been set to "true".ProxyConfig#setExposeProxyTry to return the current AOP proxy. This method is usable only if thecalling method has been invoked via AOP, and the AOP framework has been setto expose proxies. Otherwise, this method will throw an IllegalStateException.the current AOP proxy (never returns {@code null})if the proxy cannot be found, because themethod was invoked outside an AOP invocation context, or because theAOP framework has not been configured to expose the proxyMake the given proxy available via the {@code currentProxy()} method.<p>Note that the caller should be careful to keep the old value as appropriate.the proxy to expose (or {@code null} to reset it)the old proxy, which may be {@code null} if none was bound#currentProxy()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AopInfrastructureBean.javaAopInfrastructureBeanMarker interface that indicates a bean that is part of Spring'sAOP infrastructure. In particular, this implies that any such beanis not subject to auto-proxying, even if a pointcut would match.org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreatororg.springframework.aop.scope.ScopedProxyFactoryBeanC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AopProxy.javaAopProxyDelegate interface for a configured AOP proxy, allowing for the creationof actual proxy objects.<p>Out-of-the-box implementations are available for JDK dynamic proxiesand for CGLIB proxies, as applied by {@link DefaultAopProxyFactory}.DefaultAopProxyFactoryCreate a new proxy object.<p>Uses the AopProxy's default class loader (if necessary for proxy creation):usually, the thread context class loader.the new proxy object (never {@code null})Thread#getContextClassLoader(){@code null} will simply be passed down and thus lead to the low-levelproxy facility's default, which is usually different from the default chosenby the AopProxy implementation's {@link #getProxy()} method.(or {@code null} for the low-level proxy facility's default)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AopProxyFactory.javaAopProxyFactoryInterface to be implemented by factories that are able to createAOP proxies based on {@link AdvisedSupport} configuration objects.<p>Proxies should observe the following contract:<li>They should implement all interfaces that the configurationindicates should be proxied.<li>They should implement the {@link Advised} interface.<li>They should implement the equals method to compare proxiedinterfaces, advice, and target.<li>They should be serializable if all advisors and targetare serializable.<li>They should be thread-safe if advisors and targetare thread-safe.<p>Proxies may or may not allow advice changes to be made.If they do not permit advice changes (for example, becausethe configuration was frozen) a proxy should throw an{@link AopConfigException} on an attempted advice change.Create an {@link AopProxy} for the given AOP configuration.the AOP configuration in the form of anAdvisedSupport objectthe corresponding AOP proxyif the configuration is invalidC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AopProxyUtils.javaAopProxyUtilsadaptArgumentsIfNecessaryadaptArgumentsIfNecessary(java.lang.reflect.Method,java.lang.Object[])C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/AopProxyUtils.classcompleteProxiedInterfacescompleteProxiedInterfaces(org.springframework.aop.framework.AdvisedSupport,boolean)candidatecurrent"Candidate object must not be null"Candidate object must not be nulldecoratingProxyspecifiedInterfacesaddSpringProxyClass<SpringProxy>addAdvisedClass<Advised>addDecoratingProxyClass<DecoratingProxy>nonUserIfcCountproxiedInterfacesuserInterfaces"JDK proxy must implement one or more interfaces"JDK proxy must implement one or more interfacesvarargIndexvarargTypevarargArraynewArgumentstargetElementTypevarargLengthnewVarargArrayUtility methods for AOP proxy factories.Mainly for internal use within the AOP framework.<p>See {@link org.springframework.aop.support.AopUtils} for a collection ofgeneric AOP utility methods which do not depend on AOP framework internals.org.springframework.aop.support.AopUtilsObtain the singleton target object behind the given proxy, if any.the (potential) proxy to checkthe singleton target object managed in a {@link SingletonTargetSource},or {@code null} in any other case (not a proxy, not an existing singleton target)4.3.8Advised#getTargetSource()SingletonTargetSource#getTarget()Determine the ultimate target class of the given bean instance, traversingnot only a top-level proxy but any number of nested proxies as well &mdash;as long as possible without side effects, that is, just for singleton targets.the instance to check (might be an AOP proxy)the ultimate target class (or the plain class of the givenobject as fallback; never {@code null})org.springframework.aop.TargetClassAware#getTargetClass()Determine the complete set of interfaces to proxy for the given AOP configuration.<p>This will always add the {@link Advised} interface unless the AdvisedSupport's{@link AdvisedSupport#setOpaque "opaque"} flag is on. Always adds the{@link org.springframework.aop.SpringProxy} marker interface.the proxy configthe complete set of interfaces to proxywhether to expose the {@link DecoratingProxy} interfaceDecoratingProxy No user-specified interfaces: check whether target class is an interface.Extract the user-specified interfaces that the given proxy implements,i.e. all non-Advised interfaces that the proxy implements.the proxy to analyze (usually a JDK dynamic proxy)all user-specified interfaces that the proxy implements,in the original order (never {@code null} or empty)Check equality of the proxies behind the given AdvisedSupport objects.Not the same as equality of the AdvisedSupport objects:rather, equality of interfaces, advisors and target sources.Check equality of the proxied interfaces behind the given AdvisedSupport objects.Check equality of the advisors behind the given AdvisedSupport objects.Adapt the given arguments to the target signature in the given method,if necessary: in particular, if a given vararg argument array does notmatch the array type of the declared vararg parameter in the method.the target methodthe given argumentsa cloned argument array, or the original if no adaptation is neededC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.javaCglibAopProxyprocessReturnTypeprocessReturnType(java.lang.Object,java.lang.Object,java.lang.reflect.Method,java.lang.Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy.classimplementsInterfaceimplementsInterface(java.lang.reflect.Method,java.util.Set)Callback[]getCallbacksgetCallbacks(java.lang.Class)doValidateClassdoValidateClass(java.lang.Class,java.lang.ClassLoader,java.util.Set)validateClassIfNecessaryvalidateClassIfNecessary(java.lang.Class,java.lang.ClassLoader)fixedInterceptorOffsetMap<Method,Integer>fixedInterceptorMapadvisedDispatchervalidatedClassesINVOKE_HASHCODEINVOKE_EQUALSDISPATCH_ADVISEDDISPATCH_TARGETNO_OVERRIDEINVOKE_TARGETAOP_PROXYClass<CglibAopProxy>WeakHashMap<Class<?>,Boolean>C:/modules/java.base/java/util/WeakHashMap.classWeakHashMapWeakHashMap<Class<?>,Boolean>()removeMappingremoveMapping(java.lang.Object)resize(int)C:/modules/java.base/java/util/WeakHashMap$Entry.classWeakHashMap$Entryjava.lang.refWeakReference<>C:/modules/java.base/java/lang/ref/WeakReference.classWeakReferenceC:/modules/java.base/java/lang/refReference<>C:/modules/java.base/java/lang/ref/Reference.classReferenceWeakHashMap<>WeakReference<Object>Reference<Object>getEntrygetEntry(java.lang.Object)unmaskNullunmaskNull(java.lang.Object)WeakHashMap(java.util.Map)WeakHashMap<Class<?>,Boolean>(java.util.Map)WeakHashMap()WeakHashMap(int)WeakHashMap<Class<?>,Boolean>(int)WeakHashMap(int,float)WeakHashMap<Class<?>,Boolean>(int,float)Entry<K,V>[]"AdvisedSupport must not be null"AdvisedSupport must not be null"No advisors and no TargetSource specified"No advisors and no TargetSource specifiedconstructorArgsconstructorArgTypes"Both 'constructorArgs' and 'constructorArgTypes' need to be specified"Both 'constructorArgs' and 'constructorArgTypes' need to be specified"Number of 'constructorArgs' ("Number of 'constructorArgs' (") must match number of 'constructorArgTypes' (") must match number of 'constructorArgTypes' ("Creating CGLIB proxy: "Creating CGLIB proxy: rootClassproxySuperClassenhancercallbacks"Target class must be available for creating a CGLIB proxy"Target class must be available for creating a CGLIB proxyadditionalInterfacesadditionalInterfaceorg.springframework.cglib.coreAbstractClassGenerator<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/cglibcglibC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/cglib/coreC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/cglib/core/AbstractClassGenerator.classAbstractClassGeneratorsetClassLoadersetClassLoader(java.lang.ClassLoader)nextInstancenextInstance(java.lang.Object)firstInstancefirstInstance(java.lang.Class)generate(org.springframework.cglib.core.AbstractClassGenerator.ClassLoaderData)createcreate(java.lang.Object)getDefaultClassLoadergetDefaultClassLoader()getCurrentgetCurrent()getStrategygetStrategy()setStrategysetStrategy(org.springframework.cglib.core.GeneratorStrategy)getAttemptLoadgetAttemptLoad()setAttemptLoadsetAttemptLoad(boolean)getUseCachegetUseCache()setUseCachesetUseCache(boolean)getNamingPolicygetNamingPolicy()setNamingPolicysetNamingPolicy(org.springframework.cglib.core.NamingPolicy)setContextClasssetContextClass(java.lang.Class)getClassNamegetClassName()setNamePrefixsetNamePrefix(java.lang.String)AbstractClassGenerator(org.springframework.cglib.core.AbstractClassGenerator.Source)AbstractClassGenerator<>(org.springframework.cglib.core.AbstractClassGenerator.Source)unwrapCachedValueunwrapCachedValue(java.lang.Object)wrapCachedClasswrapCachedClass(java.lang.Class)x? extends CallbackClass<? extends Callback>"Could not generate CGLIB subclass of "Could not generate CGLIB subclass of ": Common causes of this problem include using a final class or a non-visible class": Common causes of this problem include using a final class or a non-visible class"Unexpected AOP exception"Unexpected AOP exceptionmod"Unable to proxy interface-implementing method ["Unable to proxy interface-implementing method ["] because " +
									"it is marked as final: Consider using interface-based JDK proxies instead!"] because it is marked as final: Consider using interface-based JDK proxies instead!"Final method ["Final method ["] cannot get proxied via CGLIB: " +
									"Calls to this method will NOT be routed to the target instance and " +
									"might lead to NPEs against uninitialized fields in the proxy instance."] cannot get proxied via CGLIB: Calls to this method will NOT be routed to the target instance and might lead to NPEs against uninitialized fields in the proxy instance."Method ["Method ["] is package-visible across different ClassLoaders " +
								"and cannot get proxied via CGLIB: Declare this method as public or protected " +
								"if you need to support invocations through the proxy."] is package-visible across different ClassLoaders and cannot get proxied via CGLIB: Declare this method as public or protected if you need to support invocations through the proxy.isFrozenisStaticaopInterceptortargetInterceptortargetDispatchermainCallbacksfixedCallbacksHashMap<Method,Integer>AbstractMap<Method,Integer>chainput(java.lang.reflect.Method,java.lang.Integer)merge(java.lang.reflect.Method,java.lang.Integer,java.util.function.BiFunction)BiFunction<? super Method,? super Integer,? extends Integer>Function<? super Method,? extends Integer>replace(java.lang.reflect.Method,java.lang.Integer)replace(java.lang.reflect.Method,java.lang.Integer,java.lang.Integer)putIfAbsent(java.lang.reflect.Method,java.lang.Integer)BiConsumer<? super Method,? super Integer>Entry<Method,Integer>Set<Entry<Method,Integer>>Collection<Entry<Method,Integer>>Iterable<Entry<Method,Integer>>Map<? extends Method,? extends Integer>returnTypeClass<RawTargetAccess>Map<String,RawTargetAccess>RawTargetAccess[]Constructor<RawTargetAccess>? super RawTargetAccessClass<? super RawTargetAccess>TypeVariable<Class<RawTargetAccess>>TypeVariable<Class<RawTargetAccess>>[]"Null return value from advice does not match primitive return type for: "Null return value from advice does not match primitive return type for: C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$StaticUnadvisedInterceptor.classCglibAopProxy$StaticUnadvisedInterceptormethodProxyretValC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$StaticUnadvisedExposedInterceptor.classCglibAopProxy$StaticUnadvisedExposedInterceptoroldProxyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$DynamicUnadvisedInterceptor.classCglibAopProxy$DynamicUnadvisedInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$DynamicUnadvisedExposedInterceptor.classCglibAopProxy$DynamicUnadvisedExposedInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$StaticDispatcher.classCglibAopProxy$StaticDispatcherC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$AdvisedDispatcher.classCglibAopProxy$AdvisedDispatcherC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$EqualsInterceptor.classCglibAopProxy$EqualsInterceptorcallbackotherAdvisedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$HashCodeInterceptor.classCglibAopProxy$HashCodeInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$FixedChainStaticTargetInterceptor.classCglibAopProxy$FixedChainStaticTargetInterceptoradviceChainC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$DynamicAdvisedInterceptor.classCglibAopProxy$DynamicAdvisedInterceptorsetProxyContextSpliterator<Object>Iterator<Object>Stream<Object>BaseStream<Object,Stream<Object>>ListIterator<Object>UnaryOperator<Object>Function<Object,Object>argsToUseC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$CglibMethodInvocation.classCglibAopProxy$CglibMethodInvocationinterceptorsAndDynamicMethodMatchersequalsPointcutsequalsPointcuts(org.springframework.aop.Advisor,org.springframework.aop.Advisor)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/CglibAopProxy$ProxyCallbackFilter.classCglibAopProxy$ProxyCallbackFilterequalsAdviceClassesequalsAdviceClasses(org.springframework.aop.Advisor,org.springframework.aop.Advisor)haveAdviceSpliterator<?>Consumer<? super ?>Iterator<?>Stream<?>BaseStream<?,Stream<?>>Predicate<? super ?>ListIterator<?>Comparator<? super ?>UnaryOperator<?>Function<?,?>"Found finalize() method - using NO_OVERRIDE"Found finalize() method - using NO_OVERRIDE"Method is declared on Advised interface: "Method is declared on Advised interface: "Found 'equals' method: "Found 'equals' method: "Found 'hashCode' method: "Found 'hashCode' method: "Must expose proxy on advised method: "Must expose proxy on advised method: "Method has advice and optimizations are enabled: "Method has advice and optimizations are enabled: "Unable to apply any optimizations to advised method: "Unable to apply any optimizations to advised method: "Method return type is assignable from target type and " +
								"may therefore return 'this' - using INVOKE_TARGET: "Method return type is assignable from target type and may therefore return 'this' - using INVOKE_TARGET: "Method return type ensures 'this' cannot be returned - " +
								"using DISPATCH_TARGET: "Method return type ensures 'this' cannot be returned - using DISPATCH_TARGET: otherCallbackFilterthisAdvisorsthatAdvisorsthisAdvisorthatAdvisorCGLIB-based {@link AopProxy} implementation for the Spring AOP framework.<p>Objects of this type should be obtained through proxy factories,configured by an {@link AdvisedSupport} object. This class is internalto Spring's AOP framework and need not be used directly by client code.<p>{@link DefaultAopProxyFactory} will automatically create CGLIB-basedproxies if necessary, for example in case of proxying a target class(see the {@link DefaultAopProxyFactory attendant javadoc} for details).<p>Proxies created using this class are thread-safe if the underlying(target) class is thread-safe.org.springframework.cglib.proxy.EnhancerAdvisedSupport#setProxyTargetClass Constants for CGLIB callback array indicesLogger available to subclasses; static to optimize serialization.Keeps track of the Classes that we have validated for final methods.The configuration used to configure this proxy.Dispatcher used for methods on Advised.Create a new CglibAopProxy for the given AOP configuration.the AOP configuration as AdvisedSupport objectif the config is invalid. We try to throw an informativeexception in this case, rather than let a mysterious failure happen later.Set constructor arguments to use for creating the proxy.the constructor argument valuesthe constructor argument types Validate the class, writing log messages as necessary. Configure CGLIB Enhancer... fixedInterceptorMap only populated at this point, after getCallbacks call above Generate the proxy class and create a proxy instance. TargetSource.getTarget() failedCreates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom{@link Enhancer} implementation.Checks to see whether the supplied {@code Class} has already been validated andvalidates it if not.Checks for final methods on the given {@code Class}, as well as package-visiblemethods across ClassLoaders, and writes warnings to the log for each one found. Parameters used for optimization choices... Choose an "aop" interceptor (used for AOP calls). Choose a "straight to target" interceptor. (used for calls that are unadvised but can return this). May be required to expose the proxy. Choose a "direct to target" dispatcher (used for unadvised calls to static targets that cannot return this). for normal advice invoke target without considering advice, if optimized no override for methods mapped to this If the target is a static one and the advice chain is frozen, then we can make some optimizations by sending the AOP calls direct to the target using the fixed chain for that method. TODO: small memory optimization here (can skip creation for methods with no advice) Now copy both the callbacks from mainCallbacks and fixedCallbacks into the callbacks array.Check whether the given method is declared on any of the given interfaces.Process a return value. Wraps a return of {@code this} if necessary to be the{@code proxy} and also verifies that {@code null} is not returned as a primitive. Massage return value if necessary Special case: it returned "this". Note that we can't help if the target sets a reference to itself in another returned object.Serializable replacement for CGLIB's NoOp interface.Public to allow use elsewhere in the framework.Method interceptor used for static targets with no advice chain. The callis passed directly back to the target. Used when the proxy needs to beexposed and it can't be determined that the method won't return{@code this}.Method interceptor used for static targets with no advice chain, when theproxy is to be exposed.Interceptor used to invoke a dynamic target without creating a methodinvocation or evaluating an advice chain. (We know there was no advicefor this method.)Interceptor for unadvised dynamic targets when the proxy needs exposing.Dispatcher for a static target. Dispatcher is much faster thaninterceptor. This will be used whenever it can be determined that amethod definitely does not return "this"Dispatcher for any methods declared on the Advised class.Dispatcher for the {@code equals} method.Ensures that the method call is always handled by this class.Dispatcher for the {@code hashCode} method.Interceptor used specifically for advised methods on a frozen, static proxy. If we get here, we need to create a MethodInvocation.General purpose AOP callback. Used when the target is dynamic or when theproxy is not frozen. Make invocation available if necessary. Get as late as possible to minimize the time we "own" the target, in case it comes from a pool... Check whether we only have one InvokerInterceptor: that is, no real advice, but just reflective invocation of the target. We can skip creating a MethodInvocation: just invoke the target directly. Note that the final invoker must be an InvokerInterceptor, so we know it does nothing but a reflective operation on the target, and no hot swapping or fancy proxying. We need to create a method invocation... Restore old proxy.CGLIB uses this to drive proxy creation.Implementation of AOP Alliance MethodInvocation used by this AOP proxy. Only use method proxy for public methods not derived from java.lang.Object Propagate original exception if declared on the target method (with callers expecting it). Always propagate it for Kotlin code since checked exceptions do not have to be explicitly declared there. Checked exception thrown in the interceptor but not declared on the target method signature -> apply an UndeclaredThrowableException, aligned with standard JDK dynamic proxy behavior.Gives a marginal performance improvement versus using reflection toinvoke the target when invoking public methods.CallbackFilter to assign Callbacks to methods.Implementation of CallbackFilter.accept() to return the index of thecallback we need.<p>The callbacks for each proxy are built up of a set of fixed callbacksfor general use and then a set of callbacks that are specific to a methodfor use on static targets with a fixed advice chain.<p>The callback used is determined thus:<dl><dt>For exposed proxies</dt><dd>Exposing the proxy requires code to execute before and after themethod/chain invocation. This means we must useDynamicAdvisedInterceptor, since all other interceptors can avoid theneed for a try/catch block</dd><dt>For Object.finalize():</dt><dd>No override for this method is used.</dd><dt>For equals():</dt><dd>The EqualsInterceptor is used to redirect equals() calls to aspecial handler to this proxy.</dd><dt>For methods on the Advised class:</dt><dd>the AdvisedDispatcher is used to dispatch the call directly tothe target</dd><dt>For advised methods:</dt><dd>If the target is static and the advice chain is frozen then aFixedChainStaticTargetInterceptor specific to the method is used toinvoke the advice chain. Otherwise a DynamicAdvisedInterceptor isused.</dd><dt>For non-advised methods:</dt><dd>Where it can be determined that the method will not return {@code this}or when {@code ProxyFactory.getExposeProxy()} returns {@code false},then a Dispatcher is used. For static targets, the StaticDispatcher is used;and for dynamic targets, a DynamicUnadvisedInterceptor is used.If it possible for the method to return {@code this} then aStaticUnadvisedInterceptor is used for static targets - theDynamicUnadvisedInterceptor already considers this.</dd></dl> We must always proxy equals, to direct calls to this. We must always calculate hashCode based on the proxy. Proxy is not yet available, but that shouldn't matter. If exposing the proxy, then AOP_PROXY must be used. Check to see if we have fixed interceptor to serve this method. Else use the AOP_PROXY. We know that we are optimizing so we can use the FixedStaticChainInterceptors. See if the return type of the method is outside the class hierarchy of the target type. If so we know it never needs to have return type massage and can use a dispatcher. If the proxy is being exposed, then must use the interceptor the correct one is already configured. If the target is not static, then we cannot use a dispatcher because the target needs to be explicitly released after the invocation. Advice instance identity is unimportant to the proxy class: All that matters is type and ordering. If only one of the advisor (but not both) is PointcutAdvisor, then it is a mismatch. Takes care of the situations where an IntroductionAdvisor is used (see SPR-3959).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.javaDefaultAdvisorChainFactoryhasMatchingIntroductionshasMatchingIntroductions(org.springframework.aop.Advisor[],java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAdvisorChainFactory.classinterceptorListArrayList<Object>AbstractList<Object>AbstractCollection<Object>ArrayList<Object>(int)AbstractCollection<Object>()AbstractList<Object>()ArrayList<Object>(java.util.Collection)ArrayList<Object>()actualClasspointcutAdvisormmmatchMethodInterceptor[]interceptorsList<MethodInterceptor>Collection<MethodInterceptor>Iterable<MethodInterceptor>Interceptor[]List<Interceptor>Collection<Interceptor>Iterable<Interceptor>A simple but definitive way of working out an advice chain for a Method,given an {@link Advised} object. Always rebuilds each advice chain;caching can be provided by subclasses. This is somewhat tricky... We have to process introductions first, but we need to preserve order in the ultimate list. Add it conditionally. Creating a new object instance in the getInterceptors() method isn't a problem as we normally cache created chains.Determine whether the Advisors contain matching introductions.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAopProxyFactory.javahasNoUserSuppliedProxyInterfaceshasNoUserSuppliedProxyInterfaces(org.springframework.aop.framework.AdvisedSupport)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/DefaultAopProxyFactory.classIN_NATIVE_IMAGE"org.graalvm.nativeimage.imagecode"org.graalvm.nativeimage.imagecode"TargetSource cannot determine target class: " +
						"Either an interface or a target is required for proxy creation."TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.Map<String,SpringProxy>SpringProxy[]Constructor<SpringProxy>? super SpringProxyClass<? super SpringProxy>TypeVariable<Class<SpringProxy>>TypeVariable<Class<SpringProxy>>[]Default {@link AopProxyFactory} implementation, creating either a CGLIB proxyor a JDK dynamic proxy.<p>Creates a CGLIB proxy if one the following is true for a given{@link AdvisedSupport} instance:<li>the {@code optimize} flag is set<li>the {@code proxyTargetClass} flag is set<li>no proxy interfaces have been specified<p>In general, specify {@code proxyTargetClass} to enforce a CGLIB proxy,or specify one or more interfaces to use a JDK dynamic proxy.Sebastien Deleuze12.03.2004AdvisedSupport#setOptimizeAdvisedSupport#setInterfacesWhether this environment lives within a native image.Exposed as a private static field rather than in a {@code NativeImageDetector.inNativeImage()} static method due to https://github.com/oracle/graal/issues/2594.<a href="https://github.com/oracle/graal/blob/master/sdk/src/org.graalvm.nativeimage/src/org/graalvm/nativeimage/ImageInfo.java">ImageInfo.java</a>Determine whether the supplied {@link AdvisedSupport} has only the{@link org.springframework.aop.SpringProxy} interface specified(or no proxy interfaces specified at all).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/InterceptorAndDynamicMethodMatcher.javaInterceptorAndDynamicMethodMatchermethodMatcherC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/InterceptorAndDynamicMethodMatcher.classInternal framework class, combining a MethodInterceptor instancewith a MethodMatcher for use as an element in the advisor chain.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/JdkDynamicAopProxy.javaJdkDynamicAopProxyfindDefinedEqualsAndHashCodeMethodsfindDefinedEqualsAndHashCodeMethods(java.lang.Class[])C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/JdkDynamicAopProxy.classhashCodeDefinedequalsDefined5531744639992436476L5531744639992436476Class<JdkDynamicAopProxy>"Creating JDK dynamic proxy: "Creating JDK dynamic proxy: proxiedInterfaceotherProxyihJDK-based {@link AopProxy} implementation for the Spring AOP framework,based on JDK {@link java.lang.reflect.Proxy dynamic proxies}.<p>Creates a dynamic proxy, implementing the interfaces exposed bythe AopProxy. Dynamic proxies <i>cannot</i> be used to proxy methodsdefined in classes, rather than interfaces.configured by an {@link AdvisedSupport} class. This class is internal<p>Proxies created using this class will be thread-safe if theunderlying (target) class is thread-safe.<p>Proxies are serializable so long as all Advisors (including Advicesand Pointcuts) and the TargetSource are serializable.Sergey Tsypanovjava.lang.reflect.ProxyProxyFactoryuse serialVersionUID from Spring 1.2 for interoperability.NOTE: We could avoid the code duplication between this class and the CGLIBproxies by refactoring "invoke" into a template method. However, this approachadds at least 10% performance overhead versus a copy-paste solution, so we sacrificeelegance for performance. (We have a good test suite to ensure that the differentproxies behave the same :-)This way, we can also more easily take advantage of minor optimizations in each class.We use a static Log to avoid serialization issues.Config used to configure this proxy.Is the {@link #equals} method defined on the proxied interfaces?Is the {@link #hashCode} method defined on the proxied interfaces?Construct a new JdkDynamicAopProxy for the given AOP configuration.Finds any {@link #equals} or {@link #hashCode} method that may be definedon the supplied set of interfaces.the interfaces to introspectImplementation of {@code InvocationHandler.invoke}.<p>Callers will see exactly the exception thrown by the target,unless a hook method throws an exception. The target does not implement the equals(Object) method itself. The target does not implement the hashCode() method itself. There is only getDecoratedClass() declared -> dispatch to proxy config. Service invocations on ProxyConfig with the proxy config... Get as late as possible to minimize the time we "own" the target, in case it comes from a pool. Get the interception chain for this method. Check whether we have any advice. If we don't, we can fallback on direct reflective invocation of the target, and avoid creating a MethodInvocation. We can skip creating a MethodInvocation: just invoke the target directly Note that the final invoker must be an InvokerInterceptor so we know it does nothing but a reflective operation on the target, and no hot swapping or fancy proxying. Proceed to the joinpoint through the interceptor chain. Massage return value if necessary. Special case: it returned "this" and the return type of the method is type-compatible. Note that we can't help if the target sets a reference to itself in another returned object. Must have come from TargetSource.Equality means interfaces, advisors and TargetSource are equal.<p>The compared object may be a JdkDynamicAopProxy instance itselfor a dynamic proxy wrapping a JdkDynamicAopProxy instance. Not a valid comparison... If we get here, otherProxy is the other AopProxy.Proxy uses the hash code of the TargetSource.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ObjenesisCglibAopProxy.javaObjenesisCglibAopProxyobjenesisC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ObjenesisCglibAopProxy.classClass<ObjenesisCglibAopProxy>proxyClassproxyInstance"Unable to instantiate proxy using Objenesis, " +
						"falling back to regular proxy construction"Unable to instantiate proxy using Objenesis, falling back to regular proxy construction"Unable to instantiate proxy using Objenesis, " +
						"and regular proxy instantiation via default constructor fails as well"Unable to instantiate proxy using Objenesis, and regular proxy instantiation via default constructor fails as wellObjenesis-based extension of {@link CglibAopProxy} to create proxy instanceswithout invoking the constructor of the class. Used by default as of Spring 4.Oliver Gierke4.0Create a new ObjenesisCglibAopProxy for the given AOP configuration. Regular instantiation via default constructor...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyConfig.javaProxyConfigfrozenC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyConfig.classopaqueoptimize8409359707199703185L8409359707199703185"Other ProxyConfig object must not be null"Other ProxyConfig object must not be null"proxyTargetClass="proxyTargetClass="optimize="optimize="opaque="opaque="exposeProxy="exposeProxy="frozen="frozen=Convenience superclass for configuration used in creating proxies,to ensure that all proxy creators have consistent properties.Set whether to proxy the target class directly, instead of just proxyingspecific interfaces. Default is "false".<p>Set this to "true" to force proxying for the TargetSource's exposedtarget class. If that target class is an interface, a JDK proxy will becreated for the given interface. If that target class is any other class,a CGLIB proxy will be created for the given class.<p>Note: Depending on the configuration of the concrete proxy factory,the proxy-target-class behavior will also be applied if no interfaceshave been specified (and no interface autodetection is activated).org.springframework.aop.TargetSource#getTargetClass()Return whether to proxy the target class directly as well as any interfaces.Set whether proxies should perform aggressive optimizations.The exact meaning of "aggressive optimizations" will differbetween proxies, but there is usually some tradeoff.Default is "false".<p>For example, optimization will usually mean that advice changes won'ttake effect after a proxy has been created. For this reason, optimizationis disabled by default. An optimize value of "true" may be ignoredif other settings preclude optimization: for example, if "exposeProxy"is set to "true" and that's not compatible with the optimization.Return whether proxies should perform aggressive optimizations.Set whether proxies created by this configuration should be preventedfrom being cast to {@link Advised} to query proxy status.<p>Default is "false", meaning that any AOP proxy can be cast to{@link Advised}.Return whether proxies created by this configuration should beprevented from being cast to {@link Advised}.ThreadLocal for retrieval via the AopContext class. This is usefulif an advised object needs to call another advised method on itself.(If it uses {@code this}, the invocation will not be advised).<p>Default is "false", in order to avoid unnecessary extra interception.This means that no guarantees are provided that AopContext access willwork consistently within any method of the advised object.Return whether the AOP proxy will expose the AOP proxy foreach invocation.Set whether this config should be frozen.<p>When a config is frozen, no advice changes can be made. This isuseful for optimization, and useful when we don't want callers tobe able to manipulate configuration after casting to Advised.Return whether the config is frozen, and no advice changes can be made.Copy configuration from the other config object.object to copy configuration fromC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyCreatorSupport.javaProxyCreatorSupportactivateactivate()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyCreatorSupport.classactiveList<AdvisedSupportListener>Collection<AdvisedSupportListener>Iterable<AdvisedSupportListener>listenersaopProxyFactoryArrayList<AdvisedSupportListener>AbstractList<AdvisedSupportListener>AbstractCollection<AdvisedSupportListener>ArrayList<AdvisedSupportListener>()Spliterator<AdvisedSupportListener>? super AdvisedSupportListenerConsumer<? super AdvisedSupportListener>Iterator<AdvisedSupportListener>Stream<AdvisedSupportListener>BaseStream<AdvisedSupportListener,Stream<AdvisedSupportListener>>Predicate<? super AdvisedSupportListener>? extends AdvisedSupportListenerCollection<? extends AdvisedSupportListener>Iterable<? extends AdvisedSupportListener>add(org.springframework.aop.framework.AdvisedSupportListener)AbstractCollection<AdvisedSupportListener>()ListIterator<AdvisedSupportListener>add(int,org.springframework.aop.framework.AdvisedSupportListener)set(int,org.springframework.aop.framework.AdvisedSupportListener)Comparator<? super AdvisedSupportListener>UnaryOperator<AdvisedSupportListener>Function<AdvisedSupportListener,AdvisedSupportListener>AbstractList<AdvisedSupportListener>()ArrayList<AdvisedSupportListener>(java.util.Collection)ArrayList<AdvisedSupportListener>(int)"AopProxyFactory must not be null"AopProxyFactory must not be nulllistener"AdvisedSupportListener must not be null"AdvisedSupportListener must not be nullBase class for proxy factories.Provides convenient access to a configurable AopProxyFactory.#createAopProxy()Set to true when the first AOP proxy has been created.Create a new ProxyCreatorSupport instance.the AopProxyFactory to useCustomize the AopProxyFactory, allowing different strategiesto be dropped in without changing the core framework.<p>Default is {@link DefaultAopProxyFactory}, using dynamic JDKproxies or CGLIB proxies based on the requirements.Return the AopProxyFactory that this ProxyConfig uses.Add the given AdvisedSupportListener to this proxy configuration.the listener to registerRemove the given AdvisedSupportListener from this proxy configuration.the listener to deregisterSubclasses should call this to get a new AOP proxy. They should <b>not</b>create an AOP proxy with {@code this} as an argument.Activate this proxy configuration.AdvisedSupportListener#activatedPropagate advice change event to all AdvisedSupportListeners.AdvisedSupportListener#adviceChangedSubclasses can call this to check whether any AOP proxies have been created yet.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyFactory.javaproxyInterface"Cannot create class proxy for TargetSource with null target class"Cannot create class proxy for TargetSource with null target classFactory for AOP proxies for programmatic use, rather than via declarativesetup in a bean factory. This class provides a simple way of obtainingand configuring AOP proxy instances in custom user code.14.03.2003Create a new ProxyFactory.<p>No target, only interfaces. Must add interceptors.the interfaces that the proxy should implementCreate a new ProxyFactory for the given interface and interceptor.<p>Convenience method for creating a proxy for a single interceptor,assuming that the interceptor handles all calls itself rather thandelegating to a target, like in the case of remoting proxies.the interface that the proxy should implementthe interceptor that the proxy should invokeCreate a ProxyFactory for the specified {@code TargetSource},making the proxy implement the specified interface.the TargetSource that the proxy should invokethe proxy objectCreate a new proxy for the given interface and interceptor.#ProxyFactory(Class, org.aopalliance.intercept.Interceptor)Create a proxy for the specified {@code TargetSource},implementing the specified interface.#ProxyFactory(Class, org.springframework.aop.TargetSource)Create a proxy for the specified {@code TargetSource} that extendsthe target class of the {@code TargetSource}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyFactoryBean.javaProxyFactoryBeanC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyFactoryBean.classnamedBeanToAdvisornamedBeanToAdvisor(java.lang.Object)freshTargetSourcefreshTargetSource()addAdvisorOnChainCreationaddAdvisorOnChainCreation(java.lang.Object)addGlobalAdvisorsaddGlobalAdvisors(org.springframework.beans.factory.ListableBeanFactory,java.lang.String)freshAdvisorChainfreshAdvisorChain()initializeAdvisorChaininitializeAdvisorChain()synchronizedisNamedBeanAnAdvisorOrAdviceisNamedBeanAnAdvisorOrAdvice(java.lang.String)checkInterceptorNamescheckInterceptorNames()newPrototypeInstancenewPrototypeInstance()getSingletonInstancegetSingletonInstance()singletonInstanceadvisorChainInitializedclassLoaderConfiguredfreezeProxyautodetectInterfacestargetName? extends ProxyFactoryBeanClass<? extends ProxyFactoryBean>"*"*"Using non-singleton proxies with singleton targets is often undesirable. " +
						"Enable prototype proxies by setting the 'targetName' property."Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the 'targetName' property."Cannot determine target class for proxy"Cannot determine target class for proxyaopProxyfinalName"' concluding interceptor chain " +
								"is not an advisor class: treating it as a target or TargetSource"' concluding interceptor chain is not an advisor class: treating it as a target or TargetSourcenamedBeanClassClass<Advisor>Map<String,Advisor>Constructor<Advisor>Class<? super Advisor>TypeVariable<Class<Advisor>>TypeVariable<Class<Advisor>>[]Class<Advice>Map<String,Advice>Constructor<Advice>? super AdviceClass<? super Advice>TypeVariable<Class<Advice>>TypeVariable<Class<Advice>>[]"Could not determine type of bean with name '"Could not determine type of bean with name '"' - assuming it is neither an Advisor nor an Advice"' - assuming it is neither an Advisor nor an Advice"No BeanFactory available anymore (probably due to serialization) " +
						"- cannot resolve interceptor names "No BeanFactory available anymore (probably due to serialization) - cannot resolve interceptor names "Target required after globals"Target required after globals"Can only use global advisors or interceptors with a ListableBeanFactory"Can only use global advisors or interceptors with a ListableBeanFactoryfreshAdvisorsparefreshedAdvisor"Refreshing bean named '"Refreshing bean named '"No BeanFactory available anymore (probably due to " +
							"serialization) - cannot resolve prototype advisor '"No BeanFactory available anymore (probably due to serialization) - cannot resolve prototype advisor 'prefixglobalAdvisorNamesglobalInterceptorNamesClass<Interceptor>next"No BeanFactory available anymore (probably due to serialization) " +
						"- cannot resolve target with name '"No BeanFactory available anymore (probably due to serialization) - cannot resolve target with name '"Refreshing target with name '"Refreshing target with name '"Unknown advisor type "Unknown advisor type "; can only include Advisor or Advice type beans in interceptorNames chain " +
					"except for last entry which may also be target instance or TargetSource"; can only include Advisor or Advice type beans in interceptorNames chain except for last entry which may also be target instance or TargetSource"Advice has changed; re-caching singleton instance"Advice has changed; re-caching singleton instanceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyFactoryBean$PrototypePlaceholderAdvisor.classProxyFactoryBean$PrototypePlaceholderAdvisor"Placeholder for prototype Advisor/Advice with bean name '"Placeholder for prototype Advisor/Advice with bean name '"Cannot invoke methods: "Cannot invoke methods: {@link org.springframework.beans.factory.FactoryBean} implementation that builds anAOP proxy based on beans in Spring {@link org.springframework.beans.factory.BeanFactory}.<p>{@link org.aopalliance.intercept.MethodInterceptor MethodInterceptors} and{@link org.springframework.aop.Advisor Advisors} are identified by a list of beannames in the current bean factory, specified through the "interceptorNames" property.The last entry in the list can be the name of a target bean or a{@link org.springframework.aop.TargetSource}; however, it is normally preferableto use the "targetName"/"target"/"targetSource" properties instead.<p>Global interceptors and advisors can be added at the factory level. The specifiedones are expanded in an interceptor list where an "xxx*" entry is included in thelist, matching the given prefix with the bean names (e.g. "global*" would matchboth "globalBean1" and "globalBean2", "*" all defined interceptors). The matchinginterceptors get applied according to their returned order value, if they implement<p>Creates a JDK proxy when proxy interfaces are given, and a CGLIB proxy for theactual target class if not. Note that the latter will only work if the target classdoes not have final methods, as a dynamic subclass will be created at runtime.<p>It's possible to cast a proxy obtained from this factory to {@link Advised},or to obtain the ProxyFactoryBean reference and programmatically manipulate it.This won't work for existing prototype references, which are independent. However,it will work for prototypes subsequently obtained from the factory. Changes tointerception will work immediately on singletons (including existing references).However, to change interfaces or target it's necessary to obtain a new instancefrom the factory. This means that singleton instances obtained from the factorydo not have the same object identity. However, they do have the same interceptorsand target, and changing any reference will change all objects.#setInterceptorNames#setProxyInterfacesorg.springframework.aop.AdvisorThis suffix in a value in an interceptor list indicates to expand globals.Whether the advisor chain has already been initialized.If this is a singleton, the cached singleton proxy instance.Set the names of the interfaces we're proxying. If no interfaceis given, a CGLIB for the actual class will be created.<p>This is essentially equivalent to the "setInterfaces" method,but mirrors TransactionProxyFactoryBean's "setProxyInterfaces".#setInterfacesAbstractSingletonProxyFactoryBean#setProxyInterfacesSet the list of Advice/Advisor bean names. This must always be setto use this factory bean in a bean factory.<p>The referenced beans should be of type Interceptor, Advisor or AdviceThe last entry in the list can be the name of any bean in the factory.If it's neither an Advice nor an Advisor, a new SingletonTargetSourceis added to wrap it. Such a target bean cannot be used if the "target"or "targetSource" or "targetName" property is set, in which case the"interceptorNames" array must contain only Advice/Advisor bean names.<p><b>NOTE: Specifying a target bean as final name in the "interceptorNames"list is deprecated and will be removed in a future Spring version.</b>Use the {@link #setTargetName "targetName"} property instead.org.aopalliance.aop.AdviceSet the name of the target bean. This is an alternative to specifyingthe target name at the end of the "interceptorNames" array.<p>You can also specify a target object or a TargetSource objectdirectly, via the "target"/"targetSource" property, respectively.#setInterceptorNames(String[])#setTarget(Object)#setTargetSource(org.springframework.aop.TargetSource)Set whether to autodetect proxy interfaces if none specified.<p>Default is "true". Turn this flag off to create a CGLIBproxy for the full target class if no interfaces specified.#setProxyTargetClassSet the value of the singleton property. Governs whether this factoryshould always return the same proxy instance (which implies the same target)or whether it should return a new prototype instance, which implies thatthe target and interceptors may be new instances also, if they are obtainedfrom prototype bean definitions. This allows for fine control ofindependence/uniqueness in the object graph.Return a proxy. Invoked when clients obtain beans from this factory bean.Create an instance of the AOP proxy to be returned by this factory.The instance will be cached for a singleton, and create on each call to{@code getObject()} for a proxy.a fresh AOP proxy reflecting the current state of this factoryReturn the type of the proxy. Will check the singleton instance ifalready created, else fall back to the proxy interface (in case of justa single one), the target bean type, or the TargetSource's target class.org.springframework.aop.TargetSource#getTargetClassCreate a composite interface Class for the given interfaces,implementing the given interfaces in one single Class.<p>The default implementation builds a JDK proxy class for thegiven interfaces.the interfaces to mergethe merged interface as Classjava.lang.reflect.Proxy#getProxyClassReturn the singleton instance of this class's proxy object,lazily creating it if it hasn't been created already.the shared singleton proxy Initialize the shared singleton instance.Create a new prototype instance of this class's created proxy object,backed by an independent AdvisedSupport configuration.a totally independent proxy, whose advice we may manipulate in isolation In the case of a prototype, we need to give the proxy an independent instance of the configuration. In this case, no proxy will have an instance of this object's configuration, but will have an independent copy. The copy needs a fresh advisor chain, and a fresh TargetSource.Return the proxy object to expose.<p>The default implementation uses a {@code getProxy} call withthe factory's bean class loader. Can be overridden to specify acustom class loader.the prepared AopProxy instance to get the proxy fromthe proxy object to exposeAopProxy#getProxy(ClassLoader)Check the interceptorNames list whether it contains a target name as final element.If found, remove the final name from the list and set it as targetName. The last name in the chain may be an Advisor/Advice or a target/TargetSource. Unfortunately we don't know; we must look at type of the bean. The target isn't an interceptor.Look at bean factory metadata to work out whether this bean name,which concludes the interceptorNames list, is an Advisor or Advice,or may be a target.bean name to check{@code true} if it's an Advisor or Advice Treat it as an target bean if we can't tell.Create the advisor (interceptor) chain. Advisors that are sourcedfrom a BeanFactory will be refreshed each time a new prototype instanceis added. Interceptors added programmatically through the factory APIare unaffected by such changes. Globals can't be last unless we specified a targetSource using the property... Materialize interceptor chain from bean names. If we get here, we need to add a named interceptor. We must check if it's a singleton or prototype. Add the real Advisor/Advice to the chain. It's a prototype Advice or Advisor: replace with a prototype. Avoid unnecessary creation of prototype bean just for advisor chain initialization.Return an independent advisor chain.We need to do this every time a new prototype instance is returned,to return distinct instances of prototype Advisors and Advices. Replace the placeholder with a fresh prototype instance resulting from a getBean lookup Add the shared instance.Add all global interceptors and pointcuts.Invoked when advice chain is created.<p>Add the given advice, advisor or object to the interceptor list.Because of these three possibilities, we can't type the signaturemore strongly.advice, advisor or target object We need to convert to an Advisor if necessary so that our source reference matches what we find from superclass interceptors.Return a TargetSource to use when creating a proxy. If the target was notspecified at the end of the interceptorNames list, the TargetSource will bethis class's TargetSource member. Otherwise, we get the target bean and wrapit in a TargetSource if necessary. Not refreshing target: bean name not specified in 'interceptorNames'Convert the following object sourced from calling getBean() on a name in theinterceptorNames array to an Advisor or TargetSource. We expected this to be an Advisor or Advice, but it wasn't. This is a configuration error.Blow away and recache singleton on an advice change.Used in the interceptor chain where we need to replace a bean with a prototypeon creating a proxy.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyProcessorSupport.javaProxyProcessorSupportC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ProxyProcessorSupport.classtargetInterfaceshasReasonableProxyInterfaceClass<InitializingBean>Class<DisposableBean>Class<Closeable>Class<AutoCloseable>Class<Aware>"groovy.lang.GroovyObject"groovy.lang.GroovyObject".cglib.proxy.Factory".cglib.proxy.Factory".bytebuddy.MockAccess".bytebuddy.MockAccessBase class with common functionality for proxy processors, in particularClassLoader management and the {@link #evaluateProxyInterfaces} algorithm.4.1This should run after all other processors, so that it can just addan advisor to existing proxies rather than double-proxy.Set the ordering which will apply to this processor's implementationof {@link Ordered}, used when applying multiple processors.<p>The default value is {@code Ordered.LOWEST_PRECEDENCE}, meaning non-ordered.the ordering value<p>Default is the bean ClassLoader, i.e. the ClassLoader used by the containing{@link org.springframework.beans.factory.BeanFactory} for loading all bean classes.This can be overridden here for specific proxies.Return the configured proxy ClassLoader for this processor.Check the interfaces on the given bean class and apply them to the {@link ProxyFactory},if appropriate.<p>Calls {@link #isConfigurationCallbackInterface} and {@link #isInternalLanguageInterface}to filter for reasonable proxy interfaces, falling back to a target-class proxy otherwise.the class of the beanthe ProxyFactory for the bean Must allow for introductions; can't just set interfaces to the target's interfaces only.Determine whether the given interface is just a container callback andtherefore not to be considered as a reasonable proxy interface.<p>If no reasonable proxy interface is found for a given bean, it will getproxied with its full target class, assuming that as the user's intention.whether the given interface is just a container callbackDetermine whether the given interface is a well-known internal language interfaceand therefore not to be considered as a reasonable proxy interface.whether the given interface is an internal language interfaceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ReflectiveMethodInvocation.javaReflectiveMethodInvocationcurrentInterceptorIndexC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/ReflectiveMethodInvocation.classMap<String,Object>userAttributesinterceptorOrInterceptionAdvicedmcloneArgumentsHashMap<String,Object>AbstractMap<String,Object>HashMap<String,Object>()merge(java.lang.String,java.lang.Object,java.util.function.BiFunction)BiFunction<? super String,? super Object,? extends Object>Function<? super String,? extends Object>replace(java.lang.String,java.lang.Object)replace(java.lang.String,java.lang.Object,java.lang.Object)putIfAbsent(java.lang.String,java.lang.Object)BiConsumer<? super String,? super Object>Entry<String,Object>Set<Entry<String,Object>>Collection<Entry<String,Object>>Iterable<Entry<String,Object>>Map<? extends String,? extends Object>put(java.lang.String,java.lang.Object)AbstractMap<String,Object>()Node<String,Object>TreeNode<String,Object>newTreeNode(int,java.lang.String,java.lang.Object,java.util.HashMap.Node)newNode(int,java.lang.String,java.lang.Object,java.util.HashMap.Node)Node<String,Object>[]putVal(int,java.lang.String,java.lang.Object,boolean,boolean)HashMap<String,Object>(java.util.Map)HashMap<String,Object>(int)HashMap<String,Object>(int,float)? extends ReflectiveMethodInvocationClass<? extends ReflectiveMethodInvocation>"Should be able to clone object of type ["Should be able to clone object of type ["]: "]: "ReflectiveMethodInvocation: "ReflectiveMethodInvocation: "target is null"target is null"target is of class ["target is of class [']'Spring's implementation of the AOP Alliance{@link org.aopalliance.intercept.MethodInvocation} interface,implementing the extended{@link org.springframework.aop.ProxyMethodInvocation} interface.<p>Invokes the target object using reflection. Subclasses can override the{@link #invokeJoinpoint()} method to change this behavior, so this is alsoa useful base class for more specialized MethodInvocation implementations.<p>It is possible to clone an invocation, to invoke {@link #proceed()}repeatedly (once per clone), using the {@link #invocableClone()} method.It is also possible to attach custom attributes to the invocation,using the {@link #setUserAttribute} / {@link #getUserAttribute} methods.<p><b>NOTE:</b> This class is considered internal and should not bedirectly accessed. The sole reason for it being public is compatibilitywith existing framework integrations (e.g. Pitchfork). For any otherpurposes, use the {@link ProxyMethodInvocation} interface instead.#invokeJoinpoint#proceed#invocableClone#getUserAttributeLazily initialized map of user-specific attributes for this invocation.List of MethodInterceptor and InterceptorAndDynamicMethodMatcherthat need dynamic checks.Index from 0 of the current interceptor we're invoking.-1 until we invoke: then the current interceptor.Construct a new ReflectiveMethodInvocation with the given arguments.the proxy object that the invocation was made onthe target object to invokethe method to invokethe arguments to invoke the method withthe target class, for MethodMatcher invocationsinterceptors that should be applied,along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime.MethodMatchers included in this struct must already have been found to have matchedas far as was possibly statically. Passing an array might be about 10% faster,but would complicate the code. And it would work only for static pointcuts.Return the method invoked on the proxied interface.May or may not correspond with a method invoked on an underlyingimplementation of that interface. We start with an index of -1 and increment early. Evaluate dynamic method matcher here: static part will already have been evaluated and found to match. Dynamic matching failed. Skip this interceptor and invoke the next in the chain. It's an interceptor, so we just invoke it: The pointcut will have been evaluated statically before this object was constructed.Invoke the joinpoint using reflection.Subclasses can override this to use custom invocation.the return value of the joinpointif invoking the joinpoint resulted in an exceptionThis implementation returns a shallow copy of this invocation object,including an independent copy of the original arguments array.<p>We want a shallow copy in this case: We want to use the same interceptorchain and other object references, but we want an independent value for thecurrent interceptor index.java.lang.Object#clone() Build an independent copy of the arguments array.using the given arguments array for the clone. Force initialization of the user attributes Map, for having a shared Map reference in the clone. Create the MethodInvocation clone.Return user attributes associated with this invocation.This method provides an invocation-bound alternative to a ThreadLocal.<p>This map is initialized lazily and is not used in the AOP framework itself.any user attributes associated with this invocation(never {@code null}) Don't do toString on target, it may be proxied.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AdvisorAdapter.javaAdvisorAdapterC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapteradapterorg.springframework.aop.framework.adapterInterface allowing extension to the Spring AOP framework to allowhandling of new Advisors and Advice types.<p>Implementing objects can create AOP Alliance Interceptors fromcustom advice types, enabling these advice types to be usedin the Spring AOP framework, which uses interception under the covers.<p>There is no need for most Spring users to implement this interface;do so only if you need to introduce more Advisor or Advice types to Spring.Does this adapter understand this advice object? Is it valid toinvoke the {@code getInterceptors} method with an Advisor thatcontains this advice as an argument?an Advice such as a BeforeAdvicewhether this adapter understands the given advice object#getInterceptor(org.springframework.aop.Advisor)org.springframework.aop.BeforeAdviceReturn an AOP Alliance MethodInterceptor exposing the behavior ofthe given advice to an interception-based AOP framework.<p>Don't worry about any Pointcut contained in the Advisor;the AOP framework will take care of checking the pointcut.the Advisor. The supportsAdvice() method must havereturned true on this objectan AOP Alliance interceptor for this Advisor. There'sno need to cache instances for efficiency, as the AOP frameworkcaches advice chains.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AdvisorAdapterRegistrationManager.javaAdvisorAdapterRegistrationManagerC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AdvisorAdapterRegistrationManager.classBeanPostProcessor that registers {@link AdvisorAdapter} beans in the BeanFactory withan {@link AdvisorAdapterRegistry} (by default the {@link GlobalAdvisorAdapterRegistry}).<p>The only requirement for it to work is that it needs to be definedin application context along with "non-native" Spring AdvisorAdaptersthat need to be "recognized" by Spring's AOP framework.Dmitriy Kopylenko27.02.2004#setAdvisorAdapterRegistrySpecify the AdvisorAdapterRegistry to register AdvisorAdapter beans with.GlobalAdvisorAdapterRegistryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AdvisorAdapterRegistry.javaAdvisorAdapterRegistryInterface for registries of Advisor adapters.<p><i>This is an SPI interface, not to be implemented by any Spring user.</i>Return an {@link Advisor} wrapping the given advice.<p>Should by default at least support{@link org.aopalliance.intercept.MethodInterceptor},{@link org.springframework.aop.MethodBeforeAdvice},{@link org.springframework.aop.AfterReturningAdvice},{@link org.springframework.aop.ThrowsAdvice}.an object that should be an advicean Advisor wrapping the given advice (never {@code null};if the advice parameter is an Advisor, it is to be returned as-is)UnknownAdviceTypeExceptionif no registered advisor adaptercan wrap the supposed adviceReturn an array of AOP Alliance MethodInterceptors to allow use of thegiven Advisor in an interception-based framework.<p>Don't worry about the pointcut associated with the {@link Advisor}, if it isa {@link org.springframework.aop.PointcutAdvisor}: just return an interceptor.the Advisor to find an interceptor foran array of MethodInterceptors to expose this Advisor's behaviorif the Advisor type isnot understood by any registered AdvisorAdapterRegister the given {@link AdvisorAdapter}. Note that it is not necessary to registeradapters for an AOP Alliance Interceptors or Spring Advices: these must beautomatically recognized by an {@code AdvisorAdapterRegistry} implementation.an AdvisorAdapter that understands particular Advisor or Advice typesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AfterReturningAdviceAdapter.javaAfterReturningAdviceAdapterAfterReturningAdviceAdapter()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AfterReturningAdviceAdapter.classAdapter to enable {@link org.springframework.aop.AfterReturningAdvice}to be used in the Spring AOP framework.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AfterReturningAdviceInterceptor.javaAfterReturningAdviceInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/AfterReturningAdviceInterceptor.classInterceptor to wrap an {@link org.springframework.aop.AfterReturningAdvice}.Used internally by the AOP framework; application developers should not needto use this class directly.MethodBeforeAdviceInterceptorThrowsAdviceInterceptorCreate a new AfterReturningAdviceInterceptor for the given advice.the AfterReturningAdvice to wrapC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/DefaultAdvisorAdapterRegistry.javaDefaultAdvisorAdapterRegistryList<AdvisorAdapter>Collection<AdvisorAdapter>Iterable<AdvisorAdapter>adaptersC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/DefaultAdvisorAdapterRegistry.classArrayList<AdvisorAdapter>AbstractList<AdvisorAdapter>AbstractCollection<AdvisorAdapter>ArrayList<AdvisorAdapter>(int)Spliterator<AdvisorAdapter>? super AdvisorAdapterConsumer<? super AdvisorAdapter>Iterator<AdvisorAdapter>Stream<AdvisorAdapter>BaseStream<AdvisorAdapter,Stream<AdvisorAdapter>>Predicate<? super AdvisorAdapter>? extends AdvisorAdapterCollection<? extends AdvisorAdapter>Iterable<? extends AdvisorAdapter>add(org.springframework.aop.framework.adapter.AdvisorAdapter)AbstractCollection<AdvisorAdapter>()ListIterator<AdvisorAdapter>add(int,org.springframework.aop.framework.adapter.AdvisorAdapter)set(int,org.springframework.aop.framework.adapter.AdvisorAdapter)Comparator<? super AdvisorAdapter>UnaryOperator<AdvisorAdapter>Function<AdvisorAdapter,AdvisorAdapter>AbstractList<AdvisorAdapter>()ArrayList<AdvisorAdapter>(java.util.Collection)ArrayList<AdvisorAdapter>()adviceObjectArrayList<MethodInterceptor>AbstractList<MethodInterceptor>AbstractCollection<MethodInterceptor>ArrayList<MethodInterceptor>(int)Spliterator<MethodInterceptor>? super MethodInterceptorConsumer<? super MethodInterceptor>Iterator<MethodInterceptor>Stream<MethodInterceptor>BaseStream<MethodInterceptor,Stream<MethodInterceptor>>Predicate<? super MethodInterceptor>? extends MethodInterceptorCollection<? extends MethodInterceptor>Iterable<? extends MethodInterceptor>add(org.aopalliance.intercept.MethodInterceptor)AbstractCollection<MethodInterceptor>()ListIterator<MethodInterceptor>add(int,org.aopalliance.intercept.MethodInterceptor)set(int,org.aopalliance.intercept.MethodInterceptor)Comparator<? super MethodInterceptor>UnaryOperator<MethodInterceptor>Function<MethodInterceptor,MethodInterceptor>AbstractList<MethodInterceptor>()ArrayList<MethodInterceptor>(java.util.Collection)ArrayList<MethodInterceptor>()Default implementation of the {@link AdvisorAdapterRegistry} interface.Supports {@link org.aopalliance.intercept.MethodInterceptor},Create a new DefaultAdvisorAdapterRegistry, registering well-known adapters. So well-known it doesn't even need an adapter. Check that it is supported.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/GlobalAdvisorAdapterRegistry.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/GlobalAdvisorAdapterRegistry.classGlobalAdvisorAdapterRegistry()Singleton to publish a shared DefaultAdvisorAdapterRegistry instance.Keep track of a single instance so we can return it to classes that request it.Return the singleton {@link DefaultAdvisorAdapterRegistry} instance.Reset the singleton {@link DefaultAdvisorAdapterRegistry}, removing any{@link AdvisorAdapterRegistry#registerAdvisorAdapter(AdvisorAdapter) registered}adapters.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/MethodBeforeAdviceAdapter.javaMethodBeforeAdviceAdapterMethodBeforeAdviceAdapter()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/MethodBeforeAdviceAdapter.classAdapter to enable {@link org.springframework.aop.MethodBeforeAdvice}C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/MethodBeforeAdviceInterceptor.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/MethodBeforeAdviceInterceptor.classInterceptor to wrap a {@link MethodBeforeAdvice}.<p>Used internally by the AOP framework; application developers should notneed to use this class directly.Create a new MethodBeforeAdviceInterceptor for the given advice.the MethodBeforeAdvice to wrapC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/ThrowsAdviceAdapter.javaThrowsAdviceAdapterThrowsAdviceAdapter()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/ThrowsAdviceAdapter.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptor.javainvokeHandlerMethodinvokeHandlerMethod(org.aopalliance.intercept.MethodInvocation,java.lang.Throwable,java.lang.reflect.Method)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptor.classgetExceptionHandlergetExceptionHandler(java.lang.Throwable)Map<Class<?>,Method>exceptionHandlerMapthrowsAdviceAFTER_THROWINGHashMap<Class<?>,Method>AbstractMap<Class<?>,Method>HashMap<Class<?>,Method>()merge(java.lang.Class,java.lang.reflect.Method,java.util.function.BiFunction)BiFunction<? super Class<?>,? super Method,? extends Method>Function<? super Class<?>,? extends Method>replace(java.lang.Class,java.lang.reflect.Method)replace(java.lang.Class,java.lang.reflect.Method,java.lang.reflect.Method)putIfAbsent(java.lang.Class,java.lang.reflect.Method)BiConsumer<? super Class<?>,? super Method>getOrDefault(java.lang.Object,java.lang.reflect.Method)Entry<Class<?>,Method>Set<Entry<Class<?>,Method>>Collection<Entry<Class<?>,Method>>Iterable<Entry<Class<?>,Method>>Map<? extends Class<?>,? extends Method>put(java.lang.Class,java.lang.reflect.Method)AbstractMap<Class<?>,Method>()Node<Class<?>,Method>TreeNode<Class<?>,Method>newTreeNode(int,java.lang.Class,java.lang.reflect.Method,java.util.HashMap.Node)newNode(int,java.lang.Class,java.lang.reflect.Method,java.util.HashMap.Node)Node<Class<?>,Method>[]putVal(int,java.lang.Class,java.lang.reflect.Method,boolean,boolean)HashMap<Class<?>,Method>(java.util.Map)HashMap<Class<?>,Method>(int)HashMap<Class<?>,Method>(int,float)"afterThrowing"Class<ThrowsAdviceInterceptor>throwableParamMap<String,Throwable>Throwable[]Constructor<Throwable>? super ThrowableClass<? super Throwable>TypeVariable<Class<Throwable>>TypeVariable<Class<Throwable>>[]"Found exception handler method on throws advice: "Found exception handler method on throws advice: "At least one handler method must be found in class ["At least one handler method must be found in class [handlerMethodexceptionexceptionClasshandler"Trying to find handler for exception of type ["Trying to find handler for exception of type ["Found handler for exception of type ["Found handler for exception of type [handlerArgstargetExInterceptor to wrap an after-throwing advice.<p>The signatures on handler methods on the {@code ThrowsAdvice}implementation method argument must be of the form:<br>{@code void afterThrowing([Method, args, target], ThrowableSubclass);}<p>Only the last argument is required.<p>This is a framework class that need not be used directly by Spring users.Methods on throws advice, keyed by exception class.Create a new ThrowsAdviceInterceptor for the given ThrowsAdvice.the advice object that defines the exception handler methods(usually a {@link org.springframework.aop.ThrowsAdvice} implementation) An exception handler to register...Return the number of handler methods in this advice.Determine the exception handle method for the given exception.the exception throwna handler for the given exception type, or {@code null} if none foundC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/UnknownAdviceTypeException.java"Advice object ["Advice object ["] is neither a supported subinterface of " +
				"[org.aopalliance.aop.Advice] nor an [org.springframework.aop.Advisor]"] is neither a supported subinterface of [org.aopalliance.aop.Advice] nor an [org.springframework.aop.Advisor]Exception thrown when an attempt is made to use an unsupportedAdvisor or Advice type.Create a new UnknownAdviceTypeException for the given advice object.Will create a message text that says that the object is neither asubinterface of Advice nor an Advisor.the advice object of unknown typeCreate a new UnknownAdviceTypeException with the given message.the message textC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/adapter/package-info.javaSPI package allowing Spring AOP framework to handle arbitrary advice types.<p>Users who want merely to <i>use</i> the Spring AOP framework, rather than extendits capabilities, don't need to concern themselves with this package.<p>You may wish to use these adapters to wrap Spring-specific advices, such as MethodBeforeAdvice,in MethodInterceptor, to allow their use in another AOP framework supporting the AOP Alliance interfaces.<p>These adapters do not depend on any other Spring framework classes to allow such usage.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAdvisorAutoProxyCreator.javaAbstractAdvisorAutoProxyCreatorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxyadvisorRetrievalHelperC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAdvisorAutoProxyCreator.class"AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: "AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: eligibleAdvisors"No BeanFactoryAdvisorRetrievalHelper available"No BeanFactoryAdvisorRetrievalHelper availableGeneric auto proxy creator that builds AOP proxies for specific beansbased on detected Advisors for each bean.<p>Subclasses may override the {@link #findCandidateAdvisors()} method toreturn a custom list of Advisors applying to any object. Subclasses canalso override the inherited {@link #shouldSkip} method to exclude certainobjects from auto-proxying.<p>Advisors or advices requiring ordering should be annotated with{@link org.springframework.core.annotation.Order @Order} or implement the{@link org.springframework.core.Ordered} interface. This class sortsadvisors using the {@link AnnotationAwareOrderComparator}. Advisors that arenot annotated with {@code @Order} or don't implement the {@code Ordered}interface will be considered as unordered; they will appear at the end of theadvisor chain in an undefined order.#findCandidateAdvisorsFind all eligible Advisors for auto-proxying this class.the clazz to find advisors forthe name of the currently proxied beanthe empty List, not {@code null},if there are no pointcuts or interceptors#sortAdvisors#extendAdvisorsFind all candidate Advisors to use in auto-proxying.the List of candidate AdvisorsSearch the given candidate Advisors to find all Advisors thatcan apply to the specified bean.the candidate Advisorsthe target's bean classthe target's bean namethe List of applicable AdvisorsProxyCreationContext#getCurrentProxiedBeanName()Return whether the Advisor bean with the given name is eligiblefor proxying in the first place.the name of the Advisor beanSort advisors based on ordering. Subclasses may choose to override thismethod to customize the sorting strategy.the source List of Advisorsthe sorted List of Advisorsorg.springframework.core.annotation.AnnotationAwareOrderComparatorExtension hook that subclasses can override to register additional Advisors,given the sorted Advisors obtained to date.<p>Typically used to add Advisors that expose contextual informationrequired by some of the later advisors.the Advisors that have already been identified asapplying to a given beanThis auto-proxy creator always returns pre-filtered Advisors.Subclass of BeanFactoryAdvisorRetrievalHelper that delegates tosurrounding AbstractAdvisorAutoProxyCreator facilities.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.javaAbstractAutoProxyCreatorresolveInterceptorNamesresolveInterceptorNames()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractAutoProxyCreator.classMap<Object,Boolean>advisedBeansMap<Object,Class<?>>proxyTypesMap<Object,Object>earlyProxyReferencestargetSourcedBeansTargetSourceCreator[]customTargetSourceCreatorsapplyCommonInterceptorsFirst? extends AbstractAutoProxyCreatorClass<? extends AbstractAutoProxyCreator>ConcurrentHashMap<String,Boolean>AbstractMap<String,Boolean>Map<String,Boolean>ConcurrentMap<String,Boolean>ConcurrentHashMap<K,V>AbstractMap<K,V>ConcurrentMap<K,V>ConcurrentHashMap<K,V>(int)AbstractMap<K,V>()ConcurrentHashMap<K,V>(int,float,int)ConcurrentHashMap<K,V>(int,float)ConcurrentHashMap<K,V>(java.util.Map)ConcurrentHashMap<K,V>()16ConcurrentHashMap<Object,Object>AbstractMap<Object,Object>ConcurrentMap<Object,Object>ConcurrentHashMap<Object,Object>(int)Function<? super Object,? extends Object>BiConsumer<? super Object,? super Object>Entry<Object,Object>Set<Entry<Object,Object>>Collection<Entry<Object,Object>>Iterable<Entry<Object,Object>>Set<Object>Map<? extends Object,? extends Object>AbstractMap<Object,Object>()ToIntFunction<Entry<Object,Object>>ToLongFunction<Entry<Object,Object>>ToDoubleFunction<Entry<Object,Object>>Function<Entry<Object,Object>,? extends U>? extends Entry<Object,Object>BiFunction<Entry<Object,Object>,Entry<Object,Object>,? extends Entry<Object,Object>>? super Entry<Object,Object>Consumer<? super Entry<Object,Object>>ToIntBiFunction<? super Object,? super Object>ToLongBiFunction<? super Object,? super Object>ToDoubleBiFunction<? super Object,? super Object>BiFunction<? super Object,? super Object,? extends U>Node<Object,Object>Node<Object,Object>[]KeySetView<Object,Object>CollectionView<Object,Object,Object>Predicate<? super Entry<Object,Object>>ConcurrentHashMap<Object,Object>(int,float,int)ConcurrentHashMap<Object,Object>(int,float)ConcurrentHashMap<Object,Object>(java.util.Map)ConcurrentHashMap<Object,Object>()ConcurrentHashMap<Object,Class<?>>AbstractMap<Object,Class<?>>ConcurrentMap<Object,Class<?>>ConcurrentHashMap<Object,Class<?>>(int)merge(java.lang.Object,java.lang.Class,java.util.function.BiFunction)BiFunction<? super Object,? super Class<?>,? extends Class<?>>Function<? super Object,? extends Class<?>>replace(java.lang.Object,java.lang.Class)replace(java.lang.Object,java.lang.Class,java.lang.Class)putIfAbsent(java.lang.Object,java.lang.Class)BiConsumer<? super Object,? super Class<?>>getOrDefault(java.lang.Object,java.lang.Class)Entry<Object,Class<?>>Set<Entry<Object,Class<?>>>Collection<Entry<Object,Class<?>>>Iterable<Entry<Object,Class<?>>>Map<? extends Object,? extends Class<?>>put(java.lang.Object,java.lang.Class)AbstractMap<Object,Class<?>>()ToIntFunction<Entry<Object,Class<?>>>ToLongFunction<Entry<Object,Class<?>>>ToDoubleFunction<Entry<Object,Class<?>>>Function<Entry<Object,Class<?>>,? extends U>? extends Entry<Object,Class<?>>BiFunction<Entry<Object,Class<?>>,Entry<Object,Class<?>>,? extends Entry<Object,Class<?>>>? super Entry<Object,Class<?>>Consumer<? super Entry<Object,Class<?>>>ToIntBiFunction<? super Object,? super Class<?>>ToLongBiFunction<? super Object,? super Class<?>>ToDoubleBiFunction<? super Object,? super Class<?>>BiFunction<? super Object,? super Class<?>,? extends U>Node<Object,Class<?>>Node<Object,Class<?>>[]KeySetView<Object,Class<?>>CollectionView<Object,Class<?>,Object>keySet(java.lang.Class)Predicate<? super Entry<Object,Class<?>>>replaceNode(java.lang.Object,java.lang.Class,java.lang.Object)putVal(java.lang.Object,java.lang.Class,boolean)ConcurrentHashMap<Object,Class<?>>(int,float,int)ConcurrentHashMap<Object,Class<?>>(int,float)ConcurrentHashMap<Object,Class<?>>(java.util.Map)ConcurrentHashMap<Object,Class<?>>()ConcurrentHashMap<Object,Boolean>AbstractMap<Object,Boolean>ConcurrentMap<Object,Boolean>ConcurrentHashMap<Object,Boolean>(int)merge(java.lang.Object,java.lang.Boolean,java.util.function.BiFunction)BiFunction<? super Object,? super Boolean,? extends Boolean>Function<? super Object,? extends Boolean>replace(java.lang.Object,java.lang.Boolean)replace(java.lang.Object,java.lang.Boolean,java.lang.Boolean)putIfAbsent(java.lang.Object,java.lang.Boolean)BiConsumer<? super Object,? super Boolean>Entry<Object,Boolean>Set<Entry<Object,Boolean>>Collection<Entry<Object,Boolean>>Iterable<Entry<Object,Boolean>>Map<? extends Object,? extends Boolean>put(java.lang.Object,java.lang.Boolean)AbstractMap<Object,Boolean>()ToIntFunction<Entry<Object,Boolean>>ToLongFunction<Entry<Object,Boolean>>ToDoubleFunction<Entry<Object,Boolean>>Function<Entry<Object,Boolean>,? extends U>? extends Entry<Object,Boolean>BiFunction<Entry<Object,Boolean>,Entry<Object,Boolean>,? extends Entry<Object,Boolean>>? super Entry<Object,Boolean>Consumer<? super Entry<Object,Boolean>>ToIntBiFunction<? super Object,? super Boolean>ToLongBiFunction<? super Object,? super Boolean>ToDoubleBiFunction<? super Object,? super Boolean>BiFunction<? super Object,? super Boolean,? extends U>Node<Object,Boolean>Node<Object,Boolean>[]KeySetView<Object,Boolean>CollectionView<Object,Boolean,Object>Predicate<? super Entry<Object,Boolean>>putVal(java.lang.Object,java.lang.Boolean,boolean)ConcurrentHashMap<Object,Boolean>(int,float,int)ConcurrentHashMap<Object,Boolean>(int,float)ConcurrentHashMap<Object,Boolean>(java.util.Map)ConcurrentHashMap<Object,Boolean>()targetSourceCreatorsspecificInterceptorsMap<String,Pointcut>Constructor<Pointcut>? super PointcutClass<? super Pointcut>TypeVariable<Class<Pointcut>>TypeVariable<Class<Pointcut>>[]Class<AopInfrastructureBean>Map<String,AopInfrastructureBean>AopInfrastructureBean[]Constructor<AopInfrastructureBean>? super AopInfrastructureBeanClass<? super AopInfrastructureBean>TypeVariable<Class<AopInfrastructureBean>>TypeVariable<Class<AopInfrastructureBean>>[]"Did not attempt to auto-proxy infrastructure class ["Did not attempt to auto-proxy infrastructure class [tscts"TargetSourceCreator ["TargetSourceCreator ["] found custom TargetSource for bean with name '"] found custom TargetSource for bean with name 'commonInterceptorsallInterceptorsnrOfCommonInterceptorsnrOfSpecificInterceptors"Creating implicit proxy for bean '"Creating implicit proxy for bean '"' with "' with " common interceptors and " common interceptors and " specific interceptors" specific interceptorscbf"BeanFactory required for resolving interceptor names"BeanFactory required for resolving interceptor namescustomTargetSource{@link org.springframework.beans.factory.config.BeanPostProcessor} implementationthat wraps each eligible bean with an AOP proxy, delegating to specified interceptorsbefore invoking the bean itself.<p>This class distinguishes between "common" interceptors: shared for all proxies itcreates, and "specific" interceptors: unique per bean instance. There need not be anycommon interceptors. If there are, they are set using the interceptorNames property.As with {@link org.springframework.aop.framework.ProxyFactoryBean}, interceptors namesin the current factory are used rather than bean references to allow correct handlingof prototype advisors and interceptors: for example, to support stateful mixins.Any advice type is supported for {@link #setInterceptorNames "interceptorNames"} entries.<p>Such auto-proxying is particularly useful if there's a large number of beans thatneed to be wrapped with similar proxies, i.e. delegating to the same interceptors.Instead of x repetitive proxy definitions for x target beans, you can registerone single such post processor with the bean factory to achieve the same effect.<p>Subclasses can apply any strategy to decide if a bean is to be proxied, e.g. by type,by name, by definition details, etc. They can also return additional interceptors thatshould just be applied to the specific bean instance. A simple concrete implementation is{@link BeanNameAutoProxyCreator}, identifying the beans to be proxied via given names.<p>Any number of {@link TargetSourceCreator} implementations can be used to createa custom target source: for example, to pool prototype objects. Auto-proxying willoccur even if there is no advice, as long as a TargetSourceCreator specifies a custom{@link org.springframework.aop.TargetSource}. If there are no TargetSourceCreators set,or if none matches, a {@link org.springframework.aop.target.SingletonTargetSource}will be used by default to wrap the target bean instance.13.10.2003#getAdvicesAndAdvisorsForBeanBeanNameAutoProxyCreatorDefaultAdvisorAutoProxyCreatorConvenience constant for subclasses: Return value for "do not proxy".Convenience constant for subclasses: Return value for"proxy without additional interceptors, just the common ones".Indicates whether or not the proxy should be frozen. Overridden from superto prevent the configuration from becoming frozen too early.Default is no common interceptors.Set whether or not the proxy should be frozen, preventing advicefrom being added to it once it is created.<p>Overridden from the super class to prevent the proxy configurationfrom being frozen before the proxy is created.Specify the {@link AdvisorAdapterRegistry} to use.<p>Default is the global {@link AdvisorAdapterRegistry}.Set custom {@code TargetSourceCreators} to be applied in this order.If the list is empty, or they all return null, a {@link SingletonTargetSource}will be created for each bean.<p>Note that TargetSourceCreators will kick in even for target beanswhere no advices or advisors have been found. If a {@code TargetSourceCreator}returns a {@link TargetSource} for a specific bean, that bean will be proxiedin any case.<p>{@code TargetSourceCreators} can only be invoked if this post processor is usedin a {@link BeanFactory} and its {@link BeanFactoryAware} callback is triggered.the list of {@code TargetSourceCreators}.Ordering is significant: The {@code TargetSource} returned from the first matching{@code TargetSourceCreator} (that is, the first that returns non-null) will be used.Set the common interceptors. These must be bean names in the current factory.They can be of any advice or advisor type Spring supports.<p>If this property isn't set, there will be zero common interceptors.This is perfectly valid, if "specific" interceptors such as matchingAdvisors are all we want.Set whether the common interceptors should be applied before bean-specific ones.Default is "true"; else, bean-specific interceptors will get applied first.Return the owning {@link BeanFactory}.May be {@code null}, as this post-processor doesn't need to belong to a bean factory. Create proxy here if we have a custom TargetSource. Suppresses unnecessary default instantiation of the target bean: The TargetSource will handle target instances in a custom fashion. skip postProcessPropertyValuesCreate a proxy with the configured interceptors if the bean isidentified as one to proxy by the subclass.Build a cache key for the given bean class and bean name.<p>Note: As of 4.2.3, this implementation does not return a concatenatedclass/name String anymore but rather the most efficient cache key possible:a plain bean name, prepended with {@link BeanFactory#FACTORY_BEAN_PREFIX}in case of a {@code FactoryBean}; or if no bean name specified, then thegiven bean {@code Class} as-is.the bean classthe bean namethe cache key for the given class and nameWrap the given bean if necessary, i.e. if it is eligible for being proxied.the raw bean instancethe cache key for metadata accessa proxy wrapping the bean, or the raw bean instance as-is Create proxy if we have advice.Return whether the given bean class represents an infrastructure classthat should never be proxied.<p>The default implementation considers Advices, Advisors andAopInfrastructureBeans as infrastructure classes.whether the bean represents an infrastructure classorg.springframework.aop.framework.AopInfrastructureBean#shouldSkipSubclasses should override this method to return {@code true} if thegiven bean should not be considered for auto-proxying by this post-processor.<p>Sometimes we need to be able to avoid this happening, e.g. if it will lead toa circular reference or if the existing target instance needs to be preserved.This implementation returns {@code false} unless the bean name indicates an"original instance" according to {@code AutowireCapableBeanFactory} conventions.whether to skip the given beanorg.springframework.beans.factory.config.AutowireCapableBeanFactory#ORIGINAL_INSTANCE_SUFFIXCreate a target source for bean instances. Uses any TargetSourceCreators if set.Returns {@code null} if no custom TargetSource should be used.<p>This implementation uses the "customTargetSourceCreators" property.Subclasses can override this method to use a different mechanism.the class of the bean to create a TargetSource fora TargetSource for this bean#setCustomTargetSourceCreators We can't create fancy target sources for directly registered singletons. Found a matching TargetSource. No custom TargetSource found.Create an AOP proxy for the given bean.the set of interceptors that isspecific to this bean (may be empty, but not null)the TargetSource for the proxy,already pre-configured to access the beanthe AOP proxy for the bean#buildAdvisorsDetermine whether the given bean should be proxied with its target class rather than its interfaces.<p>Checks the {@link AutoProxyUtils#PRESERVE_TARGET_CLASS_ATTRIBUTE "preserveTargetClass" attribute}of the corresponding bean definition.whether the given bean should be proxied with its target classAutoProxyUtils#shouldProxyTargetClassReturn whether the Advisors returned by the subclass are pre-filteredto match the bean's target class already, allowing the ClassFilter checkto be skipped when building advisors chains for AOP invocations.<p>Default is {@code false}. Subclasses may override this if theywill always return pre-filtered Advisors.whether the Advisors are pre-filteredorg.springframework.aop.framework.Advised#setPreFilteredDetermine the advisors for the given bean, including the specific interceptorsas well as the common interceptor, all adapted to the Advisor interface.the list of Advisors for the given bean Handle prototypes correctly...Resolves the specified interceptor names to Advisor objects.a ProxyFactory that is already configured withTargetSource and interfaces and will be used to create the proxyReturn whether the given bean is to be proxied, what additionaladvices (e.g. AOP Alliance interceptors) and advisors to apply.the class of the bean to advisethe TargetSource returned by the{@link #getCustomTargetSource} method: may be ignored.Will be {@code null} if no custom target source is in use.an array of additional interceptors for the particular bean;or an empty array if no additional interceptors but just the common ones;or {@code null} if no proxy at all, not even with the common interceptors.See constants DO_NOT_PROXY and PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS.BeansExceptionin case of errors#DO_NOT_PROXY#PROXY_WITHOUT_ADDITIONAL_INTERCEPTORSC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractBeanFactoryAwareAdvisingPostProcessor.javaAbstractBeanFactoryAwareAdvisingPostProcessorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AbstractBeanFactoryAwareAdvisingPostProcessor.classExtension of {@link AbstractAutoProxyCreator} which implements {@link BeanFactoryAware},adds exposure of the original target class for each proxied bean({@link AutoProxyUtils#ORIGINAL_TARGET_CLASS_ATTRIBUTE}),and participates in an externally enforced target-class mode for any given bean({@link AutoProxyUtils#PRESERVE_TARGET_CLASS_ATTRIBUTE}).This post-processor is therefore aligned with {@link AbstractAutoProxyCreator}.AutoProxyUtils#determineTargetClassC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AutoProxyUtils.javaAutoProxyUtilsisOriginalInstanceisOriginalInstance(java.lang.String,java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/AutoProxyUtils.classexposeTargetClassexposeTargetClass(org.springframework.beans.factory.config.ConfigurableListableBeanFactory,java.lang.String,java.lang.Class)Class<AutoProxyUtils>"preserveTargetClass"preserveTargetClass"originalTargetClass"originalTargetClassbdUtilities for auto-proxy aware components.Mainly for internal use within the framework.Bean definition attribute that may indicate whether a given bean is supposedto be proxied with its target class (in case of it getting proxied in the firstplace). The value is {@code Boolean.TRUE} or {@code Boolean.FALSE}.<p>Proxy factories can set this attribute if they built a target class proxyfor a specific bean, and want to enforce that bean can always be castto its target class (even if AOP advices get applied through auto-proxying).#shouldProxyTargetClassBean definition attribute that indicates the original target class of anauto-proxied bean, e.g. to be used for the introspection of annotationson the target class behind an interface-based proxy.#determineTargetClassDetermine whether the given bean should be proxied with its targetclass rather than its interfaces. Checks the{@link #PRESERVE_TARGET_CLASS_ATTRIBUTE "preserveTargetClass" attribute}the containing ConfigurableListableBeanFactoryDetermine the original target class for the specified bean, if possible,otherwise falling back to a regular {@code getType} lookup.the original target class as stored in the bean definition, if anyorg.springframework.beans.factory.BeanFactory#getType(String)Expose the given target class for the specified bean, if possible.the corresponding target classDetermine whether the given bean name indicates an "original instance"according to {@link AutowireCapableBeanFactory#ORIGINAL_INSTANCE_SUFFIX},skipping any proxy attempts for it.the corresponding bean class5.1AutowireCapableBeanFactory#ORIGINAL_INSTANCE_SUFFIXC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/BeanFactoryAdvisorRetrievalHelper.javaBeanFactoryAdvisorRetrievalHelpercachedAdvisorBeanNamesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/BeanFactoryAdvisorRetrievalHelper.classClass<BeanFactoryAdvisorRetrievalHelper>advisorNames"Skipping currently created advisor '"Skipping currently created advisor 'rootCausebcebceBeanName"Skipping advisor '"Skipping advisor '"' with dependency on currently created bean: "' with dependency on currently created bean: Helper for retrieving standard Spring Advisors from a BeanFactory,for use with auto-proxying.Create a new BeanFactoryAdvisorRetrievalHelper for the given BeanFactory.Find all eligible Advisor beans in the current bean factory,ignoring FactoryBeans and excluding beans that are currently in creation. Determine list of advisor bean names, if not cached already. Do not initialize FactoryBeans here: We need to leave all regular beans uninitialized to let the auto-proxy creator apply to them! Ignore: indicates a reference back to the bean we're trying to advise. We want to find advisors other than the currently created bean itself.Determine whether the aspect bean with the given name is eligible.<p>The default implementation always returns {@code true}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/BeanNameAutoProxyCreator.javaisSupportedBeanNameisSupportedBeanName(java.lang.Class,java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/BeanNameAutoProxyCreator.classNO_ALIASES"'beanNames' must not be empty"'beanNames' must not be emptymappedNameisFactoryBeanaliasesaliasAuto proxy creator that identifies beans to proxy via a list of names.Checks for direct, "xxx*", and "*xxx" matches.<p>For configuration details, see the javadoc of the parent classAbstractAutoProxyCreator. Typically, you will specify a list ofinterceptor names to apply to all identified beans, via the"interceptorNames" property.10.10.2003#setBeanNames#isMatchSet the names of the beans that should automatically get wrapped with proxies.A name can specify a prefix to match by ending with "*", e.g. "myBean,tx*"will match the bean named "myBean" and all beans whose name start with "tx".<p><b>NOTE:</b> In case of a FactoryBean, only the objects created by theFactoryBean will get proxied. This default behavior applies as of Spring 2.0.If you intend to proxy a FactoryBean instance itself (a rare use case, butSpring 1.2's default behavior), specify the bean name of the FactoryBeanincluding the factory-bean prefix "&": e.g. "&myFactoryBean".org.springframework.beans.factory.FactoryBeanorg.springframework.beans.factory.BeanFactory#FACTORY_BEAN_PREFIXDelegate to {@link AbstractAutoProxyCreator#getCustomTargetSource(Class, String)}if the bean name matches one of the names in the configured list of supportednames, returning {@code null} otherwise.5.3#setBeanNames(String...)Identify as a bean to proxy if the bean name matches one of the names inthe configured list of supported names.Determine if the bean name for the given bean class matches one of the namesin the configured list of supported names.{@code true} if the given bean name is supportedDetermine if the given bean name matches the mapped name.<p>The default implementation checks for "xxx*", "*xxx" and "*xxx*" matches,as well as direct equality. Can be overridden in subclasses.the bean name to checkthe name in the configured list of namesif the names matchorg.springframework.util.PatternMatchUtils#simpleMatch(String, String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/DefaultAdvisorAutoProxyCreator.javaadvisorBeanNamePrefixC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/DefaultAdvisorAutoProxyCreator.classusePrefix{@code BeanPostProcessor} implementation that creates AOP proxies based on allcandidate {@code Advisor}s in the current {@code BeanFactory}. This class iscompletely generic; it contains no special code to handle any particular aspects,such as pooling aspects.<p>It's possible to filter out advisors - for example, to use multiple post processorsof this type in the same factory - by setting the {@code usePrefix} property to true,in which case only advisors beginning with the DefaultAdvisorAutoProxyCreator's beanname followed by a dot (like "aapc.") will be used. This default prefix can be changedfrom the bean name by setting the {@code advisorBeanNamePrefix} property.The separator (.) will also be used in this case.Separator between prefix and remainder of bean name.Set whether to only include advisors with a certain prefix in the bean name.<p>Default is {@code false}, including all beans of type {@code Advisor}.#setAdvisorBeanNamePrefixReturn whether to only include advisors with a certain prefix in the bean name.Set the prefix for bean names that will cause them to be included forauto-proxying by this object. This prefix should be set to avoid circularreferences. Default value is the bean name of this object + a dot.the exclusion prefixReturn the prefix for bean names that will cause them to be includedfor auto-proxying by this object. If no infrastructure bean name prefix has been set, override it.Consider {@code Advisor} beans with the specified prefix as eligible, if activated.#setUsePrefixC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/InfrastructureAdvisorAutoProxyCreator.javaInfrastructureAdvisorAutoProxyCreatorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/InfrastructureAdvisorAutoProxyCreator.classAuto-proxy creator that considers infrastructure Advisor beans only,ignoring any application-defined Advisors.2.0.7C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/ProxyCreationContext.javaProxyCreationContextsetCurrentProxiedBeanNamesetCurrentProxiedBeanName(java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/ProxyCreationContext.classProxyCreationContext()ThreadLocal<String>currentProxiedBeanNameNamedThreadLocal<String>NamedThreadLocal<String>(java.lang.String)childValue(java.lang.String)createMap(java.lang.Thread,java.lang.String)set(java.lang.String)ThreadLocal<String>()"Name of currently proxied bean"Name of currently proxied beanHolder for the current proxy creation context, as exposed by auto-proxy creatorssuch as {@link AbstractAdvisorAutoProxyCreator}.ThreadLocal holding the current proxied bean name during Advisor matching.Return the name of the currently proxied bean instance.the name of the bean, or {@code null} if none availableSet the name of the currently proxied bean instance.the name of the bean, or {@code null} to reset itC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/TargetSourceCreator.javaTargetSourceCreatorImplementations can create special target sources, such as pooling targetsources, for particular beans. For example, they may base their choiceon attributes, such as a pooling attribute, on the target class.<p>AbstractAutoProxyCreator can support a number of TargetSourceCreators,which will be applied in order.Create a special TargetSource for the given bean, if any.a special TargetSource or {@code null} if this TargetSourceCreator isn'tinterested in the particular beanC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/package-info.javaBean post-processors for use in ApplicationContexts to simplify AOP usageby automatically creating AOP proxies without the need to use a ProxyFactoryBean.<p>The various post-processors in this package need only be added to an ApplicationContext(typically in an XML bean definition document) to automatically proxy selected beans.<p><b>NB</b>: Automatic auto-proxying is not supported for BeanFactory implementations,as post-processors beans are only automatically detected in application contexts.Post-processors can be explicitly registered on a ConfigurableBeanFactory instead.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/target/AbstractBeanFactoryBasedTargetSourceCreator.javaAbstractBeanFactoryBasedTargetSourceCreatorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/targetorg.springframework.aop.framework.autoproxy.targetMap<String,DefaultListableBeanFactory>internalBeanFactoriesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/target/AbstractBeanFactoryBasedTargetSourceCreator.class? extends AbstractBeanFactoryBasedTargetSourceCreatorClass<? extends AbstractBeanFactoryBasedTargetSourceCreator>HashMap<String,DefaultListableBeanFactory>AbstractMap<String,DefaultListableBeanFactory>HashMap<String,DefaultListableBeanFactory>()? super DefaultListableBeanFactory? extends DefaultListableBeanFactoryBiFunction<? super DefaultListableBeanFactory,? super DefaultListableBeanFactory,? extends DefaultListableBeanFactory>merge(java.lang.String,org.springframework.beans.factory.support.DefaultListableBeanFactory,java.util.function.BiFunction)BiFunction<? super String,? super DefaultListableBeanFactory,? extends DefaultListableBeanFactory>Function<? super String,? extends DefaultListableBeanFactory>replace(java.lang.String,org.springframework.beans.factory.support.DefaultListableBeanFactory)replace(java.lang.String,org.springframework.beans.factory.support.DefaultListableBeanFactory,org.springframework.beans.factory.support.DefaultListableBeanFactory)putIfAbsent(java.lang.String,org.springframework.beans.factory.support.DefaultListableBeanFactory)BiConsumer<? super String,? super DefaultListableBeanFactory>getOrDefault(java.lang.Object,org.springframework.beans.factory.support.DefaultListableBeanFactory)Entry<String,DefaultListableBeanFactory>Set<Entry<String,DefaultListableBeanFactory>>Collection<Entry<String,DefaultListableBeanFactory>>Iterable<Entry<String,DefaultListableBeanFactory>>Collection<DefaultListableBeanFactory>Iterable<DefaultListableBeanFactory>Map<? extends String,? extends DefaultListableBeanFactory>put(java.lang.String,org.springframework.beans.factory.support.DefaultListableBeanFactory)AbstractMap<String,DefaultListableBeanFactory>()Node<String,DefaultListableBeanFactory>TreeNode<String,DefaultListableBeanFactory>newTreeNode(int,java.lang.String,org.springframework.beans.factory.support.DefaultListableBeanFactory,java.util.HashMap.Node)newNode(int,java.lang.String,org.springframework.beans.factory.support.DefaultListableBeanFactory,java.util.HashMap.Node)Node<String,DefaultListableBeanFactory>[]putVal(int,java.lang.String,org.springframework.beans.factory.support.DefaultListableBeanFactory,boolean,boolean)HashMap<String,DefaultListableBeanFactory>(java.util.Map)HashMap<String,DefaultListableBeanFactory>(int)HashMap<String,DefaultListableBeanFactory>(int,float)? extends BeanFactoryClass<? extends BeanFactory>"Cannot do auto-TargetSource creation with a BeanFactory " +
					"that doesn't implement ConfigurableBeanFactory: "Cannot do auto-TargetSource creation with a BeanFactory that doesn't implement ConfigurableBeanFactory: internalBeanFactorybdCopy"Configuring AbstractBeanFactoryBasedTargetSource: "Configuring AbstractBeanFactoryBasedTargetSource: containingFactoryList<BeanPostProcessor>Collection<BeanPostProcessor>Iterable<BeanPostProcessor>? super BeanPostProcessorPredicate<? super BeanPostProcessor>Spliterator<BeanPostProcessor>Consumer<? super BeanPostProcessor>Iterator<BeanPostProcessor>Stream<BeanPostProcessor>BaseStream<BeanPostProcessor,Stream<BeanPostProcessor>>? extends BeanPostProcessorCollection<? extends BeanPostProcessor>Iterable<? extends BeanPostProcessor>add(org.springframework.beans.factory.config.BeanPostProcessor)Predicate<BeanPostProcessor>test(org.springframework.beans.factory.config.BeanPostProcessor)beanPostProcessorConvenient superclass for{@link org.springframework.aop.framework.autoproxy.TargetSourceCreator}implementations that require creating multiple instances of a prototype bean.<p>Uses an internal BeanFactory to manage the target instances,copying the original bean definition to this internal factory.This is necessary because the original BeanFactory will justcontain the proxy instance created through auto-proxying.<p>Requires running in an{@link org.springframework.beans.factory.support.AbstractBeanFactory}.org.springframework.aop.target.AbstractBeanFactoryBasedTargetSourceorg.springframework.beans.factory.support.AbstractBeanFactoryInternally used DefaultListableBeanFactory instances, keyed by bean name.Return the BeanFactory that this TargetSourceCreators runs in. Implementation of the TargetSourceCreator interface We need to override just this bean definition, as it may reference other beans and we're happy to take the parent's definition for those. Always use prototype scope if demanded. Complete configuring the PrototypeTargetSource.Return the internal BeanFactory to be used for the specified bean.the name of the target beanthe internal BeanFactory to be usedBuild an internal BeanFactory for resolving target beans.the containing BeanFactory that originally defines the beansan independent internal BeanFactory to hold copies of some target beans Set parent so that references (up container hierarchies) are correctly resolved. Required so that all BeanPostProcessors, Scopes, etc become available. Filter out BeanPostProcessors that are part of the AOP infrastructure, since those are only meant to apply to beans defined in the original factory.Destroys the internal BeanFactory on shutdown of the TargetSourceCreator.#getInternalBeanFactoryForBean Template methods to be implemented by subclassesReturn whether this TargetSourceCreator is prototype-based.The scope of the target bean definition will be set accordingly.<p>Default is "true".org.springframework.beans.factory.config.BeanDefinition#isSingleton()Subclasses must implement this method to return a new AbstractPrototypeBasedTargetSourceif they wish to create a custom TargetSource for this bean, or {@code null} if they arenot interested it in, in which case no special target source will be created.Subclasses should not call {@code setTargetBeanName} or {@code setBeanFactory}on the AbstractPrototypeBasedTargetSource: This class' implementation of{@code getTargetSource()} will do that.the AbstractPrototypeBasedTargetSource, or {@code null} if we don't match thisC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/target/LazyInitTargetSourceCreator.javaLazyInitTargetSourceCreator{@code TargetSourceCreator} that enforces a {@link LazyInitTargetSource} foreach bean that is defined as "lazy-init". This will lead to a proxy created foreach of those beans, allowing to fetch a reference to such a bean withoutactually initializing the target bean instance.<p>To be registered as custom {@code TargetSourceCreator} for an auto-proxycreator, in combination with custom interceptors for specific beans or for thecreation of lazy-init proxies only. For example, as an autodetectedinfrastructure bean in an XML application context definition:&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;&lt;property name="beanNames" value="*" /&gt; &lt;!-- apply to all beans --&gt;&lt;property name="customTargetSourceCreators"&gt;&lt;list&gt;&lt;bean class="org.springframework.aop.framework.autoproxy.target.LazyInitTargetSourceCreator" /&gt;&lt;/list&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id="myLazyInitBean" class="mypackage.MyBeanClass" lazy-init="true"&gt;&lt;!-- ... --&gt;&lt;/bean&gt;</pre>1.2org.springframework.beans.factory.config.BeanDefinition#isLazyInitorg.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#setCustomTargetSourceCreatorsorg.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreatorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/autoproxy/target/QuickTargetSourceCreator.javaQuickTargetSourceCreator":":"%"%cpts25Convenient TargetSourceCreator using bean name prefixes to create one of threewell-known TargetSource types:<li>: CommonsPool2TargetSource<li>% ThreadLocalTargetSource<li>! PrototypeTargetSourceStephane Nicollorg.springframework.aop.target.ThreadLocalTargetSourceThe CommonsPool2TargetSource prefix.The ThreadLocalTargetSource prefix.The PrototypeTargetSource prefix. No match. Don't create a custom target source.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/framework/package-info.javaPackage containing Spring's basic AOP infrastructure, compliant with the<a href="http://aopalliance.sourceforge.net">AOP Alliance</a> interfaces.<p>Spring AOP supports proxying interfaces or classes, introductions, and offersstatic and dynamic pointcuts.<p>Any Spring AOP proxy can be cast to the ProxyConfig AOP configuration interfacein this package to add or remove interceptors.<p>The ProxyFactoryBean is a convenient way to create AOP proxies in a BeanFactoryor ApplicationContext. However, proxies can be created programmatically using theProxyFactory class.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/AbstractMonitoringInterceptor.javaAbstractMonitoringInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptororg.springframework.aop.interceptorlogTargetClassInvocationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/AbstractMonitoringInterceptor.classsuffixBase class for monitoring interceptors, such as performance monitors.Provides configurable "prefix and "suffix" properties that help toclassify/group performance monitoring results.<p>In their {@link #invokeUnderTrace} implementation, subclasses should call the{@link #createInvocationTraceName} method to create a name for the given trace,including information about the method invocation along with a prefix/suffix.1.2.7#setPrefix#setSuffix#createInvocationTraceNameSet the text that will get appended to the trace data.<p>Default is none.Return the text that will get appended to the trace data.Set the text that will get prepended to the trace data.Return the text that will get prepended to the trace data.Set whether to log the invocation on the target class, if applicable(i.e. if the method is actually delegated to the target class).<p>Default is "false", logging the invocation based on the proxyinterface/class name.Create a {@code String} name for the given {@code MethodInvocation}that can be used for trace/logging purposes. This name is made up of theconfigured prefix, followed by the fully-qualified name of the method beinginvoked, followed by the configured suffix.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/AbstractTraceInterceptor.javaAbstractTraceInterceptorlogExceptionStackTraceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/AbstractTraceInterceptor.classhideProxyClassNames? extends AbstractTraceInterceptorClass<? extends AbstractTraceInterceptor>useDynamicLoggerloggerName"Target must not be null"Target must not be nullBase {@code MethodInterceptor} implementation for tracing.<p>By default, log messages are written to the log for the interceptor class,not the class which is being intercepted. Setting the {@code useDynamicLogger}bean property to {@code true} causes all log messages to be written tothe {@code Log} for the target class being intercepted.<p>Subclasses must implement the {@code invokeUnderTrace} method, whichis invoked by this class ONLY when a particular invocation SHOULD be traced.Subclasses should write to the {@code Log} instance provided.#setUseDynamicLogger#invokeUnderTrace(org.aopalliance.intercept.MethodInvocation, org.apache.commons.logging.Log)The default {@code Log} instance used to write trace messages.This instance is mapped to the implementing {@code Class}.Indicates whether or not proxy class names should be hidden when using dynamic loggers.Indicates whether to pass an exception to the logger.#writeToLog(Log, String, Throwable)Set whether to use a dynamic logger or a static logger.Default is a static logger for this trace interceptor.<p>Used to determine which {@code Log} instance should be used to writelog messages for a particular method invocation: a dynamic one for the{@code Class} getting called, or a static one for the {@code Class}of the trace interceptor.<p><b>NOTE:</b> Specify either this property or "loggerName", not both.#getLoggerForInvocation(org.aopalliance.intercept.MethodInvocation) Release default logger if it is not being used.Set the name of the logger to use. The name will be passed to theunderlying logger implementation through Commons Logging, gettinginterpreted as log category according to the logger's configuration.<p>This can be specified to not log into the category of a class(whether this interceptor's class or the class getting called)but rather into a specific named category.<p><b>NOTE:</b> Specify either this property or "useDynamicLogger", not both.org.apache.commons.logging.LogFactory#getLog(String)java.util.logging.Logger#getLogger(String)Set to "true" to have {@link #setUseDynamicLogger dynamic loggers} hideproxy class names wherever possible. Default is "false".Set whether to pass an exception to the logger, suggesting inclusionof its stack trace into the log. Default is "true"; set this to "false"in order to reduce the log output to just the trace message (which mayinclude the exception class name and exception message, if applicable).4.3.10Determines whether or not logging is enabled for the particular {@code MethodInvocation}.If not, the method invocation proceeds as normal, otherwise the method invocation is passedto the {@code invokeUnderTrace} method for handling.Return the appropriate {@code Log} instance to use for the given{@code MethodInvocation}. If the {@code useDynamicLogger} flagis set, the {@code Log} instance will be for the target class of the{@code MethodInvocation}, otherwise the {@code Log} will be thedefault static logger.the {@code MethodInvocation} being tracedthe {@code Log} instance to useDetermine the class to use for logging purposes.the target object to introspectthe target class for the given object#setHideProxyClassNamesDetermine whether the interceptor should kick in, that is,whether the {@code invokeUnderTrace} method should be called.<p>Default behavior is to check whether the given {@code Log}instance is enabled. Subclasses can override this to apply theinterceptor in other cases as well.the {@code Log} instance to check#invokeUnderTrace#isLogEnabledDetermine whether the given {@link Log} instance is enabled.<p>Default is {@code true} when the "trace" level is enabled.Subclasses can override this to change the level under which 'tracing' occurs.Write the supplied trace message to the supplied {@code Log} instance.<p>To be called by {@link #invokeUnderTrace} for enter/exit messages.<p>Delegates to {@link #writeToLog(Log, String, Throwable)} as theultimate delegate that controls the underlying logger invocation.Write the supplied trace message and {@link Throwable} to thesupplied {@code Log} instance.<p>To be called by {@link #invokeUnderTrace} for enter/exit outcomes,potentially including an exception. Note that an exception's stack tracewon't get logged when {@link #setLogExceptionStackTrace} is "false".<p>By default messages are written at {@code TRACE} level. Subclassescan override this method to control which level the message is writtenat, typically also overriding {@link #isLogEnabled} accordingly.#setLogExceptionStackTraceSubclasses must override this method to perform any tracing around thesupplied {@code MethodInvocation}. Subclasses are responsible forensuring that the {@code MethodInvocation} actually executes bycalling {@code MethodInvocation.proceed()}.<p>By default, the passed-in {@code Log} instance will have log level"trace" enabled. Subclasses do not have to check for this again, unlessthey overwrite the {@code isInterceptorEnabled} method to modifythe default behavior, and may delegate to {@code writeToLog} for actualmessages to be written.the {@code Log} to write trace messages tothe result of the call to {@code MethodInvocation.proceed()}if the call to {@code MethodInvocation.proceed()}encountered any errors#writeToLog(Log, String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.javaAsyncExecutionAspectSupportC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionAspectSupport.classorg.springframework.util.functionSingletonSupplier<AsyncUncaughtExceptionHandler>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/functionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/function/SingletonSupplier.classSingletonSupplierSupplier<AsyncUncaughtExceptionHandler>exceptionHandlerSingletonSupplier<Executor>Supplier<Executor>defaultExecutorMap<Method,AsyncTaskExecutor>executors? extends AsyncExecutionAspectSupportClass<? extends AsyncExecutionAspectSupport>ConcurrentHashMap<Method,AsyncTaskExecutor>AbstractMap<Method,AsyncTaskExecutor>ConcurrentMap<Method,AsyncTaskExecutor>ConcurrentHashMap<Method,AsyncTaskExecutor>(int)? super AsyncTaskExecutor? extends AsyncTaskExecutorBiFunction<? super AsyncTaskExecutor,? super AsyncTaskExecutor,? extends AsyncTaskExecutor>merge(java.lang.reflect.Method,org.springframework.core.task.AsyncTaskExecutor,java.util.function.BiFunction)BiFunction<? super Method,? super AsyncTaskExecutor,? extends AsyncTaskExecutor>Function<? super Method,? extends AsyncTaskExecutor>replace(java.lang.reflect.Method,org.springframework.core.task.AsyncTaskExecutor)replace(java.lang.reflect.Method,org.springframework.core.task.AsyncTaskExecutor,org.springframework.core.task.AsyncTaskExecutor)putIfAbsent(java.lang.reflect.Method,org.springframework.core.task.AsyncTaskExecutor)BiConsumer<? super Method,? super AsyncTaskExecutor>getOrDefault(java.lang.Object,org.springframework.core.task.AsyncTaskExecutor)Entry<Method,AsyncTaskExecutor>Set<Entry<Method,AsyncTaskExecutor>>Collection<Entry<Method,AsyncTaskExecutor>>Iterable<Entry<Method,AsyncTaskExecutor>>Collection<AsyncTaskExecutor>Iterable<AsyncTaskExecutor>Map<? extends Method,? extends AsyncTaskExecutor>put(java.lang.reflect.Method,org.springframework.core.task.AsyncTaskExecutor)AbstractMap<Method,AsyncTaskExecutor>()ToIntFunction<Entry<Method,AsyncTaskExecutor>>ToLongFunction<Entry<Method,AsyncTaskExecutor>>ToDoubleFunction<Entry<Method,AsyncTaskExecutor>>Function<Entry<Method,AsyncTaskExecutor>,? extends U>? extends Entry<Method,AsyncTaskExecutor>BiFunction<Entry<Method,AsyncTaskExecutor>,Entry<Method,AsyncTaskExecutor>,? extends Entry<Method,AsyncTaskExecutor>>? super Entry<Method,AsyncTaskExecutor>Consumer<? super Entry<Method,AsyncTaskExecutor>>ToIntFunction<? super AsyncTaskExecutor>ToLongFunction<? super AsyncTaskExecutor>ToDoubleFunction<? super AsyncTaskExecutor>Function<? super AsyncTaskExecutor,? extends U>Consumer<? super AsyncTaskExecutor>ToIntBiFunction<? super Method,? super AsyncTaskExecutor>ToLongBiFunction<? super Method,? super AsyncTaskExecutor>ToDoubleBiFunction<? super Method,? super AsyncTaskExecutor>BiFunction<? super Method,? super AsyncTaskExecutor,? extends U>Node<Method,AsyncTaskExecutor>Node<Method,AsyncTaskExecutor>[]KeySetView<Method,AsyncTaskExecutor>CollectionView<Method,AsyncTaskExecutor,Method>keySet(org.springframework.core.task.AsyncTaskExecutor)Enumeration<AsyncTaskExecutor>Predicate<? super AsyncTaskExecutor>Predicate<? super Entry<Method,AsyncTaskExecutor>>replaceNode(java.lang.Object,org.springframework.core.task.AsyncTaskExecutor,java.lang.Object)putVal(java.lang.reflect.Method,org.springframework.core.task.AsyncTaskExecutor,boolean)ConcurrentHashMap<Method,AsyncTaskExecutor>(int,float,int)ConcurrentHashMap<Method,AsyncTaskExecutor>(int,float)ConcurrentHashMap<Method,AsyncTaskExecutor>(java.util.Map)ConcurrentHashMap<Method,AsyncTaskExecutor>()"taskExecutor"taskExecutor? extends ExecutorSupplier<? extends Executor>SingletonSupplier<Executor>(java.util.concurrent.Executor,java.util.function.Supplier)SingletonSupplier<>SingletonSupplier<T>Supplier<T>ofNullable(java.util.function.Supplier)of(java.util.function.Supplier)obtainobtain()SingletonSupplier(java.util.function.Supplier,java.util.function.Supplier)SingletonSupplier<Executor>(java.util.function.Supplier,java.util.function.Supplier)SingletonSupplier(java.lang.Object,java.util.function.Supplier)SingletonSupplier<>(java.util.function.Supplier,java.util.function.Supplier)SingletonSupplier<>(java.lang.Object,java.util.function.Supplier)? extends AsyncUncaughtExceptionHandlerSupplier<? extends AsyncUncaughtExceptionHandler>SingletonSupplier<AsyncUncaughtExceptionHandler>(java.util.function.Supplier,java.util.function.Supplier)SingletonSupplier<AsyncUncaughtExceptionHandler>(org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler,java.util.function.Supplier)targetExecutorqualifier"BeanFactory must be set on "BeanFactory must be set on Map<String,? extends AsyncExecutionAspectSupport>AsyncExecutionAspectSupport[]? extends AsyncExecutionAspectSupport[]Constructor<? extends AsyncExecutionAspectSupport>? super ? extends AsyncExecutionAspectSupportClass<? super ? extends AsyncExecutionAspectSupport>TypeVariable<Class<? extends AsyncExecutionAspectSupport>>TypeVariable<Class<? extends AsyncExecutionAspectSupport>>[]" to access qualified executor '" to access qualified executor 'Class<Executor>Class<TaskExecutor>"Could not find unique TaskExecutor bean"Could not find unique TaskExecutor bean"More than one TaskExecutor bean found within the context, and none is named " +
								"'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly " +
								"as an alias) in order to use it for async processing: "More than one TaskExecutor bean found within the context, and none is named 'taskExecutor'. Mark one of them as primary or name it 'taskExecutor' (possibly as an alias) in order to use it for async processing: "Could not find default TaskExecutor bean"Could not find default TaskExecutor bean"No task executor bean found for async processing: " +
							"no bean of type TaskExecutor and no bean named 'taskExecutor' either"No task executor bean found for async processing: no bean of type TaskExecutor and no bean named 'taskExecutor' eitherCallable<Object>C:/modules/java.base/java/util/concurrent/Callable.classCallabletaskCompletableFuture<>C:/modules/java.base/java/util/concurrent/CompletableFuture.classCompletableFutureFuture<>C:/modules/java.base/java/util/concurrent/Future.classFutureCompletionStage<>C:/modules/java.base/java/util/concurrent/CompletionStage.classCompletionStageClass<CompletableFuture<>>Map<String,CompletableFuture<>>CompletableFuture[]CompletableFuture<>[]Constructor<CompletableFuture<>>? super CompletableFuture<>Class<? super CompletableFuture<>>TypeVariable<Class<CompletableFuture<>>>TypeVariable<Class<CompletableFuture<>>>[]CompletableFuture<Object>Future<Object>CompletionStage<Object>CompletableFuture<U>Future<U>CompletionStage<U>supplyAsyncsupplyAsync(java.util.function.Supplier,java.util.concurrent.Executor)Supplier<U>get(long,java.util.concurrent.TimeUnit)isDoneisDone()isCancelledisCancelled()cancelcancel(boolean)CompletableFuture<T>Future<T>toCompletableFuturetoCompletableFuture()? extends CompletionStageFunction<Throwable,? extends CompletionStage>exceptionallyComposeAsyncexceptionallyComposeAsync(java.util.function.Function,java.util.concurrent.Executor)exceptionallyComposeAsync(java.util.function.Function)exceptionallyComposeexceptionallyCompose(java.util.function.Function)Function<Throwable,? extends T>exceptionallyAsyncexceptionallyAsync(java.util.function.Function,java.util.concurrent.Executor)exceptionallyAsync(java.util.function.Function)exceptionallyexceptionally(java.util.function.Function)BiConsumer<? super T,? super Throwable>whenCompleteAsyncwhenCompleteAsync(java.util.function.BiConsumer,java.util.concurrent.Executor)whenCompleteAsync(java.util.function.BiConsumer)whenCompletewhenComplete(java.util.function.BiConsumer)handleAsynchandleAsync(java.util.function.BiFunction,java.util.concurrent.Executor)BiFunction<? super T,Throwable,? extends U>handleAsync(java.util.function.BiFunction)handlehandle(java.util.function.BiFunction)thenComposeAsyncthenComposeAsync(java.util.function.Function,java.util.concurrent.Executor)? extends CompletionStage<U>Function<? super T,? extends CompletionStage<U>>thenComposeAsync(java.util.function.Function)thenComposethenCompose(java.util.function.Function)CompletionStage<?>CompletionStage<Void>runAfterEitherAsyncrunAfterEitherAsync(java.util.concurrent.CompletionStage,java.lang.Runnable,java.util.concurrent.Executor)runAfterEitherAsync(java.util.concurrent.CompletionStage,java.lang.Runnable)runAfterEitherrunAfterEither(java.util.concurrent.CompletionStage,java.lang.Runnable)CompletionStage<? extends T>acceptEitherAsyncacceptEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Consumer,java.util.concurrent.Executor)acceptEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Consumer)acceptEitheracceptEither(java.util.concurrent.CompletionStage,java.util.function.Consumer)applyToEitherAsyncapplyToEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Function,java.util.concurrent.Executor)Function<? super T,U>applyToEitherAsync(java.util.concurrent.CompletionStage,java.util.function.Function)applyToEitherapplyToEither(java.util.concurrent.CompletionStage,java.util.function.Function)runAfterBothAsyncrunAfterBothAsync(java.util.concurrent.CompletionStage,java.lang.Runnable,java.util.concurrent.Executor)runAfterBothAsync(java.util.concurrent.CompletionStage,java.lang.Runnable)runAfterBothrunAfterBoth(java.util.concurrent.CompletionStage,java.lang.Runnable)thenAcceptBothAsyncthenAcceptBothAsync(java.util.concurrent.CompletionStage,java.util.function.BiConsumer,java.util.concurrent.Executor)CompletionStage<? extends U>BiConsumer<? super T,? super U>thenAcceptBothAsync(java.util.concurrent.CompletionStage,java.util.function.BiConsumer)thenAcceptBoththenAcceptBoth(java.util.concurrent.CompletionStage,java.util.function.BiConsumer)CompletionStage<V>thenCombineAsyncthenCombineAsync(java.util.concurrent.CompletionStage,java.util.function.BiFunction,java.util.concurrent.Executor)BiFunction<? super T,? super U,? extends V>thenCombineAsync(java.util.concurrent.CompletionStage,java.util.function.BiFunction)thenCombinethenCombine(java.util.concurrent.CompletionStage,java.util.function.BiFunction)thenRunAsyncthenRunAsync(java.lang.Runnable,java.util.concurrent.Executor)thenRunAsync(java.lang.Runnable)thenRunthenRun(java.lang.Runnable)thenAcceptAsyncthenAcceptAsync(java.util.function.Consumer,java.util.concurrent.Executor)thenAcceptAsync(java.util.function.Consumer)thenAcceptthenAccept(java.util.function.Consumer)thenApplyAsyncthenApplyAsync(java.util.function.Function,java.util.concurrent.Executor)thenApplyAsync(java.util.function.Function)thenApplythenApply(java.util.function.Function)failedStagefailedStage(java.lang.Throwable)failedFuturefailedFuture(java.lang.Throwable)completedStagecompletedStage(java.lang.Object)delayedExecutordelayedExecutor(long,java.util.concurrent.TimeUnit)delayedExecutor(long,java.util.concurrent.TimeUnit,java.util.concurrent.Executor)completeOnTimeoutcompleteOnTimeout(java.lang.Object,long,java.util.concurrent.TimeUnit)orTimeoutorTimeout(long,java.util.concurrent.TimeUnit)completeAsynccompleteAsync(java.util.function.Supplier)completeAsync(java.util.function.Supplier,java.util.concurrent.Executor)CompletionStage<T>minimalCompletionStageminimalCompletionStage()defaultExecutor()newIncompleteFuturenewIncompleteFuture()getNumberOfDependentsgetNumberOfDependents()obtrudeExceptionobtrudeException(java.lang.Throwable)obtrudeValueobtrudeValue(java.lang.Object)isCompletedExceptionallyisCompletedExceptionally()CompletableFuture<?>Future<?>CompletableFuture<?>[]anyOfanyOf(java.util.concurrent.CompletableFuture[])CompletableFuture<Void>Future<Void>allOfallOf(java.util.concurrent.CompletableFuture[])? extends CompletionStage<T>Function<Throwable,? extends CompletionStage<T>>CompletableFuture<V>Future<V>completeExceptionallycompleteExceptionally(java.lang.Throwable)completecomplete(java.lang.Object)getNowgetNow(java.lang.Object)joinjoin()completedFuturecompletedFuture(java.lang.Object)runAsyncrunAsync(java.lang.Runnable,java.util.concurrent.Executor)runAsync(java.lang.Runnable)supplyAsync(java.util.function.Supplier)CompletableFuture(java.lang.Object)CompletableFuture<>(java.lang.Object)CompletableFuture()CompletableFuture<>()asyncRunStageasyncRunStage(java.util.concurrent.Executor,java.lang.Runnable)asyncSupplyStageasyncSupplyStage(java.util.concurrent.Executor,java.util.function.Supplier)BiCompletion<?,?,?>C:/modules/java.base/java/util/concurrent/CompletableFuture$BiCompletion.classCompletableFuture$BiCompletionUniCompletion<?,?>C:/modules/java.base/java/util/concurrent/CompletableFuture$UniCompletion.classCompletableFuture$UniCompletionorpushorpush(java.util.concurrent.CompletableFuture,java.util.concurrent.CompletableFuture.BiCompletion)BiCompletion<>UniCompletion<>andTreeandTree(java.util.concurrent.CompletableFuture[],int,int)BiRun<?,?>C:/modules/java.base/java/util/concurrent/CompletableFuture$BiRun.classCompletableFuture$BiRunBiCompletion<?,?,Void>UniCompletion<?,Void>biRunbiRun(java.lang.Object,java.lang.Object,java.lang.Runnable,java.util.concurrent.CompletableFuture.BiRun)BiRun<>BiAccept<>C:/modules/java.base/java/util/concurrent/CompletableFuture$BiAccept.classCompletableFuture$BiAcceptbiAcceptbiAccept(java.lang.Object,java.lang.Object,java.util.function.BiConsumer,java.util.concurrent.CompletableFuture.BiAccept)? super SBiConsumer<? super R,? super S>BiAccept<R,S>BiCompletion<R,S,Void>UniCompletion<R,Void>BiApply<>C:/modules/java.base/java/util/concurrent/CompletableFuture$BiApply.classCompletableFuture$BiApplybiApplybiApply(java.lang.Object,java.lang.Object,java.util.function.BiFunction,java.util.concurrent.CompletableFuture.BiApply)BiFunction<? super R,? super S,? extends T>BiApply<R,S,T>BiCompletion<R,S,T>UniCompletion<R,T>postFirepostFire(java.util.concurrent.CompletableFuture,java.util.concurrent.CompletableFuture,int)bipushbipush(java.util.concurrent.CompletableFuture,java.util.concurrent.CompletableFuture.BiCompletion)Function<? super Throwable,? extends T>UniExceptionally<T>C:/modules/java.base/java/util/concurrent/CompletableFuture$UniExceptionally.classCompletableFuture$UniExceptionallyUniCompletion<T,T>uniExceptionallyuniExceptionally(java.lang.Object,java.util.function.Function,java.util.concurrent.CompletableFuture.UniExceptionally)UniExceptionally<>UniHandle<>C:/modules/java.base/java/util/concurrent/CompletableFuture$UniHandle.classCompletableFuture$UniHandleuniHandleuniHandle(java.lang.Object,java.util.function.BiFunction,java.util.concurrent.CompletableFuture.UniHandle)BiFunction<? super S,Throwable,? extends T>UniHandle<S,T>UniCompletion<S,T>UniWhenComplete<T>C:/modules/java.base/java/util/concurrent/CompletableFuture$UniWhenComplete.classCompletableFuture$UniWhenCompleteuniWhenCompleteuniWhenComplete(java.lang.Object,java.util.function.BiConsumer,java.util.concurrent.CompletableFuture.UniWhenComplete)UniWhenComplete<>postFire(java.util.concurrent.CompletableFuture,int)unipushunipush(java.util.concurrent.CompletableFuture.Completion)cleanStackcleanStack()postCompletepostComplete()screenExecutorscreenExecutor(java.util.concurrent.Executor)completeRelaycompleteRelay(java.lang.Object)encodeRelayencodeRelay(java.lang.Object)encodeOutcomeencodeOutcome(java.lang.Object,java.lang.Throwable)completeThrowablecompleteThrowable(java.lang.Throwable,java.lang.Object)encodeThrowableencodeThrowable(java.lang.Throwable,java.lang.Object)completeThrowable(java.lang.Throwable)encodeThrowable(java.lang.Throwable)completeValuecompleteValue(java.lang.Object)encodeValueencodeValue(java.lang.Object)completeNullcompleteNull()pushStackpushStack(java.util.concurrent.CompletableFuture.Completion)tryPushStacktryPushStack(java.util.concurrent.CompletableFuture.Completion)internalCompleteinternalComplete(java.lang.Object)NESTEDASYNCSYNCNILstackSupplier<Object>org.springframework.util.concurrentListenableFuture<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/concurrentC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/concurrent/ListenableFuture.classListenableFutureClass<ListenableFuture<>>Map<String,ListenableFuture<>>ListenableFuture[]ListenableFuture<>[]Constructor<ListenableFuture<>>? super ListenableFuture<>Class<? super ListenableFuture<>>TypeVariable<Class<ListenableFuture<>>>TypeVariable<Class<ListenableFuture<>>>[]ListenableFuture<Object>Callable<>Class<Future<>>Map<String,Future<>>Future[]Future<>[]Constructor<Future<>>? super Future<>Class<? super Future<>>TypeVariable<Class<Future<>>>TypeVariable<Class<Future<>>>[]params"Exception handler for async method '"Exception handler for async method '"' threw unexpected exception itself"' threw unexpected exception itselfBase class for asynchronous method execution aspects, such as{@code org.springframework.scheduling.annotation.AnnotationAsyncExecutionInterceptor}or {@code org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect}.<p>Provides support for <i>executor qualification</i> on a method-by-method basis.{@code AsyncExecutionAspectSupport} objects must be constructed with a default {@codeExecutor}, but each individual method may further qualify a specific {@code Executor}bean to be used when executing it, e.g. through an annotation attribute.3.1.2The default name of the {@link TaskExecutor} bean to pick up: "taskExecutor".<p>Note that the initial lookup happens by type; this is just the fallbackin case of multiple executor beans found in the context.4.2.6Create a new instance with a default {@link AsyncUncaughtExceptionHandler}.the {@code Executor} (typically a Spring {@code AsyncTaskExecutor}or {@link java.util.concurrent.ExecutorService}) to delegate to, unless a more specificexecutor has been requested via a qualifier on the async method, in which case theexecutor will be looked up at invocation time against the enclosing bean factoryCreate a new {@link AsyncExecutionAspectSupport} with the given exception handler.the {@link AsyncUncaughtExceptionHandler} to useConfigure this aspect with the given executor and exception handler suppliers,applying the corresponding default if a supplier is not resolvable.Supply the executor to be used when executing async methods.#getExecutorQualifier(Method)#setBeanFactory(BeanFactory)#getDefaultExecutor(BeanFactory)Supply the {@link AsyncUncaughtExceptionHandler} to use to handle exceptionsthrown by invoking asynchronous methods with a {@code void} return type.Set the {@link BeanFactory} to be used when looking up executors by qualifieror when relying on the default executor lookup algorithm.#findQualifiedExecutor(BeanFactory, String)Determine the specific executor to use when executing the given method.Should preferably return an {@link AsyncListenableTaskExecutor} implementation.the executor to use (or {@code null}, but just if no default executor is available)Return the qualifier or bean name of the executor to be used when executing thegiven async method, typically specified in the form of an annotation attribute.Returning an empty string or {@code null} indicates that no specific executor hasbeen specified and that the {@linkplain #setExecutor(Executor) default executor}should be used.the method to inspect for executor qualifier metadatathe qualifier if specified, otherwise empty String or {@code null}#determineAsyncExecutor(Method)Retrieve a target executor for the given qualifier.the qualifier to resolvethe target executor, or {@code null} if none availableRetrieve or build a default executor for this advice instance.An executor returned from here will be cached for further use.<p>The default implementation searches for a unique {@link TaskExecutor} beanin the context, or for an {@link Executor} bean named "taskExecutor" otherwise.If neither of the two is resolvable, this implementation will return {@code null}.the BeanFactory to use for a default executor lookupthe default executor, or {@code null} if none available#DEFAULT_TASK_EXECUTOR_BEAN_NAME Search for TaskExecutor bean... not plain Executor since that would match with ScheduledExecutorService as well, which is unusable for our purposes here. TaskExecutor is more clearly designed for it. Giving up -> either using local default executor or none at all...Delegate for actually executing the given task with the chosen executor.the task to executethe chosen executorthe declared return type (potentially a {@link Future} variant)the execution result (potentially a corresponding {@link Future} handle)Handles a fatal error thrown while asynchronously invoking the specified{@link Method}.<p>If the return type of the method is a {@link Future} object, the originalexception can be propagated by just throwing it at the higher level. However,for all other cases, the exception will not be transmitted back to the client.In that later case, the current {@link AsyncUncaughtExceptionHandler} will beused to manage such exception.the exception to handlethe method that was invokedthe parameters used to invoke the method Could not transmit the exception to the caller with default executorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncExecutionInterceptor.javaAsyncExecutionInterceptorspecificMethoduserDeclaredMethod"No executor specified and no default executor set on AsyncExecutionInterceptor either"No executor specified and no default executor set on AsyncExecutionInterceptor eitherAOP Alliance {@code MethodInterceptor} that processes method invocationsasynchronously, using a given {@link org.springframework.core.task.AsyncTaskExecutor}.Typically used with the {@link org.springframework.scheduling.annotation.Async} annotation.<p>In terms of target method signatures, any parameter types are supported.However, the return type is constrained to either {@code void} or{@code java.util.concurrent.Future}. In the latter case, the Future handlereturned from the proxy will be an actual asynchronous Future that can be usedto track the result of the asynchronous method execution. However, since thetarget method needs to implement the same signature, it will have to returna temporary Future handle that just passes the return value through(like Spring's {@link org.springframework.scheduling.annotation.AsyncResult}or EJB 3.1's {@code javax.ejb.AsyncResult}).<p>When the return type is {@code java.util.concurrent.Future}, any exception thrownduring the execution can be accessed and managed by the caller. With {@code void}return type however, such exceptions cannot be transmitted back. In that case an{@link AsyncUncaughtExceptionHandler} can be registered to process such exceptions.<p>As of Spring 3.1.2 the {@code AnnotationAsyncExecutionInterceptor} subclass ispreferred for use due to its support for executor qualification in conjunction withSpring's {@code @Async} annotation.3.0org.springframework.scheduling.annotation.Asyncorg.springframework.scheduling.annotation.AsyncAnnotationAdvisororg.springframework.scheduling.annotation.AnnotationAsyncExecutionInterceptorthe {@link Executor} (typically a Spring {@link AsyncTaskExecutor}or {@link java.util.concurrent.ExecutorService}) to delegate to;as of 4.2.6, a local executor for this interceptor will be built otherwiseCreate a new {@code AsyncExecutionInterceptor}.Intercept the given method invocation, submit the actual calling of the method tothe correct task executor and return immediately to the caller.the method to intercept and make asynchronous{@link Future} if the original method returns {@code Future}; {@code null}otherwise.This implementation is a no-op for compatibility in Spring 3.1.2.Subclasses may override to provide support for extracting qualifier information,e.g. via an annotation on the given method.always {@code null}This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor}bean in the context, or for an {@link Executor} bean named "taskExecutor" otherwise.If neither of the two is resolvable (e.g. if no {@code BeanFactory} was configured at all),this implementation falls back to a newly created {@link SimpleAsyncTaskExecutor} instancefor local use if no default could be found.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.javaAsyncUncaughtExceptionHandlerA strategy for handling uncaught exceptions thrown from asynchronous methods.<p>An asynchronous method usually returns a {@link java.util.concurrent.Future}instance that gives access to the underlying exception. When the method doesnot provide that return type, this handler can be used to manage suchuncaught exceptions.Handle the given uncaught exception thrown from an asynchronous method.the exception thrown from the asynchronous methodthe asynchronous methodthe parameters used to invoked the methodC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/ConcurrencyThrottleInterceptor.javaConcurrencyThrottleInterceptorInterceptor that throttles concurrent access, blocking invocationsif a specified concurrency limit is reached.<p>Can be applied to methods of local services that involve heavy useof system resources, in a scenario where it is more efficient tothrottle concurrency for a specific service rather than restrictingthe entire thread pool (e.g. the web container's thread pool).<p>The default concurrency limit of this interceptor is 1.Specify the "concurrencyLimit" bean property to change this value.11.02.2004#setConcurrencyLimitC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/CustomizableTraceInterceptor.javaCustomizableTraceInterceptorcheckForInvalidPlaceholderscheckForInvalidPlaceholders(java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/CustomizableTraceInterceptor.classappendArgumentTypesappendArgumentTypes(org.aopalliance.intercept.MethodInvocation,java.util.regex.Matcher,java.lang.StringBuffer)appendReturnValueappendReturnValue(org.aopalliance.intercept.MethodInvocation,java.util.regex.Matcher,java.lang.StringBuffer,java.lang.Object)exceptionMessageexitMessageenterMessageALLOWED_PLACEHOLDERSPATTERNDEFAULT_EXCEPTION_MESSAGEDEFAULT_EXIT_MESSAGEDEFAULT_ENTER_MESSAGE"$[methodName]"$[methodName]"$[targetClassName]"$[targetClassName]"$[targetClassShortName]"$[targetClassShortName]"$[returnValue]"$[returnValue]"$[argumentTypes]"$[argumentTypes]"$[arguments]"$[arguments]"$[exception]"$[exception]"$[invocationTime]"$[invocationTime]"Entering method '"Entering method '"' of class ["' of class ["Exiting method '"Exiting method '"Exception thrown in method '"Exception thrown in method '"\\$\\[\\p{Alpha}+]"\$\[\p{Alpha}+]Class<CustomizableTraceInterceptor>"PLACEHOLDER_"PLACEHOLDER_"enterMessage must not be empty"enterMessage must not be empty"enterMessage cannot contain placeholder "enterMessage cannot contain placeholder "exitMessage must not be empty"exitMessage must not be empty"exitMessage cannot contain placeholder"exitMessage cannot contain placeholder"exceptionMessage must not be empty"exceptionMessage must not be empty"exceptionMessage cannot contain placeholder "exceptionMessage cannot contain placeholder stopWatchexitThroughExceptionthrowableinvocationTimematcheroutputshortName"Unknown placeholder ["Unknown placeholder ["void""null"nullargumentTypeShortNames"Placeholder ["Placeholder ["] is not valid"] is not valid{@code MethodInterceptor} implementation that allows for highly customizablemethod-level tracing, using placeholders.<p>Trace messages are written on method entry, and if the method invocation succeedson method exit. If an invocation results in an exception, then an exception messageis written. The contents of these trace messages is fully customizable and specialplaceholders are available to allow you to include runtime information in your logmessages. The placeholders available are:<p><ul><li>{@code $[methodName]} - replaced with the name of the method being invoked</li><li>{@code $[targetClassName]} - replaced with the name of the class that isthe target of the invocation</li><li>{@code $[targetClassShortName]} - replaced with the short name of the classthat is the target of the invocation</li><li>{@code $[returnValue]} - replaced with the value returned by the invocation</li><li>{@code $[argumentTypes]} - replaced with a comma-separated list of theshort class names of the method arguments</li><li>{@code $[arguments]} - replaced with a comma-separated list of the{@code String} representation of the method arguments</li><li>{@code $[exception]} - replaced with the {@code String} representationof any {@code Throwable} raised during the invocation</li><li>{@code $[invocationTime]} - replaced with the time, in milliseconds,taken by the method invocation</li><p>There are restrictions on which placeholders can be used in which messages:see the individual message properties for details on the valid placeholders.#setEnterMessage#setExitMessage#setExceptionMessageSimpleTraceInterceptorThe {@code $[methodName]} placeholder.Replaced with the name of the method being invoked.The {@code $[targetClassName]} placeholder.Replaced with the fully-qualified name of the {@code Class}of the method invocation target.The {@code $[targetClassShortName]} placeholder.Replaced with the short name of the {@code Class} of themethod invocation target.The {@code $[returnValue]} placeholder.Replaced with the {@code String} representation of the valuereturned by the method invocation.The {@code $[argumentTypes]} placeholder.Replaced with a comma-separated list of the argument types for themethod invocation. Argument types are written as short class names.The {@code $[arguments]} placeholder.Replaced with a comma separated list of the argument values for themethod invocation. Relies on the {@code toString()} method ofeach argument type.The {@code $[exception]} placeholder.Replaced with the {@code String} representation of any{@code Throwable} raised during method invocation.The {@code $[invocationTime]} placeholder.Replaced with the time taken by the invocation (in milliseconds).The default message used for writing method entry messages.The default message used for writing method exit messages.The default message used for writing exception messages.The {@code Pattern} used to match placeholders.The {@code Set} of allowed placeholders.The message for method entry.The message for method exit.The message for exceptions during method execution.Set the template used for method entry log messages.This template can contain any of the following placeholders:<li>{@code $[targetClassName]}</li><li>{@code $[targetClassShortName]}</li><li>{@code $[argumentTypes]}</li><li>{@code $[arguments]}</li>Set the template used for method exit log messages.<li>{@code $[returnValue]}</li><li>{@code $[invocationTime]}</li>Set the template used for method exception log messages.<li>{@code $[exception]}</li>Writes a log message before the invocation based on the value of {@code enterMessage}.If the invocation succeeds, then a log message is written on exit based on the value{@code exitMessage}. If an exception occurs during invocation, then a message iswritten based on the value of {@code exceptionMessage}.Replace the placeholders in the given message with the supplied values,or values derived from those supplied.the message template containing the placeholders to be replacedthe {@code MethodInvocation} being logged.Used to derive values for all placeholders except {@code $[exception]}and {@code $[returnValue]}.any value returned by the invocation.Used to replace the {@code $[returnValue]} placeholder. May be {@code null}.any {@code Throwable} raised during the invocation.The value of {@code Throwable.toString()} is replaced for the{@code $[exception]} placeholder. May be {@code null}.the value to write in place of the{@code $[invocationTime]} placeholderthe formatted output to write to the log Should not happen since placeholders are checked earlier.Adds the {@code String} representation of the method return valueto the supplied {@code StringBuffer}. Correctly handles{@code null} and {@code void} results.the {@code MethodInvocation} that returned the valuethe {@code Matcher} containing the matched placeholderthe {@code StringBuffer} to write output tothe value returned by the method invocation.Adds a comma-separated list of the short {@code Class} names of themethod argument types to the output. For example, if a method has signature{@code put(java.lang.String, java.lang.Object)} then the value returnedwill be {@code String, Object}.Arguments will be retrieved from the corresponding {@code Method}.the {@code Matcher} containing the state of the outputthe {@code StringBuffer} containing the outputChecks to see if the supplied {@code String} has any placeholdersthat are not specified as constants on this class and throws an{@code IllegalArgumentException} if so.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/DebugInterceptor.javaDebugInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/DebugInterceptor.class"; count="; count=AOP Alliance {@code MethodInterceptor} that can be introduced in a chainto display verbose information about intercepted invocations to the logger.<p>Logs full invocation details on method entry and method exit,including invocation arguments and invocation count. This is onlyintended for debugging purposes; use {@code SimpleTraceInterceptor}or {@code CustomizableTraceInterceptor} for pure tracing purposes.Create a new DebugInterceptor with a static logger.Create a new DebugInterceptor with dynamic or static logger,according to the given flag.whether to use a dynamic logger or a static loggerReturn the number of times this interceptor has been invoked.Reset the invocation count to zero.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/ExposeBeanNameAdvisors.javaExposeBeanNameAdvisorsBEAN_NAME_ATTRIBUTEC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/ExposeBeanNameAdvisors.classClass<ExposeBeanNameAdvisors>Map<String,ExposeBeanNameAdvisors>ExposeBeanNameAdvisors[]Constructor<ExposeBeanNameAdvisors>? super ExposeBeanNameAdvisorsClass<? super ExposeBeanNameAdvisors>TypeVariable<Class<ExposeBeanNameAdvisors>>TypeVariable<Class<ExposeBeanNameAdvisors>>[]".BEAN_NAME".BEAN_NAME"Cannot get bean name; not set on MethodInvocation: "Cannot get bean name; not set on MethodInvocation: C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/ExposeBeanNameAdvisors$ExposeBeanNameInterceptor.classExposeBeanNameAdvisors$ExposeBeanNameInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/ExposeBeanNameAdvisors$ExposeBeanNameIntroduction.classExposeBeanNameAdvisors$ExposeBeanNameIntroductionConvenient methods for creating advisors that may be used when autoproxying beanscreated with the Spring IoC container, binding the bean name to the currentinvocation. May support a {@code bean()} pointcut designator with AspectJ.<p>Typically used in Spring auto-proxying, where the bean name is knownat proxy creation time.org.springframework.beans.factory.NamedBeanBinding for the bean name of the bean which is currently being invokedin the ReflectiveMethodInvocation userAttributes Map.Find the bean name for the current invocation. Assumes that an ExposeBeanNameAdvisorhas been included in the interceptor chain, and that the invocation is exposedwith ExposeInvocationInterceptor.the bean name (never {@code null})if the bean name has not been exposedFind the bean name for the given invocation. Assumes that an ExposeBeanNameAdvisorhas been included in the interceptor chain.the MethodInvocation that should contain the bean name as an attributeCreate a new advisor that will expose the given bean name,with no introduction.bean name to exposeCreate a new advisor that will expose the given bean name, introducingthe NamedBean interface to make the bean name accessible without forcingthe target object to be aware of this Spring IoC concept.the bean name to exposeInterceptor that exposes the specified bean name as invocation attribute.Introduction that exposes the specified bean name as invocation attribute.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/ExposeInvocationInterceptor.javaExposeInvocationInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/ExposeInvocationInterceptor.classExposeInvocationInterceptor()ThreadLocal<MethodInvocation>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/ExposeInvocationInterceptor$1.classExposeInvocationInterceptor$1(org.aopalliance.aop.Advice)Class<ExposeInvocationInterceptor>Map<String,ExposeInvocationInterceptor>ExposeInvocationInterceptor[]Constructor<ExposeInvocationInterceptor>? super ExposeInvocationInterceptorClass<? super ExposeInvocationInterceptor>TypeVariable<Class<ExposeInvocationInterceptor>>TypeVariable<Class<ExposeInvocationInterceptor>>[]".ADVISOR".ADVISORNamedThreadLocal<MethodInvocation>NamedThreadLocal<MethodInvocation>(java.lang.String)childValue(org.aopalliance.intercept.MethodInvocation)createMap(java.lang.Thread,org.aopalliance.intercept.MethodInvocation)set(org.aopalliance.intercept.MethodInvocation)ThreadLocal<MethodInvocation>()"Current AOP method invocation"Current AOP method invocation"No MethodInvocation found: Check that an AOP invocation is in progress and that the " +
					"ExposeInvocationInterceptor is upfront in the interceptor chain. Specifically, note that " +
					"advices with order HIGHEST_PRECEDENCE will execute before ExposeInvocationInterceptor! " +
					"In addition, ExposeInvocationInterceptor and ExposeInvocationInterceptor.currentInvocation() " +
					"must be invoked from the same thread."No MethodInvocation found: Check that an AOP invocation is in progress and that the ExposeInvocationInterceptor is upfront in the interceptor chain. Specifically, note that advices with order HIGHEST_PRECEDENCE will execute before ExposeInvocationInterceptor! In addition, ExposeInvocationInterceptor and ExposeInvocationInterceptor.currentInvocation() must be invoked from the same thread.oldInvocationInterceptor that exposes the current {@link org.aopalliance.intercept.MethodInvocation}as a thread-local object. We occasionally need to do this; for example, when a pointcut(e.g. an AspectJ expression pointcut) needs to know the full invocation context.<p>Don't use this interceptor unless this is really necessary. Target objects shouldnot normally know about Spring AOP, as this creates a dependency on Spring API.Target objects should be plain POJOs as far as possible.<p>If used, this interceptor will normally be the first in the interceptor chain.Singleton instance of this class.Singleton advisor for this class. Use in preference to INSTANCE when usingSpring AOP, as it prevents the need to create a new Advisor to wrap the instance.Return the AOP Alliance MethodInvocation object associated with the current invocation.the invocation object associated with the current invocationif there is no AOP invocation in progress,or if the ExposeInvocationInterceptor was not added to this interceptor chainEnsures that only the canonical instance can be created.Required to support serialization. Replaces with canonical instanceon deserialization, protecting Singleton pattern.<p>Alternative to overriding the {@code equals} method.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/JamonPerformanceMonitorInterceptor.javaJamonPerformanceMonitorInterceptortrackAllInvocationsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/JamonPerformanceMonitorInterceptor.class"ms."ms.monitor"JAMon performance statistics for method ["JAMon performance statistics for method ["]:\n"]:
stackTrace"stackTrace="stackTrace=Map<String,? extends Throwable>? extends Throwable[]Constructor<? extends Throwable>Class<? super ? extends Throwable>TypeVariable<Class<? extends Throwable>>TypeVariable<Class<? extends Throwable>>[]"Exception"Performance monitor interceptor that uses <b>JAMon</b> library to perform theperformance measurement on the intercepted method and output the stats.In addition, it tracks/counts exceptions thrown by the intercepted method.The stack traces can be viewed in the JAMon web application.<p>This code is inspired by Thierry Templier's blog.Steve Souzacom.jamonapi.MonitorFactoryPerformanceMonitorInterceptorCreate a new JamonPerformanceMonitorInterceptor with a static logger.Create a new JamonPerformanceMonitorInterceptor with a dynamic or static logger,whether to track all invocations that go throughthis interceptor, or just invocations with trace logging enabledSet whether to track all invocations that go through this interceptor,or just invocations with trace logging enabled.<p>Default is "false": Only invocations with trace logging enabled willbe monitored. Specify "true" to let JAMon track all invocations,gathering statistics even when trace logging is disabled.Always applies the interceptor if the "trackAllInvocations" flag has been set;else just kicks in if the log is enabled.#setTrackAllInvocationsWraps the invocation with a JAMon Monitor and writes the currentperformance statistics to the log (if enabled).com.jamonapi.MonitorFactory#startcom.jamonapi.Monitor#stopCount the thrown exception and put the stack trace in the details portion of the key.This will allow the stack trace to be viewed in the JAMon web application. Specific exception counter. Example: java.lang.RuntimeException General exception counter which is a total for all exceptions thrownC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/PerformanceMonitorInterceptor.javaSimple AOP Alliance {@code MethodInterceptor} for performance monitoring.This interceptor has no effect on the intercepted method call.<p>Uses a {@code StopWatch} for the actual performance measuring.org.springframework.util.StopWatchCreate a new PerformanceMonitorInterceptor with a static logger.Create a new PerformanceMonitorInterceptor with a dynamic or static logger,C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/SimpleAsyncUncaughtExceptionHandler.javaSimpleAsyncUncaughtExceptionHandlerC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/SimpleAsyncUncaughtExceptionHandler.classClass<SimpleAsyncUncaughtExceptionHandler>"Unexpected exception occurred invoking async method: "Unexpected exception occurred invoking async method: A default {@link AsyncUncaughtExceptionHandler} that simply logs the exception.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/SimpleTraceInterceptor.javainvocationDescription"Entering "Entering rval"Exiting "Exiting "Exception thrown in "Exception thrown in "method '"method 'Simple AOP Alliance {@code MethodInterceptor} that can be introducedin a chain to display verbose trace information about intercepted methodinvocations, with method entry and method exit info.<p>Consider using {@code CustomizableTraceInterceptor} for moreadvanced needs.Create a new SimpleTraceInterceptor with a static logger.Create a new SimpleTraceInterceptor with dynamic or static logger,Return a description for the given method invocation.the invocation to describethe descriptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/interceptor/package-info.javaProvides miscellaneous interceptor implementations.More specific interceptors can be found in correspondingfunctionality packages, like "transaction" and "orm".C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/package-info.javaCore Spring AOP interfaces, built on AOP Alliance AOP interoperability interfaces.<p>Any AOP Alliance MethodInterceptor is usable in Spring.<br>Spring AOP also offers:<li>Introduction support<li>A Pointcut abstraction, supporting "static" pointcuts(class and method-based) and "dynamic" pointcuts (also considering method arguments).There are currently no AOP Alliance interfaces for pointcuts.<li>A full range of advice types, including around, before, after returning and throws advice.<li>Extensibility allowing arbitrary custom advice types tobe plugged in without modifying the core framework.<p>Spring AOP can be used programmatically or (preferably)integrated with the Spring IoC container.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scope/DefaultScopedObject.javaDefaultScopedObjectC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scopeorg.springframework.aop.scopeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scope/DefaultScopedObject.class"'targetBeanName' must not be empty"'targetBeanName' must not be emptyDefault implementation of the {@link ScopedObject} interface.<p>Simply delegates the calls to the underlying{@link ConfigurableBeanFactory bean factory}({@link ConfigurableBeanFactory#getBean(String)}/{@link ConfigurableBeanFactory#destroyScopedBean(String)}).org.springframework.beans.factory.config.ConfigurableBeanFactory#destroyScopedBeanCreates a new instance of the {@link DefaultScopedObject} class.the {@link ConfigurableBeanFactory} that holds the scoped target objectC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scope/ScopedObject.javaScopedObjectAn AOP introduction interface for scoped objects.<p>Objects created from the {@link ScopedProxyFactoryBean} can be castto this interface, enabling access to the raw target objectand programmatic removal of the target object.ScopedProxyFactoryBeanReturn the current target object behind this scoped object proxy,in its raw form (as stored in the target scope).<p>The raw target object can for example be passed to persistenceproviders which would not be able to handle the scoped proxy object.the current target object behind this scoped object proxyRemove this object from its target scope, for example fromthe backing session.<p>Note that no further calls may be made to the scoped objectafterwards (at least within the current thread, that is, withthe exact same target object in the target scope).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scope/ScopedProxyFactoryBean.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scope/ScopedProxyFactoryBean.classscopedTargetSourcepfscopedObject"Not running in a ConfigurableBeanFactory: "Not running in a ConfigurableBeanFactory: "Cannot create scoped proxy for bean '"Cannot create scoped proxy for bean '"': Target type could not be determined at the time of proxy creation."': Target type could not be determined at the time of proxy creation.Convenient proxy factory bean for scoped objects.<p>Proxies created using this factory bean are thread-safe singletonsand may be injected into shared objects, with transparent scoping behavior.<p>Proxies returned by this class implement the {@link ScopedObject} interface.This presently allows for removing the corresponding object from the scope,seamlessly creating a new instance in the scope on next access.<p>Please note that the proxies created by this factory are<i>class-based</i> proxies by default. This can be customizedthrough switching the "proxyTargetClass" property to "false".The TargetSource that manages scoping.The name of the target bean.The cached singleton proxy.Create a new ScopedProxyFactoryBean instance.Set the name of the bean that is to be scoped. Add an introduction that implements only the methods on ScopedObject. Add the AopInfrastructureBean marker to indicate that the scoped proxy itself is not subject to auto-proxying! Only its target bean is.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scope/ScopedProxyUtils.javaScopedProxyUtilsTARGET_NAME_PREFIX_LENGTHC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scope/ScopedProxyUtils.classTARGET_NAME_PREFIX"scopedTarget."scopedTarget.originalBeanNameClass<ScopedProxyFactoryBean>"bean name '"bean name '"' does not refer to the target of a scoped proxy"' does not refer to the target of a scoped proxyUtility class for creating a scoped proxy.<p>Used by ScopedProxyBeanDefinitionDecorator and ClassPathBeanDefinitionScanner.Generate a scoped proxy for the supplied target bean, registering the targetbean with an internal name and setting 'targetBeanName' on the scoped proxy.the original bean definitionthe bean definition registrywhether to create a target class proxythe scoped proxy definition#getTargetBeanName(String)#getOriginalBeanName(String) Create a scoped proxy definition for the original bean name, "hiding" the target bean in an internal target definition. ScopedProxyFactoryBean's "proxyTargetClass" default is TRUE, so we don't need to set it explicitly here. Copy autowire settings from original bean definition. The target bean should be ignored in favor of the scoped proxy. Register the target bean as separate bean in the factory. Return the scoped proxy definition as primary bean definition (potentially an inner bean).Generate the bean name that is used within the scoped proxy to reference the target bean.the original name of beanthe generated bean to be used to reference the target beanGet the original bean name for the provided {@linkplain #getTargetBeanNametarget bean name}.the target bean name for the scoped proxythe original bean nameif the supplied bean name does not referto the target of a scoped proxy5.1.10#isScopedTarget(String)Determine if the {@code beanName} is the name of a bean that referencesthe target bean within a scoped proxy.4.1.4C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/scope/package-info.javaSupport for AOP-based scoping of target objects, with configurable backend.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractBeanFactoryPointcutAdvisor.javaAbstractBeanFactoryPointcutAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/supportorg.springframework.aop.supportC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractBeanFactoryPointcutAdvisor.classresetAdviceMonitorresetAdviceMonitor()adviceMonitor"'adviceBeanName' must be specified"'adviceBeanName' must be specified"BeanFactory must be set to resolve 'adviceBeanName'"BeanFactory must be set to resolve 'adviceBeanName'? extends AbstractBeanFactoryPointcutAdvisorClass<? extends AbstractBeanFactoryPointcutAdvisor>Map<String,? extends AbstractBeanFactoryPointcutAdvisor>AbstractBeanFactoryPointcutAdvisor[]? extends AbstractBeanFactoryPointcutAdvisor[]Constructor<? extends AbstractBeanFactoryPointcutAdvisor>? super ? extends AbstractBeanFactoryPointcutAdvisorClass<? super ? extends AbstractBeanFactoryPointcutAdvisor>TypeVariable<Class<? extends AbstractBeanFactoryPointcutAdvisor>>TypeVariable<Class<? extends AbstractBeanFactoryPointcutAdvisor>>[]": advice ": advice "bean '"bean 'Abstract BeanFactory-based PointcutAdvisor that allows for any Adviceto be configured as reference to an Advice bean in a BeanFactory.<p>Specifying the name of an advice bean instead of the advice object itself(if running within a BeanFactory) increases loose coupling at initialization time,in order to not initialize the advice object until the pointcut actually matches.#setAdviceBeanNameDefaultBeanFactoryPointcutAdvisorSpecify the name of the advice bean that this advisor should refer to.<p>An instance of the specified bean will be obtained on first accessof this advisor's advice. This advisor will only ever obtain at most onesingle instance of the advice bean, caching the instance for the lifetimeof the advisor.#getAdvice()Return the name of the advice bean that this advisor refers to, if any.Specify a particular instance of the target advice directly,avoiding lazy resolution in {@link #getAdvice()}. Rely on singleton semantics provided by the factory.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractExpressionPointcut.javaAbstractExpressionPointcutC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractExpressionPointcut.class"Invalid expression at location ["Invalid expression at location [Abstract superclass for expression pointcuts,offering location and expression properties.#setLocation#setExpressionSet the location for debugging.Return location information about the pointcut expressionif available. This is useful in debugging.location information as a human-readable String,or {@code null} if none is available Fill in location information if possible.Called when a new pointcut expression is set.The expression should be parsed at this point if possible.<p>This implementation is empty.the expression to setif the expression is invalidReturn this pointcut's expression.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractGenericPointcutAdvisor.javaAbstractGenericPointcutAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractGenericPointcutAdvisor.class? extends AbstractGenericPointcutAdvisorClass<? extends AbstractGenericPointcutAdvisor>Map<String,? extends AbstractGenericPointcutAdvisor>AbstractGenericPointcutAdvisor[]? extends AbstractGenericPointcutAdvisor[]Constructor<? extends AbstractGenericPointcutAdvisor>? super ? extends AbstractGenericPointcutAdvisorClass<? super ? extends AbstractGenericPointcutAdvisor>TypeVariable<Class<? extends AbstractGenericPointcutAdvisor>>TypeVariable<Class<? extends AbstractGenericPointcutAdvisor>>[]": advice [": advice [Abstract generic {@link org.springframework.aop.PointcutAdvisor}that allows for any {@link Advice} to be configured.#setAdviceDefaultPointcutAdvisorSpecify the advice that this advisor should apply.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractPointcutAdvisor.javaAbstractPointcutAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractPointcutAdvisor.classClass<PointcutAdvisor>Abstract base class for {@link org.springframework.aop.PointcutAdvisor}implementations. Can be subclassed for returning a specific pointcut/adviceor a freely configurable pointcut/advice.1.1.2C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractRegexpMethodPointcut.javaAbstractRegexpMethodPointcutexcludedPatternsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AbstractRegexpMethodPointcut.class"'patterns' must not be empty"'patterns' must not be emptyexcludedPattern"'excludedPatterns' must not be empty"'excludedPatterns' must not be emptysignatureStringmatchedexcludedpatternIndexotherPointcut27? extends AbstractRegexpMethodPointcutClass<? extends AbstractRegexpMethodPointcut>Map<String,? extends AbstractRegexpMethodPointcut>AbstractRegexpMethodPointcut[]? extends AbstractRegexpMethodPointcut[]Constructor<? extends AbstractRegexpMethodPointcut>? super ? extends AbstractRegexpMethodPointcutClass<? super ? extends AbstractRegexpMethodPointcut>TypeVariable<Class<? extends AbstractRegexpMethodPointcut>>TypeVariable<Class<? extends AbstractRegexpMethodPointcut>>[]": patterns ": patterns ", excluded patterns ", excluded patterns Abstract base regular expression pointcut bean. JavaBean properties are:<li>pattern: regular expression for the fully-qualified method names to match.The exact regexp syntax will depend on the subclass (e.g. Perl5 regular expressions)<li>patterns: alternative property taking a String array of patterns.The result will be the union of these patterns.<p>Note: the regular expressions must be a match. For example,{@code .*get.*} will match com.mycom.Foo.getBar().{@code get.*} will not.<p>This base class is serializable. Subclasses should declare all fields transient;the {@link #initPatternRepresentation} method will be invoked again on deserialization.1.1JdkRegexpMethodPointcutRegular expressions to match.Regular expressions <strong>not</strong> to match.Convenience method when we have only a single pattern.Use either this method or {@link #setPatterns}, not both.#setPatternsSet the regular expressions defining methods to match.Matching will be the union of all these; if any match, the pointcut matches.#setPatternReturn the regular expressions for method matching.Convenience method when we have only a single exclusion pattern.Use either this method or {@link #setExcludedPatterns}, not both.#setExcludedPatternsSet the regular expressions defining methods to match for exclusion.#setExcludedPatternReturns the regular expressions for exclusion matching.Try to match the regular expression against the fully qualified nameof the target class as well as against the method's declaring class,plus the name of the method.Match the specified candidate against the configured patterns."java.lang.Object.hashCode" style signaturewhether the candidate matches at least one of the specified patternsSubclasses must implement this to initialize regexp pointcuts.Can be invoked multiple times.<p>This method will be invoked from the {@link #setPatterns} method,and also on deserialization.the patterns to initializein case of an invalid pattern<p>This method will be invoked from the {@link #setExcludedPatterns} method,Does the pattern at the given index match the given String?the {@code String} pattern to matchindex of pattern (starting from 0){@code true} if there is a match, {@code false} otherwiseDoes the exclusion pattern at the given index match the given String?C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/AopUtils.javaAopUtilsobjectmethodToUse"Need to invoke method '%s' found on proxy for target class '%s' but cannot " +
					"be delegated to target bean. Switch its visibility to package or protected."Need to invoke method '%s' found on proxy for target class '%s' but cannot be delegated to target bean. Switch its visibility to package or protected."finalize"finalizespecificTargetClassresolvedMethodintroductionAwareMethodMatcherclassesLinkedHashSet<Class<?>>C:/modules/java.base/java/util/LinkedHashSet.classLinkedHashSetHashSet<Class<?>>AbstractSet<Class<?>>LinkedHashSet<Class<?>>()AbstractSet<Class<?>>()HashSet<Class<?>>(int,float,boolean)HashSet<Class<?>>(int)HashSet<Class<?>>(int,float)HashSet<Class<?>>(java.util.Collection)HashSet<Class<?>>()LinkedHashSet(java.util.Collection)LinkedHashSet<Class<?>>(java.util.Collection)LinkedHashSet()LinkedHashSet(int)LinkedHashSet<Class<?>>(int)LinkedHashSet(int,float)LinkedHashSet<Class<?>>(int,float)"Pointcut must not be null"Pointcut must not be nullpca"AOP configuration seems to be invalid: tried calling method ["AOP configuration seems to be invalid: tried calling method ["] on target ["] on target ["Could not access method ["Could not access method [Utility methods for AOP support code.<p>Mainly for internal use within Spring's AOP support.<p>See {@link org.springframework.aop.framework.AopProxyUtils} for acollection of framework-specific AOP utility methods which dependon internals of Spring's AOP framework implementation.org.springframework.aop.framework.AopProxyUtilsCheck whether the given object is a JDK dynamic proxy or a CGLIB proxy.<p>This method additionally checks if the given object is an instanceof {@link SpringProxy}.the object to check#isJdkDynamicProxy#isCglibProxyCheck whether the given object is a JDK dynamic proxy.<p>This method goes beyond the implementation of{@link Proxy#isProxyClass(Class)} by additionally checking if thegiven object is an instance of {@link SpringProxy}.java.lang.reflect.Proxy#isProxyClassCheck whether the given object is a CGLIB proxy.{@link ClassUtils#isCglibProxy(Object)} by additionally checking ifthe given object is an instance of {@link SpringProxy}.ClassUtils#isCglibProxy(Object)Determine the target class of the given bean instance which might be an AOP proxy.<p>Returns the target class for an AOP proxy or the plain class otherwise.the target class (or the plain class of the given object as fallback;never {@code null})org.springframework.aop.framework.AopProxyUtils#ultimateTargetClass(Object)Select an invocable method on the target type: either the given method itselfif actually exposed on the target type, or otherwise a corresponding methodon one of the target type's interfaces or on the target type itself.the method to checkthe target type to search methods on (typically an AOP proxy)a corresponding invocable method on the target typeif the given method is not invocable on the giventarget type (typically due to a proxy mismatch)MethodIntrospector#selectInvocableMethod(Method, Class)Determine whether the given method is an "equals" method.java.lang.Object#equalsDetermine whether the given method is a "hashCode" method.java.lang.Object#hashCodeDetermine whether the given method is a "toString" method.java.lang.Object#toString()Determine whether the given method is a "finalize" method.java.lang.Object#finalize()Given a method, which may come from an interface, and a target class usedin the current AOP invocation, find the corresponding target method if thereis one. E.g. the method may be {@code IFoo.bar()} and the target classmay be {@code DefaultFoo}. In this case, the method may be{@code DefaultFoo.bar()}. This enables attributes on that method to be found.<p><b>NOTE:</b> In contrast to {@link org.springframework.util.ClassUtils#getMostSpecificMethod},this method resolves Java 5 bridge methods in order to retrieve attributesfrom the <i>original</i> method definition.the method to be invoked, which may come from an interfacethe target class for the current invocation.May be {@code null} or may not even implement the method.the specific target method, or the original method if the{@code targetClass} doesn't implement it or is {@code null}org.springframework.util.ClassUtils#getMostSpecificMethod If we are dealing with method with generic parameters, find the original method.Can the given pointcut apply at all on the given class?<p>This is an important test as it can be used to optimizeout a pointcut for a class.the static or dynamic pointcut to checkthe class to testwhether the pointcut can apply on any methodwhether or not the advisor chainfor this bean includes any introductions No need to iterate the methods if we're matching any method anyway...Can the given advisor apply at all on the given class?This is an important test as it can be used to optimizeout a advisor for a class.the advisor to checkclass we're testing<p>This is an important test as it can be used to optimize out a advisor for a class.This version also takes into account introductions (for IntroductionAwareMethodMatchers).whether or not the advisor chain for this bean includesany introductions It doesn't have a pointcut so we assume it applies.Determine the sublist of the {@code candidateAdvisors} listthat is applicable to the given class.the Advisors to evaluatesublist of Advisors that can apply to an object of the given class(may be the incoming List as-is) already processedInvoke the given target via reflection, as part of an AOP method invocation.the target objectthe arguments for the methodthe invocation result, if anyif thrown by the target methodorg.springframework.aop.AopInvocationExceptionin case of a reflection error Use reflection to invoke the method. Invoked method threw a checked exception. We must rethrow it. The client won't see the interceptor.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/ClassFilters.javaClassFilterscf1cf2"First ClassFilter must not be null"First ClassFilter must not be null"Second ClassFilter must not be null"Second ClassFilter must not be nullClassFilter[]classFilters"ClassFilter array must not be empty"ClassFilter array must not be emptyUnionClassFilterUnionClassFilter(org.springframework.aop.ClassFilter[])C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/ClassFilters$UnionClassFilter.classClassFilters$UnionClassFilterfilters? extends UnionClassFilterClass<? extends UnionClassFilter>Map<String,? extends UnionClassFilter>UnionClassFilter[]? extends UnionClassFilter[]Constructor<? extends UnionClassFilter>? super ? extends UnionClassFilterClass<? super ? extends UnionClassFilter>TypeVariable<Class<? extends UnionClassFilter>>TypeVariable<Class<? extends UnionClassFilter>>[]IntersectionClassFilterIntersectionClassFilter(org.springframework.aop.ClassFilter[])C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/ClassFilters$IntersectionClassFilter.classClassFilters$IntersectionClassFilter? extends IntersectionClassFilterClass<? extends IntersectionClassFilter>Map<String,? extends IntersectionClassFilter>IntersectionClassFilter[]? extends IntersectionClassFilter[]Constructor<? extends IntersectionClassFilter>? super ? extends IntersectionClassFilterClass<? super ? extends IntersectionClassFilter>TypeVariable<Class<? extends IntersectionClassFilter>>TypeVariable<Class<? extends IntersectionClassFilter>>[]Static utility methods for composing {@link ClassFilter ClassFilters}.MethodMatchersPointcutsMatch all classes that <i>either</i> (or both) of the given ClassFilters matches.the first ClassFilterthe second ClassFiltera distinct ClassFilter that matches all classes that eitherof the given ClassFilter matchesMatch all classes that <i>either</i> (or all) of the given ClassFilters matches.the ClassFilters to matchMatch all classes that <i>both</i> of the given ClassFilters match.a distinct ClassFilter that matches all classes that bothof the given ClassFilter matchMatch all classes that <i>all</i> of the given ClassFilters match.ClassFilter implementation for a union of the given ClassFilters.ClassFilter implementation for an intersection of the given ClassFilters.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/ComposablePointcut.javaComposablePointcutC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/ComposablePointcut.classclassFilter2743223737633663832L2743223737633663832"ClassFilter must not be null"ClassFilter must not be null"MethodMatcher must not be null"MethodMatcher must not be null37? extends ComposablePointcutClass<? extends ComposablePointcut>Map<String,? extends ComposablePointcut>ComposablePointcut[]? extends ComposablePointcut[]Constructor<? extends ComposablePointcut>? super ? extends ComposablePointcutClass<? super ? extends ComposablePointcut>TypeVariable<Class<? extends ComposablePointcut>>TypeVariable<Class<? extends ComposablePointcut>>[]Convenient class for building up pointcuts.<p>All methods return {@code ComposablePointcut}, so we can use concise idiomslike in the following example.<pre class="code">Pointcut pc = new ComposablePointcut().union(classFilter).intersection(methodMatcher).intersection(pointcut);</pre>Create a default ComposablePointcut, with {@code ClassFilter.TRUE}and {@code MethodMatcher.TRUE}.Create a ComposablePointcut based on the given Pointcut.the original PointcutCreate a ComposablePointcut for the given ClassFilter,with {@code MethodMatcher.TRUE}.the ClassFilter to useCreate a ComposablePointcut for the given MethodMatcher,with {@code ClassFilter.TRUE}.the MethodMatcher to useCreate a ComposablePointcut for the given ClassFilter and MethodMatcher.Apply a union with the given ClassFilter.the ClassFilter to apply a union withthis composable pointcut (for call chaining)Apply an intersection with the given ClassFilter.the ClassFilter to apply an intersection withApply a union with the given MethodMatcher.the MethodMatcher to apply a union withApply an intersection with the given MethodMatcher.the MethodMatcher to apply an intersection withApply a union with the given Pointcut.<p>Note that for a Pointcut union, methods will only match if theiroriginal ClassFilter (from the originating Pointcut) matches as well.MethodMatchers and ClassFilters from different Pointcuts will neverget interleaved with each other.the Pointcut to apply a union withApply an intersection with the given Pointcut.the Pointcut to apply an intersection withC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/ControlFlowPointcut.javaControlFlowPointcutevaluationsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/ControlFlowPointcut.class"Class must not be null"Class must not be nullStackTraceElement[]thatcode? extends ControlFlowPointcutClass<? extends ControlFlowPointcut>Map<String,? extends ControlFlowPointcut>ControlFlowPointcut[]? extends ControlFlowPointcut[]Constructor<? extends ControlFlowPointcut>? super ? extends ControlFlowPointcutClass<? super ? extends ControlFlowPointcut>TypeVariable<Class<? extends ControlFlowPointcut>>TypeVariable<Class<? extends ControlFlowPointcut>>[]": class = ": class = "; methodName = "; methodName = Pointcut and method matcher for use in simple <b>cflow</b>-style pointcut.Note that evaluating such pointcuts is 10-15 times slower than evaluatingnormal pointcuts, but they are useful in some cases.Construct a new pointcut that matches all control flows below that class.the clazzConstruct a new pointcut that matches all calls below the given methodin the given class. If no method name is given, matches all control flowsbelow the given class.the name of the method (may be {@code null})Subclasses can override this for greater filtering (and performance).Subclasses can override this if it's possible to filter out some candidate classes.It's useful to know how many times we've fired, for optimization.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DefaultBeanFactoryPointcutAdvisor.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DefaultBeanFactoryPointcutAdvisor.class? extends DefaultBeanFactoryPointcutAdvisorClass<? extends DefaultBeanFactoryPointcutAdvisor>Map<String,? extends DefaultBeanFactoryPointcutAdvisor>DefaultBeanFactoryPointcutAdvisor[]? extends DefaultBeanFactoryPointcutAdvisor[]Constructor<? extends DefaultBeanFactoryPointcutAdvisor>? super ? extends DefaultBeanFactoryPointcutAdvisorClass<? super ? extends DefaultBeanFactoryPointcutAdvisor>TypeVariable<Class<? extends DefaultBeanFactoryPointcutAdvisor>>TypeVariable<Class<? extends DefaultBeanFactoryPointcutAdvisor>>[]": pointcut [": pointcut ["]; advice bean '"]; advice bean 'Concrete BeanFactory-based PointcutAdvisor that allows for any Adviceto be configured as reference to an Advice bean in the BeanFactory,as well as the Pointcut to be configured through a bean property.#setPointcutSpecify the pointcut targeting the advice.<p>Default is {@code Pointcut.TRUE}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DefaultIntroductionAdvisor.javaDefaultIntroductionAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DefaultIntroductionAdvisor.classintroductionInfointroducedInterfaces"IntroductionAdviceSupport implements no interfaces"IntroductionAdviceSupport implements no interfaces"Specified class ["Specified class ["] must be an interface"] must be an interface"DynamicIntroductionAdvice ["DynamicIntroductionAdvice ["] " +
						"does not implement interface ["] does not implement interface ["] specified for introduction"] specified for introduction? extends DefaultIntroductionAdvisorClass<? extends DefaultIntroductionAdvisor>Map<String,? extends DefaultIntroductionAdvisor>DefaultIntroductionAdvisor[]? extends DefaultIntroductionAdvisor[]Constructor<? extends DefaultIntroductionAdvisor>? super ? extends DefaultIntroductionAdvisorClass<? super ? extends DefaultIntroductionAdvisor>TypeVariable<Class<? extends DefaultIntroductionAdvisor>>TypeVariable<Class<? extends DefaultIntroductionAdvisor>>[]"]; interfaces "]; interfaces Simple {@link org.springframework.aop.IntroductionAdvisor} implementationthat by default applies to any class.Create a DefaultIntroductionAdvisor for the given advice.the Advice to apply (may implement the{@link org.springframework.aop.IntroductionInfo} interface)#addInterfacethe Advice to applythe IntroductionInfo that describesthe interface to introduce (may be {@code null})the interface to introduceAdd the specified interface to the list of interfaces to introduce.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DefaultPointcutAdvisor.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DefaultPointcutAdvisor.class? extends DefaultPointcutAdvisorClass<? extends DefaultPointcutAdvisor>Map<String,? extends DefaultPointcutAdvisor>DefaultPointcutAdvisor[]? extends DefaultPointcutAdvisor[]Constructor<? extends DefaultPointcutAdvisor>? super ? extends DefaultPointcutAdvisorClass<? super ? extends DefaultPointcutAdvisor>TypeVariable<Class<? extends DefaultPointcutAdvisor>>TypeVariable<Class<? extends DefaultPointcutAdvisor>>[]"]; advice ["]; advice [Convenient Pointcut-driven Advisor implementation.<p>This is the most commonly used Advisor implementation. It can be usedwith any pointcut and advice type, except for introductions. There isnormally no need to subclass this class, or to implement custom Advisors.Create an empty DefaultPointcutAdvisor.<p>Advice must be set before use using setter methods.Pointcut will normally be set also, but defaults to {@code Pointcut.TRUE}.Create a DefaultPointcutAdvisor that matches all methods.<p>{@code Pointcut.TRUE} will be used as Pointcut.the Advice to useCreate a DefaultPointcutAdvisor, specifying Pointcut and Advice.the Pointcut targeting the Advicethe Advice to run when Pointcut matchesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DelegatePerTargetObjectIntroductionInterceptor.javaDelegatePerTargetObjectIntroductionInterceptorcreateNewDelegatecreateNewDelegate()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DelegatePerTargetObjectIntroductionInterceptor.classgetIntroductionDelegateForgetIntroductionDelegateFor(java.lang.Object)defaultImplTypedelegateMapWeakHashMap<Object,Object>WeakHashMap<Object,Object>()WeakHashMap<Object,Object>(java.util.Map)WeakHashMap<Object,Object>(int)WeakHashMap<Object,Object>(int,float)Class<IntroductionInterceptor>Class<DynamicIntroductionAdvice>"Cannot create default implementation for '"Cannot create default implementation for '"' mixin ("' mixin ("): "): Convenient implementation of the{@link org.springframework.aop.IntroductionInterceptor} interface.<p>This differs from {@link DelegatingIntroductionInterceptor} in that a singleinstance of this class can be used to advise multiple target objects, and each targetobject will have its <i>own</i> delegate (whereas DelegatingIntroductionInterceptorshares the same delegate, and hence the same state across all targets).<p>The {@code suppressInterface} method can be used to suppress interfacesimplemented by the delegate class but which should not be introduced to theowning AOP proxy.<p>An instance of this class is serializable if the delegates are.<p><i>Note: There are some implementation similarities between this class and{@link DelegatingIntroductionInterceptor} that suggest a possible refactoringto extract a common ancestor class in the future.</i>#suppressInterfaceDelegatingIntroductionInterceptorHold weak references to keys as we don't want to interfere with garbage collection.. Create a new delegate now (but don't store it in the map). We do this for two reasons: 1) to fail early if there is a problem instantiating delegates 2) to populate the interface map once and once onlySubclasses may need to override this if they want to perform custombehaviour in around advice. However, subclasses should invoke thismethod, which handles introduced interfaces and forwarding to the target. Using the following method rather than direct reflection, we get correct handling of InvocationTargetException if the introduced method throws an exception. Massage return value if possible: if the delegate returned itself, we really want to return the proxy.Proceed with the supplied {@link org.aopalliance.intercept.MethodInterceptor}.Subclasses can override this method to intercept method invocations on thetarget object which is useful when an introduction needs to monitor the objectthat it is introduced into. This method is <strong>never</strong> called for{@link MethodInvocation MethodInvocations} on the introduced interfaces. If we get here, just pass the invocation on.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DelegatingIntroductionInterceptor.javainitinit(java.lang.Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DelegatingIntroductionInterceptor.class"Delegate must not be null"Delegate must not be null<p>Subclasses merely need to extend this class and implement the interfacesto be introduced themselves. In this case the delegate is the subclassinstance itself. Alternatively a separate delegate may implement theinterface, and be set via the delegate bean property.<p>Delegates or subclasses may implement any number of interfaces.All interfaces except IntroductionInterceptor are picked up fromthe subclass or delegate by default.implemented by the delegate but which should not be introduced to the owningAOP proxy.<p>An instance of this class is serializable if the delegate is.16.11.2003Object that actually implements the interfaces.May be "this" if a subclass implements the introduced interfaces.Construct a new DelegatingIntroductionInterceptor, providinga delegate that implements the interfaces to be introduced.the delegate that implements the introduced interfacesConstruct a new DelegatingIntroductionInterceptor.The delegate will be the subclass, which must implementadditional interfaces.Both constructors use this init method, as it is impossible to passa "this" reference from one constructor to another.the delegate object We don't want to expose the control interface Using the following method rather than direct reflection, we get correct handling of InvocationTargetExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DynamicMethodMatcher.javaDynamicMethodMatcherConvenient abstract superclass for dynamic method matchers,which do care about arguments at runtime.Can override to add preconditions for dynamic matching. This implementationalways returns true.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/DynamicMethodMatcherPointcut.javaDynamicMethodMatcherPointcutConvenient superclass when we want to force subclasses toimplement MethodMatcher interface, but subclasseswill want to be pointcuts. The getClassFilter() method canbe overridden to customize ClassFilter behaviour as well.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/ExpressionPointcut.javaExpressionPointcutInterface to be implemented by pointcuts that use String expressions.Return the String expression for this pointcut.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/IntroductionInfoSupport.javaIntroductionInfoSupportC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/IntroductionInfoSupport.classMap<Method,Boolean>rememberedMethodsConcurrentHashMap<Method,Boolean>AbstractMap<Method,Boolean>ConcurrentMap<Method,Boolean>ConcurrentHashMap<Method,Boolean>(int)merge(java.lang.reflect.Method,java.lang.Boolean,java.util.function.BiFunction)BiFunction<? super Method,? super Boolean,? extends Boolean>Function<? super Method,? extends Boolean>replace(java.lang.reflect.Method,java.lang.Boolean)replace(java.lang.reflect.Method,java.lang.Boolean,java.lang.Boolean)putIfAbsent(java.lang.reflect.Method,java.lang.Boolean)BiConsumer<? super Method,? super Boolean>Entry<Method,Boolean>Set<Entry<Method,Boolean>>Collection<Entry<Method,Boolean>>Iterable<Entry<Method,Boolean>>Map<? extends Method,? extends Boolean>put(java.lang.reflect.Method,java.lang.Boolean)AbstractMap<Method,Boolean>()ToIntFunction<Entry<Method,Boolean>>ToLongFunction<Entry<Method,Boolean>>ToDoubleFunction<Entry<Method,Boolean>>Function<Entry<Method,Boolean>,? extends U>? extends Entry<Method,Boolean>BiFunction<Entry<Method,Boolean>,Entry<Method,Boolean>,? extends Entry<Method,Boolean>>? super Entry<Method,Boolean>Consumer<? super Entry<Method,Boolean>>ToIntBiFunction<? super Method,? super Boolean>ToLongBiFunction<? super Method,? super Boolean>ToDoubleBiFunction<? super Method,? super Boolean>BiFunction<? super Method,? super Boolean,? extends U>Node<Method,Boolean>Node<Method,Boolean>[]KeySetView<Method,Boolean>CollectionView<Method,Boolean,Method>Predicate<? super Entry<Method,Boolean>>putVal(java.lang.reflect.Method,java.lang.Boolean,boolean)ConcurrentHashMap<Method,Boolean>(int,float,int)ConcurrentHashMap<Method,Boolean>(int,float)ConcurrentHashMap<Method,Boolean>(java.util.Map)ConcurrentHashMap<Method,Boolean>()pubIfcrememberedResultSupport for implementations of {@link org.springframework.aop.IntroductionInfo}.<p>Allows subclasses to conveniently add all interfaces from a given object,and to suppress interfaces that should not be added. Also allows for queryingall introduced interfaces.Suppress the specified interface, which may have been autodetecteddue to the delegate implementing it. Call this method to excludeinternal interfaces from being visible at the proxy level.<p>Does nothing if the interface is not implemented by the delegate.the interface to suppressCheck whether the specified interfaces is a published introduction interface.whether the interface is part of this introductionPublish all interfaces that the given delegate implements at the proxy level.Is this method on an introduced interface?the method invocationwhether the invoked method is on an introduced interface Work it out and cache it.This method is implemented only to restore the logger.We don't make the logger static as that would mean that subclasseswould use this class's log category.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/JdkRegexpMethodPointcut.javaPattern[]compilePatternscompilePatterns(java.lang.String[])C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/JdkRegexpMethodPointcut.classcompiledExclusionPatternscompiledPatternsdestinationRegular expression pointcut based on the {@code java.util.regex} package.Supports the following JavaBean properties:<li>pattern: regular expression for the fully-qualified method names to match<li>patterns: alternative property taking a String array of patterns. The result willbe the union of these patterns.Compiled form of the patterns.Compiled form of the exclusion patterns.Initialize {@link Pattern Patterns} from the supplied {@code String[]}.Initialize exclusion {@link Pattern Patterns} from the supplied {@code String[]}.Returns {@code true} if the {@link Pattern} at index {@code patternIndex}matches the supplied candidate {@code String}.Returns {@code true} if the exclusion {@link Pattern} at index {@code patternIndex}Compiles the supplied {@code String[]} into an array of{@link Pattern} objects and returns that array.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/MethodMatchers.javaunionunion(org.springframework.aop.MethodMatcher,org.springframework.aop.ClassFilter,org.springframework.aop.MethodMatcher,org.springframework.aop.ClassFilter)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/MethodMatchers.classmm1mm2"First MethodMatcher must not be null"First MethodMatcher must not be null"Second MethodMatcher must not be null"Second MethodMatcher must not be null? extends UnionMethodMatcherClass<? extends UnionMethodMatcher>Map<String,? extends UnionMethodMatcher>UnionMethodMatcher[]? extends UnionMethodMatcher[]Constructor<? extends UnionMethodMatcher>? super ? extends UnionMethodMatcherClass<? super ? extends UnionMethodMatcher>TypeVariable<Class<? extends UnionMethodMatcher>>TypeVariable<Class<? extends UnionMethodMatcher>>[]C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/MethodMatchers$ClassFilterAwareUnionMethodMatcher.classMethodMatchers$ClassFilterAwareUnionMethodMatcherotherCf1otherCf2cfa? extends ClassFilterAwareUnionMethodMatcherClass<? extends ClassFilterAwareUnionMethodMatcher>Map<String,? extends ClassFilterAwareUnionMethodMatcher>ClassFilterAwareUnionMethodMatcher[]? extends ClassFilterAwareUnionMethodMatcher[]Constructor<? extends ClassFilterAwareUnionMethodMatcher>? super ? extends ClassFilterAwareUnionMethodMatcherClass<? super ? extends ClassFilterAwareUnionMethodMatcher>TypeVariable<Class<? extends ClassFilterAwareUnionMethodMatcher>>TypeVariable<Class<? extends ClassFilterAwareUnionMethodMatcher>>[]aMatchesbMatches? extends IntersectionMethodMatcherClass<? extends IntersectionMethodMatcher>Map<String,? extends IntersectionMethodMatcher>IntersectionMethodMatcher[]? extends IntersectionMethodMatcher[]Constructor<? extends IntersectionMethodMatcher>? super ? extends IntersectionMethodMatcherClass<? super ? extends IntersectionMethodMatcher>TypeVariable<Class<? extends IntersectionMethodMatcher>>TypeVariable<Class<? extends IntersectionMethodMatcher>>[]Static utility methods for composing {@link MethodMatcher MethodMatchers}.<p>A MethodMatcher may be evaluated statically (based on method and targetclass) or need further evaluation dynamically (based on arguments at thetime of method invocation).Match all methods that <i>either</i> (or both) of the given MethodMatchers matches.the first MethodMatcherthe second MethodMatchera distinct MethodMatcher that matches all methods that eitherof the given MethodMatchers matchesthe corresponding ClassFilter for the first MethodMatcherthe corresponding ClassFilter for the second MethodMatcherMatch all methods that <i>both</i> of the given MethodMatchers match.a distinct MethodMatcher that matches all methods that bothof the given MethodMatchers matchApply the given MethodMatcher to the given Method, supporting an{@link org.springframework.aop.IntroductionAwareMethodMatcher}(if applicable).the MethodMatcher to apply (may be an IntroductionAwareMethodMatcher)MethodMatcher implementation for a union of two given MethodMatchers.MethodMatcher implementation for a union of two given MethodMatchersof which at least one is an IntroductionAwareMethodMatcher.MethodMatcher implementation for a union of two given MethodMatchers,supporting an associated ClassFilter per MethodMatcher. Allow for matching with regular UnionMethodMatcher by providing same hash...of which at least one is an IntroductionAwareMethodMatcher,MethodMatcher implementation for an intersection of two given MethodMatchers. Because a dynamic intersection may be composed of a static and dynamic part, we must avoid calling the 3-arg matches method on a dynamic matcher, as it will probably be an unsupported operation.MethodMatcher implementation for an intersection of two given MethodMatchersC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/NameMatchMethodPointcut.javaNameMatchMethodPointcutmappedNamesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/NameMatchMethodPointcut.class? extends NameMatchMethodPointcutClass<? extends NameMatchMethodPointcut>Map<String,? extends NameMatchMethodPointcut>NameMatchMethodPointcut[]? extends NameMatchMethodPointcut[]Constructor<? extends NameMatchMethodPointcut>? super ? extends NameMatchMethodPointcutClass<? super ? extends NameMatchMethodPointcut>TypeVariable<Class<? extends NameMatchMethodPointcut>>TypeVariable<Class<? extends NameMatchMethodPointcut>>[]Pointcut bean for simple method name matches, as an alternative to regexp patterns.<p>Does not handle overloaded methods: all methods with a given name will be eligible.Convenience method when we have only a single method name to match.Use either this method or {@code setMappedNames}, not both.#setMappedNamesSet the method names defining methods to match.Matching will be the union of all these; if any match,the pointcut matches.Add another eligible method name, in addition to those already named.Like the set methods, this method is for use when configuring proxies,before a proxy is used.<p><b>NB:</b> This method does not work after the proxy is inuse, as advice chains will be cached.the name of the additional method that will matchthis pointcut to allow for multiple additions in one lineReturn if the given method name matches the mapped name.the method name of the classthe name in the descriptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/NameMatchMethodPointcutAdvisor.javaNameMatchMethodPointcutAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/NameMatchMethodPointcutAdvisor.classCopyright 2002-2014 the original author or authors.Convenient class for name-match method pointcuts that hold an Advice,making them an Advisor.Set the {@link ClassFilter} to use for this pointcut.Default is {@link ClassFilter#TRUE}.NameMatchMethodPointcut#setClassFilterNameMatchMethodPointcut#setMappedNameNameMatchMethodPointcut#setMappedNamesNameMatchMethodPointcut#addMethodNameC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/Pointcuts.javapc1pc2C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/Pointcuts$SetterPointcut.classPointcuts$SetterPointcutSetterPointcutSetterPointcut()"set""Pointcuts.SETTERS"Pointcuts.SETTERSC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/Pointcuts$GetterPointcut.classPointcuts$GetterPointcutGetterPointcutGetterPointcut()"get""Pointcuts.GETTERS"Pointcuts.GETTERSPointcut constants for matching getters and setters,and static methods useful for manipulating and evaluating pointcuts.<p>These methods are particularly useful for composing pointcutsusing the union and intersection methods.Pointcut matching all bean property setters, in any class.Pointcut matching all bean property getters, in any class.Match all methods that <b>either</b> (or both) of the given pointcuts matches.the first Pointcutthe second Pointcuta distinct Pointcut that matches all methods that eitherof the given Pointcuts matchesMatch all methods that <b>both</b> the given pointcuts match.a distinct Pointcut that matches all methods that bothof the given Pointcuts matchPerform the least expensive check for a pointcut match.the pointcut to match Only check if it gets past first hurdle. We may need additional runtime (argument) check.Pointcut implementation that matches bean property setters.Pointcut implementation that matches bean property getters.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/RegexpMethodPointcutAdvisor.javaRegexpMethodPointcutAdvisorpointcutMonitorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/RegexpMethodPointcutAdvisor.class? extends RegexpMethodPointcutAdvisorClass<? extends RegexpMethodPointcutAdvisor>Map<String,? extends RegexpMethodPointcutAdvisor>RegexpMethodPointcutAdvisor[]? extends RegexpMethodPointcutAdvisor[]Constructor<? extends RegexpMethodPointcutAdvisor>? super ? extends RegexpMethodPointcutAdvisorClass<? super ? extends RegexpMethodPointcutAdvisor>TypeVariable<Class<? extends RegexpMethodPointcutAdvisor>>TypeVariable<Class<? extends RegexpMethodPointcutAdvisor>>[]"], pointcut patterns "], pointcut patterns SerializableMonitorSerializableMonitor()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/RegexpMethodPointcutAdvisor$SerializableMonitor.classRegexpMethodPointcutAdvisor$SerializableMonitorConvenient class for regexp method pointcuts that hold an Advice,making them an {@link org.springframework.aop.Advisor}.<p>Configure this class using the "pattern" and "patterns"pass-through properties. These are analogous to the patternand patterns properties of {@link AbstractRegexpMethodPointcut}.<p>Can delegate to any {@link AbstractRegexpMethodPointcut} subclass.By default, {@link JdkRegexpMethodPointcut} will be used. To choosea specific one, override the {@link #createPointcut} method.Create an empty RegexpMethodPointcutAdvisor.Create a RegexpMethodPointcutAdvisor for the given advice.The pattern still needs to be specified afterwards.the advice to usethe pattern to usethe patterns to useSet the regular expression defining methods to match.<p>Use either this method or {@link #setPatterns}, not both.To be passed through to the pointcut implementation.<p>Matching will be the union of all these; if any of thepatterns matches, the pointcut matches.AbstractRegexpMethodPointcut#setPatternsInitialize the singleton Pointcut held within this Advisor.Create the actual pointcut: By default, a {@link JdkRegexpMethodPointcut}will be used.the Pointcut instance (never {@code null})Empty class used for a serializable monitor object.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/RootClassFilter.javaRootClassFilterC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/RootClassFilter.class? extends RootClassFilterClass<? extends RootClassFilter>Map<String,? extends RootClassFilter>RootClassFilter[]? extends RootClassFilter[]Constructor<? extends RootClassFilter>? super ? extends RootClassFilterClass<? super ? extends RootClassFilter>TypeVariable<Class<? extends RootClassFilter>>TypeVariable<Class<? extends RootClassFilter>>[]Simple ClassFilter implementation that passes classes (and optionally subclasses).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/StaticMethodMatcher.javaStaticMethodMatcher"Illegal MethodMatcher usage"Illegal MethodMatcher usageConvenient abstract superclass for static method matchers, which don't careabout arguments at runtime. should never be invoked because isRuntime() returns falseC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/StaticMethodMatcherPointcut.javaStaticMethodMatcherPointcutC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/StaticMethodMatcherPointcut.classConvenient superclass when we want to force subclasses to implement the{@link MethodMatcher} interface but subclasses will want to be pointcuts.<p>The {@link #setClassFilter "classFilter"} property can be set to customize{@link ClassFilter} behavior. The default is {@link ClassFilter#TRUE}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/StaticMethodMatcherPointcutAdvisor.javaStaticMethodMatcherPointcutAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/StaticMethodMatcherPointcutAdvisor.classConvenient base class for Advisors that are also static pointcuts.Serializable if Advice and subclass are.Create a new StaticMethodMatcherPointcutAdvisor,expecting bean-style configuration.Create a new StaticMethodMatcherPointcutAdvisor for the given advice.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotation/AnnotationClassFilter.javaAnnotationClassFilterC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotationorg.springframework.aop.support.annotationcheckInheritedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotation/AnnotationClassFilter.class"Annotation type must not be null"Annotation type must not be nullotherCf? extends AnnotationClassFilterClass<? extends AnnotationClassFilter>Map<String,? extends AnnotationClassFilter>AnnotationClassFilter[]? extends AnnotationClassFilter[]Constructor<? extends AnnotationClassFilter>? super ? extends AnnotationClassFilterClass<? super ? extends AnnotationClassFilter>TypeVariable<Class<? extends AnnotationClassFilter>>TypeVariable<Class<? extends AnnotationClassFilter>>[]Simple ClassFilter that looks for a specific Java 5 annotationbeing present on a class.AnnotationMatchingPointcutCreate a new AnnotationClassFilter for the given annotation type.the annotation type to look forwhether to also check the superclasses andinterfaces as well as meta-annotations for the annotation type(i.e. whether to use {@link AnnotatedElementUtils#hasAnnotation}semantics instead of standard Java {@link Class#isAnnotationPresent})C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotation/AnnotationMatchingPointcut.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotation/AnnotationMatchingPointcut.classclassAnnotationTypemethodAnnotationType"Either Class annotation type or Method annotation type needs to be specified (or both)"Either Class annotation type or Method annotation type needs to be specified (or both)"AnnotationMatchingPointcut: "AnnotationMatchingPointcut: AnnotationCandidateClassFilterAnnotationCandidateClassFilter(java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotation/AnnotationMatchingPointcut$AnnotationCandidateClassFilter.classAnnotationMatchingPointcut$AnnotationCandidateClassFilter? extends AnnotationCandidateClassFilterClass<? extends AnnotationCandidateClassFilter>Map<String,? extends AnnotationCandidateClassFilter>AnnotationCandidateClassFilter[]? extends AnnotationCandidateClassFilter[]Constructor<? extends AnnotationCandidateClassFilter>? super ? extends AnnotationCandidateClassFilterClass<? super ? extends AnnotationCandidateClassFilter>TypeVariable<Class<? extends AnnotationCandidateClassFilter>>TypeVariable<Class<? extends AnnotationCandidateClassFilter>>[]Simple Pointcut that looks for a specific Java 5 annotationbeing present on a {@link #forClassAnnotation class} or{@link #forMethodAnnotation method}.AnnotationMethodMatcherCreate a new AnnotationMatchingPointcut for the given annotation type.the annotation type to look for at the class levelwhether to also check the superclasses and interfacesas well as meta-annotations for the annotation typeAnnotationClassFilter#AnnotationClassFilter(Class, boolean)Create a new AnnotationMatchingPointcut for the given annotation types.(can be {@code null})the annotation type to look for at the method levelAnnotationMethodMatcher#AnnotationMethodMatcher(Class, boolean)Factory method for an AnnotationMatchingPointcut that matchesfor the specified annotation at the class level.the corresponding AnnotationMatchingPointcutfor the specified annotation at the method level.{@link ClassFilter} that delegates to {@link AnnotationUtils#isCandidateClass}for filtering classes whose methods are not worth searching to begin with.5.2C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotation/AnnotationMethodMatcher.javamatchesMethodmatchesMethod(java.lang.reflect.Method)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotation/AnnotationMethodMatcher.class? extends AnnotationMethodMatcherClass<? extends AnnotationMethodMatcher>Map<String,? extends AnnotationMethodMatcher>AnnotationMethodMatcher[]? extends AnnotationMethodMatcher[]Constructor<? extends AnnotationMethodMatcher>? super ? extends AnnotationMethodMatcherClass<? super ? extends AnnotationMethodMatcher>TypeVariable<Class<? extends AnnotationMethodMatcher>>TypeVariable<Class<? extends AnnotationMethodMatcher>>[]Simple MethodMatcher that looks for a specific Java 5 annotationbeing present on a method (checking both the method on the invokedinterface, if any, and the corresponding method on the target class).semantics instead of standard Java {@link Method#isAnnotationPresent}) Proxy classes never have annotations on their redeclared methods. The method may be on an interface, so let's check on the target class as well.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/annotation/package-info.javaAnnotation support for AOP pointcuts.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/support/package-info.javaConvenience classes for using Spring's AOP API.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/AbstractBeanFactoryBasedTargetSource.javaAbstractBeanFactoryBasedTargetSourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/targetorg.springframework.aop.targetC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/AbstractBeanFactoryBasedTargetSource.class? extends AbstractBeanFactoryBasedTargetSourceClass<? extends AbstractBeanFactoryBasedTargetSource>4721607536018568393L4721607536018568393beanInstance"Getting bean with name '"Getting bean with name '"' for type determination"' for type determinationotherTargetSourceMap<String,? extends AbstractBeanFactoryBasedTargetSource>AbstractBeanFactoryBasedTargetSource[]? extends AbstractBeanFactoryBasedTargetSource[]Constructor<? extends AbstractBeanFactoryBasedTargetSource>? super ? extends AbstractBeanFactoryBasedTargetSourceClass<? super ? extends AbstractBeanFactoryBasedTargetSource>TypeVariable<Class<? extends AbstractBeanFactoryBasedTargetSource>>TypeVariable<Class<? extends AbstractBeanFactoryBasedTargetSource>>[]" for target bean '" for target bean '" of type [" of type [Base class for {@link org.springframework.aop.TargetSource} implementationsthat are based on a Spring {@link org.springframework.beans.factory.BeanFactory},delegating to Spring-managed bean instances.<p>Subclasses can create prototype instances or lazily access asingleton target, for example. See {@link LazyInitTargetSource} and{@link AbstractPrototypeBasedTargetSource}'s subclasses for concrete strategies.<p>BeanFactory-based TargetSources are serializable. This involvesdisconnecting the current target and turning into a {@link SingletonTargetSource}.1.1.4LazyInitTargetSourcePrototypeTargetSourceThreadLocalTargetSourceCommonsPool2TargetSourceuse serialVersionUID from Spring 1.2.7 for interoperability.Name of the target bean we will create on each invocation.Class of the target.BeanFactory that owns this TargetSource. We need to hold onto thisreference so that we can create new prototype instances as necessary.Set the name of the target bean in the factory.<p>The target bean should not be a singleton, else the same instance willalways be obtained from the factory, resulting in the same behavior asprovided by {@link SingletonTargetSource}.name of the target bean in the BeanFactorythat owns this interceptorSingletonTargetSourceReturn the name of the target bean in the factory.Specify the target class explicitly, to avoid any kind of access to thetarget bean (for example, to avoid initialization of a FactoryBean instance).<p>Default is to detect the type automatically, through a {@code getType}call on the BeanFactory (or even a full {@code getBean} call as fallback).Set the owning BeanFactory. We need to save a reference so that we canuse the {@code getBean} method on every invocation.Return the owning BeanFactory. Full check within synchronization, entering the BeanFactory interaction algorithm only once... Determine type of the target bean. Nothing to do here.Copy configuration from the other AbstractBeanFactoryBasedTargetSource object.Subclasses should override this if they wish to expose it.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/AbstractLazyCreationTargetSource.javaAbstractLazyCreationTargetSourcelazyTargetC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/AbstractLazyCreationTargetSource.class? extends AbstractLazyCreationTargetSourceClass<? extends AbstractLazyCreationTargetSource>"Initializing lazy target object"Initializing lazy target object{@link org.springframework.aop.TargetSource} implementation that willlazily create a user-managed object.<p>Creation of the lazy target object is controlled by the user by implementingthe {@link #createObject()} method. This {@code TargetSource} will invokethis method the first time the proxy is accessed.<p>Useful when you need to pass a reference to some dependency to an objectbut you don't actually want the dependency to be created until it is first used.A typical scenario for this is a connection to a remote resource.1.2.4#isInitialized()#createObject()The lazily initialized target object.Return whether the lazy target object of this TargetSourcehas already been fetched.This default implementation returns {@code null} if thetarget is {@code null} (it is hasn't yet been initialized),or the target class if the target has already been initialized.<p>Subclasses may wish to override this method in order to providea meaningful value when the target is still {@code null}.Returns the lazy-initialized target object,creating it on-the-fly if it doesn't exist already. nothing to doSubclasses should implement this method to return the lazy initialized object.Called the first time the proxy is invoked.the created objectif creation failedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/AbstractPoolingTargetSource.javaAbstractPoolingTargetSourcemaxSizeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/AbstractPoolingTargetSource.class"Could not create instance pool for TargetSource"Could not create instance pool for TargetSourcediiClass<PoolingConfig>Copyright 2002-2021 the original author or authors.Abstract base class for pooling {@link org.springframework.aop.TargetSource}implementations which maintain a pool of target instances, acquiring andreleasing a target object from the pool for each method invocation.This abstract base class is independent of concrete pooling technology;see the subclass {@link CommonsPool2TargetSource} for a concrete example.<p>Subclasses must implement the {@link #getTarget} and{@link #releaseTarget} methods based on their chosen object pool.The {@link #newPrototypeInstance()} method inherited from{@link AbstractPrototypeBasedTargetSource} can be used to create objectsin order to put them into the pool.<p>Subclasses must also implement some of the monitoring methods from the{@link PoolingConfig} interface. The {@link #getPoolingConfigMixin()} methodmakes these stats available on proxied objects through an IntroductionAdvisor.<p>This class implements the {@link org.springframework.beans.factory.DisposableBean}interface in order to force subclasses to implement a {@link #destroy()}method, closing down their object pool.#releaseTarget#destroyThe maximum size of the pool.Set the maximum size of the pool.Default is -1, indicating no size limit.Return the maximum size of the pool.Create the pool.to avoid placing constraints on pooling APIsAcquire an object from the pool.an object from the poolwe may need to deal with checked exceptions from poolAPIs, so we're forgiving with our exception signatureReturn the given object to the pool.object that must have been acquired from the poolvia a call to {@code getTarget()}to allow pooling APIs to throw exceptionReturn an IntroductionAdvisor that provides a mixinexposing statistics about the pool maintained by this object.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/AbstractPrototypeBasedTargetSource.javaAbstractPrototypeBasedTargetSourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/AbstractPrototypeBasedTargetSource.class"Cannot use prototype-based TargetSource against non-prototype bean with name '"Cannot use prototype-based TargetSource against non-prototype bean with name '"': instances would not be independent"': instances would not be independent"Creating new instance of bean '"Creating new instance of bean '"Destroying instance of bean '"Destroying instance of bean '"Destroy method on bean with name '"Destroy method on bean with name '"' threw an exception"' threw an exception"A prototype-based TargetSource itself is not deserializable - " +
				"just a disconnected SingletonTargetSource or EmptyTargetSource is"A prototype-based TargetSource itself is not deserializable - just a disconnected SingletonTargetSource or EmptyTargetSource is"Disconnecting TargetSource ["Disconnecting TargetSource ["Cannot get target for disconnecting TargetSource ["Cannot get target for disconnecting TargetSource [Base class for dynamic {@link org.springframework.aop.TargetSource} implementationsthat create new prototype bean instances to support a pooling ornew-instance-per-invocation strategy.<p>Such TargetSources must run in a {@link BeanFactory}, as it needs tocall the {@code getBean} method to create a new prototype instance.Therefore, this base class extends {@link AbstractBeanFactoryBasedTargetSource}. Check whether the target bean is defined as prototype.Subclasses should call this method to create a new prototype instance.if bean creation failedSubclasses should call this method to destroy an obsolete prototype instance.the bean instance to destroyReplaces this object with a SingletonTargetSource on serialization.Protected as otherwise it won't be invoked for subclasses.(The {@code writeReplace()} method must be visible to the classbeing serialized.)<p>With this implementation of this method, there is no need to marknon-serializable fields in this class or subclasses as transient. Create disconnected SingletonTargetSource/EmptyTargetSource.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/CommonsPool2TargetSource.javaorg.apache.commons.pool2ObjectPool<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jarcommons-pool2-2.9.0C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe84058e9e8bbd29cf3e7861cb80c0a615770baffe840C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.02.9.0C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2commons-pool2C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commonsorg.apache.commonsC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/orgC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apacheapacheC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commonscommonsC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2pool2C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/ObjectPool.classObjectPoolpoolC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/CommonsPool2TargetSource.classblockWhenExhaustedminEvictableIdleTimeMillistimeBetweenEvictionRunsMillismaxWaitminIdlemaxIdlePooledObjectFactory<Object>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/PooledObjectFactory.classPooledObjectFactoryorg.apache.commons.pool2.implGenericObjectPoolConfig<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/implimplC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/impl/GenericObjectPoolConfig.classGenericObjectPoolConfigBaseObjectPoolConfig<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/impl/BaseObjectPoolConfig.classBaseObjectPoolConfig"Creating Commons object pool"Creating Commons object poolGenericObjectPoolConfig<>()toStringAppendFieldstoStringAppendFields(java.lang.StringBuilder)setJmxNamePrefixsetJmxNamePrefix(java.lang.String)getJmxNamePrefixgetJmxNamePrefix()setJmxNameBasesetJmxNameBase(java.lang.String)getJmxNameBasegetJmxNameBase()setJmxEnabledsetJmxEnabled(boolean)getJmxEnabledgetJmxEnabled()setBlockWhenExhaustedsetBlockWhenExhausted(boolean)getBlockWhenExhaustedgetBlockWhenExhausted()setEvictionPolicyClassNamesetEvictionPolicyClassName(java.lang.String)EvictionPolicy<T>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/impl/EvictionPolicy.classEvictionPolicysetEvictionPolicysetEvictionPolicy(org.apache.commons.pool2.impl.EvictionPolicy)EvictionPolicy<>getEvictionPolicyClassNamegetEvictionPolicyClassName()getEvictionPolicygetEvictionPolicy()setTimeBetweenEvictionRunsMillissetTimeBetweenEvictionRunsMillis(long)getTimeBetweenEvictionRunsMillisgetTimeBetweenEvictionRunsMillis()setTestWhileIdlesetTestWhileIdle(boolean)getTestWhileIdlegetTestWhileIdle()setTestOnReturnsetTestOnReturn(boolean)getTestOnReturngetTestOnReturn()setTestOnBorrowsetTestOnBorrow(boolean)getTestOnBorrowgetTestOnBorrow()setTestOnCreatesetTestOnCreate(boolean)getTestOnCreategetTestOnCreate()setEvictorShutdownTimeoutMillissetEvictorShutdownTimeoutMillis(long)getEvictorShutdownTimeoutMillisgetEvictorShutdownTimeoutMillis()setNumTestsPerEvictionRunsetNumTestsPerEvictionRun(int)getNumTestsPerEvictionRungetNumTestsPerEvictionRun()setSoftMinEvictableIdleTimeMillissetSoftMinEvictableIdleTimeMillis(long)getSoftMinEvictableIdleTimeMillisgetSoftMinEvictableIdleTimeMillis()setMinEvictableIdleTimeMillissetMinEvictableIdleTimeMillis(long)getMinEvictableIdleTimeMillisgetMinEvictableIdleTimeMillis()setMaxWaitMillissetMaxWaitMillis(long)getMaxWaitMillisgetMaxWaitMillis()setFairnesssetFairness(boolean)setLifosetLifo(boolean)getFairnessgetFairness()getLifogetLifo()BaseObjectPoolConfig()BaseObjectPoolConfig<>()DEFAULT_EVICTION_POLICY_CLASS_NAMEDEFAULT_JMX_NAME_BASEDEFAULT_JMX_NAME_PREFIXDEFAULT_JMX_ENABLEDEFAULT_BLOCK_WHEN_EXHAUSTEDDEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLISDEFAULT_TEST_WHILE_IDLEDEFAULT_TEST_ON_RETURNDEFAULT_TEST_ON_BORROWDEFAULT_TEST_ON_CREATEDEFAULT_NUM_TESTS_PER_EVICTION_RUNDEFAULT_EVICTOR_SHUTDOWN_TIMEOUT_MILLISDEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLISDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLISDEFAULT_MAX_WAIT_MILLISDEFAULT_FAIRNESSDEFAULT_LIFOsetMinIdlesetMinIdle(int)getMinIdlegetMinIdle()setMaxIdlesetMaxIdle(int)getMaxIdlegetMaxIdle()setMaxTotalsetMaxTotal(int)getMaxTotalgetMaxTotal()GenericObjectPoolConfig()DEFAULT_MIN_IDLEDEFAULT_MAX_IDLEDEFAULT_MAX_TOTALGenericObjectPool<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/impl/GenericObjectPool.classGenericObjectPoolBaseGenericObjectPool<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/impl/BaseGenericObjectPool.classBaseGenericObjectPoolUsageTracking<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/UsageTracking.classUsageTrackingPooledObjectFactory<>PooledObjectFactory<T>GenericObjectPoolConfig<T>BaseObjectPoolConfig<T>GenericObjectPool<>(org.apache.commons.pool2.PooledObjectFactory,org.apache.commons.pool2.impl.GenericObjectPoolConfig)jmxUnregisterjmxUnregister()PooledObject<T>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/PooledObject.classPooledObjectComparable<PooledObject<T>>markReturningStatemarkReturningState(org.apache.commons.pool2.PooledObject)PooledObject<>Comparable<>updateStatsReturnupdateStatsReturn(long)updateStatsBorrowupdateStatsBorrow(org.apache.commons.pool2.PooledObject,long)swallowExceptionswallowException(java.lang.Exception)setSwallowedExceptionListenersetSwallowedExceptionListener(org.apache.commons.pool2.SwallowedExceptionListener)getSwallowedExceptionListenergetSwallowedExceptionListener()getNumIdlegetNumIdle()getMaxBorrowWaitTimeMillisgetMaxBorrowWaitTimeMillis()getMeanBorrowWaitTimeMillisgetMeanBorrowWaitTimeMillis()getMeanIdleTimeMillisgetMeanIdleTimeMillis()getMeanActiveTimeMillisgetMeanActiveTimeMillis()getDestroyedByBorrowValidationCountgetDestroyedByBorrowValidationCount()getDestroyedByEvictorCountgetDestroyedByEvictorCount()getDestroyedCountgetDestroyedCount()getCreatedCountgetCreatedCount()getReturnedCountgetReturnedCount()getBorrowedCountgetBorrowedCount()getCreationStackTracegetCreationStackTrace()getJmxNamegetJmxName()ensureMinIdleensureMinIdle()stopEvictorstopEvictor()startEvictorstartEvictor(long)assertOpenassertOpen()evictevict()isClosedisClosed()setEvictionPolicyClassName(java.lang.String,java.lang.ClassLoader)setConfigsetConfig(org.apache.commons.pool2.impl.BaseObjectPoolConfig)BaseGenericObjectPool(org.apache.commons.pool2.impl.BaseObjectPoolConfig,java.lang.String,java.lang.String)BaseGenericObjectPool<>(org.apache.commons.pool2.impl.BaseObjectPoolConfig,java.lang.String,java.lang.String)destroyedByBorrowValidationCountdestroyedByEvictorCountdestroyedCountcreatedCountevictionIteratorevictionLockclosedcloseLockMEAN_TIMING_STATS_CACHE_SIZEreturnObjectreturnObject(java.lang.Object)invalidateObjectinvalidateObject(java.lang.Object,org.apache.commons.pool2.DestroyMode)invalidateObject(java.lang.Object)getNumActivegetNumActive()borrowObjectborrowObject()addObjectsaddObjects(int)addObjectaddObject()useuse(java.lang.Object)Set<DefaultPooledObjectInfo>Collection<DefaultPooledObjectInfo>Iterable<DefaultPooledObjectInfo>listAllObjectslistAllObjects()getFactoryTypegetFactoryType()getNumWaitersgetNumWaiters()preparePoolpreparePool()borrowObject(long)getFactorygetFactory()setAbandonedConfigsetAbandonedConfig(org.apache.commons.pool2.impl.AbandonedConfig)setConfig(org.apache.commons.pool2.impl.GenericObjectPoolConfig)getRemoveAbandonedTimeoutgetRemoveAbandonedTimeout()getRemoveAbandonedOnMaintenancegetRemoveAbandonedOnMaintenance()getRemoveAbandonedOnBorrowgetRemoveAbandonedOnBorrow()getLogAbandonedgetLogAbandoned()isAbandonedConfigisAbandonedConfig()GenericObjectPool(org.apache.commons.pool2.PooledObjectFactory,org.apache.commons.pool2.impl.GenericObjectPoolConfig,org.apache.commons.pool2.impl.AbandonedConfig)GenericObjectPool<>(org.apache.commons.pool2.PooledObjectFactory,org.apache.commons.pool2.impl.GenericObjectPoolConfig,org.apache.commons.pool2.impl.AbandonedConfig)GenericObjectPool(org.apache.commons.pool2.PooledObjectFactory,org.apache.commons.pool2.impl.GenericObjectPoolConfig)GenericObjectPool(org.apache.commons.pool2.PooledObjectFactory)GenericObjectPool<>(org.apache.commons.pool2.PooledObjectFactory)"No Commons ObjectPool available"No Commons ObjectPool available"Closing Commons ObjectPool"Closing Commons ObjectPoolPooledObject<Object>Comparable<PooledObject<Object>>DefaultPooledObject<Object>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.apache.commons/commons-pool2/2.9.0/58e9e8bbd29cf3e7861cb80c0a615770baffe840/commons-pool2-2.9.0.jar/org/apache/commons/pool2/impl/DefaultPooledObject.classDefaultPooledObjectDefaultPooledObject<Object>(java.lang.Object)compareTocompareTo(java.lang.Object)compareTo(org.apache.commons.pool2.PooledObject)markReturningmarkReturning()markAbandonedmarkAbandoned()getStategetState()printStackTraceprintStackTrace(java.io.PrintWriter)use()setRequireFullStackTracesetRequireFullStackTrace(boolean)setLogAbandonedsetLogAbandoned(boolean)invalidateinvalidate()deallocatedeallocate()allocateallocate()Deque<PooledObject>C:/modules/java.base/java/util/Deque.classDequeQueue<PooledObject>C:/modules/java.base/java/util/Queue.classQueueCollection<PooledObject>Iterable<PooledObject>endEvictionTestendEvictionTest(java.util.Deque)Deque<PooledObject<Object>>Queue<PooledObject<Object>>Collection<PooledObject<Object>>Iterable<PooledObject<Object>>startEvictionTeststartEvictionTest()getLastUsedTimegetLastUsedTime()getLastReturnTimegetLastReturnTime()getLastBorrowTimegetLastBorrowTime()getIdleTimeMillisgetIdleTimeMillis()getActiveTimeMillisgetActiveTimeMillis()getCreateTimegetCreateTime()getObjectgetObject()Deque<PooledObject<T>>Queue<PooledObject<T>>Collection<PooledObject<T>>Iterable<PooledObject<T>>DefaultPooledObject(java.lang.Object)p{@link org.springframework.aop.TargetSource} implementation that holdsobjects in a configurable Apache Commons2 Pool.<p>By default, an instance of {@code GenericObjectPool} is created.Subclasses may change the type of {@code ObjectPool} used byoverriding the {@code createObjectPool()} method.<p>Provides many configuration properties mirroring those of the Commons Pool{@code GenericObjectPool} class; these properties are passed to the{@code GenericObjectPool} during construction. If creating a subclass of thisclass to change the {@code ObjectPool} implementation type, pass in the valuesof configuration properties that are relevant to your chosen implementation.<p>The {@code testOnBorrow}, {@code testOnReturn} and {@code testWhileIdle}properties are explicitly not mirrored because the implementation of{@code PoolableObjectFactory} used by this class does not implementmeaningful validation. All exposed Commons Pool properties use thecorresponding Commons Pool defaults.<p>Compatible with Apache Commons Pool 2.4, as of Spring 4.2.Kazuki Shimizu#createObjectPool()#setMaxSize#setMaxIdle#setMinIdle#setMaxWait#setTimeBetweenEvictionRunsMillis#setMinEvictableIdleTimeMillisThe Apache Commons {@code ObjectPool} used to pool target objects.Create a CommonsPoolTargetSource with default settings.Default maximum size of the pool is 8.GenericObjectPoolConfig#setMaxTotalSet the maximum number of idle objects in the pool.Default is 8.GenericObjectPool#setMaxIdleReturn the maximum number of idle objects in the pool.Set the minimum number of idle objects in the pool.Default is 0.GenericObjectPool#setMinIdleReturn the minimum number of idle objects in the pool.Set the maximum waiting time for fetching an object from the pool.Default is -1, waiting forever.GenericObjectPool#setMaxWaitMillisReturn the maximum waiting time for fetching an object from the pool.Set the time between eviction runs that check idle objects whetherthey have been idle for too long or have become invalid.Default is -1, not performing any eviction.GenericObjectPool#setTimeBetweenEvictionRunsMillisReturn the time between eviction runs that check idle objects.Set the minimum time that an idle object can sit in the pool beforeit becomes subject to eviction. Default is 1800000 (30 minutes).<p>Note that eviction runs need to be performed to take thissetting into effect.GenericObjectPool#setMinEvictableIdleTimeMillisReturn the minimum time that an idle object can sit in the pool.Set whether the call should bock when the pool is exhausted.Specify if the call should block when the pool is exhausted.Creates and holds an ObjectPool instance.Subclasses can override this if they want to return a specific Commons pool.They should apply any configuration properties to the pool here.<p>Default is a GenericObjectPool instance with the given pool size.an empty Commons {@code ObjectPool}.Borrows an object from the {@code ObjectPool}.Returns the specified object to the underlying {@code ObjectPool}.Closes the underlying {@code ObjectPool} when destroying this object.---------------------------------------------------------------------------- Implementation of org.apache.commons.pool2.PooledObjectFactory interfaceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/EmptyTargetSource.javaEmptyTargetSourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/EmptyTargetSource.classEmptyTargetSource(java.lang.Class,boolean)3680494563553489691L3680494563553489691otherTsClass<EmptyTargetSource>"EmptyTargetSource: "EmptyTargetSource: "target class ["target class ["no target class"no target class"static""dynamic"dynamicCanonical {@code TargetSource} when there is no target(or just the target class known), and behavior is suppliedby interfaces and advisors only. Static factory methodsThe canonical (Singleton) instance of this {@link EmptyTargetSource}.Return an EmptyTargetSource for the given target Class.the target Class (may be {@code null})#getTargetClass()whether the TargetSource should be marked as static Instance implementationCreate a new instance of the {@link EmptyTargetSource} class.<p>This constructor is {@code private} to enforce theSingleton pattern / factory method pattern.the target class to expose (may be {@code null})whether the TargetSource is marked as staticAlways returns the specified target Class, or {@code null} if none.Always returns {@code true}.Always returns {@code null}.Nothing to release.Returns the canonical instance on deserialization in caseof no target class, thus protecting the Singleton pattern.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/HotSwappableTargetSource.javaHotSwappableTargetSourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/HotSwappableTargetSource.class7497929212653839187L7497929212653839187initialTargetnewTargetClass<HotSwappableTargetSource>"HotSwappableTargetSource for target: "HotSwappableTargetSource for target: {@link org.springframework.aop.TargetSource} implementation thatcaches a local target object, but allows the target to be swappedwhile the application is running.<p>If configuring an object of this class in a Spring IoC container,use constructor injection.<p>This TargetSource is serializable if the target is at the timeof serialization.The current target object.Create a new HotSwappableTargetSource with the given initial target object.the initial target objectReturn the type of the current target object.<p>The returned type should usually be constant across all target objects.Swap the target, returning the old target object.the new target objectthe old target objectif the new target is invalidTwo HotSwappableTargetSources are equal if the current targetobjects are equal.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/LazyInitTargetSource.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/LazyInitTargetSource.class{@link org.springframework.aop.TargetSource} that lazily accesses asingleton bean from a {@link org.springframework.beans.factory.BeanFactory}.<p>Useful when a proxy reference is needed on initialization butthe actual target object should not be initialized until first use.When the target bean is defined in an{@link org.springframework.context.ApplicationContext} (or a{@code BeanFactory} that is eagerly pre-instantiating singleton beans)it must be marked as "lazy-init" too, else it will be instantiated by said{@code ApplicationContext} (or {@code BeanFactory}) on startup.<p>For example:&lt;bean id="serviceTarget" class="example.MyService" lazy-init="true"&gt;&lt;bean id="service" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;&lt;property name="targetSource"&gt;&lt;bean class="org.springframework.aop.target.LazyInitTargetSource"&gt;&lt;property name="targetBeanName"&gt;&lt;idref local="serviceTarget"/&gt;&lt;/property&gt;The "serviceTarget" bean will not get initialized until a method on the"service" proxy gets invoked.<p>Subclasses can extend this class and override the {@link #postProcessTargetObject(Object)} toperform some additional processing with the target object when it is first loaded.#postProcessTargetObjectSubclasses may override this method to perform additional processing onthe target object when it is first loaded.the target object that has just been instantiated (and configured)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/PoolingConfig.javaPoolingConfigConfig interface for a pooling target source.Return the number of active objects in the pool.if not supported by the poolReturn the number of idle objects in the pool.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/PrototypeTargetSource.java"PrototypeTargetSource for target bean with name '"PrototypeTargetSource for target bean with name 'creates a new instance of the target bean for each request,destroying each instance on release (after each request).<p>Obtains bean instances from its containing{@link org.springframework.beans.factory.BeanFactory}.#setBeanFactory#setTargetBeanNameObtain a new prototype instance for every call.#newPrototypeInstance()Destroy the given independent instance.#destroyPrototypeInstanceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/SimpleBeanTargetSource.javaSimpleBeanTargetSourceSimple {@link org.springframework.aop.TargetSource} implementation,freshly obtaining the specified target bean from its containingSpring {@link org.springframework.beans.factory.BeanFactory}.<p>Can obtain any kind of target bean: singleton, scoped, or prototype.Typically used for scoped beans.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/SingletonTargetSource.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/SingletonTargetSource.class9031246629662423738L9031246629662423738"SingletonTargetSource for target object ["SingletonTargetSource for target object [Implementation of the {@link org.springframework.aop.TargetSource} interfacethat holds a given object. This is the default implementation of the TargetSourceinterface, as used by the Spring AOP framework. There is usually no need tocreate objects of this class in application code.<p>This class is serializable. However, the actual serializability of aSingletonTargetSource will depend on whether the target is serializable.org.springframework.aop.framework.AdvisedSupport#setTarget(Object)Target cached and invoked using reflection.Create a new SingletonTargetSource for the given target.Two invoker interceptors are equal if they have the same target or if thetargets or the targets are equal.SingletonTargetSource uses the hash code of the target object.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/ThreadLocalTargetSource.javahitCountC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/ThreadLocalTargetSource.classinvocationCounttargetSettargetInThread"Thread-local instance of bean '"Thread-local instance of bean 'HashSet<Object>AbstractSet<Object>HashSet<Object>()AbstractSet<Object>()HashSet<Object>(int,float,boolean)HashSet<Object>(int)HashSet<Object>(int,float)HashSet<Object>(java.util.Collection)"No target for prototype '"No target for prototype '"' bound to thread: " +
						"creating one and binding it to thread '"' bound to thread: creating one and binding it to thread '"Destroying ThreadLocalTargetSource bindings"Destroying ThreadLocalTargetSource bindingsClass<ThreadLocalTargetSourceStats>Alternative to an object pool. This {@link org.springframework.aop.TargetSource}uses a threading model in which every thread has its own copy of the target.There's no contention for targets. Target object creation is kept to a minimumon the running server.<p>Application code is written as to a normal pool; callers can't assume theywill be dealing with the same instance in invocations in different threads.However, state can be relied on during the operations of a single thread:for example, if one caller makes repeated calls on the AOP proxy.<p>Cleanup of thread-bound objects is performed on BeanFactory destruction,calling their {@code DisposableBean.destroy()} method if available.Be aware that many thread-bound objects can be around until the applicationactually shuts down.ThreadLocalTargetSourceStatsorg.springframework.beans.factory.DisposableBean#destroy()ThreadLocal holding the target associated with the currentthread. Unlike most ThreadLocals, which are static, this variableis meant to be per thread per instance of the ThreadLocalTargetSource class.Set of managed targets, enabling us to keep track of the targets we've created.Implementation of abstract getTarget() method.We look for a target held in a ThreadLocal. If we don't find one,we create one and bind it to the thread. No synchronization is required. Associate target with ThreadLocal.Dispose of targets if necessary; clear ThreadLocal. Clear ThreadLocal, just in case.Return an introduction advisor mixin that allows the AOP proxy to becast to ThreadLocalInvokerStats.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/ThreadLocalTargetSourceStats.javaStatistics for a ThreadLocal TargetSource.Return the number of client invocations.Return the number of hits that were satisfied by a thread-bound object.Return the number of thread-bound objects created.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/dynamic/AbstractRefreshableTargetSource.javaAbstractRefreshableTargetSourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/dynamicorg.springframework.aop.target.dynamicrefreshCheckDelayElapsedrefreshCheckDelayElapsed()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/dynamic/AbstractRefreshableTargetSource.classrefreshCountlastRefreshTimelastRefreshCheckrefreshCheckDelay? extends AbstractRefreshableTargetSourceClass<? extends AbstractRefreshableTargetSource>"Attempting to refresh target"Attempting to refresh target"Target refreshed successfully"Target refreshed successfullycurrentTimeMillis"Refresh check delay elapsed - checking whether refresh is required"Refresh check delay elapsed - checking whether refresh is requiredAbstract {@link org.springframework.aop.TargetSource} implementation thatwraps a refreshable target object. Subclasses can determine whether arefresh is required, and need to provide fresh target objects.<p>Implements the {@link Refreshable} interface in order to allow forexplicit control over the refresh status.#requiresRefresh()#freshTarget()Set the delay between refresh checks, in milliseconds.Default is -1, indicating no refresh checks at all.<p>Note that an actual refresh will only happen when{@link #requiresRefresh()} returns {@code true}.Not static.No need to release target. Going to perform a refresh check - update the timestamp.Determine whether a refresh is required.Invoked for each refresh check, after the refresh check delay has elapsed.<p>The default implementation always returns {@code true}, triggeringa refresh every time the delay has elapsed. To be overridden by subclasseswith an appropriate check of the underlying target resource.whether a refresh is requiredObtain a fresh target object.<p>Only invoked if a refresh check has found that a refresh is required(that is, {@link #requiresRefresh()} has returned {@code true}).the fresh target objectC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/dynamic/BeanFactoryRefreshableTargetSource.javaBeanFactoryRefreshableTargetSourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/dynamic/BeanFactoryRefreshableTargetSource.class"BeanFactory is required"BeanFactory is required"Bean name is required"Bean name is requiredRefreshable TargetSource that fetches fresh target beans from a BeanFactory.<p>Can be subclassed to override {@code requiresRefresh()} to suppressunnecessary refreshes. By default, a refresh will be performed every timethe "refreshCheckDelay" has elapsed.#setRefreshCheckDelayCreate a new BeanFactoryRefreshableTargetSource for the givenbean factory and bean name.<p>Note that the passed-in BeanFactory should have an appropriatebean definition set up for the given bean name.the BeanFactory to fetch beans fromRetrieve a fresh target object.A template method that subclasses may override to provide afresh target object for the given bean factory and bean name.<p>This default implementation fetches a new target beaninstance from the bean factory.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/main/java/org/springframework/aop/target/dynamic/Refreshable.javaRefreshableInterface to be implemented by dynamic target objects,which support reloading and optionally polling for updates.Refresh the underlying target object.Return the number of actual refreshes since startup.Return the last time an actual refresh happened (as timestamp).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJAdviceParameterNameDiscoverAnnotationTests.javaAspectJAdviceParameterNameDiscoverAnnotationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectjC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aopC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframeworkC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/orgC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test"pjpAndAnAnnotation"pjpAndAnAnnotation"execution(* *(..)) && @annotation(ann)"execution(* *(..)) && @annotation(ann)"ann"Additional parameter name discover tests that need Java 5.Yes this will re-run the tests from the superclass, but thatdoesn't matter in the grand scheme of things...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJAdviceParameterNameDiscovererTests.javaAspectJAdviceParameterNameDiscovererTestsformatformat(java.lang.String[])C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJAdviceParameterNameDiscovererTests.class"noArgs"noArgs"execution(* *(..))"execution(* *(..))"tjp"tjp"tjpsp"tjpsp"twoJoinPoints"twoJoinPoints"foo()"foo()"Failed to bind all argument names: 1 argument(s) could not be bound"Failed to bind all argument names: 1 argument(s) could not be bound"oneThrowable"oneThrowable"ex""jpAndOneThrowable"jpAndOneThrowableClass<AmbiguousBindingException>"jpAndTwoThrowables"jpAndTwoThrowables"Binding of throwing parameter 'ex' is ambiguous: could be bound to argument 1 or argument 2"Binding of throwing parameter 'ex' is ambiguous: could be bound to argument 1 or argument 2"oneObject"oneObject"obj""twoObjects"twoObjects"Binding of returning parameter 'obj' is ambiguous, there are 2 candidates."Binding of returning parameter 'obj' is ambiguous, there are 2 candidates."this(x)"this(x)"x""this( x )"this( x )"this( x)"this( x)"this (x )"this (x )"this(x )"this(x )"foo() && this(x)"foo() && this(x)"this(x) || this(y)"this(x) || this(y)"Found 2 candidate this(), target() or args() variables but only one unbound argument slot"Found 2 candidate this(), target() or args() variables but only one unbound argument slot"this(x && foo()"this(x && foo()"target(x)"target(x)"target( x )"target( x )"target( x)"target( x)"target (x )"target (x )"target(x )"target(x )"foo() && target(x)"foo() && target(x)"target(x) || target(y)"target(x) || target(y)"target(x && foo()"target(x && foo()"args(x)"args(x)"args(x,y)"args(x,y)"Still 2 unbound args at this(),target(),args() binding stage, with no way to determine between them"Still 2 unbound args at this(),target(),args() binding stage, with no way to determine between them"onePrimitive"onePrimitive"args(count)"args(count)"count""oneObjectOnePrimitive"oneObjectOnePrimitive"args(count,obj)"args(count,obj)"Found 2 candidate variable names but only one candidate binding slot when matching primitive args"Found 2 candidate variable names but only one candidate binding slot when matching primitive args"args(count) && this(obj)"args(count) && this(obj)"args(count) && target(obj)"args(count) && target(obj)"oneThrowableOnePrimitive"oneThrowableOnePrimitive"theBigOne"theBigOne"this(foo) && args(x)"this(foo) && args(x)"somepc(foo)"somepc(foo)"call(bar *) && somepc(foo)"call(bar *) && somepc(foo)"somepc ( foo )"somepc ( foo )"somepc( foo)"somepc( foo)candidates? extends AspectJAdviceParameterNameDiscovererTestsClass<? extends AspectJAdviceParameterNameDiscovererTests>Map<String,? extends AspectJAdviceParameterNameDiscovererTests>AspectJAdviceParameterNameDiscovererTests[]? extends AspectJAdviceParameterNameDiscovererTests[]Constructor<? extends AspectJAdviceParameterNameDiscovererTests>? super ? extends AspectJAdviceParameterNameDiscovererTestsClass<? super ? extends AspectJAdviceParameterNameDiscovererTests>TypeVariable<Class<? extends AspectJAdviceParameterNameDiscovererTests>>TypeVariable<Class<? extends AspectJAdviceParameterNameDiscovererTests>>[]"Bad test specification, no method '"Bad test specification, no method '"' found in test class"' found in test classdiscoveredNamesformattedExpectedNamesformattedActualNames"bad test specification, must have same number of parameter names as method arguments"bad test specification, must have same number of parameter names as method arguments" parameter names in return set '" parameter names in return set '"', but found "', but found " '" '"Parameter names must never be null"Parameter names must never be null"Expecting parameter "Expecting parameter " to be named '" to be named '"' but was '"' but was 'exceptionTypeThrowableAssertAlternative<? extends Throwable>AbstractAssert<ThrowableAssertAlternative<? extends Throwable>,? extends Throwable>Assert<ThrowableAssertAlternative<? extends Throwable>,? extends Throwable>Descriptable<ThrowableAssertAlternative<? extends Throwable>>ExtensionPoints<ThrowableAssertAlternative<? extends Throwable>,? extends Throwable>AbstractAssert<ThrowableAssertAlternative<? extends Throwable>,? extends Throwable>(java.lang.Throwable,java.lang.Class)ThrowableAssertAlternative<? extends Throwable>(java.lang.Throwable)ThrowableTypeAssert<? extends Throwable>Descriptable<ThrowableTypeAssert<? extends Throwable>>? extends ? extends ThrowableClass<? extends ? extends Throwable>ThrowableTypeAssert<? extends Throwable>(java.lang.Class)jp1jp2erryUnit tests for the {@link AspectJAdviceParameterNameDiscoverer} class.<p>See also {@link TigerAspectJAdviceParameterNameDiscovererTests} for tests relating to annotations. Assumes no overloading of test methods... Methods to discover parameter names forC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJExpressionPointcutTests.javaAspectJExpressionPointcutTestsassertThatIllegalArgumentExceptionassertThatIllegalStateExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/AspectJExpressionPointcutTests.classassertMatchesTestBeanClassassertMatchesTestBeanClass(org.springframework.aop.ClassFilter)assertMatchesGetAgeassertMatchesGetAge(org.springframework.aop.MethodMatcher)getAdvisedProxygetAdvisedProxy(java.lang.String,org.springframework.aop.aspectj.CallCountingInterceptor)testWithinPackagetestWithinPackage(boolean)testThisOrTargettestThisOrTarget(java.lang.String)setSomeNumbergetAgeClass<TestBean>Map<String,TestBean>TestBean[]Constructor<TestBean>? super TestBeanClass<? super TestBean>TypeVariable<Class<TestBean>>TypeVariable<Class<TestBean>>[]"getAge"Class<Integer>Class<Number>"setSomeNumber""execution(int org.springframework.beans.testfixture.beans.TestBean.getAge())"execution(int org.springframework.beans.testfixture.beans.TestBean.getAge())"Should not be a runtime match"Should not be a runtime match"Expression should match setAge() method"Expression should match setAge() method"execution(* *..TestBean.*Age(..))"execution(* *..TestBean.*Age(..))"Expression should match setAge(int) method"Expression should match setAge(int) methodwhichmatchesTestBean"(org.springframework.beans.testfixture.beans.TestBean)"(org.springframework.beans.testfixture.beans.TestBean)matchesIOther"(org.springframework.beans.testfixture.beans.IOther)"(org.springframework.beans.testfixture.beans.IOther)testBeanPciOtherPcClass<OtherIOther>Map<String,OtherIOther>OtherIOther[]Constructor<OtherIOther>? super OtherIOtherClass<? super OtherIOther>TypeVariable<Class<OtherIOther>>TypeVariable<Class<OtherIOther>>[]"absquatulate"absquatulatematchSubpackageswithinBeansPackage"within(org.springframework.beans.testfixture.beans."within(org.springframework.beans.testfixture.beans.withinBeansPc"*)"*)Class<DeepBean>Map<String,DeepBean>DeepBean[]Constructor<DeepBean>? super DeepBeanClass<? super DeepBean>TypeVariable<Class<DeepBean>>TypeVariable<Class<DeepBean>>[]"aMethod"aMethodThrowableAssertAlternative<IllegalStateException>AbstractAssert<ThrowableAssertAlternative<IllegalStateException>,IllegalStateException>Assert<ThrowableAssertAlternative<IllegalStateException>,IllegalStateException>Descriptable<ThrowableAssertAlternative<IllegalStateException>>ExtensionPoints<ThrowableAssertAlternative<IllegalStateException>,IllegalStateException>? super IllegalStateExceptionCondition<? super IllegalStateException>Descriptable<Condition<? super IllegalStateException>>Comparator<? super IllegalStateException>Function<? super IllegalStateException,? extends T>Consumer<IllegalStateException>Predicate<? super IllegalStateException>AbstractAssert<ThrowableAssertAlternative<IllegalStateException>,IllegalStateException>(java.lang.IllegalStateException,java.lang.Class)ThrowableAssertAlternative<IllegalStateException>(java.lang.IllegalStateException)ThrowableTypeAssert<IllegalStateException>Descriptable<ThrowableTypeAssert<IllegalStateException>>? extends IllegalStateExceptionClass<? extends IllegalStateException>ThrowableTypeAssert<IllegalStateException>(java.lang.Class)Class<ITestBean>"execution(void org.springframework.beans.testfixture.beans.TestBean.setSomeNumber(Number)) && args(Double)"execution(void org.springframework.beans.testfixture.beans.TestBean.setSomeNumber(Number)) && args(Double)12D12.0"Should match with setSomeNumber with Double input"Should match with setSomeNumber with Double input11"Should not match setSomeNumber with Integer input"Should not match setSomeNumber with Integer input"Should not match getAge"Should not match getAge"Should be a runtime match"Should be a runtime match"Calls should be 0"Calls should be 0"Calls should be 1"Calls should be 190"Calls should still be 1"Calls should still be 130D30.0"execution(void org.springframework.beans.testfixture.beans.TestBean.setSomeNumber(Number) && args(Double)"execution(void org.springframework.beans.testfixture.beans.TestBean.setSomeNumber(Number) && args(Double)ThrowableAssertAlternative<IllegalArgumentException>AbstractAssert<ThrowableAssertAlternative<IllegalArgumentException>,IllegalArgumentException>Assert<ThrowableAssertAlternative<IllegalArgumentException>,IllegalArgumentException>Descriptable<ThrowableAssertAlternative<IllegalArgumentException>>ExtensionPoints<ThrowableAssertAlternative<IllegalArgumentException>,IllegalArgumentException>ThrowableTypeAssert<IllegalArgumentException>Descriptable<ThrowableTypeAssert<IllegalArgumentException>>? extends IllegalArgumentExceptionClass<? extends IllegalArgumentException>ThrowableTypeAssert<IllegalArgumentException>(java.lang.Class)"Expression should match getAge() method"Expression should match getAge() method"Expression should match TestBean class"Expression should match TestBean class"call(int org.springframework.beans.testfixture.beans.TestBean.getAge())"call(int org.springframework.beans.testfixture.beans.TestBean.getAge())ThrowableAssertAlternative<UnsupportedPointcutPrimitiveException>AbstractAssert<ThrowableAssertAlternative<UnsupportedPointcutPrimitiveException>,UnsupportedPointcutPrimitiveException>Assert<ThrowableAssertAlternative<UnsupportedPointcutPrimitiveException>,UnsupportedPointcutPrimitiveException>Descriptable<ThrowableAssertAlternative<UnsupportedPointcutPrimitiveException>>ExtensionPoints<ThrowableAssertAlternative<UnsupportedPointcutPrimitiveException>,UnsupportedPointcutPrimitiveException>Consumer<UnsupportedPointcutPrimitiveException>? super UnsupportedPointcutPrimitiveExceptionCondition<? super UnsupportedPointcutPrimitiveException>Descriptable<Condition<? super UnsupportedPointcutPrimitiveException>>Comparator<? super UnsupportedPointcutPrimitiveException>Function<? super UnsupportedPointcutPrimitiveException,? extends T>Predicate<? super UnsupportedPointcutPrimitiveException>AbstractAssert<ThrowableAssertAlternative<UnsupportedPointcutPrimitiveException>,UnsupportedPointcutPrimitiveException>(org.aspectj.weaver.tools.UnsupportedPointcutPrimitiveException,java.lang.Class)ThrowableTypeAssert<UnsupportedPointcutPrimitiveException>Descriptable<ThrowableTypeAssert<UnsupportedPointcutPrimitiveException>>? extends UnsupportedPointcutPrimitiveExceptionClass<? extends UnsupportedPointcutPrimitiveException>ThrowableTypeAssert<UnsupportedPointcutPrimitiveException>(java.lang.Class)Class<UnsupportedPointcutPrimitiveException>andThen(java.util.function.Consumer)Consumer<? super UnsupportedPointcutPrimitiveException>acceptaccept(java.lang.Object)accept(org.aspectj.weaver.tools.UnsupportedPointcutPrimitiveException)ObjectAssert<PointcutPrimitive>AbstractObjectAssert<ObjectAssert<PointcutPrimitive>,PointcutPrimitive>AbstractAssert<ObjectAssert<PointcutPrimitive>,PointcutPrimitive>Assert<ObjectAssert<PointcutPrimitive>,PointcutPrimitive>Descriptable<ObjectAssert<PointcutPrimitive>>ExtensionPoints<ObjectAssert<PointcutPrimitive>,PointcutPrimitive>Condition<? super PointcutPrimitive>Descriptable<Condition<? super PointcutPrimitive>>Comparator<? super PointcutPrimitive>Function<? super PointcutPrimitive,? extends T>Consumer<PointcutPrimitive>AbstractAssert<ObjectAssert<PointcutPrimitive>,PointcutPrimitive>(org.aspectj.weaver.tools.PointcutPrimitive,java.lang.Class)"execution(* *(..)) and args(String)"execution(* *(..)) and args(String)expr"execution(* *(..)) && args(String)"execution(* *(..)) && args(String)"execution(* *(..)) and args(String) and this(Object)"execution(* *(..)) and args(String) and this(Object)"execution(* *(..)) && args(String) && this(Object)"execution(* *(..)) && args(String) && this(Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/CallCountingInterceptor.classCallCountingInterceptorCallCountingInterceptor() not currently testable in a reliable fashionassertDoesNotMatchStringClass(classFilter);This and target are equivalent. Really instanceof pointcuts.this or target Subpackages are matched by ** call to getClassFilter forces resolution call to getClassFilter forces resolution... EmptyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/BeanNamePointcutMatchingTests.javaBeanNamePointcutMatchingTestsmatches(java.lang.String,java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/BeanNamePointcutMatchingTests.classassertMisMatchassertMisMatch(java.lang.String,java.lang.String)assertMatchassertMatch(java.lang.String,java.lang.String)"someName"someName"bean(someName)"bean(someName)"someName/someOtherName"someName/someOtherName"bean(someName/someOtherName)"bean(someName/someOtherName)"someName/foo/someOtherName"someName/foo/someOtherName"bean(someName/*/someOtherName)"bean(someName/*/someOtherName)"someName/foo/bar/someOtherName"someName/foo/bar/someOtherName"someName/*/**"someName/*/**"bean(someName/*)"bean(someName/*)"service:name=traceService"service:name=traceService"bean(service:name=traceService)"bean(service:name=traceService)"bean(service:name=*)"bean(service:name=*)"bean(*:name=traceService)"bean(*:name=traceService)"bean(*someName)"bean(*someName)"bean(*Name)"bean(*Name)"bean(*)"bean(*)"bean(someName*)"bean(someName*)"bean(some*)"bean(some*)"bean(some*Name)"bean(some*Name)"bean(*some*Name*)"bean(*some*Name*)"bean(*s*N*)"bean(*s*N*)"bean(someName) || bean(someOtherName)"bean(someName) || bean(someOtherName)"someOtherName"someOtherName"!bean(someOtherName)"!bean(someOtherName)"bean(someName) || !bean(someOtherName)"bean(someName) || !bean(someOtherName)"bean(someName) && !bean(someOtherName)"bean(someName) && !bean(someOtherName)"bean(someNamex)"bean(someNamex)"bean(someX*Name)"bean(someX*Name)"bean(someName) && bean(someOtherName)"bean(someName) && bean(someOtherName)"!bean(someName)"!bean(someName)"!bean(someName) && bean(someOtherName)"!bean(someName) && bean(someOtherName)"!bean(someName) || bean(someOtherName)"!bean(someName) || bean(someOtherName)pcExpression"Unexpected mismatch for bean \""Unexpected mismatch for bean ""\" for pcExpression \""" for pcExpression ""\""""Unexpected match for bean \""Unexpected match for bean "C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/BeanNamePointcutMatchingTests$1.classBeanNamePointcutMatchingTests$1getCurrentProxiedBeanNamegetCurrentProxiedBeanName()Tests for matching of bean() pointcut designator. Spring bean names are less restrictive compared to AspectJ names (methods, types etc.) MVC Controller-kind JMX-kind Wildcards Or, and, not expressions And, not expressionsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPointTests.javaMethodInvocationProceedingJoinPointTestsraw23depthitbthisProxymsig"Method named in toString"Method named in toStringObjectAssert<Signature>AbstractObjectAssert<ObjectAssert<Signature>,Signature>AbstractAssert<ObjectAssert<Signature>,Signature>Assert<ObjectAssert<Signature>,Signature>Descriptable<ObjectAssert<Signature>>ExtensionPoints<ObjectAssert<Signature>,Signature>? super SignatureCondition<? super Signature>Descriptable<Condition<? super Signature>>Comparator<? super Signature>Function<? super Signature,? extends T>Consumer<Signature>Predicate<? super Signature>AbstractAssert<ObjectAssert<Signature>,Signature>(org.aspectj.lang.Signature,java.lang.Class)Function<Signature,T>Function<? super Signature,T>Function<? super Signature,?>Function<? super Signature,?>[]AbstractObjectAssert<ObjectAssert<Signature>,Signature>(org.aspectj.lang.Signature,java.lang.Class)"Return same MethodSignature repeatedly"Return same MethodSignature repeatedlyObjectAssert<JoinPoint>AbstractObjectAssert<ObjectAssert<JoinPoint>,JoinPoint>AbstractAssert<ObjectAssert<JoinPoint>,JoinPoint>Assert<ObjectAssert<JoinPoint>,JoinPoint>Descriptable<ObjectAssert<JoinPoint>>ExtensionPoints<ObjectAssert<JoinPoint>,JoinPoint>Condition<? super JoinPoint>Descriptable<Condition<? super JoinPoint>>Comparator<? super JoinPoint>Function<? super JoinPoint,? extends T>Consumer<JoinPoint>Predicate<? super JoinPoint>AbstractAssert<ObjectAssert<JoinPoint>,JoinPoint>(org.aspectj.lang.JoinPoint,java.lang.Class)Function<JoinPoint,T>Function<? super JoinPoint,T>Function<? super JoinPoint,?>Function<? super JoinPoint,?>[]AbstractObjectAssert<ObjectAssert<JoinPoint>,JoinPoint>(org.aspectj.lang.JoinPoint,java.lang.Class)"Return same JoinPoint repeatedly"Return same JoinPoint repeatedlyAbstractAssert<ClassAssert,Class<?>>Assert<ClassAssert,Class<?>>Descriptable<ClassAssert>ExtensionPoints<ClassAssert,Class<?>>Condition<? super Class<?>>Descriptable<Condition<? super Class<?>>>Function<? super Class<?>,? extends T>Consumer<Class<?>>AbstractAssert<ClassAssert,Class<?>>(java.lang.Class,java.lang.Class)"Advice reentrantly set age"Advice reentrantly set ageslocObjectAssert<SourceLocation>AbstractObjectAssert<ObjectAssert<SourceLocation>,SourceLocation>AbstractAssert<ObjectAssert<SourceLocation>,SourceLocation>Assert<ObjectAssert<SourceLocation>,SourceLocation>Descriptable<ObjectAssert<SourceLocation>>ExtensionPoints<ObjectAssert<SourceLocation>,SourceLocation>? super SourceLocationCondition<? super SourceLocation>Descriptable<Condition<? super SourceLocation>>Comparator<? super SourceLocation>Function<? super SourceLocation,? extends T>Consumer<SourceLocation>Predicate<? super SourceLocation>AbstractAssert<ObjectAssert<SourceLocation>,SourceLocation>(org.aspectj.lang.reflect.SourceLocation,java.lang.Class)Function<SourceLocation,T>Function<? super SourceLocation,T>Function<? super SourceLocation,?>Function<? super SourceLocation,?>[]AbstractObjectAssert<ObjectAssert<SourceLocation>,SourceLocation>(org.aspectj.lang.reflect.SourceLocation,java.lang.Class)"Same source location must be returned on subsequent requests"Same source location must be returned on subsequent requestsThrowableAssertAlternative<UnsupportedOperationException>AbstractAssert<ThrowableAssertAlternative<UnsupportedOperationException>,UnsupportedOperationException>Assert<ThrowableAssertAlternative<UnsupportedOperationException>,UnsupportedOperationException>Descriptable<ThrowableAssertAlternative<UnsupportedOperationException>>ExtensionPoints<ThrowableAssertAlternative<UnsupportedOperationException>,UnsupportedOperationException>ThrowableTypeAssert<UnsupportedOperationException>Descriptable<ThrowableTypeAssert<UnsupportedOperationException>>? extends UnsupportedOperationExceptionClass<? extends UnsupportedOperationException>ThrowableTypeAssert<UnsupportedOperationException>(java.lang.Class)Class<UnsupportedOperationException>staticPartObjectAssert<StaticPart>AbstractObjectAssert<ObjectAssert<StaticPart>,StaticPart>AbstractAssert<ObjectAssert<StaticPart>,StaticPart>Assert<ObjectAssert<StaticPart>,StaticPart>Descriptable<ObjectAssert<StaticPart>>ExtensionPoints<ObjectAssert<StaticPart>,StaticPart>? super StaticPartCondition<? super StaticPart>Descriptable<Condition<? super StaticPart>>Comparator<? super StaticPart>Function<? super StaticPart,? extends T>Consumer<StaticPart>Predicate<? super StaticPart>AbstractAssert<ObjectAssert<StaticPart>,StaticPart>(org.aspectj.lang.JoinPoint.StaticPart,java.lang.Class)Function<StaticPart,T>Function<? super StaticPart,T>Function<? super StaticPart,?>Function<? super StaticPart,?>[]AbstractObjectAssert<ObjectAssert<StaticPart>,StaticPart>(org.aspectj.lang.JoinPoint.StaticPart,java.lang.Class)"Same static part must be returned on subsequent requests"Same static part must be returned on subsequent requestsaspectJVersionJp Will be set by advice during a method call Ensure that these don't cause problems Check getting again doesn't cause a problem Try reentrant call--will go through this advice. Be sure to increment depth to avoid infinite recursion Check that toString doesn't cause a problem Change age, so this will be returned by invocation Any call will do makeEncSJP, although meant for computing the enclosing join point, it serves our purpose here we don't really care...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJAdviceParameterNameDiscovererTests.javaTigerAspectJAdviceParameterNameDiscovererTests"oneAnnotation"oneAnnotation"@this(a)"@this(a)"a""@target(a)"@target(a)"@args(a)"@args(a)"@within(a)"@within(a)"@withincode(a)"@withincode(a)"@annotation(a)"@annotation(a)"twoAnnotations"twoAnnotations"@annotation(a) && @this(x)"@annotation(a) && @this(x)"Found 2 potential annotation variable(s), and 2 potential argument slots"Found 2 potential annotation variable(s), and 2 potential argument slotsClass<IllegalArgumentException>"Found 2 candidate annotation binding variables but only one potential argument binding slot"Found 2 candidate annotation binding variables but only one potential argument binding slot"annotationMedley"annotationMedley"@annotation(a) && args(count) && this(foo)"@annotation(a) && args(count) && this(foo)anotherAnnmaTests just the annotation binding part of {@link AspectJAdviceParameterNameDiscoverer};see supertype for remaining tests.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests.javaTigerAspectJExpressionPointcutTeststestMatchAnnotationOnClasstestMatchAnnotationOnClass(java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests.classMap<String,Method>methodsOnHasGenericHashMap<String,Method>AbstractMap<String,Method>HashMap<String,Method>()merge(java.lang.String,java.lang.reflect.Method,java.util.function.BiFunction)BiFunction<? super String,? super Method,? extends Method>Function<? super String,? extends Method>replace(java.lang.String,java.lang.reflect.Method)replace(java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method)putIfAbsent(java.lang.String,java.lang.reflect.Method)BiConsumer<? super String,? super Method>Entry<String,Method>Set<Entry<String,Method>>Collection<Entry<String,Method>>Iterable<Entry<String,Method>>Map<? extends String,? extends Method>put(java.lang.String,java.lang.reflect.Method)AbstractMap<String,Method>()Node<String,Method>TreeNode<String,Method>newTreeNode(int,java.lang.String,java.lang.reflect.Method,java.util.HashMap.Node)newNode(int,java.lang.String,java.lang.reflect.Method,java.util.HashMap.Node)Node<String,Method>[]putVal(int,java.lang.String,java.lang.reflect.Method,boolean,boolean)HashMap<String,Method>(java.util.Map)HashMap<String,Method>(int)HashMap<String,Method>(int,float)Class<HasGeneric>Map<String,HasGeneric>HasGeneric[]Constructor<HasGeneric>? super HasGenericClass<? super HasGeneric>TypeVariable<Class<HasGeneric>>TypeVariable<Class<HasGeneric>>[]"execution(* set*(java.util.List<org.springframework.beans.testfixture.beans.TestBean>) )"execution(* set*(java.util.List<org.springframework.beans.testfixture.beans.TestBean>) )takesGenericList"setFriends"setFriends"setEnemies"setEnemies"setPartners"setPartners"setPhoneNumbers"setPhoneNumbers"execution(int *.*(String, Object...))"execution(int *.*(String, Object...))jdbcVarArgsMyTemplateC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests$1MyTemplate.classTigerAspectJExpressionPointcutTests$1MyTemplate"unused"unusedqueryForIntqueryForInt(java.lang.String,java.lang.Object[])MyTemplate()sqlClass<MyTemplate>Map<String,MyTemplate>MyTemplate[]Constructor<MyTemplate>? super MyTemplateClass<? super MyTemplate>TypeVariable<Class<MyTemplate>>TypeVariable<Class<MyTemplate>>[]Class<Object[]>"queryForInt""@within(test.annotation.transaction.Tx)"@within(test.annotation.transaction.Tx)"within(@test.annotation.transaction.Tx *)"within(@test.annotation.transaction.Tx *)"within(@(test.annotation..*) *)"within(@(test.annotation..*) *)springAnnotatedPcspringTxAnnotatedPc"setName"setNameClass<SpringAnnotated>Map<String,SpringAnnotated>SpringAnnotated[]Constructor<SpringAnnotated>? super SpringAnnotatedClass<? super SpringAnnotated>TypeVariable<Class<SpringAnnotated>>TypeVariable<Class<SpringAnnotated>>[]"within(@(test.annotation.transaction..*) *)"within(@(test.annotation.transaction..*) *)"within(@(test.annotation.transaction.*) *)"within(@(test.annotation.transaction.*) *)Class<HasTransactionalAnnotation>Map<String,HasTransactionalAnnotation>HasTransactionalAnnotation[]Constructor<HasTransactionalAnnotation>? super HasTransactionalAnnotationClass<? super HasTransactionalAnnotation>TypeVariable<Class<HasTransactionalAnnotation>>TypeVariable<Class<HasTransactionalAnnotation>>[]Class<BeanB>Map<String,BeanB>BeanB[]Constructor<BeanB>? super BeanBClass<? super BeanB>TypeVariable<Class<BeanB>>TypeVariable<Class<BeanB>>[]Class<BeanA>Map<String,BeanA>BeanA[]Constructor<BeanA>? super BeanAClass<? super BeanA>TypeVariable<Class<BeanA>>TypeVariable<Class<BeanA>>[]"@annotation(test.annotation.transaction.Tx)"@annotation(test.annotation.transaction.Tx)? extends BeanAClass<? extends BeanA>? extends IBeanAClass<? extends IBeanA>Class<IBeanA>Map<String,IBeanA>IBeanA[]Constructor<IBeanA>? super IBeanAClass<? super IBeanA>TypeVariable<Class<IBeanA>>TypeVariable<Class<IBeanA>>[]"execution(@(test.annotation..*) * *(..))"execution(@(test.annotation..*) * *(..))anySpringMethodAnnotation"@args(*, test.annotation.EmptySpringAnnotation))"@args(*, test.annotation.EmptySpringAnnotation))takesSpringAnnotatedArgument2Class<ProcessesSpringAnnotatedParameters>Map<String,ProcessesSpringAnnotatedParameters>ProcessesSpringAnnotatedParameters[]Constructor<ProcessesSpringAnnotatedParameters>? super ProcessesSpringAnnotatedParametersClass<? super ProcessesSpringAnnotatedParameters>TypeVariable<Class<ProcessesSpringAnnotatedParameters>>TypeVariable<Class<ProcessesSpringAnnotatedParameters>>[]"takesAnnotatedParameters"takesAnnotatedParameters"takesNoAnnotatedParameters"takesNoAnnotatedParameters"execution(* *(*, @(test..*) *))"execution(* *(*, @(test..*) *))List<TestBean>Collection<TestBean>Iterable<TestBean>friendsenemiespartnersnumberstbsatb3ageC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests$BeanA.classTigerAspectJExpressionPointcutTests$BeanABeanABeanA()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TigerAspectJExpressionPointcutTests$BeanB.classTigerAspectJExpressionPointcutTests$BeanBBeanBBeanB()Java 5 specific {@link AspectJExpressionPointcutTests}. Assumes no overloading TODO this will currently map, would be nice for optimizationassertTrue(ajexp.matches(HasGeneric.class));assertFalse(ajexp.matches(TestBean.class)); True because it maybeMatches with potential argument subtypesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TrickyAspectJPointcutExpressionTests.javaTrickyAspectJPointcutExpressionTeststestAdvicetestAdvice(org.springframework.aop.Advisor,org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests.LogUserAdvice,org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests.TestService,java.lang.String,boolean)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TrickyAspectJPointcutExpressionTests.classtestAdvice(org.springframework.aop.Advisor,org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests.LogUserAdvice,org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests.TestService,java.lang.String)logAdvice"TestServiceImpl"TestServiceImpl"execution(* %s.TestService.*(..))"execution(* %s.TestService.*(..))? extends TrickyAspectJPointcutExpressionTestsClass<? extends TrickyAspectJPointcutExpressionTests>Map<String,? extends TrickyAspectJPointcutExpressionTests>TrickyAspectJPointcutExpressionTests[]? extends TrickyAspectJPointcutExpressionTests[]Constructor<? extends TrickyAspectJPointcutExpressionTests>? super ? extends TrickyAspectJPointcutExpressionTestsClass<? super ? extends TrickyAspectJPointcutExpressionTests>TypeVariable<Class<? extends TrickyAspectJPointcutExpressionTests>>TypeVariable<Class<? extends TrickyAspectJPointcutExpressionTests>>[]"@within(%s.Log)"@within(%s.Log)loaderClass<TestServiceImpl>Map<String,TestServiceImpl>TestServiceImpl[]Constructor<TestServiceImpl>? super TestServiceImplClass<? super TestServiceImpl>TypeVariable<Class<TestServiceImpl>>TypeVariable<Class<TestServiceImpl>>[]Class<TestService>Map<String,TestService>TestService[]Constructor<TestService>? super TestServiceClass<? super TestService>TypeVariable<Class<TestService>>TypeVariable<Class<TestService>>[]Class<TestException>Map<String,TestException>TestException[]Constructor<TestException>? super TestExceptionClass<? super TestException>TypeVariable<Class<TestException>>TypeVariable<Class<TestException>>[]ThrowableAssertAlternative<TestException>AbstractAssert<ThrowableAssertAlternative<TestException>,TestException>Assert<ThrowableAssertAlternative<TestException>,TestException>Descriptable<ThrowableAssertAlternative<TestException>>ExtensionPoints<ThrowableAssertAlternative<TestException>,TestException>Condition<? super TestException>Descriptable<Condition<? super TestException>>Comparator<? super TestException>Function<? super TestException,? extends T>Consumer<TestException>Predicate<? super TestException>AbstractAssert<ThrowableAssertAlternative<TestException>,TestException>(org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests.TestException,java.lang.Class)ThrowableAssertAlternative<TestException>(org.springframework.aop.aspectj.TrickyAspectJPointcutExpressionTests.TestException)ThrowableTypeAssert<TestException>Descriptable<ThrowableTypeAssert<TestException>>? extends TestExceptionClass<? extends TestException>ThrowableTypeAssert<TestException>(java.lang.Class)stringcountThrowsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TrickyAspectJPointcutExpressionTests$LogUserAdvice.classTrickyAspectJPointcutExpressionTests$LogUserAdvicecountBefore Test with default class loader first... Then try again with a different class loader on the target... Make sure the interface is loaded from the  parent class loaderCreate a new SimpleThrowawayClassLoader for the given class loader.the ClassLoader to build a throwaway ClassLoader forC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TypePatternClassFilterTests.javaTypePatternClassFilterTeststestToStringtestToString()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/TypePatternClassFilterTests.classtestHashCodetestHashCode()testEqualstestEquals()andOrNotReplacementandOrNotReplacement()subclassMatchingsubclassMatching()validPatternMatchingvalidPatternMatching()invocationOfMatchesMethodBlowsUpWhenNoTypePatternHasBeenSetinvocationOfMatchesMethodBlowsUpWhenNoTypePatternHasBeenSet()invalidPatterninvalidPattern()nullPatternnullPattern()TypePatternClassFilterTests()"-"-tpcf"org.springframework.beans.testfixture.beans.*"org.springframework.beans.testfixture.beans.*"Must match: in package"Must match: in packageClass<IOther>"Must be excluded: in wrong package"Must be excluded: in wrong packageClass<BeanFactory>Class<DefaultListableBeanFactory>"org.springframework.beans.testfixture.beans.ITestBean+"org.springframework.beans.testfixture.beans.ITestBean+Class<CountingTestBean>"Must be excluded: not subclass"Must be excluded: not subclass"java.lang.Object or java.lang.String"java.lang.Object or java.lang.String"matches Number"matches Number"matches Object"matches Object"matchesString"matchesString"java.lang.Number+ and java.lang.Float"java.lang.Number+ and java.lang.FloatClass<Float>"matches Float"matches FloatClass<Double>"matches Double"matches Double"java.lang.Number+ and not java.lang.Float"java.lang.Number+ and not java.lang.Floatfilter1filter2filter3"org.springframework.tests.*"org.springframework.tests.*ObjectAssert<TypePatternClassFilter>AbstractObjectAssert<ObjectAssert<TypePatternClassFilter>,TypePatternClassFilter>AbstractAssert<ObjectAssert<TypePatternClassFilter>,TypePatternClassFilter>Assert<ObjectAssert<TypePatternClassFilter>,TypePatternClassFilter>Descriptable<ObjectAssert<TypePatternClassFilter>>ExtensionPoints<ObjectAssert<TypePatternClassFilter>,TypePatternClassFilter>? super TypePatternClassFilterCondition<? super TypePatternClassFilter>Descriptable<Condition<? super TypePatternClassFilter>>Comparator<? super TypePatternClassFilter>Function<? super TypePatternClassFilter,? extends T>Consumer<TypePatternClassFilter>Predicate<? super TypePatternClassFilter>AbstractAssert<ObjectAssert<TypePatternClassFilter>,TypePatternClassFilter>(org.springframework.aop.aspectj.TypePatternClassFilter,java.lang.Class)"org.springframework.aop.aspectj.TypePatternClassFilter: org.springframework.beans.testfixture.beans.*"org.springframework.aop.aspectj.TypePatternClassFilter: org.springframework.beans.testfixture.beans.*Unit tests for the {@link TypePatternClassFilter} class.Rick EvansC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests.javaAbstractAspectJAdvisorFactoryTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotationdeclarePrecedenceNotSupporteddeclarePrecedenceNotSupported()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests.classfailureWithoutExplicitDeclarePrecedencefailureWithoutExplicitDeclarePrecedence()afterAdviceTypesafterAdviceTypes()twoAdvicesOnOneAspecttwoAdvicesOnOneAspect()aspectMethodThrowsExceptionIllegalOnSignatureaspectMethodThrowsExceptionIllegalOnSignature()aspectMethodThrowsExceptionLegalOnSignatureaspectMethodThrowsExceptionLegalOnSignature()introductionWithArgumentBindingintroductionWithArgumentBinding()introductionBasedOnAnnotationMatch_SPR5307introductionBasedOnAnnotationMatch_SPR5307()introductionOnTargetExcludedByTypePatternintroductionOnTargetExcludedByTypePattern()introductionOnTargetImplementingInterfaceintroductionOnTargetImplementingInterface()introductionAdvisorExcludedFromTargetImplementingInterfaceintroductionAdvisorExcludedFromTargetImplementingInterface()introductionOnTargetNotImplementingInterfaceintroductionOnTargetNotImplementingInterface()bindingWithMultipleArgsDifferentlyOrderedbindingWithMultipleArgsDifferentlyOrdered()bindingWithSingleArgbindingWithSingleArg()namedPointcutsnamedPointcuts(java.lang.Object)namedPointcutFromAspectLibraryWithBindingnamedPointcutFromAspectLibraryWithBinding()namedPointcutFromAspectLibrarynamedPointcutFromAspectLibrary()namedPointcutAspectWithoutFQNnamedPointcutAspectWithoutFQN()namedPointcutAspectWithFQNnamedPointcutAspectWithFQN()perTypeWithinAspectperTypeWithinAspect()perThisAspectperThisAspect()multiplePerTargetAspectsWithOrderAnnotationmultiplePerTargetAspectsWithOrderAnnotation()multiplePerTargetAspectsmultiplePerTargetAspects()perTargetAspectperTargetAspect()rejectsPerCflowBelowAspectrejectsPerCflowBelowAspect()rejectsPerCflowAspectrejectsPerCflowAspect()AbstractAspectJAdvisorFactoryTests()ThrowableAssertAlternative<AopConfigException>AbstractAssert<ThrowableAssertAlternative<AopConfigException>,AopConfigException>Assert<ThrowableAssertAlternative<AopConfigException>,AopConfigException>Descriptable<ThrowableAssertAlternative<AopConfigException>>ExtensionPoints<ThrowableAssertAlternative<AopConfigException>,AopConfigException>? super AopConfigExceptionCondition<? super AopConfigException>Descriptable<Condition<? super AopConfigException>>Comparator<? super AopConfigException>Function<? super AopConfigException,? extends T>Consumer<AopConfigException>Predicate<? super AopConfigException>AbstractAssert<ThrowableAssertAlternative<AopConfigException>,AopConfigException>(org.springframework.aop.framework.AopConfigException,java.lang.Class)ThrowableAssertAlternative<AopConfigException>(org.springframework.aop.framework.AopConfigException)ThrowableTypeAssert<AopConfigException>Descriptable<ThrowableTypeAssert<AopConfigException>>? extends AopConfigExceptionClass<? extends AopConfigException>ThrowableTypeAssert<AopConfigException>(java.lang.Class)Class<AopConfigException>"someBean"someBean"PERCFLOW"PERCFLOW"PERCFLOWBELOW"PERCFLOWBELOWrealAge65siaimapa"Around advice must NOT apply"Around advice must NOT apply"getSpouse"getSpouseObjectAssert<Pointcut>AbstractObjectAssert<ObjectAssert<Pointcut>,Pointcut>AbstractAssert<ObjectAssert<Pointcut>,Pointcut>Assert<ObjectAssert<Pointcut>,Pointcut>Descriptable<ObjectAssert<Pointcut>>ExtensionPoints<ObjectAssert<Pointcut>,Pointcut>Condition<? super Pointcut>Descriptable<Condition<? super Pointcut>>Comparator<? super Pointcut>Function<? super Pointcut,? extends T>Consumer<Pointcut>Predicate<? super Pointcut>AbstractAssert<ObjectAssert<Pointcut>,Pointcut>(org.springframework.aop.Pointcut,java.lang.Class)"Around advice must apply"Around advice must applyaspect1aspect210"someBean1"someBean1"someBean2"someBean2itb2"No method calls"No method calls"Around advice must now apply"Around advice must now apply"Around advice must still apply"Around advice must still apply"Around advice be independent for second instance"Around advice be independent for second instance20mvaClass<ManyValuedArgs>12cd"d""stringbuf"stringbufexpectedResultnotLockableTargetnotLockable1Class<NotLockable>lockablenotLockable2TargetnotLockable2lockable2Class<CannotBeUnlocked>ObjectAssert<Lockable>AbstractObjectAssert<ObjectAssert<Lockable>,Lockable>AbstractAssert<ObjectAssert<Lockable>,Lockable>Assert<ObjectAssert<Lockable>,Lockable>Descriptable<ObjectAssert<Lockable>>ExtensionPoints<ObjectAssert<Lockable>,Lockable>? super LockableCondition<? super Lockable>Descriptable<Condition<? super Lockable>>Comparator<? super Lockable>Function<? super Lockable,? extends T>Consumer<Lockable>Predicate<? super Lockable>AbstractAssert<ObjectAssert<Lockable>,Lockable>(test.aop.Lockable,java.lang.Class)Class<Lockable>"Already locked"Already locked"Real target ignores locking"Real target ignores locking"Type pattern must have excluded mixin"Type pattern must have excluded mixinClass<AnnotatedTarget>modifiableoldAgeObjectAssert<Modifiable>AbstractObjectAssert<ObjectAssert<Modifiable>,Modifiable>AbstractAssert<ObjectAssert<Modifiable>,Modifiable>Assert<ObjectAssert<Modifiable>,Modifiable>Descriptable<ObjectAssert<Modifiable>>ExtensionPoints<ObjectAssert<Modifiable>,Modifiable>? super ModifiableCondition<? super Modifiable>Descriptable<Condition<? super Modifiable>>Comparator<? super Modifiable>Function<? super Modifiable,? extends T>Consumer<Modifiable>Predicate<? super Modifiable>AbstractAssert<ObjectAssert<Modifiable>,Modifiable>(org.springframework.aop.aspectj.annotation.Modifiable,java.lang.Class)Class<Modifiable>"Setting same value does not modify"Setting same value does not modify"And now for something completely different"And now for something completely different"Should be locked"Should be locked"Else"Else"Tony"TonyexpectedException"One advice method was found"One advice method was foundThrowableAssertAlternative<UndeclaredThrowableException>AbstractAssert<ThrowableAssertAlternative<UndeclaredThrowableException>,UndeclaredThrowableException>Assert<ThrowableAssertAlternative<UndeclaredThrowableException>,UndeclaredThrowableException>Descriptable<ThrowableAssertAlternative<UndeclaredThrowableException>>ExtensionPoints<ThrowableAssertAlternative<UndeclaredThrowableException>,UndeclaredThrowableException>? super UndeclaredThrowableExceptionCondition<? super UndeclaredThrowableException>Descriptable<Condition<? super UndeclaredThrowableException>>Comparator<? super UndeclaredThrowableException>Function<? super UndeclaredThrowableException,? extends T>Consumer<UndeclaredThrowableException>Predicate<? super UndeclaredThrowableException>AbstractAssert<ThrowableAssertAlternative<UndeclaredThrowableException>,UndeclaredThrowableException>(java.lang.reflect.UndeclaredThrowableException,java.lang.Class)ThrowableAssertAlternative<UndeclaredThrowableException>(java.lang.reflect.UndeclaredThrowableException)ThrowableTypeAssert<UndeclaredThrowableException>Descriptable<ThrowableTypeAssert<UndeclaredThrowableException>>? extends UndeclaredThrowableExceptionClass<? extends UndeclaredThrowableException>ThrowableTypeAssert<UndeclaredThrowableException>(java.lang.Class)Class<UndeclaredThrowableException>twoAdviceAspect"Two advice methods found"Two advice methods found"exceptionHandlingAspect"exceptionHandlingAspectClass<Echo>ThrowableAssertAlternative<FileNotFoundException>AbstractAssert<ThrowableAssertAlternative<FileNotFoundException>,FileNotFoundException>Assert<ThrowableAssertAlternative<FileNotFoundException>,FileNotFoundException>Descriptable<ThrowableAssertAlternative<FileNotFoundException>>ExtensionPoints<ThrowableAssertAlternative<FileNotFoundException>,FileNotFoundException>ThrowableTypeAssert<FileNotFoundException>Descriptable<ThrowableTypeAssert<FileNotFoundException>>? extends FileNotFoundExceptionClass<? extends FileNotFoundException>ThrowableTypeAssert<FileNotFoundException>(java.lang.Class)Class<FileNotFoundException>PerCflowAspectPerCflowAspect()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$PerCflowAspect.classAbstractAspectJAdvisorFactoryTests$PerCflowAspect"percflow(execution(* *(..)))"percflow(execution(* *(..)))PerCflowBelowAspectPerCflowBelowAspect()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$PerCflowBelowAspect.classAbstractAspectJAdvisorFactoryTests$PerCflowBelowAspect"percflowbelow(execution(* *(..)))"percflowbelow(execution(* *(..)))countSettercountSetter()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$PerTargetAspectWithOrderAnnotation10.classAbstractAspectJAdvisorFactoryTests$PerTargetAspectWithOrderAnnotation10"execution(void *.set*(int))"execution(void *.set*(int))returnCountAsAgereturnCountAsAge()"execution(int *.getAge())"execution(int *.getAge())PerTargetAspectWithOrderAnnotation10PerTargetAspectWithOrderAnnotation10()"pertarget(execution(* *.getSpouse()))"pertarget(execution(* *.getSpouse()))C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$PerTargetAspectWithOrderAnnotation5.classAbstractAspectJAdvisorFactoryTests$PerTargetAspectWithOrderAnnotation5PerTargetAspectWithOrderAnnotation5PerTargetAspectWithOrderAnnotation5()countAnythingVoidcountAnythingVoid()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$PerTypeWithinAspect.classAbstractAspectJAdvisorFactoryTests$PerTypeWithinAspect"execution(void *.*(..))"execution(void *.*(..))PerTypeWithinAspectPerTypeWithinAspect()"pertypewithin(org.springframework.beans.testfixture.beans.IOther+)"pertypewithin(org.springframework.beans.testfixture.beans.IOther+)getInstantiationCountgetInstantiationCount()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$PerTypeWithinAspectInstanceFactory.classAbstractAspectJAdvisorFactoryTests$PerTypeWithinAspectInstanceFactoryPerTypeWithinAspectInstanceFactoryPerTypeWithinAspectInstanceFactory()Class<PerTypeWithinAspect>Map<String,PerTypeWithinAspect>PerTypeWithinAspect[]Constructor<PerTypeWithinAspect>? super PerTypeWithinAspectClass<? super PerTypeWithinAspect>TypeVariable<Class<PerTypeWithinAspect>>TypeVariable<Class<PerTypeWithinAspect>>[]"perTypeWithin"perTypeWithinchangeReturnValuechangeReturnValue(org.aspectj.lang.ProceedingJoinPoint)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$NamedPointcutAspectWithFQN.classAbstractAspectJAdvisorFactoryTests$NamedPointcutAspectWithFQN"org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.NamedPointcutAspectWithFQN.getAge()"org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.NamedPointcutAspectWithFQN.getAge()getAge()"execution(* getAge())"execution(* getAge())fieldThatShouldBeIgnoredBySpringAtAspectJProcessingNamedPointcutAspectWithFQNNamedPointcutAspectWithFQN()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$NamedPointcutAspectWithoutFQN.classAbstractAspectJAdvisorFactoryTests$NamedPointcutAspectWithoutFQN"getAge()"NamedPointcutAspectWithoutFQNNamedPointcutAspectWithoutFQN()doubleArgdoubleArg(org.aspectj.lang.ProceedingJoinPoint,int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$NamedPointcutAspectFromLibrary.classAbstractAspectJAdvisorFactoryTests$NamedPointcutAspectFromLibrary"org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.Library.integerArgOperation(x)"org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.Library.integerArgOperation(x)changeReturnTypechangeReturnType(org.aspectj.lang.ProceedingJoinPoint)"org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.Library.propertyAccess()"org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactoryTests.Library.propertyAccess()NamedPointcutAspectFromLibraryNamedPointcutAspectFromLibrary()integerArgOperationintegerArgOperation(int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$Library.classAbstractAspectJAdvisorFactoryTests$Library"execution(* *(..)) && args(i)"execution(* *(..)) && args(i)propertyAccesspropertyAccess()"execution(!void get*())"execution(!void get*())LibraryLibrary()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$NamedPointcutAspectFromLibraryWithBinding.classAbstractAspectJAdvisorFactoryTests$NamedPointcutAspectFromLibraryWithBindingNamedPointcutAspectFromLibraryWithBindingNamedPointcutAspectFromLibraryWithBinding()changeReturnType(org.aspectj.lang.ProceedingJoinPoint,int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$BindingAspectWithSingleArg.classAbstractAspectJAdvisorFactoryTests$BindingAspectWithSingleArg"setAge(age)"setAge(age)"age"setAge(int)"args(a)"args(a)BindingAspectWithSingleArgBindingAspectWithSingleArg()reverseAdvicereverseAdvice(org.aspectj.lang.ProceedingJoinPoint,int,int,java.lang.String,java.lang.StringBuffer,java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$ManyValuedArgs.classAbstractAspectJAdvisorFactoryTests$ManyValuedArgs"execution(String mungeArgs(..)) && args(a, b, c, d, e)"execution(String mungeArgs(..)) && args(a, b, c, d, e)"b,c,d,e,a"b,c,d,e,amungeArgsmungeArgs(java.lang.String,int,int,java.lang.String,java.lang.StringBuffer)ManyValuedArgsManyValuedArgs()throwExceptionthrowException()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$ExceptionThrowingAspect.classAbstractAspectJAdvisorFactoryTests$ExceptionThrowingAspectExceptionThrowingAspectExceptionThrowingAspect(java.lang.Exception)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$Echo.classAbstractAspectJAdvisorFactoryTests$EchoC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$InvocationTrackingAspect.classAbstractAspectJAdvisorFactoryTests$InvocationTrackingAspectpreventExecutionpreventExecution(org.aspectj.lang.ProceedingJoinPoint)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$NoDeclarePrecedenceShouldFail.classAbstractAspectJAdvisorFactoryTests$NoDeclarePrecedenceShouldFailblowUpButDoesntMatterBecauseAroundAdviceWontLetThisBeInvokedblowUpButDoesntMatterBecauseAroundAdviceWontLetThisBeInvoked()NoDeclarePrecedenceShouldFailNoDeclarePrecedenceShouldFail()666C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactoryTests$DeclarePrecedenceShouldSucceed.classAbstractAspectJAdvisorFactoryTests$DeclarePrecedenceShouldSucceedDeclarePrecedenceShouldSucceedDeclarePrecedenceShouldSucceed()"test..*"test..*getGetterFromSettergetGetterFromSetter(java.lang.reflect.Method)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractMakeModifiable.classAbstractMakeModifiablerecordModificationIfSetterArgumentDiffersFromOldValuerecordModificationIfSetterArgumentDiffersFromOldValue(org.aspectj.lang.JoinPoint,org.springframework.aop.aspectj.annotation.AbstractMakeModifiable.MutableModifiable,java.lang.Object)"execution(void set*(*)) && this(modifiable) && args(newValue)"execution(void set*(*)) && this(modifiable) && args(newValue)"modifiable,newValue"modifiable,newValueAbstractMakeModifiable()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AbstractMakeModifiable$ModifiableImpl.classAbstractMakeModifiable$ModifiableImplModifiableImplModifiableImpl()mixinnewValuecorrespondingGetteroldValuesettergetterNameC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/MakeITestBeanModifiable.classMakeITestBeanModifiableMakeITestBeanModifiable()Class<ModifiableImpl>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/MakeAnnotatedTypeModifiable.classMakeAnnotatedTypeModifiable"(@org.springframework.aop.aspectj.annotation.Measured *)"(@org.springframework.aop.aspectj.annotation.Measured *)MakeAnnotatedTypeModifiable()Class<DefaultLockable>checkNotLockedcheckNotLocked(test.aop.Lockable)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/MakeLockable.classMakeLockable"execution(void set*(*)) && this(mixin)"execution(void set*(*)) && this(mixin)"mixin""org.springframework..*"org.springframework..*MakeLockable()CannotBeUnlockedCannotBeUnlocked()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/CannotBeUnlocked.classComparable<Object>AnnotatedTargetImplAnnotatedTargetImpl()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AnnotatedTargetImpl.classsetIntValuesetIntValue(int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/NotLockable.classNotLockablegetIntValuegetIntValue()intValueNotLockable()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/PerThisAspect.classPerThisAspectPerThisAspect()"perthis(execution(* *.getSpouse()))"perthis(execution(* *.getSpouse()))Abstract tests for {@link AspectJAdvisorFactory} implementations.<p>See subclasses for tests of concrete factories.To be overridden by concrete test subclasses.the fixture Check that the perclause pointcut is valid Hit the method in the per clause to instantiate the aspect Will be ExposeInvocationInterceptor, synthetic instantiation advisor, 2 method advisorsIn this case the introduction will be made. Ensure that we exclude TODO: Why does this test fail? It hasn't been run before, so it maybe never actually passed... TODO document this behaviour. Is it different AspectJ behaviour, at least for checked exceptions? Required everywhere we use AspectJ proxies @ArgNames({"age"})	// AMC needs more work here? ignoring pjp arg... ok?? argNames should be supported in Around as it is in PointcutAdd a DeclareParents field in concrete subclasses, to identifythe type pattern to apply the introduction to.We use the mixin to check and, if necessary, change,modification status. We need the JoinPoint to get thesetter method. We use newValue for comparison.We try to invoke the getter if possible. Already changed, don't need to change againSystem.out.println("changed"); Find the current raw value, by invoking the corresponding setterSystem.out.println("Old value=" + oldValue + "; new=" + newValue); Don't sweat on exceptions; assume value was modifiedSystem.out.println("cannot get getter for " + jp); must be write onlyAdds a declare parents pointcut.Adds a declare parents pointcut - spr5307Andy ClementDemonstrates introductions, AspectJ annotation style. Can also obtain the mixin (this) this wayLockable mixin = (Lockable) jp.getThis();Used as a mixin.Used as a target. Just to check that this doesn't cause problems with introduction processingC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/ArgumentBindingTests.javaArgumentBindingTestsproxiedTestBeanClass<NamedPointcutWithArgs>"Supercalifragalisticexpialidocious"SupercalifragalisticexpialidociousClass<PointcutWithAnnotationArgument>"somepc(formal) && set(* *)"somepc(formal) && set(* *)methodUsedForParameterTypeDiscovery? extends ArgumentBindingTestsClass<? extends ArgumentBindingTests>Map<String,? extends ArgumentBindingTests>ArgumentBindingTests[]? extends ArgumentBindingTests[]Constructor<? extends ArgumentBindingTests>? super ? extends ArgumentBindingTestsClass<? super ? extends ArgumentBindingTests>TypeVariable<Class<? extends ArgumentBindingTests>>TypeVariable<Class<? extends ArgumentBindingTests>>[]"methodWithOneParam"methodWithOneParampnames"one parameter name"one parameter name"formal"formalaParamPointcutWithAnnotationArgumentPointcutWithAnnotationArgument()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/PointcutWithAnnotationArgument.class"execution(* org.springframework..*.*(..)) && @annotation(transaction)"execution(* org.springframework..*.*(..)) && @annotation(transaction)"Invoked with transaction "Invoked with transaction NamedPointcutWithArgsNamedPointcutWithArgs()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/NamedPointcutWithArgs.class"execution(* *(..)) && args(s,..)"execution(* *(..)) && args(s,..)"pointcutWithArgs(aString)"pointcutWithArgs(aString)aString"got '"got '"' at '"' at 'Represents Spring's Transactional annotation without actually introducing the dependencyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AspectJPointcutAdvisorTests.javaAspectJPointcutAdvisorTeststestIllegalInstantiationModeltestIllegalInstantiationModel(java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AspectJPointcutAdvisorTests.classafajpaClass<PerCflowAspect>Class<PerCflowBelowAspect>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AspectMetadataTests.javaAspectMetadataTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AspectMetadataTests.classsingletonAspectsingletonAspect()notAnAspectnotAnAspect()AspectMetadataTests()Class<ExceptionThrowingAspect>AbstractComparableAssert<?,PerClauseKind>AbstractObjectAssert<?,PerClauseKind>AbstractAssert<?,PerClauseKind>Assert<?,PerClauseKind>ExtensionPoints<?,PerClauseKind>ComparableAssert<?,PerClauseKind>? super PerClauseKindCondition<? super PerClauseKind>Descriptable<Condition<? super PerClauseKind>>Comparator<? super PerClauseKind>Function<? super PerClauseKind,? extends T>Consumer<PerClauseKind>Predicate<? super PerClauseKind>AbstractAssert<?,PerClauseKind>(org.aspectj.lang.reflect.PerClauseKind,java.lang.Class)Class<PerTargetAspect>"execution(* *.getSpouse())"execution(* *.getSpouse())Class<PerThisAspect>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AspectProxyFactoryTests.javaAspectProxyFactoryTestsClass<MultiplyReturnValue>"Multiplication did not occur"Multiplication did not occurbean1pf1pf2proxy1proxy2Class<LoggingAspectOnVarargs>MyInterface[]multipleserializedProxy24Class<LoggingAspectOnSetter>V[]C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AspectProxyFactoryTests$TestBean.classAspectProxyFactoryTests$TestBeanMyEnumMyEnum()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AspectProxyFactoryTests$MyEnum.classAspectProxyFactoryTests$MyEnumMyOtherEnumMyOtherEnum()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/AspectProxyFactoryTests$MyOtherEnum.classAspectProxyFactoryTests$MyOtherEnum"execution(* doWithVarargs(*))"execution(* doWithVarargs(*))"execution(* setAge(*))"execution(* setAge(*))C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/MultiplyReturnValue.classMultiplyReturnValueMultiplyReturnValue() SPR-13328C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactoryTests.javaReflectiveAspectJAdvisorFactoryTestsReflectiveAspectJAdvisorFactoryTests()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/annotation/ReflectiveAspectJAdvisorFactoryTests.classTests for {@link ReflectiveAspectJAdvisorFactory}.<p>Tests are inherited: we only set the test fixture here.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJNamespaceHandlerTests.javaAspectJNamespaceHandlerTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJNamespaceHandlerTests.classreaderEventListenersourceExtractorreaderreaderContext"Incorrect number of definitions registered"Incorrect number of definitions registered"Incorrect APC class"Incorrect APC classMap<String,AspectJAwareAdvisorAutoProxyCreator>AspectJAwareAdvisorAutoProxyCreator[]Constructor<AspectJAwareAdvisorAutoProxyCreator>? super AspectJAwareAdvisorAutoProxyCreatorClass<? super AspectJAwareAdvisorAutoProxyCreator>TypeVariable<Class<AspectJAwareAdvisorAutoProxyCreator>>TypeVariable<Class<AspectJAwareAdvisorAutoProxyCreator>>[]"Incorrect definition count"Incorrect definition count"APC class not switched"APC class not switchedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparatorTests.javaAspectJPrecedenceComparatorTestscreateSpringAOPBeforeAdvicecreateSpringAOPBeforeAdvice(int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparatorTests.classcreateSpringAOPAfterAdvicecreateSpringAOPAfterAdvice(int)createAspectJAdvicecreateAspectJAdvice(int,int,java.lang.String,org.springframework.aop.aspectj.AbstractAspectJAdvice)createAspectJAfterThrowingAdvicecreateAspectJAfterThrowingAdvice(int,int,java.lang.String)createAspectJAfterReturningAdvicecreateAspectJAfterReturningAdvice(int,int,java.lang.String)createAspectJAfterAdvicecreateAspectJAfterAdvice(int,int,java.lang.String)createAspectJAroundAdvicecreateAspectJAroundAdvice(int,int,java.lang.String)createAspectJBeforeAdvicecreateAspectJBeforeAdvice(int,int,java.lang.String)anyOldPointcutanyOldMethodLATE_ADVICE_DECLARATION_ORDEREARLY_ADVICE_DECLARATION_ORDERLOW_PRECEDENCE_ADVISOR_ORDERHIGH_PRECEDENCE_ADVISOR_ORDER200? extends AspectJPrecedenceComparatorTestsClass<? extends AspectJPrecedenceComparatorTests>Map<String,? extends AspectJPrecedenceComparatorTests>AspectJPrecedenceComparatorTests[]? extends AspectJPrecedenceComparatorTests[]Constructor<? extends AspectJPrecedenceComparatorTests>? super ? extends AspectJPrecedenceComparatorTestsClass<? super ? extends AspectJPrecedenceComparatorTests>TypeVariable<Class<? extends AspectJPrecedenceComparatorTests>>TypeVariable<Class<? extends AspectJPrecedenceComparatorTests>>[]"someAspect"someAspect"advisor1 sorted before advisor2"advisor1 sorted before advisor2"advisor2 sorted before advisor1"advisor2 sorted before advisor1"advisor1 and advisor2 not comparable"advisor1 and advisor2 not comparable"someOtherAspect"someOtherAspect"nothing to say about order here"nothing to say about order here"advisor2 sorted after advisor1"advisor2 sorted after advisor1"advisor1 sorted after advisor2"advisor1 sorted after advisor2advisorOrderadviceDeclarationOrderafterReturning(java.lang.Object,java.lang.reflect.Method,java.lang.Object[],java.lang.Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/aspectj/autoproxy/AspectJPrecedenceComparatorTests$1.classAspectJPrecedenceComparatorTests$1C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/config/AopNamespaceHandlerEventTests.javaAopNamespaceHandlerEventTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/configqualifiedResourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/config/AopNamespaceHandlerEventTests.classeventListenerDIRECT_POINTCUT_EVENTS_CONTEXTPOINTCUT_REF_CONTEXTPOINTCUT_EVENTS_CONTEXTCONTEXTClass<AopNamespaceHandlerEventTests>"context.xml"context.xml"pointcutEvents.xml"pointcutEvents.xml"pointcutRefEvents.xml"pointcutRefEvents.xml"directPointcutEvents.xml"directPointcutEvents.xmlComponentDefinition[]componentDefinitionsnestedComponentDefspcd"Incorrect number of events fired"Incorrect number of events fired"No holder with nested components"No holder with nested components"aop:config"aop:config"Incorrect number of inner components"Incorrect number of inner componentscomponentDefinitionObjectAssert<PointcutComponentDefinition>AbstractObjectAssert<ObjectAssert<PointcutComponentDefinition>,PointcutComponentDefinition>AbstractAssert<ObjectAssert<PointcutComponentDefinition>,PointcutComponentDefinition>Assert<ObjectAssert<PointcutComponentDefinition>,PointcutComponentDefinition>Descriptable<ObjectAssert<PointcutComponentDefinition>>ExtensionPoints<ObjectAssert<PointcutComponentDefinition>,PointcutComponentDefinition>? super PointcutComponentDefinitionCondition<? super PointcutComponentDefinition>Descriptable<Condition<? super PointcutComponentDefinition>>Comparator<? super PointcutComponentDefinition>Function<? super PointcutComponentDefinition,? extends T>Consumer<PointcutComponentDefinition>Predicate<? super PointcutComponentDefinition>AbstractAssert<ObjectAssert<PointcutComponentDefinition>,PointcutComponentDefinition>(org.springframework.aop.config.PointcutComponentDefinition,java.lang.Class)Function<PointcutComponentDefinition,T>Function<? super PointcutComponentDefinition,T>Function<? super PointcutComponentDefinition,?>Function<? super PointcutComponentDefinition,?>[]AbstractObjectAssert<ObjectAssert<PointcutComponentDefinition>,PointcutComponentDefinition>(org.springframework.aop.config.PointcutComponentDefinition,java.lang.Class)"PointcutComponentDefinition not found"PointcutComponentDefinition not found"Incorrect number of BeanDefinitions"Incorrect number of BeanDefinitionsacdObjectAssert<AdvisorComponentDefinition>AbstractObjectAssert<ObjectAssert<AdvisorComponentDefinition>,AdvisorComponentDefinition>AbstractAssert<ObjectAssert<AdvisorComponentDefinition>,AdvisorComponentDefinition>Assert<ObjectAssert<AdvisorComponentDefinition>,AdvisorComponentDefinition>Descriptable<ObjectAssert<AdvisorComponentDefinition>>ExtensionPoints<ObjectAssert<AdvisorComponentDefinition>,AdvisorComponentDefinition>? super AdvisorComponentDefinitionCondition<? super AdvisorComponentDefinition>Descriptable<Condition<? super AdvisorComponentDefinition>>Comparator<? super AdvisorComponentDefinition>Function<? super AdvisorComponentDefinition,? extends T>Consumer<AdvisorComponentDefinition>Predicate<? super AdvisorComponentDefinition>AbstractAssert<ObjectAssert<AdvisorComponentDefinition>,AdvisorComponentDefinition>(org.springframework.aop.config.AdvisorComponentDefinition,java.lang.Class)Function<AdvisorComponentDefinition,T>Function<? super AdvisorComponentDefinition,T>Function<? super AdvisorComponentDefinition,?>Function<? super AdvisorComponentDefinition,?>[]AbstractObjectAssert<ObjectAssert<AdvisorComponentDefinition>,AdvisorComponentDefinition>(org.springframework.aop.config.AdvisorComponentDefinition,java.lang.Class)"AdvisorComponentDefinition not found"AdvisorComponentDefinition not found"No advice bean found"No advice bean foundexpectedReferencesnestedComponentDefs2ObjectAssert<AspectComponentDefinition>AbstractObjectAssert<ObjectAssert<AspectComponentDefinition>,AspectComponentDefinition>AbstractAssert<ObjectAssert<AspectComponentDefinition>,AspectComponentDefinition>Assert<ObjectAssert<AspectComponentDefinition>,AspectComponentDefinition>Descriptable<ObjectAssert<AspectComponentDefinition>>ExtensionPoints<ObjectAssert<AspectComponentDefinition>,AspectComponentDefinition>? super AspectComponentDefinitionCondition<? super AspectComponentDefinition>Descriptable<Condition<? super AspectComponentDefinition>>Comparator<? super AspectComponentDefinition>Function<? super AspectComponentDefinition,? extends T>Consumer<AspectComponentDefinition>Predicate<? super AspectComponentDefinition>AbstractAssert<ObjectAssert<AspectComponentDefinition>,AspectComponentDefinition>(org.springframework.aop.config.AspectComponentDefinition,java.lang.Class)Function<AspectComponentDefinition,T>Function<? super AspectComponentDefinition,T>Function<? super AspectComponentDefinition,?>Function<? super AspectComponentDefinition,?>[]AbstractObjectAssert<ObjectAssert<AspectComponentDefinition>,AspectComponentDefinition>(org.springframework.aop.config.AspectComponentDefinition,java.lang.Class)"AspectComponentDefinition not found"AspectComponentDefinition not found"pc"beanReference"Incorrect references found"Incorrect references found"Inner PointcutComponentDefinition not found"Inner PointcutComponentDefinition not foundC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/config/AopNamespaceHandlerPointcutErrorTests.javaAopNamespaceHandlerPointcutErrorTestsThrowableAssertAlternative<BeanDefinitionStoreException>AbstractAssert<ThrowableAssertAlternative<BeanDefinitionStoreException>,BeanDefinitionStoreException>Assert<ThrowableAssertAlternative<BeanDefinitionStoreException>,BeanDefinitionStoreException>Descriptable<ThrowableAssertAlternative<BeanDefinitionStoreException>>ExtensionPoints<ThrowableAssertAlternative<BeanDefinitionStoreException>,BeanDefinitionStoreException>Consumer<BeanDefinitionStoreException>? super BeanDefinitionStoreExceptionCondition<? super BeanDefinitionStoreException>Descriptable<Condition<? super BeanDefinitionStoreException>>Comparator<? super BeanDefinitionStoreException>Function<? super BeanDefinitionStoreException,? extends T>Predicate<? super BeanDefinitionStoreException>AbstractAssert<ThrowableAssertAlternative<BeanDefinitionStoreException>,BeanDefinitionStoreException>(org.springframework.beans.factory.BeanDefinitionStoreException,java.lang.Class)ThrowableTypeAssert<BeanDefinitionStoreException>Descriptable<ThrowableTypeAssert<BeanDefinitionStoreException>>? extends BeanDefinitionStoreExceptionClass<? extends BeanDefinitionStoreException>ThrowableTypeAssert<BeanDefinitionStoreException>(java.lang.Class)Class<BeanDefinitionStoreException>? extends AopNamespaceHandlerPointcutErrorTestsClass<? extends AopNamespaceHandlerPointcutErrorTests>"pointcutDuplication.xml"pointcutDuplication.xmlConsumer<? super BeanDefinitionStoreException>accept(org.springframework.beans.factory.BeanDefinitionStoreException)Class<BeanDefinitionParsingException>"pointcutMissing.xml"pointcutMissing.xmlC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/config/TopLevelAopTagTests.javaTopLevelAopTagTestsClass<TopLevelAopTagTests>"testPointcut"testPointcutTests that the &lt;aop:config/&gt; element can be used as a top level element.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/AopProxyUtilsTests.javaAopProxyUtilsTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/frameworkcompletedInterfacesifacesClass<Comparable<>>? extends AopProxyUtilsTestsClass<? extends AopProxyUtilsTests>Map<String,? extends AopProxyUtilsTests>AopProxyUtilsTests[]? extends AopProxyUtilsTests[]Constructor<? extends AopProxyUtilsTests>? super ? extends AopProxyUtilsTestsClass<? super ? extends AopProxyUtilsTests>TypeVariable<Class<? extends AopProxyUtilsTests>>TypeVariable<Class<? extends AopProxyUtilsTests>>[]invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object[]) Can't assume ordering for others, so use a listC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/ClassWithConstructor.javaClassWithConstructorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/IntroductionBenchmarkTests.javaIntroductionBenchmarkTestsINVOCATIONSC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/IntroductionBenchmarkTests.classEXPECTED_COMPARE100000sw" invocations on proxy, not hitting introduction" invocations on proxy, not hitting introduction" invocations on proxy, hitting introduction" invocations on proxy, hitting introduction" invocations on target" invocations on targetBenchmarks for introductions.NOTE: No assertions!Increase this if you want meaningful results!C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/MethodInvocationTests.javaMethodInvocationTeststestToStringDoesntHitTargettestToStringDoesntHitTarget()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/MethodInvocationTests.classtestValidInvocationtestValidInvocation()MethodInvocationTests()Constructor<Object>Class<? super Object>TypeVariable<Class<Object>>TypeVariable<Class<Object>>[]"hashCode"invoke(org.aopalliance.intercept.MethodInvocation)rvFunction<Object,T>Function<? super Object,T>Function<? super Object,?>Function<? super Object,?>[]AbstractObjectAssert<ObjectAssert<Object>,Object>(java.lang.Object,java.lang.Class)"correct response"correct responseC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/MethodInvocationTests$1.classMethodInvocationTests$1"toString"toString on target can cause failure. If it hits target, the test will fail with the UnsupportedOpException in the inner class above.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/NullPrimitiveTests.javaNullPrimitiveTestsSimpleFooC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/NullPrimitiveTests$1SimpleFoo.classNullPrimitiveTests$1SimpleFoogetValuegetValue()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/NullPrimitiveTests.classSimpleFoo()ThrowableAssertAlternative<AopInvocationException>AbstractAssert<ThrowableAssertAlternative<AopInvocationException>,AopInvocationException>Assert<ThrowableAssertAlternative<AopInvocationException>,AopInvocationException>Descriptable<ThrowableAssertAlternative<AopInvocationException>>ExtensionPoints<ThrowableAssertAlternative<AopInvocationException>,AopInvocationException>? super AopInvocationExceptionCondition<? super AopInvocationException>Descriptable<Condition<? super AopInvocationException>>Comparator<? super AopInvocationException>Function<? super AopInvocationException,? extends T>Consumer<AopInvocationException>Predicate<? super AopInvocationException>AbstractAssert<ThrowableAssertAlternative<AopInvocationException>,AopInvocationException>(org.springframework.aop.AopInvocationException,java.lang.Class)ThrowableAssertAlternative<AopInvocationException>(org.springframework.aop.AopInvocationException)ThrowableTypeAssert<AopInvocationException>Descriptable<ThrowableTypeAssert<AopInvocationException>>? extends AopInvocationExceptionClass<? extends AopInvocationException>ThrowableTypeAssert<AopInvocationException>(java.lang.Class)Class<AopInvocationException>"Foo.getValue()"Foo.getValue()"Bar.getValue()"Bar.getValue()Test for SPR-4675. A null value returned from around advice is very hard to debug ifthe caller expects a primitive.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/PrototypeTargetTests.javaPrototypeTargetTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/PrototypeTargetTests.classClass<PrototypeTargetTests>"testInterceptor"testInterceptor"testBeanPrototype"testBeanPrototype"testBeanSingleton"testBeanSingletonconstructionCountC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/PrototypeTargetTests$TestBeanImpl.classPrototypeTargetTests$TestBeanImplC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/PrototypeTargetTests$TestInterceptor.classPrototypeTargetTests$TestInterceptor03.09.2004C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/ProxyFactoryTests.javaProxyFactoryTestsnopcbaproxiednop2cba1cba2ObjectAssert<Advisor>AbstractObjectAssert<ObjectAssert<Advisor>,Advisor>AbstractAssert<ObjectAssert<Advisor>,Advisor>Assert<ObjectAssert<Advisor>,Advisor>Descriptable<ObjectAssert<Advisor>>ExtensionPoints<ObjectAssert<Advisor>,Advisor>Condition<? super Advisor>Descriptable<Condition<? super Advisor>>Function<? super Advisor,? extends T>Consumer<Advisor>AbstractAssert<ObjectAssert<Advisor>,Advisor>(org.springframework.aop.Advisor,java.lang.Class)tstorg.springframework.core.testfixturegetTimeStampgetTimeStamp()"getTimeStamp"Class<TimeStamped>TestBeanSubclassC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/ProxyFactoryTests$1TestBeanSubclass.classProxyFactoryTests$1TestBeanSubclassC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/ProxyFactoryTests.classTestBeanSubclass()555555L555555tioldProxiedInterfacesnewProxiedInterfaces"compareTo""Found correct number of interfaces"Found correct number of interfacesFunction<ITestBean,T>Function<? super ITestBean,T>Function<? super ITestBean,?>Function<? super ITestBean,?>[]AbstractObjectAssert<ObjectAssert<ITestBean>,ITestBean>(org.springframework.beans.testfixture.beans.ITestBean,java.lang.Class)"Picked up secondary interface"Picked up secondary interface"Advisor proxies one more interface after introduction"Advisor proxies one more interface after introductiondidiUnusedMyInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/ProxyFactoryTests$1MyInterceptor.classProxyFactoryTests$1MyInterceptorMyInterceptor()Class<NopInterceptor>Class<MyInterceptor>time666LoldCountitdebugInterceptor"Shouldn't implement TimeStamped before manipulation"Shouldn't implement TimeStamped before manipulationThrowableAssertAlternative<RuntimeException>AbstractAssert<ThrowableAssertAlternative<RuntimeException>,RuntimeException>Assert<ThrowableAssertAlternative<RuntimeException>,RuntimeException>Descriptable<ThrowableAssertAlternative<RuntimeException>>ExtensionPoints<ThrowableAssertAlternative<RuntimeException>,RuntimeException>ThrowableTypeAssert<RuntimeException>Descriptable<ThrowableTypeAssert<RuntimeException>>? extends RuntimeExceptionClass<? extends RuntimeException>ThrowableTypeAssert<RuntimeException>(java.lang.Class)Class<RuntimeException>"Existing object won't implement this interface any more"Existing object won't implement this interface any more"Should no longer implement TimeStamped"Should no longer implement TimeStampedAbstractLongAssert<?>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.assertj/assertj-core/3.19.0/f64cb5690b85e68d5e1e6c6152bfb6e3840a452d/assertj-core-3.19.0.jar/org/assertj/core/api/AbstractLongAssert.classAbstractLongAssertAbstractComparableAssert<?,Long>AbstractObjectAssert<?,Long>AbstractAssert<?,Long>Assert<?,Long>ExtensionPoints<?,Long>ComparableAssert<?,Long>NumberAssert<?,Long>AbstractLongAssert<>? super LongCondition<? super Long>Descriptable<Condition<? super Long>>Comparator<? super Long>Function<? super Long,? extends T>Consumer<Long>Predicate<? super Long>AbstractAssert<?,Long>(java.lang.Long,java.lang.Class)Function<Long,T>Function<? super Long,T>Function<? super Long,?>Function<? super Long,?>[]AbstractObjectAssert<?,Long>(java.lang.Long,java.lang.Class)isStrictlyBetween(java.lang.Long,java.lang.Long)isBetween(java.lang.Long,java.lang.Long)isGreaterThanOrEqualTo(java.lang.Long)isGreaterThan(java.lang.Long)isLessThanOrEqualTo(java.lang.Long)isLessThan(java.lang.Long)isNotEqualByComparingTo(java.lang.Long)isEqualByComparingTo(java.lang.Long)AbstractComparableAssert<?,Long>(java.lang.Long,java.lang.Class)isNotCloseTo(java.lang.Long,org.assertj.core.data.Percentage)isCloseTo(java.lang.Long,org.assertj.core.data.Percentage)Offset<Long>isNotCloseTo(java.lang.Long,org.assertj.core.data.Offset)isCloseTo(java.lang.Long,org.assertj.core.data.Offset)isNotCloseTo(long,org.assertj.core.data.Percentage)isCloseTo(long,org.assertj.core.data.Percentage)isNotCloseTo(long,org.assertj.core.data.Offset)isCloseTo(long,org.assertj.core.data.Offset)isGreaterThanOrEqualTo(long)isGreaterThan(long)isLessThanOrEqualTo(long)isLessThan(long)isNotEqualTo(long)AbstractLongAssert(java.lang.Long,java.lang.Class)AbstractLongAssert<?>(java.lang.Long,java.lang.Class)longs"Proxy is a JDK proxy"Proxy is a JDK proxy"Proxy is a CGLIB proxy"Proxy is a CGLIB proxy"Not implemented yet, see https://jira.springframework.org/browse/SPR-5708"Not implemented yet, see https://jira.springframework.org/browse/SPR-5708frame"tb"Also tests AdvisedSupport and ProxyCreatorSupport superclasses.14.05.2003 Can use advised and ProxyFactory interchangeably Removes counting before advisor Removes Nop1 Check out of bounds Ok Use the type cast feature Replace etc methods on advised should be same as on ProxyFactory We've already implicitly added this interface. This call should be ignored without error All cool Extend to get new interfaceSystem.out.println("Proxied interfaces are " + StringUtils.arrayToDelimitedString(factory.getProxiedInterfaces(), ",")); Shouldn't fail;Should see effect immediately on behavior. Add to front of interceptor chain Can remove Existing reference will fail Now check non-effect of removing interceptor that isn't there not invoked againC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptorTests.javaThrowsAdviceInterceptorTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/adaptergiventhretClass<MethodInvocation>org.mockitoBDDMyOngoingStubbing<Object>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/3.7.0/ccd43add1a3973f828441e2f7179253c0d87dc92/mockito-core-3.7.0.jarmockito-core-3.7.0C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/3.7.0/ccd43add1a3973f828441e2f7179253c0d87dc92ccd43add1a3973f828441e2f7179253c0d87dc92C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/3.7.03.7.0C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-coremockito-coreC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockitoC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/3.7.0/ccd43add1a3973f828441e2f7179253c0d87dc92/mockito-core-3.7.0.jar/orgC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/3.7.0/ccd43add1a3973f828441e2f7179253c0d87dc92/mockito-core-3.7.0.jar/org/mockitomockitoC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/3.7.0/ccd43add1a3973f828441e2f7179253c0d87dc92/mockito-core-3.7.0.jar/org/mockito/BDDMockito$BDDMyOngoingStubbing.classBDDMockito$BDDMyOngoingStubbingBDDMyOngoingStubbing<>willReturnwillReturn(java.lang.Object)MgetMockgetMock()willCallRealMethodwillCallRealMethod()Class<? extends Throwable>[]willThrowwillThrow(java.lang.Class,java.lang.Class[])willThrow(java.lang.Class)willThrow(java.lang.Throwable[])willReturn(java.lang.Object,java.lang.Object[])org.mockito.stubbingAnswer<?>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/3.7.0/ccd43add1a3973f828441e2f7179253c0d87dc92/mockito-core-3.7.0.jar/org/mockito/stubbingstubbingC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.mockito/mockito-core/3.7.0/ccd43add1a3973f828441e2f7179253c0d87dc92/mockito-core-3.7.0.jar/org/mockito/stubbing/Answer.classAnswerwillwill(org.mockito.stubbing.Answer)willAnswerwillAnswer(org.mockito.stubbing.Answer)BDDMyOngoingStubbing<Method>willReturn(java.lang.reflect.Method)willReturn(java.lang.reflect.Method,java.lang.reflect.Method[])? super FileNotFoundExceptionCondition<? super FileNotFoundException>Descriptable<Condition<? super FileNotFoundException>>Comparator<? super FileNotFoundException>Function<? super FileNotFoundException,? extends T>Consumer<FileNotFoundException>Predicate<? super FileNotFoundException>AbstractAssert<ThrowableAssertAlternative<FileNotFoundException>,FileNotFoundException>(java.io.FileNotFoundException,java.lang.Class)"ioException"ioExceptionThrowableAssertAlternative<ConnectException>AbstractAssert<ThrowableAssertAlternative<ConnectException>,ConnectException>Assert<ThrowableAssertAlternative<ConnectException>,ConnectException>Descriptable<ThrowableAssertAlternative<ConnectException>>ExtensionPoints<ThrowableAssertAlternative<ConnectException>,ConnectException>? super ConnectExceptionCondition<? super ConnectException>Descriptable<Condition<? super ConnectException>>Comparator<? super ConnectException>Function<? super ConnectException,? extends T>Consumer<ConnectException>Predicate<? super ConnectException>AbstractAssert<ThrowableAssertAlternative<ConnectException>,ConnectException>(java.rmi.ConnectException,java.lang.Class)ThrowableTypeAssert<ConnectException>Descriptable<ThrowableTypeAssert<ConnectException>>? extends ConnectExceptionClass<? extends ConnectException>ThrowableTypeAssert<ConnectException>(java.lang.Class)Class<ConnectException>"remoteException"remoteExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptorTests.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/framework/adapter/ThrowsAdviceInterceptorTests$1.classThrowsAdviceInterceptorTests$1afterThrowing(java.rmi.RemoteException)ThrowableAssertAlternative<Throwable>AbstractAssert<ThrowableAssertAlternative<Throwable>,Throwable>Assert<ThrowableAssertAlternative<Throwable>,Throwable>Descriptable<ThrowableAssertAlternative<Throwable>>ExtensionPoints<ThrowableAssertAlternative<Throwable>,Throwable>Condition<? super Throwable>Descriptable<Condition<? super Throwable>>Comparator<? super Throwable>Consumer<Throwable>Predicate<? super Throwable>AbstractAssert<ThrowableAssertAlternative<Throwable>,Throwable>(java.lang.Throwable,java.lang.Class)ThrowableTypeAssert<Throwable>Descriptable<ThrowableTypeAssert<Throwable>>ThrowableTypeAssert<Throwable>(java.lang.Class) should require one handler method at least Extends RemoteExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/ConcurrencyThrottleInterceptorTests.javaConcurrencyThrottleInterceptorTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptortestMultipleThreadstestMultipleThreads(int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/ConcurrencyThrottleInterceptorTests.classClass<ConcurrencyThrottleInterceptorTests>1000ctiserializedCticoncurrencyLimitThread[]threadsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/ConcurrencyThrottleInterceptorTests$ConcurrencyThread.classConcurrencyThrottleInterceptorTests$ConcurrencyThread"Expected exception thrown"Expected exception thrown"finished"finished06.04.2004 should never happenC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/CustomizableTraceInterceptorTests.javaCustomizableTraceInterceptorTestsanyStringeqtimesverifylogClass<Log>BDDMyOngoingStubbing<Boolean>willReturn(java.lang.Boolean)Boolean[]willReturn(java.lang.Boolean,java.lang.Boolean[])BDDMyOngoingStubbing<Object[]>willReturn(java.lang.Object[])Object[][]willReturn(java.lang.Object[],java.lang.Object[][])"$ One \\$"$ One \$2L"Hello!"Hello!"Entering the '"Entering the '"' method of the ["' method of the ["] class with the following args ("] class with the following args (") and arg types (") and arg types (").")."Exiting the '"Exiting the '"), returning '"), returning '"' and taking '"' and taking '"' this long."' this long.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/CustomizableTraceInterceptorTests$StubCustomizableTraceInterceptor.classCustomizableTraceInterceptorTests$StubCustomizableTraceInterceptor Must not be able to set empty enter message Must not be able to set enter message with return value placeholder Must not be able to set enter message with exception placeholder Must not be able to set enter message with invocation time placeholder Must not be able to set empty exit message Must not be able to set exit message with exception placeholder Must not be able to set empty exception message Must not be able to set exception message with return value placeholderC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/DebugInterceptorTests.javaDebugInterceptorTestscheckCallCountTotalcheckCallCountTotal(org.springframework.aop.interceptor.DebugInterceptor)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/DebugInterceptorTests.class"Intercepted call count not being incremented correctly"Intercepted call count not being incremented correctlyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/DebugInterceptorTests$StubDebugInterceptor.classDebugInterceptorTests$StubDebugInterceptorUnit tests for the {@link DebugInterceptor} class.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposeBeanNameAdvisorsTests.javaExposeBeanNameAdvisorsTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposeBeanNameAdvisorsTests$RequiresBeanNameBoundTestBean.classExposeBeanNameAdvisorsTests$RequiresBeanNameBoundTestBean"No introduction"No introductionnb"Introduction was made"Introduction was made"Name returned correctly"Name returned correctly Requires bindingC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposeInvocationInterceptorTests.javaExposeInvocationInterceptorTests"proxy""tony"tonyClass<ExposeInvocationInterceptorTests>Non-XML tests are in AbstractAopProxyTests Fires context checksC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposedInvocationTestBean.javaExposedInvocationTestBeanExposedInvocationTestBean()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/ExposedInvocationTestBean.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/InvocationCheckExposedInvocationTestBean.javaInvocationCheckExposedInvocationTestBeanInvocationCheckExposedInvocationTestBean()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/InvocationCheckExposedInvocationTestBean.classMap<String,ITestBean>ITestBean[]Constructor<ITestBean>Class<? super ITestBean>TypeVariable<Class<ITestBean>>TypeVariable<Class<ITestBean>>[]"Invocation should be on ITestBean: "Invocation should be on ITestBean: C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/JamonPerformanceMonitorInterceptorTests.javaJamonPerformanceMonitorInterceptorTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/JamonPerformanceMonitorInterceptorTests.class"jamon must track the method being invoked"jamon must track the method being invoked"The jamon report must contain the toString method that was invoked"The jamon report must contain the toString method that was invoked"Monitors must exist for the method invocation and 2 exceptions"Monitors must exist for the method invocation and 2 exceptions"The jamon report must contain the generic exception: "The jamon report must contain the generic exception: "IllegalArgumentException""The jamon report must contain the specific exception: IllegalArgumentException'"The jamon report must contain the specific exception: IllegalArgumentException'C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/PerformanceMonitorInterceptorTests.javaPerformanceMonitorInterceptorTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/interceptor/SimpleTraceInterceptorTests.javaSimpleTraceInterceptorTestsUnit tests for the {@link SimpleTraceInterceptor} class.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/scope/DefaultScopedObjectTests.javaDefaultScopedObjectTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/scopetestBadTargetBeanNametestBadTargetBeanName(java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/scope/DefaultScopedObjectTests.classGOOD_BEAN_NAME"   "   badTargetBeanNameClass<ConfigurableBeanFactory>Unit tests for the {@link DefaultScopedObject} class.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/scope/ScopedProxyAutowireTests.javaScopedProxyAutowireTestsautowired"autowired"unscoped"unscoped"Class<ScopedProxyAutowireTests>"scopedAutowireFalse.xml"scopedAutowireFalse.xml"scoped"scopedObjectAssert<TestBean>AbstractObjectAssert<ObjectAssert<TestBean>,TestBean>AbstractAssert<ObjectAssert<TestBean>,TestBean>Assert<ObjectAssert<TestBean>,TestBean>Descriptable<ObjectAssert<TestBean>>ExtensionPoints<ObjectAssert<TestBean>,TestBean>Condition<? super TestBean>Descriptable<Condition<? super TestBean>>Comparator<? super TestBean>Function<? super TestBean,? extends T>Consumer<TestBean>Predicate<? super TestBean>AbstractAssert<ObjectAssert<TestBean>,TestBean>(org.springframework.aop.scope.ScopedProxyAutowireTests.TestBean,java.lang.Class)"scopedAutowireTrue.xml"scopedAutowireTrue.xmlC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/scope/ScopedProxyAutowireTests$TestBean.classScopedProxyAutowireTests$TestBeanTestBeanTestBean()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/scope/ScopedProxyUtilsTests.javaScopedProxyUtilsTestsgetOriginalBeanNameForNonScopedTargetgetOriginalBeanNameForNonScopedTarget()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/scope/ScopedProxyUtilsTests.classgetOriginalBeanNameForNullTargetBeangetOriginalBeanNameForNullTargetBean()getOriginalBeanNameAndIsScopedTargetgetOriginalBeanNameAndIsScopedTarget()getTargetBeanNameAndIsScopedTargetgetTargetBeanNameAndIsScopedTarget()ScopedProxyUtilsTests()"myBean"myBeanparsedOriginalBeanName? super IllegalArgumentExceptionCondition<? super IllegalArgumentException>Descriptable<Condition<? super IllegalArgumentException>>Comparator<? super IllegalArgumentException>Function<? super IllegalArgumentException,? extends T>Consumer<IllegalArgumentException>Predicate<? super IllegalArgumentException>AbstractAssert<ThrowableAssertAlternative<IllegalArgumentException>,IllegalArgumentException>(java.lang.IllegalArgumentException,java.lang.Class)ThrowableAssertAlternative<IllegalArgumentException>(java.lang.IllegalArgumentException)"bean name 'null' does not refer to the target of a scoped proxy"bean name 'null' does not refer to the target of a scoped proxy"bean name 'myBean' does not refer to the target of a scoped proxy"bean name 'myBean' does not refer to the target of a scoped proxyUnit tests for {@link ScopedProxyUtils}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/AbstractRegexpMethodPointcutTests.javaAbstractRegexpMethodPointcutTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/supportrpcC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/AbstractRegexpMethodPointcutTests.class"wait"wait"java.lang.Object.hashCode"java.lang.Object.hashCode"java.lang.String.hashCode"java.lang.String.hashCode".*Object.hashCode".*Object.hashCode"java.lang.Object.*"java.lang.Object.*Class<IOException>Map<String,Exception>Exception[]Constructor<Exception>Class<? super Exception>TypeVariable<Class<Exception>>TypeVariable<Class<Exception>>[]"getMessage"getMessage".*get.*".*get.*".*Age.*".*Age.*"getName" assumes rpc.setPattern("java.lang.Object.hashCode"); Doesn't match a method from ThrowableC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/AopUtilsTests.javaAopUtilsTestsnoTestPointcutC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/AopUtilsTests$1TestPointcut.classAopUtilsTests$1TestPointcutmatches(java.lang.reflect.Method,java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/AopUtilsTests.classTestPointcut()clazzyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/AopUtilsTests$2TestPointcut.classAopUtilsTests$2TestPointcutObjectAssert<MethodMatcher>AbstractObjectAssert<ObjectAssert<MethodMatcher>,MethodMatcher>AbstractAssert<ObjectAssert<MethodMatcher>,MethodMatcher>Assert<ObjectAssert<MethodMatcher>,MethodMatcher>Descriptable<ObjectAssert<MethodMatcher>>ExtensionPoints<ObjectAssert<MethodMatcher>,MethodMatcher>? super MethodMatcherCondition<? super MethodMatcher>Descriptable<Condition<? super MethodMatcher>>Comparator<? super MethodMatcher>Function<? super MethodMatcher,? extends T>Consumer<MethodMatcher>Predicate<? super MethodMatcher>AbstractAssert<ObjectAssert<MethodMatcher>,MethodMatcher>(org.springframework.aop.MethodMatcher,java.lang.Class)ObjectAssert<ClassFilter>AbstractObjectAssert<ObjectAssert<ClassFilter>,ClassFilter>AbstractAssert<ObjectAssert<ClassFilter>,ClassFilter>Assert<ObjectAssert<ClassFilter>,ClassFilter>Descriptable<ObjectAssert<ClassFilter>>ExtensionPoints<ObjectAssert<ClassFilter>,ClassFilter>? super ClassFilterCondition<? super ClassFilter>Descriptable<Condition<? super ClassFilter>>Comparator<? super ClassFilter>Function<? super ClassFilter,? extends T>Consumer<ClassFilter>Predicate<? super ClassFilter>AbstractAssert<ObjectAssert<ClassFilter>,ClassFilter>(org.springframework.aop.ClassFilter,java.lang.Class)ObjectAssert<EmptyTargetSource>AbstractObjectAssert<ObjectAssert<EmptyTargetSource>,EmptyTargetSource>AbstractAssert<ObjectAssert<EmptyTargetSource>,EmptyTargetSource>Assert<ObjectAssert<EmptyTargetSource>,EmptyTargetSource>Descriptable<ObjectAssert<EmptyTargetSource>>ExtensionPoints<ObjectAssert<EmptyTargetSource>,EmptyTargetSource>? super EmptyTargetSourceCondition<? super EmptyTargetSource>Descriptable<Condition<? super EmptyTargetSource>>Comparator<? super EmptyTargetSource>Function<? super EmptyTargetSource,? extends T>Consumer<EmptyTargetSource>Predicate<? super EmptyTargetSource>AbstractAssert<ObjectAssert<EmptyTargetSource>,EmptyTargetSource>(org.springframework.aop.target.EmptyTargetSource,java.lang.Class)ObjectAssert<ExposeInvocationInterceptor>AbstractObjectAssert<ObjectAssert<ExposeInvocationInterceptor>,ExposeInvocationInterceptor>AbstractAssert<ObjectAssert<ExposeInvocationInterceptor>,ExposeInvocationInterceptor>Assert<ObjectAssert<ExposeInvocationInterceptor>,ExposeInvocationInterceptor>Descriptable<ObjectAssert<ExposeInvocationInterceptor>>ExtensionPoints<ObjectAssert<ExposeInvocationInterceptor>,ExposeInvocationInterceptor>Condition<? super ExposeInvocationInterceptor>Descriptable<Condition<? super ExposeInvocationInterceptor>>Comparator<? super ExposeInvocationInterceptor>Function<? super ExposeInvocationInterceptor,? extends T>Consumer<ExposeInvocationInterceptor>Predicate<? super ExposeInvocationInterceptor>AbstractAssert<ObjectAssert<ExposeInvocationInterceptor>,ExposeInvocationInterceptor>(org.springframework.aop.interceptor.ExposeInvocationInterceptor,java.lang.Class) will return true if we're not proxying interfacesTest that when we serialize and deserialize various canonical instancesof AOP classes, they return the same instance, not a new instancethat's subverted the singleton construction limitation.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ClassFiltersTests.javaClassFiltersTestsintersectionintersection()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ClassFiltersTests.classunion()hasRootCauseFilterinterfaceFilterexceptionFilterClassFiltersTests()Class<NestedRuntimeException>"^.+UnionClassFilter: \\[.+RootClassFilter: .+Exception, .+RootClassFilter: .+TestBean\\]$"^.+UnionClassFilter: \[.+RootClassFilter: .+Exception, .+RootClassFilter: .+TestBean\]$"^.+IntersectionClassFilter: \\[.+RootClassFilter: .+Exception, .+RootClassFilter: .+NestedRuntimeException\\]$"^.+IntersectionClassFilter: \[.+RootClassFilter: .+Exception, .+RootClassFilter: .+NestedRuntimeException\]$Unit tests for {@link ClassFilters}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ClassUtilsTests.javaClassUtilsTests? extends TestBeanClass<? extends TestBean>"Class name did not match"Class name did not match"TestBean"Colin SampaleanuC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ComposablePointcutTests.javaComposablePointcutTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ComposablePointcutTests$1.classComposablePointcutTests$1C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ComposablePointcutTests.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ComposablePointcutTests$2.classComposablePointcutTests$2C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ComposablePointcutTests$3.classComposablePointcutTests$3C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ComposablePointcutTests$4.classComposablePointcutTests$4cfObjectAssert<ComposablePointcut>AbstractObjectAssert<ObjectAssert<ComposablePointcut>,ComposablePointcut>AbstractAssert<ObjectAssert<ComposablePointcut>,ComposablePointcut>Assert<ObjectAssert<ComposablePointcut>,ComposablePointcut>Descriptable<ObjectAssert<ComposablePointcut>>ExtensionPoints<ObjectAssert<ComposablePointcut>,ComposablePointcut>? super ComposablePointcutCondition<? super ComposablePointcut>Descriptable<Condition<? super ComposablePointcut>>Comparator<? super ComposablePointcut>Function<? super ComposablePointcut,? extends T>Consumer<ComposablePointcut>Predicate<? super ComposablePointcut>AbstractAssert<ObjectAssert<ComposablePointcut>,ComposablePointcut>(org.springframework.aop.support.ComposablePointcut,java.lang.Class) Matches the getAge() method in any class Should now match all getter methods Should now match absquatulate() as well But it doesn't match everything Use the Pointcuts matches methodC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ControlFlowPointcutTests.javaControlFlowPointcutTestscflowClass<One>settersUnderOneObjectAssert<ControlFlowPointcut>AbstractObjectAssert<ObjectAssert<ControlFlowPointcut>,ControlFlowPointcut>AbstractAssert<ObjectAssert<ControlFlowPointcut>,ControlFlowPointcut>Assert<ObjectAssert<ControlFlowPointcut>,ControlFlowPointcut>Descriptable<ObjectAssert<ControlFlowPointcut>>ExtensionPoints<ObjectAssert<ControlFlowPointcut>,ControlFlowPointcut>? super ControlFlowPointcutCondition<? super ControlFlowPointcut>Descriptable<Condition<? super ControlFlowPointcut>>Comparator<? super ControlFlowPointcut>Function<? super ControlFlowPointcut,? extends T>Consumer<ControlFlowPointcut>Predicate<? super ControlFlowPointcut>AbstractAssert<ObjectAssert<ControlFlowPointcut>,ControlFlowPointcut>(org.springframework.aop.support.ControlFlowPointcut,java.lang.Class)Class<ControlFlowPointcut>Map<String,ControlFlowPointcut>Constructor<ControlFlowPointcut>Class<? super ControlFlowPointcut>TypeVariable<Class<ControlFlowPointcut>>TypeVariable<Class<ControlFlowPointcut>>[]Map<String,One>One[]Constructor<One>? super OneClass<? super One>TypeVariable<Class<One>>TypeVariable<Class<One>>[]"; methodName = null"; methodName = null"; methodName = getAge"; methodName = getAgeset(org.springframework.beans.testfixture.beans.ITestBean)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/ControlFlowPointcutTests$One.classControlFlowPointcutTests$Onenomatchnomatch(org.springframework.beans.testfixture.beans.ITestBean)getAge(org.springframework.beans.testfixture.beans.ITestBean) Not advised, not under One Will be advised Won't be advisedCheck that we can use a cflow pointcut only in conjunction witha static pointcut: e.g. all setter methods that are invoked undera particular class. This greatly reduces the number of callsto the cflow pointcut, meaning that it's not so prohibitivelyexpensive. Not advised; under One but not a setter We saved most evaluationsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests.javaDelegatingIntroductionInterceptorTeststimestamp111L111tspBDDMyOngoingStubbing<Long>willReturn(java.lang.Long)Long[]willReturn(java.lang.Long,java.lang.Long[])Class<SubTimeStamped>1001L1001iiTesterC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests$1Tester.classDelegatingIntroductionInterceptorTests$1TesterC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests.classTester()TestIIC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests$1TestII.classDelegatingIntroductionInterceptorTests$1TestIITestII()ObjectAssert<TimeStamped>AbstractObjectAssert<ObjectAssert<TimeStamped>,TimeStamped>AbstractAssert<ObjectAssert<TimeStamped>,TimeStamped>Assert<ObjectAssert<TimeStamped>,TimeStamped>Descriptable<ObjectAssert<TimeStamped>>ExtensionPoints<ObjectAssert<TimeStamped>,TimeStamped>? super TimeStampedCondition<? super TimeStamped>Descriptable<Condition<? super TimeStamped>>Comparator<? super TimeStamped>Function<? super TimeStamped,? extends T>Consumer<TimeStamped>Predicate<? super TimeStamped>AbstractAssert<ObjectAssert<TimeStamped>,TimeStamped>(org.springframework.core.testfixture.TimeStamped,java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests$1.classDelegatingIntroductionInterceptorTests$1(java.lang.Object)"Shouldn't be invoked"Shouldn't be invokedcompany"Interface21"Interface21C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests$2.classDelegatingIntroductionInterceptorTests$2getSpouse()introduction"Introduced method returning delegate returns proxy"Introduced method returning delegate returns proxyserializableTargetClass<Person>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests$2TestII.classDelegatingIntroductionInterceptorTests$2TestIIC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests$SerializableTimeStamped.classDelegatingIntroductionInterceptorTests$SerializableTimeStampedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/DelegatingIntroductionInterceptorTests$TargetClass.classDelegatingIntroductionInterceptorTests$TargetClass13.05.2003 Shouldn't accept null targetassertTrue(Arrays.binarySearch(pf.getProxiedInterfaces(), TimeStamped.class) != -1); Shouldn't proxy framework interfaces Test removal Note that we need to construct a new proxy factory, or suppress the interface on the proxy factory Test when target implements the interface: should get interceptor by preference. != t From introduction interceptor, not targetC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/JdkRegexpMethodPointcutTests.javaJdkRegexpMethodPointcutTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/MethodMatchersTests.javaMethodMatchersTestsIOTHER_ABSQUATULATEC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/MethodMatchersTests.classITESTBEAN_GETAGEITESTBEAN_SETAGEEXCEPTION_GETMESSAGEMap<String,IOther>IOther[]Constructor<IOther>? super IOtherClass<? super IOther>TypeVariable<Class<IOther>>TypeVariable<Class<IOther>>[]defaultMm"Intersection is a dynamic matcher"Intersection is a dynamic matcher"2Matched setAge method"2Matched setAge method"3Matched setAge method"3Matched setAge method"3 - not Matched setAge method"3 - not Matched setAge methodgetterMatchersetterMatcher"Union is a static matcher"Union is a static matcher"Matched setAge method"Matched setAge method"Matched getAge method"Matched getAge method"Didn't matched absquatulate method"Didn't matched absquatulate methodsecondC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/MethodMatchersTests$StartsWithMatcher.classMethodMatchersTests$StartsWithMatcherTestDynamicMethodMatcherWhichMatchesTestDynamicMethodMatcherWhichMatches()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/MethodMatchersTests$TestDynamicMethodMatcherWhichMatches.classMethodMatchersTests$TestDynamicMethodMatcherWhichMatchesTestDynamicMethodMatcherWhichDoesNotMatchTestDynamicMethodMatcherWhichDoesNotMatch()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/MethodMatchersTests$TestDynamicMethodMatcherWhichDoesNotMatch.classMethodMatchersTests$TestDynamicMethodMatcherWhichDoesNotMatch Knock out dynamic partC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/NameMatchMethodPointcutTests.javaNameMatchMethodPointcutTests"echo""ech*"ech*"setN*"setN*"set*"set*"testing"testing"*ing"*ingObjectAssert<NameMatchMethodPointcut>AbstractObjectAssert<ObjectAssert<NameMatchMethodPointcut>,NameMatchMethodPointcut>AbstractAssert<ObjectAssert<NameMatchMethodPointcut>,NameMatchMethodPointcut>Assert<ObjectAssert<NameMatchMethodPointcut>,NameMatchMethodPointcut>Descriptable<ObjectAssert<NameMatchMethodPointcut>>ExtensionPoints<ObjectAssert<NameMatchMethodPointcut>,NameMatchMethodPointcut>? super NameMatchMethodPointcutCondition<? super NameMatchMethodPointcut>Descriptable<Condition<? super NameMatchMethodPointcut>>Comparator<? super NameMatchMethodPointcut>Function<? super NameMatchMethodPointcut,? extends T>Consumer<NameMatchMethodPointcut>Predicate<? super NameMatchMethodPointcut>AbstractAssert<ObjectAssert<NameMatchMethodPointcut>,NameMatchMethodPointcut>(org.springframework.aop.support.NameMatchMethodPointcut,java.lang.Class)Create an empty pointcut, populating instance variables. Can't do exact matching through isMatch Count is now 2C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/PointcutsTests.javaPointcutsTests"Shouldn't happen: error in test suite"Shouldn't happen: error in test suiteC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/PointcutsTests$1.classPointcutsTests$1C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/PointcutsTests.classgetClassFiltergetClassFilter()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/PointcutsTests$2.classPointcutsTests$2Class<MyTestBean>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/PointcutsTests$3.classPointcutsTests$3C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/PointcutsTests$4.classPointcutsTests$4Class<MyTestBeanSubclass>Matches only TestBean class, not subclasses Subclass used for matching Will match MyTestBeanSubclass Still more specific classShould match all setters and getters on any class Union with all settersTests vertical composition. First pointcut matches all setters.Second one matches all getters in the MyTestBean class. TestBean getters shouldn't pass. Still doesn't match superclass setterIntersection should be MyTestBean getAge() only:it's the union of allClassGetAge and subclass getters Matches subclass of MyTestBean Now intersection with MyTestBeanSubclass getters should eliminate MyTestBean target Still matches subclass of MyTestBean Now union with all TestBean methodsThe intersection of these two pointcuts leaves nothing.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/RegexpMethodPointcutAdvisorIntegrationTests.javaRegexpMethodPointcutAdvisorIntegrationTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/RegexpMethodPointcutAdvisorIntegrationTests.classClass<RegexpMethodPointcutAdvisorIntegrationTests>"settersAdvised"settersAdvised"nopInterceptor"nopInterceptor"settersAndAbsquatulateAdvised"settersAndAbsquatulateAdvised"serializableSettersAdvised"serializableSettersAdvised Interceptor behind regexp advisor Not advised Only setter fired This is a CGLIB proxy, so we can proxy it to the target class This is proxied Serialize and continue... Remembers count, but we need to get a new reference to nop...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/RootClassFilterTests.javaRootClassFilterTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/RootClassFilterTests.classmatches()RootClassFilterTests()Class<Error>"org.springframework.aop.support.RootClassFilter: java.lang.Exception"org.springframework.aop.support.RootClassFilter: java.lang.ExceptionUnit tests for {@link RootClassFilter}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/annotation/AnnotationMatchingPointcutTests.javaAnnotationMatchingPointcutTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/annotationclassLevelAndMethodLevelPointcutsclassLevelAndMethodLevelPointcuts()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/support/annotation/AnnotationMatchingPointcutTests.classmethodLevelPointcutsmethodLevelPointcuts()classLevelPointcutsclassLevelPointcuts()AnnotationMatchingPointcutTests()pointcut1Class<Qualifier>pointcut2pointcut3Class<AnnotationClassFilter>? extends ClassFilterClass<? extends ClassFilter>Map<String,Qualifier>Qualifier[]Constructor<Qualifier>? super QualifierClass<? super Qualifier>TypeVariable<Class<Qualifier>>TypeVariable<Class<Qualifier>>[]Map<String,? extends ClassFilter>? extends ClassFilter[]Constructor<? extends ClassFilter>? super ? extends ClassFilterClass<? super ? extends ClassFilter>TypeVariable<Class<? extends ClassFilter>>TypeVariable<Class<? extends ClassFilter>>[]"AnnotationCandidateClassFilter"Class<AnnotationMethodMatcher>? extends MethodMatcherClass<? extends MethodMatcher>Unit tests for {@link AnnotationMatchingPointcut}. #1 and #3 have equivalent hash codes even though equals() returns false.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/CommonsPool2TargetSourceProxyTests.javaCommonsPool2TargetSourceProxyTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/targetC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/CommonsPool2TargetSourceProxyTests.classClass<CommonsPool2TargetSourceProxyTests>"testBean"C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/HotSwappableTargetSourceTests.javaHotSwappableTargetSourceTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/HotSwappableTargetSourceTests.classINITIAL_COUNTClass<HotSwappableTargetSourceTests>"swappable"swappabletarget1"target1"target2"target2"swapper"swapper""Correct old target was returned"Correct old target was returned21"Shouldn't be able to swap to invalid value"Shouldn't be able to swap to invalid valuesp1sp2hts"Gordon"GordonInitial count value set in bean factory XMLWe must simulate container shutdown, which should clear threads. Will call pool.close()Check it works like a normal invoker TODO should be able to make this assertion: need to fix target handling in AdvisedSupportassertEquals(target2, ((Advised) proxied).getTarget()); Swap it back It shouldn't be corrupted, it should still work We need to get a reference to the client-side targetsourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/LazyCreationTargetSourceTests.javaLazyCreationTargetSourceTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/LazyCreationTargetSourceTests$1.classLazyCreationTargetSourceTests$1getTargetClassgetTargetClass()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/LazyCreationTargetSourceTests.classcreateObjectcreateObject()Class<InitCountingBean>"Init count should be 0"Init count should be 0"Target class incorrect"Target class incorrect"Init count should still be 0 after getTargetClass()"Init count should still be 0 after getTargetClass()"Init count should now be 1"Init count should now be 1"Init count should still be 1"Init count should still be 1? extends InitCountingBeanClass<? extends InitCountingBean> only increment when creating the actual target - not the proxyno-opC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/LazyInitTargetSourceTests.javaLazyInitTargetSourceTestsFACTORY_BEAN_CONTEXTC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/LazyInitTargetSourceTests.classCUSTOM_TARGET_CONTEXTSINGLETON_CONTEXTClass<LazyInitTargetSourceTests>"singleton.xml"singleton.xml"customTarget.xml"customTarget.xml"factoryBean.xml"factoryBean.xmlSet<?>set1"proxy1"set2"proxy2""10""20"07.01.2005C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/PrototypeBasedTargetSourceTests.javaPrototypeBasedTargetSourceTeststsPvstsBdClass<TestTargetSource>Class<SerializablePerson>"ts"serializedsts"person"person"Changed to SingletonTargetSource on deserialization"Changed to SingletonTargetSource on deserializationthisFieldIsNotSerializableC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/PrototypeBasedTargetSourceTests$TestTargetSource.classPrototypeBasedTargetSourceTests$TestTargetSourceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/PrototypeBasedTargetSourceTests.classTestTargetSourceTestTargetSource()1LUnit tests relating to the abstract {@link AbstractPrototypeBasedTargetSource}and not subclasses.Nonserializable test field to check that subclassstate can't prevent serialization from workingC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/PrototypeTargetSourceTests.javaPrototypeTargetSourceTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/PrototypeTargetSourceTests.classClass<PrototypeTargetSourceTests>Test that multiple invocations of the prototype bean will resultin no change to visible state, as a new instance is used.With the singleton, there will be change.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/ThreadLocalTargetSourceTests.javaThreadLocalTargetSourceTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/ThreadLocalTargetSourceTests.classClass<ThreadLocalTargetSourceTests>apartment"apartment""threadLocal2"threadLocal2"Rod"Rod"Kerry"KerrystatsRunnerC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/ThreadLocalTargetSourceTests$1Runner.classThreadLocalTargetSourceTests$1Runnerrunrun()mineRunner()rObjectAssert<Runner>AbstractObjectAssert<ObjectAssert<Runner>,Runner>AbstractAssert<ObjectAssert<Runner>,Runner>Assert<ObjectAssert<Runner>,Runner>Descriptable<ObjectAssert<Runner>>ExtensionPoints<ObjectAssert<Runner>,Runner>? super RunnerCondition<? super Runner>Descriptable<Condition<? super Runner>>Comparator<? super Runner>Function<? super Runner,? extends T>Consumer<Runner>Predicate<? super Runner>AbstractAssert<ObjectAssert<Runner>,Runner>(Runner,java.lang.Class)"threadLocalTs"threadLocalTsCheck we can use two different ThreadLocalTargetSourcesmanaging objects of different types without them interferingwith one another.Relies on introduction. +1 because creating target for stats call counts +1 again + 1 for states call! Only one thread so only one object can have been bound Check it didn't affect the other thread's copy When we use other thread's copy in this thread it should behave like ours Bound to two threadsTest for SPR-1442. Destroyed target should re-associated with thread and not throw NPE. try first time try second time Should not throw NPEC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/dynamic/RefreshableTargetSourceTests.javaRefreshableTargetSourceTestsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/dynamic"Should be one call to freshTarget to get initial target"Should be one call to freshTarget to get initial target"Returned objects should be the same - no refresh should occur"Returned objects should be the same - no refresh should occur"Should have called freshTarget twice"Should have called freshTarget twice"Should be different objects"Should be different objects"Refresh target should only be called once"Refresh target should only be called once"Objects should be the same - refresh check delay not elapsed"Objects should be the same - refresh check delay not elapsedf"Objects should be same"Objects should be same50"A and C should be same"A and C should be same60"D should not be null"D should not be null"A and D should not be equal"A and D should not be equal"D and E should be equal"D and E should be equal110"E and F should be different"E and F should be differentrequiresRefreshC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/org/springframework/aop/target/dynamic/RefreshableTargetSourceTests$CountingRefreshableTargetSource.classRefreshableTargetSourceTests$CountingRefreshableTargetSourcecallCountTest what happens when checking for refresh but not refreshing object.Test what happens when checking for refresh and refresh occurs.Test what happens when no refresh occurs.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/annotation/EmptySpringAnnotation.javaEmptySpringAnnotationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/annotationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/testtest.annotationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/annotation/transaction/Tx.javaTxC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/annotation/transactiontest.annotation.transactionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/DefaultLockable.javaDefaultLockableC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aoptest.aoplockedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/DefaultLockable.classSimple implementation of Lockable interface for use in mixins.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/Lockable.javaLockableSimple interface to use for mixinsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/PerTargetAspect.javaPerTargetAspectC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/PerTargetAspect.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/PerThisAspect.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/PerThisAspect.class"perthis(execution(* getAge()))"perthis(execution(* getAge()))Copyright 2002-2005 the original author or authors.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/TwoAdviceAspect.javaTwoAdviceAspecttotalCallsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/test/java/test/aop/TwoAdviceAspect.class"execution(* setAge(int)) && args(newAge)"execution(* setAge(int)) && args(newAge)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/advice/CountingAfterReturningAdvice.javaCountingAfterReturningAdviceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/adviceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixturetestfixtureC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aopC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframeworkC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/orgC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixturestestFixturesorg.springframework.aop.testfixture.adviceSimple before advice example that we can use for counting checks.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/advice/CountingBeforeAdvice.javaCountingBeforeAdviceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/advice/MethodCounter.javaMethodCounterallCountC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/advice/MethodCounter.classBiFunction<Integer,Integer,Integer>BiFunction<T,U,V>BiFunction<Integer,Integer,V>Function<? super Integer,? extends V>apply(java.lang.Object,java.lang.Object)apply(java.lang.Integer,java.lang.Integer)n? extends MethodCounterClass<? extends MethodCounter>Abstract superclass for counting advices etc.Method name --> count, does not understand overloadingA bit simplistic: just wants the same class.Doesn't worry about counts.java.lang.Object#equals(java.lang.Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/advice/MyThrowsHandler.javaMyThrowsHandler"Shouldn't be called"Shouldn't be called Full method signatureNot valid, wrong number of argumentsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/advice/TimestampIntroductionAdvisor.javaTimestampIntroductionAdvisorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/interceptor/NopInterceptor.javaNopInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/interceptororg.springframework.aop.testfixture.interceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/interceptor/NopInterceptor.classTrivial interceptor that can be introduced in a chain to display it.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/interceptor/SerializableNopInterceptor.javaSerializableNopInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/interceptor/SerializableNopInterceptor.classSubclass of NopInterceptor that is serializable andcan be used to test proxy serialization.We must override this field and the related methods asotherwise count won't be serialized from the non-serializableNopInterceptor superclass.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/interceptor/TimestampIntroductionInterceptor.javaTimestampIntroductionInterceptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-aop/src/testFixtures/java/org/springframework/aop/testfixture/interceptor/TimestampIntroductionInterceptor.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmp/compileGroovy/groovy-java-stubs/org/springframework/beans/factory/groovy/GroovyDynamicElementReader.javaGroovyDynamicElementReaderC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmp/compileGroovy/groovy-java-stubs/org/springframework/beans/factory/groovygroovyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmp/compileGroovy/groovy-java-stubs/org/springframework/beans/factoryC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmp/compileGroovy/groovy-java-stubs/org/springframework/beansC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmp/compileGroovy/groovy-java-stubs/org/springframeworkC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmp/compileGroovy/groovy-java-stubs/orgC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmp/compileGroovy/groovy-java-stubsgroovy-java-stubsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmp/compileGroovycompileGroovyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/tmptmporg.springframework.beans.factory.groovyjava.iojava.netgroovy.langgroovy.utilnamespacenamespaceMapdecoratingC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.javaAbstractNestablePropertyAccessorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beansC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframeworkC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/orgC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/mainC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/srcorg.springframework.beansgetPropertyNameKeyEndgetPropertyNameKeyEnd(java.lang.String,int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/AbstractNestablePropertyAccessor.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beansC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframeworkC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/orgC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/mainC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classesgetPropertyNameTokensgetPropertyNameTokens(java.lang.String)newValue(java.lang.Class,org.springframework.core.convert.TypeDescriptor,java.lang.String)createDefaultPropertyValuecreateDefaultPropertyValue(org.springframework.beans.AbstractNestablePropertyAccessor.PropertyTokenHolder)setDefaultValuesetDefaultValue(org.springframework.beans.AbstractNestablePropertyAccessor.PropertyTokenHolder)getNestedPropertyAccessorgetNestedPropertyAccessor(java.lang.String)growCollectionIfNecessarygrowCollectionIfNecessary(java.util.Collection,int,java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor.PropertyHandler,int)growArrayIfNecessarygrowArrayIfNecessary(java.lang.Object,int,java.lang.String)convertIfNecessaryconvertIfNecessary(java.lang.String,java.lang.Object,java.lang.Object,java.lang.Class,org.springframework.core.convert.TypeDescriptor)processLocalPropertyprocessLocalProperty(org.springframework.beans.AbstractNestablePropertyAccessor.PropertyTokenHolder,org.springframework.beans.PropertyValue)getPropertyHoldingValuegetPropertyHoldingValue(org.springframework.beans.AbstractNestablePropertyAccessor.PropertyTokenHolder)processKeyedPropertyprocessKeyedProperty(org.springframework.beans.AbstractNestablePropertyAccessor.PropertyTokenHolder,org.springframework.beans.PropertyValue)Map<String,AbstractNestablePropertyAccessor>nestedPropertyAccessorsrootObjectnestedPathwrappedObjectautoGrowCollectionLimitClass<AbstractNestablePropertyAccessor>registerDefaultEditors"No wrapped object"No wrapped object"No root object"No root objectpropertyNamenestedPa"Nested property in path '"Nested property in path '"' does not exist"' does not existpvpropValuephlastKey"No property handler found"No property handler found"No token keys"No token keysrequiredTypearrayIndexconvertedValuenewArray"Invalid array index in property path '"Invalid array index in property path '"Cannot set element with index "Cannot set element with index " in List of size " in List of size ", accessed using property path '", accessed using property path '"': List does not support filling up gaps with null elements"': List does not support filling up gaps with null elements"Invalid list index in property path '"Invalid list index in property path 'mapKeyTypemapValueTypetypeDescriptorconvertedMapKeyconvertedMapValue"Property referenced in indexed property path '"Property referenced in indexed property path '"' is neither an array nor a List nor a Map; returned value was ["' is neither an array nor a List nor a Map; returned value was [getterTokens"Cannot access indexed value in property referenced " +
					"in indexed property path '"Cannot access indexed value in property referenced in indexed property path 'lastKeyIndex'['"Cannot access indexed value in property referenced " +
						"in indexed property path '""': returned null"': returned null"Ignoring optional value for property '"Ignoring optional value for property '"' - property not found on bean class ["' - property not found on bean class [originalValuevalueToApply"Could not read previous value of property '"Could not read previous value of property 'propertyChangeEventpceeditorTypefinalPathtd"No TypeConverterDelegate"No TypeConverterDelegateactualNameindexedPropertyName"Cannot access indexed value of property referenced in indexed " +
										"property path '"Cannot access indexed value of property referenced in indexed property path '"Cannot get element with index "Cannot get element with index " from Set of size " from Set of size hasNexthasNext()forEachRemainingforEachRemaining(java.util.function.Consumer)next()elemint[]"' is neither an array nor a List nor a Set nor a Map; returned value was ["' is neither an array nor a List nor a Set nor a Map; returned value was ["Index of out of bounds in property path '"Index of out of bounds in property path '"Invalid index in property path '"Invalid index in property path '"Getter for property '"Getter for property '"' threw exception"' threw exception"Illegal attempt to get property '"Illegal attempt to get property '"Property name must not be null"Property name must not be nullarraydefaultValue"Default value must not be null"Default value must not be nullcollectionnestingLevelelementTypepropertyPathnestedPropertycanonicalName? super AbstractNestablePropertyAccessor? extends AbstractNestablePropertyAccessorBiFunction<? super AbstractNestablePropertyAccessor,? super AbstractNestablePropertyAccessor,? extends AbstractNestablePropertyAccessor>merge(java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor,java.util.function.BiFunction)BiFunction<? super String,? super AbstractNestablePropertyAccessor,? extends AbstractNestablePropertyAccessor>Function<? super String,? extends AbstractNestablePropertyAccessor>replace(java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor)replace(java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor,org.springframework.beans.AbstractNestablePropertyAccessor)putIfAbsent(java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor)BiConsumer<? super String,? super AbstractNestablePropertyAccessor>getOrDefault(java.lang.Object,org.springframework.beans.AbstractNestablePropertyAccessor)Entry<String,AbstractNestablePropertyAccessor>Set<Entry<String,AbstractNestablePropertyAccessor>>Collection<Entry<String,AbstractNestablePropertyAccessor>>Iterable<Entry<String,AbstractNestablePropertyAccessor>>Collection<AbstractNestablePropertyAccessor>Iterable<AbstractNestablePropertyAccessor>Map<? extends String,? extends AbstractNestablePropertyAccessor>put(java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor)HashMap<String,AbstractNestablePropertyAccessor>AbstractMap<String,AbstractNestablePropertyAccessor>HashMap<String,AbstractNestablePropertyAccessor>()AbstractMap<String,AbstractNestablePropertyAccessor>()Node<String,AbstractNestablePropertyAccessor>TreeNode<String,AbstractNestablePropertyAccessor>newTreeNode(int,java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor,java.util.HashMap.Node)newNode(int,java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor,java.util.HashMap.Node)Node<String,AbstractNestablePropertyAccessor>[]putVal(int,java.lang.String,org.springframework.beans.AbstractNestablePropertyAccessor,boolean,boolean)HashMap<String,AbstractNestablePropertyAccessor>(java.util.Map)HashMap<String,AbstractNestablePropertyAccessor>(int)HashMap<String,AbstractNestablePropertyAccessor>(int,float)Optional<?>XorElseThroworElseThrow(java.util.function.Supplier)? extends XSupplier<? extends X>orElseThrow()orElseGetorElseGet(java.util.function.Supplier)? extends ?Supplier<? extends ?>orElseorElse(java.lang.Object)Optional<? extends T>? extends Optional<? extends T>Supplier<? extends Optional<? extends T>>or(java.util.function.Supplier)Optional<? extends ?>? extends Optional<? extends ?>Supplier<? extends Optional<? extends ?>>Optional<U>Optional<? extends U>? extends Optional<? extends U>Function<? super T,? extends Optional<? extends U>>Function<? super ?,? extends Optional<? extends U>>Function<? super ?,? extends U>ifPresentOrElseifPresentOrElse(java.util.function.Consumer,java.lang.Runnable)ifPresentifPresent(java.util.function.Consumer)"Creating new nested "Creating new nested Class<? extends AbstractNestablePropertyAccessor>Map<String,? extends AbstractNestablePropertyAccessor>AbstractNestablePropertyAccessor[]? extends AbstractNestablePropertyAccessor[]Constructor<? extends AbstractNestablePropertyAccessor>? super ? extends AbstractNestablePropertyAccessorClass<? super ? extends AbstractNestablePropertyAccessor>TypeVariable<Class<? extends AbstractNestablePropertyAccessor>>TypeVariable<Class<? extends AbstractNestablePropertyAccessor>>[]" for property '" for property '"Using cached nested property accessor for property '"Using cached nested property accessor for property 'desc"Could not determine property type for auto-growing a default value"Could not determine property type for auto-growing a default valueClass<Collection<>>Map<String,Collection<>>Collection[]Collection<>[]Constructor<Collection<>>? super Collection<>Class<? super Collection<>>TypeVariable<Class<Collection<>>>TypeVariable<Class<Collection<>>>[]elementDescClass<Map<>>Map<String,Map<>>Map[]Map<>[]Constructor<Map<>>? super Map<>Class<? super Map<>>TypeVariable<Class<Map<>>>TypeVariable<Class<Map<>>>[]keyDesc"Auto-growing not allowed with private constructor: "Auto-growing not allowed with private constructor: "Could not instantiate property type ["Could not instantiate property type ["] to auto-grow nested property path"] to auto-grow nested property pathsearchIndexkeyStartkeyEndunclosedPrefixes": no wrapped object set": no wrapped object set": wrapping object [": wrapping object [writableC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/AbstractNestablePropertyAccessor$PropertyHandler.classAbstractNestablePropertyAccessor$PropertyHandlerreadablepropertyTypelevelA basic {@link ConfigurablePropertyAccessor} that provides the necessaryinfrastructure for all typical use cases.<p>This accessor will convert collection and array values to the correspondingtarget collections or arrays, if necessary. Custom property editors that dealwith collections or arrays can either be written via PropertyEditor's{@code setValue}, or against a comma-delimited String via {@code setAsText},as String arrays are converted in such a format if the array itself is notassignable.#registerCustomEditor#setPropertyValues#setPropertyValue#getPropertyValue#getPropertyTypeBeanWrapperPropertyEditorRegistrySupportWe'll create a lot of these objects, so we don't want a new logger every time.Map with cached nested Accessors: nested path -> Accessor instance.Create a new empty accessor. Wrapped instance needs to be set afterwards.Registers default editors.#setWrappedInstancewhether to register default editors(can be suppressed if the accessor won't need any type conversion)Create a new accessor for the given object.the object wrapped by this accessorCreate a new accessor, wrapping a new instance of the specified class.class to instantiate and wrapCreate a new accessor for the given object,registering a nested path that the object is in.the nested path of the objectthe root object at the top of the paththe containing accessor (must not be {@code null})Specify a limit for array and collection auto-growing.<p>Default is unlimited on a plain accessor.Return the limit for array and collection auto-growing.Switch the target object, replacing the cached introspection results onlyif the class of the new object is different to that of the replaced object.Return the nested path of the object wrapped by this accessor.Return the root object at the top of the path of this accessor.#getNestedPathReturn the class of the root object at the top of the path of this accessor. IMPORTANT: Do not pass full property name in here - property editors must not kick in for map keys but rather only for map values. Pass full property name and old value in here, since we want full conversion ability for map values. Apply indexes and map keys: fetch value for all keys but the last one. null map value case Optimization for common ignoreUnknown=true scenario since the exception would be caught and swallowed higher up anyway... May happen e.g. with Groovy-generated methods Maybe an indexed/mapped property... Check to see if there is a custom editor, which might give an indication on the desired target type. Consider as not determinable. Cannot be evaluated, so can't be readable. Cannot be evaluated, so can't be writable. apply indexes and map keys Apply index to Iterator in case of a Set.Return the {@link PropertyHandler} for the specified {@code propertyName}, navigatingif necessary. Return {@code null} if not found rather than throwing an exception.the property to obtain the descriptor forthe property descriptor for the specified property,or {@code null} if not foundin case of introspection failureReturn a {@link PropertyHandler} for the specified local {@code propertyName}.Only used to reach a property available in the current context.the name of a local propertythe handler for that property, or {@code null} if it has not been foundCreate a new nested property accessor instance.Can be overridden in subclasses to create a PropertyAccessor subclass.the object wrapped by this PropertyAccessorthe nested PropertyAccessor instanceCreate a {@link NotWritablePropertyException} for the specified property.Get the last component of the path. Also works if not nested.property accessor to work onproperty path we know is nestedlast component of the path (the property on the target bean)Recursively navigate to return a property accessor for the nested property path.property path, which may be nesteda property accessor for the target bean Handle nested properties recursively.Retrieve a Property accessor for the given nested property.Create a new one if not found in the cache.<p>Note: Caching nested PropertyAccessors is necessary now,to keep registered custom editors for nested properties.property to create the PropertyAccessor forthe PropertyAccessor instance, either cached or newly created Get value of bean property. Lookup cached sub-PropertyAccessor, create new one if not found. Inherit all type-specific PropertyEditors. TODO - only handles 2-dimensional arraysParse the given property name into the corresponding property name tokens.the property name to parserepresentation of the parsed property tokens The property name contains opening prefix(es)... No unclosed prefix(es) in the property name (left) -> this is the suffix we are looking for. This suffix does not close the initial prefix but rather just one that occurred within the property name.A handler for a specific property.Holder class used to store property tokens.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.javaAbstractPropertyAccessorsuppressNotWritablePropertyExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/AbstractPropertyAccessor.classautoGrowNestedPathsextractOldValueForEditorignoreUnknownignoreInvalidList<PropertyAccessException>Collection<PropertyAccessException>Iterable<PropertyAccessException>propertyAccessExceptionsList<PropertyValue>Collection<PropertyValue>Iterable<PropertyValue>propertyValuesPropertyValue[]ArrayList<PropertyAccessException>AbstractList<PropertyAccessException>AbstractCollection<PropertyAccessException>ArrayList<PropertyAccessException>()Spliterator<PropertyAccessException>? super PropertyAccessExceptionConsumer<? super PropertyAccessException>Iterator<PropertyAccessException>Stream<PropertyAccessException>BaseStream<PropertyAccessException,Stream<PropertyAccessException>>Predicate<? super PropertyAccessException>? extends PropertyAccessExceptionCollection<? extends PropertyAccessException>Iterable<? extends PropertyAccessException>add(org.springframework.beans.PropertyAccessException)AbstractCollection<PropertyAccessException>()ListIterator<PropertyAccessException>add(int,org.springframework.beans.PropertyAccessException)set(int,org.springframework.beans.PropertyAccessException)Comparator<? super PropertyAccessException>UnaryOperator<PropertyAccessException>Function<PropertyAccessException,PropertyAccessException>AbstractList<PropertyAccessException>()ArrayList<PropertyAccessException>(java.util.Collection)ArrayList<PropertyAccessException>(int)PropertyAccessException[]paeArrayAbstract implementation of the {@link PropertyAccessor} interface.Provides base implementations of all convenience methods, with theimplementation of actual property access left to subclasses. setPropertyValue may throw any BeansException, which won't be caught here, if there is a critical failure such as no matching field. We can attempt to deal only with less serious exceptions. Otherwise, just ignore it and continue... If we encountered individual exceptions, throw the composite exception. Redefined with public visibility.Actually get the value of a property.name of the property to get the value ofthe value of the propertyInvalidPropertyExceptionif there is no such property orif the property isn't readablePropertyAccessExceptionif the property was valid but theaccessor method failedActually set a property value.name of the property to set value ofthe new valueif the property isn't writableaccessor method failed or a type mismatch occurredC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeanInfoFactory.javaBeanInfoFactoryStrategy interface for creating {@link BeanInfo} instances for Spring beans.Can be used to plug in custom bean property resolution strategies (e.g. for otherlanguages on the JVM) or more efficient {@link BeanInfo} retrieval algorithms.<p>BeanInfoFactories are instantiated by the {@link CachedIntrospectionResults},by using the {@link org.springframework.core.io.support.SpringFactoriesLoader}utility class.When a {@link BeanInfo} is to be created, the {@code CachedIntrospectionResults}will iterate through the discovered factories, calling {@link #getBeanInfo(Class)}on each one. If {@code null} is returned, the next factory will be queried.If none of the factories support the class, a standard {@link BeanInfo} will becreated as a default.<p>Note that the {@link org.springframework.core.io.support.SpringFactoriesLoader}sorts the {@code BeanInfoFactory} instances by{@link org.springframework.core.annotation.Order @Order}, so that ones with ahigher precedence come first.Arjen PoutsmaCachedIntrospectionResultsorg.springframework.core.io.support.SpringFactoriesLoaderReturn the bean info for the given class, if supported.the BeanInfo, or {@code null} if the given class is not supportedIntrospectionExceptionin case of exceptionsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeanInstantiationException.javaBeanInstantiationExceptionconstructingMethodC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/BeanInstantiationException.classconstructor"Failed to instantiate ["Failed to instantiate [Exception thrown when instantiation of a bean failed.Carries the offending bean class.1.2.8Create a new BeanInstantiationException.the offending bean classthe offending constructorthe delegate for bean construction purposes(typically, but not necessarily, a static factory method)Return the offending bean class (never {@code null}).the class that was to be instantiatedReturn the offending constructor, if known.the constructor in use, or {@code null} in case of afactory method or in case of default instantiationReturn the delegate for bean construction purposes, if known.the method in use (typically a static factory method),or {@code null} in case of constructor-based instantiationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeanMetadataAttribute.javaBeanMetadataAttributeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/BeanMetadataAttribute.class"Name must not be null"Name must not be nullotherMa"metadata attribute '"metadata attribute 'Holder for a key-value style attribute that is part of a bean definition.Keeps track of the definition source in addition to the key-value pair.Create a new AttributeValue instance.the name of the attribute (never {@code null})the value of the attribute (possibly before type conversion)Return the name of the attribute.Return the value of the attribute.Set the configuration source {@code Object} for this metadata element.<p>The exact type of the object will depend on the configuration mechanism used.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeanMetadataAttributeAccessor.javaBeanMetadataAttributeAccessorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/BeanMetadataAttributeAccessor.classattributeExtension of {@link org.springframework.core.AttributeAccessorSupport},holding attributes as {@link BeanMetadataAttribute} objects in orderto keep track of the definition source.Add the given BeanMetadataAttribute to this accessor's set of attributes.the BeanMetadataAttribute object to registerLook up the given BeanMetadataAttribute in this accessor's set of attributes.the corresponding BeanMetadataAttribute object,or {@code null} if no such attribute definedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeanMetadataElement.javaBeanMetadataElementInterface to be implemented by bean metadata elementsthat carry a configuration source object.Return the configuration source {@code Object} for this metadata element(may be {@code null}).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeanUtils.javaBeanUtilscopyPropertiescopyProperties(java.lang.Object,java.lang.Object,java.lang.Class,java.lang.String[])C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/BeanUtils.classDEFAULT_TYPE_VALUESunknownEditorTypesClass<BeanUtils>ConcurrentReferenceHashMap<Class<?>,Boolean>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/ConcurrentReferenceHashMap.classConcurrentReferenceHashMapConcurrentReferenceHashMap<K,V>ConcurrentReferenceHashMap<K,V>(int)calculateShiftcalculateShift(int,int)purgeUnreferencedEntriespurgeUnreferencedEntries()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/ConcurrentReferenceHashMap$Reference.classConcurrentReferenceHashMap$ReferenceConcurrentReferenceHashMap<>Reference<K,V>getReferencegetReference(java.lang.Object,org.springframework.util.ConcurrentReferenceHashMap.Restructure)getHashgetHash(java.lang.Object)ReferenceManager<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/ConcurrentReferenceHashMap$ReferenceManager.classConcurrentReferenceHashMap$ReferenceManagercreateReferenceManagercreateReferenceManager()Segment<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/util/ConcurrentReferenceHashMap$Segment.classConcurrentReferenceHashMap$SegmentgetSegmentgetSegment(int)getSegmentsSizegetSegmentsSize()getLoadFactorgetLoadFactor()ConcurrentReferenceHashMap(int,float,int,org.springframework.util.ConcurrentReferenceHashMap.ReferenceType)ConcurrentReferenceHashMap<K,V>(int,float,int,org.springframework.util.ConcurrentReferenceHashMap.ReferenceType)ConcurrentReferenceHashMap(int,float,int)ConcurrentReferenceHashMap<K,V>(int,float,int)ConcurrentReferenceHashMap(int,org.springframework.util.ConcurrentReferenceHashMap.ReferenceType)ConcurrentReferenceHashMap<K,V>(int,org.springframework.util.ConcurrentReferenceHashMap.ReferenceType)ConcurrentReferenceHashMap(int,int)ConcurrentReferenceHashMap<K,V>(int,int)ConcurrentReferenceHashMap(int,float)ConcurrentReferenceHashMap<K,V>(int,float)ConcurrentReferenceHashMap(int)ConcurrentReferenceHashMap()ConcurrentReferenceHashMap<K,V>()64HashMap<Class<?>,Object>HashMap<Class<?>,Object>()TreeNode<Class<?>,Object>newTreeNode(int,java.lang.Class,java.lang.Object,java.util.HashMap.Node)newNode(int,java.lang.Class,java.lang.Object,java.util.HashMap.Node)putVal(int,java.lang.Class,java.lang.Object,boolean,boolean)HashMap<Class<?>,Object>(java.util.Map)HashMap<Class<?>,Object>(int)HashMap<Class<?>,Object>(int,float)Class<Boolean>Class<Byte>Class<Short>shortClass<Long>"Specified class is an interface"Specified class is an interface"Is it an abstract class?"Is it an abstract class?"Is the constructor accessible?"Is the constructor accessible?"No default constructor found"No default constructor found"Unresolvable class definition"Unresolvable class definitionassignableTo"Constructor must not be null"Constructor must not be nullTypeVariable<Constructor<T>>TypeVariable<Constructor<T>>[]Constructor<T>(java.lang.Class,java.lang.Class[],java.lang.Class[],int,int,java.lang.String,byte[],byte[])argsWithDefaultValues"Can't specify more arguments than constructor parameters"Can't specify more arguments than constructor parametersparameterType"Illegal arguments for constructor"Illegal arguments for constructor"Constructor threw exception"Constructor threw exceptionctors"No primary or single public constructor found for "No primary or single public constructor found for " - and no default constructor found either" - and no default constructor found eithernumMethodsFoundWithCurrentMinimumArgsnumParams"Cannot resolve method '"Cannot resolve method '"' to a unique method. Attempted to resolve to overloaded method with " +
					"the least number of parameters but there were "' to a unique method. Attempted to resolve to overloaded method with the least number of parameters but there were startParenendParen"'signature' must not be empty"'signature' must not be empty"Invalid method signature '"Invalid method signature '"': expected closing ')' for args list"': expected closing ')' for args list"': expected opening '(' for args list"': expected opening '(' for args listparameterTypeNamesparameterTypeName"Invalid method signature: unable to resolve type ["Invalid method signature: unable to resolve type ["] for argument "] for argument ". Root cause: ". Root cause: PropertyDescriptor[]pds"Method must not be null"Method must not be nullpdcltargetTypeNameeditorName"Editor"Editor"Could not access system ClassLoader: "Could not access system ClassLoader: editorClassClass<PropertyEditor>Map<String,PropertyEditor>PropertyEditor[]Constructor<PropertyEditor>? super PropertyEditorClass<? super PropertyEditor>TypeVariable<Class<PropertyEditor>>TypeVariable<Class<PropertyEditor>>[]"Editor class ["Editor class ["] does not implement [java.beans.PropertyEditor] interface"] does not implement [java.beans.PropertyEditor] interface"No property editor ["No property editor ["] found for type "] found for type " according to 'Editor' suffix convention" according to 'Editor' suffix conventionbeanClasseswriteMethod"No write method available"No write method availableClass<ConstructorProperties>"Cannot resolve parameter names for constructor "Cannot resolve parameter names for constructor "Invalid number of parameter names: "Invalid number of parameter names: " for constructor " for constructor "'type' must not be null"'type' must not be nullEnum<>C:/modules/java.base/java/lang/Enum.classEnumClass<Enum<>>Map<String,Enum<>>Enum[]Enum<>[]Constructor<Enum<>>? super Enum<>Class<? super Enum<>>TypeVariable<Class<Enum<>>>TypeVariable<Class<Enum<>>>[]Class<CharSequence>Map<String,CharSequence>Constructor<CharSequence>? super CharSequenceClass<? super CharSequence>TypeVariable<Class<CharSequence>>TypeVariable<Class<CharSequence>>[]Map<String,Number>Number[]Constructor<Number>? super NumberClass<? super Number>TypeVariable<Class<Number>>TypeVariable<Class<Number>>[]Class<Date>Map<String,Date>Date[]Constructor<Date>? super DateClass<? super Date>TypeVariable<Class<Date>>TypeVariable<Class<Date>>[]Class<Temporal>Map<String,Temporal>Temporal[]Constructor<Temporal>? super TemporalClass<? super Temporal>TypeVariable<Class<Temporal>>TypeVariable<Class<Temporal>>[]Class<URI>Class<URL>Class<Locale>Class<Class<>>editableignorePropertiesactualEditabletargetPdsignoreList"Source must not be null"Source must not be null"Target class ["Target class ["] not assignable to Editable class ["] not assignable to Editable class [targetPdsourcePdreadMethodsourceResolvableTypetargetResolvableTypeisAssignable"Could not copy property '"Could not copy property '"' from source to target"' from source to targetKotlinDelegateKotlinDelegate()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/BeanUtils$KotlinDelegate.classBeanUtils$KotlinDelegatekotlin.reflectKFunction<T>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.21/4a668382d7c38688d3490afde93b6a113ed46698/kotlin-stdlib-1.4.21.jarkotlin-stdlib-1.4.21C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.21/4a668382d7c38688d3490afde93b6a113ed466984a668382d7c38688d3490afde93b6a113ed46698C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.211.4.21C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlibkotlin-stdlibC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlinorg.jetbrains.kotlinC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.21/4a668382d7c38688d3490afde93b6a113ed46698/kotlin-stdlib-1.4.21.jar/kotlinkotlinC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.21/4a668382d7c38688d3490afde93b6a113ed46698/kotlin-stdlib-1.4.21.jar/kotlin/reflectC:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.21/4a668382d7c38688d3490afde93b6a113ed46698/kotlin-stdlib-1.4.21.jar/kotlin/reflect/KFunction.classKFunctionKCallable<T>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.21/4a668382d7c38688d3490afde93b6a113ed46698/kotlin-stdlib-1.4.21.jar/kotlin/reflect/KCallable.classKCallable" T\n\n \n\n \n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n \n\n$\nf *  20J%$8 2%0'0&\"0'H&(J#)8 2%00'0*H&+R08&XR08&X\tR\n08&X\nR08&X\rR0XR00XR0XR 008&XR0 8&X!\"#," T

 

 





 









 

$
f *  20J%$8 2%0'0&"0'H&(J#)8 2%00'0*H&+R08&XR08&X	R
08&X
R08&XR0XR00XR0XR 008&XR0 8&X!"#,"Lkotlin/reflect/KCallable;"Lkotlin/reflect/KCallable;"R""Lkotlin/reflect/KAnnotatedElement;"Lkotlin/reflect/KAnnotatedElement;"isAbstract"isAbstract"isAbstract$annotations"isAbstract$annotations"()V"()V"()Z"()Z"isFinal"isFinal"isFinal$annotations"isFinal$annotations"isOpen"isOpen"isOpen$annotations"isOpen$annotations"isSuspend"isSuspend"isSuspend$annotations"isSuspend$annotations"()Ljava/lang/String;"()Ljava/lang/String;"parameters"parameters"Lkotlin/reflect/KParameter;"Lkotlin/reflect/KParameter;"getParameters"getParameters"()Ljava/util/List;"()Ljava/util/List;"returnType""Lkotlin/reflect/KType;"Lkotlin/reflect/KType;"getReturnType"getReturnType"()Lkotlin/reflect/KType;"()Lkotlin/reflect/KType;"typeParameters"typeParameters"Lkotlin/reflect/KTypeParameter;"Lkotlin/reflect/KTypeParameter;"getTypeParameters$annotations"getTypeParameters$annotations"getTypeParameters""visibility"visibility"Lkotlin/reflect/KVisibility;"Lkotlin/reflect/KVisibility;"getVisibility$annotations"getVisibility$annotations"getVisibility"getVisibility"()Lkotlin/reflect/KVisibility;"()Lkotlin/reflect/KVisibility;"call""([Ljava/lang/Object;)Ljava/lang/Object;"([Ljava/lang/Object;)Ljava/lang/Object;"callBy"callBy"(Ljava/util/Map;)Ljava/lang/Object;"(Ljava/util/Map;)Ljava/lang/Object;"kotlin-stdlib"Function<T>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.21/4a668382d7c38688d3490afde93b6a113ed46698/kotlin-stdlib-1.4.21.jar/kotlin/Function.class" \n\n \n \n f *  20" 

 
 
 f *  20"Lkotlin/Function;"Lkotlin/Function;" \n\n \n\n\n \n\nf *  2H02H0R08&XR\t08&X\n\tR08&XR\r08&X\rR08&X" 

 


 

f *  2H02H0R08&XR	08&X
	R08&XR08&XR08&X"Lkotlin/reflect/KFunction;"Lkotlin/reflect/KFunction;"isExternal"isExternal"isExternal$annotations"isExternal$annotations"isInfix"isInfix"isInfix$annotations"isInfix$annotations"isInline"isInline"isInline$annotations"isInline$annotations"isOperator"isOperator"isOperator$annotations"isOperator$annotationsprimaryCtorKClass<>C:/Users/Semiu/.gradle/caches/modules-2/files-2.1/org.jetbrains.kotlin/kotlin-stdlib/1.4.21/4a668382d7c38688d3490afde93b6a113ed46698/kotlin-stdlib-1.4.21.jar/kotlin/reflect/KClass.classKClass" d\n\n \n \n\n\n\n \n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\nf * *0202020J>02?0HJ@0AH&JB02C0H'R\n8 00X\t\nR08&X\rR08&XR08&XR08&XR08&XR08&XR08&XR08&XR00X \nR!0 0X\"\nR#8 X$%R&0'X()R(*\n8 0 0+8&X,-.R/0'X0)R 1020+8&X34.R 5060+8&X78.R90:8&X;<=D" d

 
 



 









 








f * *0202020J>02?0HJ@0AH&JB02C0H'R
8 00X	
R08&XR08&XR08&XR08&XR08&XR08&XR08&XR08&XR00X 
R!0 0X"
R#8 X$%R&0'X()R(*
8 0 0+8&X,-.R/0'X0)R 1020+8&X34.R 5060+8&X78.R90:8&X;<=D"Lkotlin/reflect/KClass;"Lkotlin/reflect/KClass;"T""Lkotlin/reflect/KDeclarationContainer;"Lkotlin/reflect/KDeclarationContainer;"Lkotlin/reflect/KClassifier;"Lkotlin/reflect/KClassifier;"constructors"constructors"getConstructors""()Ljava/util/Collection;"()Ljava/util/Collection;"isCompanion"isCompanion"isCompanion$annotations"isCompanion$annotations"isData"isData"isData$annotations"isData$annotations"isFun"isFun"isFun$annotations"isFun$annotations"isInner"isInner"isInner$annotations"isInner$annotations"isSealed""isSealed$annotations"isSealed$annotations"members"members"getMembers"getMembers"nestedClasses"nestedClasses"getNestedClasses"getNestedClasses"objectInstance"objectInstance"getObjectInstance"getObjectInstance"()Ljava/lang/Object;"()Ljava/lang/Object;"qualifiedName"qualifiedName"getQualifiedName"getQualifiedName"sealedSubclasses"sealedSubclasses"getSealedSubclasses$annotations"getSealedSubclasses$annotations"getSealedSubclasses"getSealedSubclasses"simpleName"simpleName"getSimpleName""supertypes"supertypes"getSupertypes$annotations"getSupertypes$annotations"getSupertypes"getSupertypes"equals""other""isInstance"KFunction<>KCallable<>KClass<T>"Failed to find Java constructor for Kotlin primary constructor: "Failed to find Java constructor for Kotlin primary constructor: kotlinConstructorList<KParameter>Collection<KParameter>Iterable<KParameter>getParameters()isSuspend()isAbstract()isOpen()isFinal()getVisibility()Map<KParameter,? extends Object>callBy(java.util.Map)call(java.lang.Object[])List<KTypeParameter>Collection<KTypeParameter>Iterable<KTypeParameter>getReturnType()Map<KParameter,Object>argParametersHashMap<KParameter,Object>AbstractMap<KParameter,Object>Spliterator<KParameter>? super KParameterConsumer<? super KParameter>Iterator<KParameter>Stream<KParameter>BaseStream<KParameter,Stream<KParameter>>Predicate<? super KParameter>? extends KParameterCollection<? extends KParameter>Iterable<? extends KParameter>add(kotlin.reflect.KParameter)ListIterator<KParameter>add(int,kotlin.reflect.KParameter)set(int,kotlin.reflect.KParameter)Comparator<? super KParameter>UnaryOperator<KParameter>Function<KParameter,KParameter>KCallable<?>"Number of provided arguments should be less of equals than number of constructor parameters"Number of provided arguments should be less of equals than number of constructor parametersput(kotlin.reflect.KParameter,java.lang.Object)merge(kotlin.reflect.KParameter,java.lang.Object,java.util.function.BiFunction)BiFunction<? super KParameter,? super Object,? extends Object>compute(kotlin.reflect.KParameter,java.util.function.BiFunction)computeIfPresent(kotlin.reflect.KParameter,java.util.function.BiFunction)Function<? super KParameter,? extends Object>computeIfAbsent(kotlin.reflect.KParameter,java.util.function.Function)replace(kotlin.reflect.KParameter,java.lang.Object)replace(kotlin.reflect.KParameter,java.lang.Object,java.lang.Object)putIfAbsent(kotlin.reflect.KParameter,java.lang.Object)BiConsumer<? super KParameter,? super Object>Entry<KParameter,Object>Set<Entry<KParameter,Object>>Collection<Entry<KParameter,Object>>Iterable<Entry<KParameter,Object>>Set<KParameter>Map<? extends KParameter,? extends Object>Static convenience methods for JavaBeans: for instantiating beans,checking bean property types, copying bean properties, etc.<p>Mainly for internal use within the framework, but to some degree alsouseful for application classes. Consider<a href="https://commons.apache.org/proper/commons-beanutils/">Apache Commons BeanUtils</a>,<a href="https://hotelsdotcom.github.io/bull/">BULL - Bean Utils Light Library</a>,or similar third-party frameworks for more comprehensive bean utilities.Convenience method to instantiate a class using its no-arg constructor.class to instantiatethe new instanceif the bean cannot be instantiated@deprecatedas of Spring 5.0, following the deprecation of{@link Class#newInstance()} in JDK 9Class#newInstance()Instantiate a class using its 'primary' constructor (for Kotlin classes,potentially having default arguments declared) or its default constructor(for regular Java classes, expecting a standard no-arg setup).<p>Note that this method tries to set the constructor accessibleif given a non-accessible (that is, non-public) constructor.the class to instantiateif the bean cannot be instantiated.The cause may notably indicate a {@link NoSuchMethodException} if noprimary/default constructor was found, a {@link NoClassDefFoundError}or other {@link LinkageError} in case of an unresolvable class definition(e.g. due to a missing dependency at runtime), or an exception thrownfrom the constructor invocation itself.Constructor#newInstanceInstantiate a class using its no-arg constructor and return the new instanceas the specified assignable type.<p>Useful in cases where the type of the class to instantiate (clazz) is notavailable, but the type desired (assignableTo) is known.<p>Note that this method tries to set the constructor accessible if given anon-accessible (that is, non-public) constructor.type that clazz must be assignableToConvenience method to instantiate a class using the given constructor.non-accessible (that is, non-public) constructor, and supports Kotlin classeswith optional parameters and default values.the constructor to instantiatethe constructor arguments to apply (use {@code null} for an unspecifiedparameter, Kotlin optional parameters and Java primitive types are supported)Return a resolvable constructor for the provided class, either a primary constructoror single public constructor or simply a default constructor. Callers have to beprepared to resolve arguments for the returned constructor's parameters, if any.the class to check#findPrimaryConstructorReturn the primary constructor of the provided class. For Kotlin classes, thisreturns the Java constructor corresponding to the Kotlin primary constructor(as defined in the Kotlin specification). Otherwise, in particular for non-Kotlinclasses, this simply returns {@code null}.<a href="https://kotlinlang.org/docs/reference/classes.html#constructors">Kotlin docs</a>Find a method with the given method name and the given parameter types,declared on the given class or one of its superclasses. Prefers public methods,but will return a protected, package access, or private method too.<p>Checks {@code Class.getMethod} first, falling back to{@code findDeclaredMethod}. This allows to find public methodswithout issues even in environments with restricted Java security settings.the name of the method to findthe parameter types of the method to findthe Method object, or {@code null} if not foundClass#getMethod#findDeclaredMethoddeclared on the given class or one of its superclasses. Will return a public,protected, package access, or private method.<p>Checks {@code Class.getDeclaredMethod}, cascading upwards to all superclasses.Class#getDeclaredMethodFind a method with the given method name and minimal parameters (best case: none),<p>Checks {@code Class.getMethods} first, falling back to{@code findDeclaredMethodWithMinimalParameters}. This allows for finding publicmethods without issues even in environments with restricted Java security settings.if methods of the given name were found butcould not be resolved to a unique method with minimal parametersClass#getMethods#findDeclaredMethodWithMinimalParameters<p>Checks {@code Class.getDeclaredMethods}, cascading upwards to all superclasses.Class#getDeclaredMethodsFind a method with the given method name and minimal parameters (best case: none)in the given list of methods.the methods to check Prefer regular method over bridge... Additional candidate with same lengthParse a method signature in the form {@code methodName[([arg_list])]},where {@code arg_list} is an optional, comma-separated list of fully-qualifiedtype names, and attempts to resolve that signature against the supplied {@code Class}.<p>When not supplying an argument list ({@code methodName}) the method whose namematches and has the least number of parameters will be returned. When supplying anargument type list, only the method whose name and argument types match will be returned.<p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>resolved in the same way. The signature {@code methodName} means the method called{@code methodName} with the least number of arguments, whereas {@code methodName()}means the method called {@code methodName} with exactly 0 arguments.<p>If no method can be found, then {@code null} is returned.the method signature as String representationthe class to resolve the method signature againstthe resolved Method#findMethod#findMethodWithMinimalParametersRetrieve the JavaBeans {@code PropertyDescriptor}s of a given class.the Class to retrieve the PropertyDescriptors foran array of {@code PropertyDescriptors} for the given classif PropertyDescriptor look failsRetrieve the JavaBeans {@code PropertyDescriptors} for the given property.the Class to retrieve the PropertyDescriptor forthe name of the propertythe corresponding PropertyDescriptor, or {@code null} if noneif PropertyDescriptor lookup failsFind a JavaBeans {@code PropertyDescriptor} for the given method,with the method either being the read method or the write method forthat bean property.the method to find a corresponding PropertyDescriptor for,introspecting its declaring classthe method to find a corresponding PropertyDescriptor forthe (most specific) class to introspect for descriptors3.2.13Find a JavaBeans PropertyEditor following the 'Editor' suffix convention(e.g. "mypackage.MyDomainClass" -> "mypackage.MyDomainClassEditor").<p>Compatible to the standard JavaBeans convention as implemented by{@link java.beans.PropertyEditorManager} but isolated from the latter'sregistered default editors for primitive types.the type to find an editor forthe corresponding editor, or {@code null} if none found e.g. AccessControlException on Google App Engine Misbehaving ClassLoader returned null instead of ClassNotFoundException - fall back to unknown editor type registration below Ignore - fall back to unknown editor type registration belowDetermine the bean property type for the given property from thegiven classes/interfaces, if possible.the name of the bean propertythe classes to check againstthe property type, or {@code Object.class} as fallbackObtain a new MethodParameter object for the write method of thespecified property.the PropertyDescriptor for the propertya corresponding MethodParameter objectDetermine required parameter names for the given constructor,considering the JavaBeans {@link ConstructorProperties} annotationas well as Spring's {@link DefaultParameterNameDiscoverer}.the constructor to find parameter names forthe parameter names (matching the constructor's parameter count)if the parameter names are not resolvableConstructorPropertiesDefaultParameterNameDiscovererCheck if the given type represents a "simple" property: a simple valuetype or an array of simple value types.<p>See {@link #isSimpleValueType(Class)} for the definition of <em>simplevalue type</em>.<p>Used to determine properties to check for a "simple" dependency-check.the type to checkwhether the given type represents a "simple" propertyorg.springframework.beans.factory.support.RootBeanDefinition#DEPENDENCY_CHECK_SIMPLEorg.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#checkDependencies#isSimpleValueType(Class)Check if the given type represents a "simple" value type: a primitive orprimitive wrapper, an enum, a String or other CharSequence, a Number, aDate, a Temporal, a URI, a URL, a Locale, or a Class.<p>{@code Void} and {@code void} are not considered simple value types.whether the given type represents a "simple" value type#isSimpleProperty(Class)Copy the property values of the given source bean into the target bean.<p>Note: The source and target classes do not have to match or even be derivedfrom each other, as long as the properties match. Any bean properties that thesource bean exposes but the target bean does not will silently be ignored.<p>This is just a convenience method. For more complex transfer needs,consider using a full BeanWrapper.the source beanthe target beanif the copying failedCopy the property values of the given source bean into the given target bean,only setting properties defined in the given "editable" class (or interface).the class (or interface) to restrict property setting toignoring the given "ignoreProperties".array of property names to ignoreCopy the property values of the given source bean into the given target bean.<p>As of Spring Framework 5.3, this method honors generic type informationwhen matching properties in the source and target objects. Ignore generic types in assignable check if either ResolvableType has unresolvable generics.Inner class to avoid a hard dependency on Kotlin at runtime.Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any.the {@link Class} of the Kotlin class<a href="https://kotlinlang.org/docs/reference/classes.html#constructors">https://kotlinlang.org/docs/reference/classes.html#constructors</a>Instantiate a Kotlin class using the provided constructor.the constructor of the Kotlin class to instantiatethe constructor arguments to apply(use {@code null} for unspecified parameter if needed)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeanWrapper.javaThe central interface of Spring's low-level JavaBeans infrastructure.<p>Typically not used directly but rather implicitly via a{@link org.springframework.beans.factory.BeanFactory} or a{@link org.springframework.validation.DataBinder}.<p>Provides operations to analyze and manipulate standard JavaBeans:the ability to get and set property values (individually or in bulk),get property descriptors, and query the readability/writability of properties.<p>This interface supports <b>nested properties</b> enabling the settingof properties on subproperties to an unlimited depth.<p>A BeanWrapper's default for the "extractOldValueForEditor" settingis "false", to avoid side effects caused by getter method invocations.Turn this to "true" to expose present property values to custom editors.13 April 2001PropertyAccessorPropertyEditorRegistryPropertyAccessorFactory#forBeanPropertyAccessorg.springframework.validation.BeanPropertyBindingResultorg.springframework.validation.DataBinder#initBeanPropertyAccess()<p>Default is unlimited on a plain BeanWrapper.Return the bean instance wrapped by this object.Return the type of the wrapped bean instance.Obtain the PropertyDescriptors for the wrapped object(as determined by standard JavaBeans introspection).the PropertyDescriptors for the wrapped objectObtain the property descriptor for a specific propertyof the wrapped object.(may be a nested path, but no indexed/mapped property)the property descriptor for the specified propertyif there is no such propertyC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.javaBeanWrapperImplpropertyproperty(java.beans.PropertyDescriptor)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/BeanWrapperImpl.classgetCachedIntrospectionResultsgetCachedIntrospectionResults()BeanWrapperImpl(java.lang.Object,java.lang.String,org.springframework.beans.BeanWrapperImpl)acccachedIntrospectionResults"No property '"No property '"' found"' foundgpdnestedBwC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/BeanWrapperImpl$BeanPropertyHandler.classBeanWrapperImpl$BeanPropertyHandlerjava.securityPrivilegedAction<>C:/modules/java.base/java/security/PrivilegedAction.classPrivilegedActionC:/modules/java.base/java/securitysecurityPrivilegedAction<Object>PrivilegedExceptionAction<>C:/modules/java.base/java/security/PrivilegedExceptionAction.classPrivilegedExceptionActionPrivilegedExceptionAction<Object>paeDefault {@link BeanWrapper} implementation that should be sufficientfor all typical use cases. Caches introspection results for efficiency.<p>Note: Auto-registers default property editors from the{@code org.springframework.beans.propertyeditors} package, which applyin addition to the JDK's standard PropertyEditors. Applications can callthe {@link #registerCustomEditor(Class, java.beans.PropertyEditor)} methodto register an editor for a particular instance (i.e. they are not sharedacross the application). See the base class{@link PropertyEditorRegistrySupport} for details.<p><b>NOTE: As of Spring 2.5, this is - for almost all purposes - aninternal class.</b> It is just public in order to allow for access fromother framework packages. For standard application access purposes, use the{@link PropertyAccessorFactory#forBeanPropertyAccess} factory method instead.15 April 2001Cached introspections results for this object, to prevent encounteringthe cost of JavaBeans introspection every time.The security context used for invoking the property methods.Create a new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards.(can be suppressed if the BeanWrapper won't need any type conversion)Create a new BeanWrapperImpl for the given object.the object wrapped by this BeanWrapperCreate a new BeanWrapperImpl, wrapping a new instance of the specified class.Create a new BeanWrapperImpl for the given object,the containing BeanWrapper (must not be {@code null})Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}.the actual target object#setWrappedInstance(Object)Set the class to introspect.Needs to be called when the target object changes.the class to introspectObtain a lazily initialized CachedIntrospectionResults instancefor the wrapped object.Set the security context used during the invocation of the wrapped instance methods.Can be null.Return the security context used during the invocation of the wrapped instance methods.Convert the given value for the specified property to the latter's type.<p>This method is only intended for optimizations in a BeanFactory.Use the {@code convertIfNecessary} methods for programmatic conversion.the value to convertthe target property(note that nested or indexed properties are not supported here)the new value, possibly the result of type conversionTypeMismatchExceptionif type conversion failedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/BeansException.javaAbstract superclass for all exceptions thrown in the beans packageand subpackages.<p>Note that this is a runtime (unchecked) exception. Beans exceptionsare usually fatal; there is no reason for them to be checked.Create a new BeansException with the specified message.Create a new BeansException with the specified messageand root cause.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/CachedIntrospectionResults.javagetTypeDescriptorgetTypeDescriptor(java.beans.PropertyDescriptor)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/CachedIntrospectionResults.classaddTypeDescriptoraddTypeDescriptor(java.beans.PropertyDescriptor,org.springframework.core.convert.TypeDescriptor)buildGenericTypeAwarePropertyDescriptorbuildGenericTypeAwarePropertyDescriptor(java.lang.Class,java.beans.PropertyDescriptor)getPropertyDescriptorsgetPropertyDescriptors()getPropertyDescriptorgetPropertyDescriptor(java.lang.String)getBeanClassgetBeanClass()getBeanInfogetBeanInfo()isPlainAccessorisPlainAccessor(java.lang.reflect.Method)introspectPlainAccessorsintrospectPlainAccessors(java.lang.Class,java.util.Set)introspectInterfacesintrospectInterfaces(java.lang.Class,java.lang.Class,java.util.Set)CachedIntrospectionResults(java.lang.Class)ConcurrentMap<PropertyDescriptor,TypeDescriptor>Map<PropertyDescriptor,TypeDescriptor>typeDescriptorCacheMap<String,PropertyDescriptor>propertyDescriptorsbeanInfogetBeanInfo(java.lang.Class)isUnderneathClassLoaderisUnderneathClassLoader(java.lang.ClassLoader,java.lang.ClassLoader)isClassLoaderAcceptedisClassLoaderAccepted(java.lang.ClassLoader)forClassforClass(java.lang.Class)ConcurrentMap<Class<?>,CachedIntrospectionResults>Map<Class<?>,CachedIntrospectionResults>softClassCachestrongClassCacheSet<ClassLoader>Collection<ClassLoader>Iterable<ClassLoader>acceptedClassLoadersList<BeanInfoFactory>Collection<BeanInfoFactory>Iterable<BeanInfoFactory>beanInfoFactoriesshouldIntrospectorIgnoreBeaninfoClassesEMPTY_PROPERTY_DESCRIPTOR_ARRAY"spring.beaninfo.ignore"spring.beaninfo.ignoreClass<BeanInfoFactory>Class<CachedIntrospectionResults>Map<String,CachedIntrospectionResults>CachedIntrospectionResults[]Constructor<CachedIntrospectionResults>? super CachedIntrospectionResultsClass<? super CachedIntrospectionResults>TypeVariable<Class<CachedIntrospectionResults>>TypeVariable<Class<CachedIntrospectionResults>>[]ConcurrentHashMap<ClassLoader,Boolean>AbstractMap<ClassLoader,Boolean>Map<ClassLoader,Boolean>ConcurrentMap<ClassLoader,Boolean>ConcurrentHashMap<Class<?>,CachedIntrospectionResults>AbstractMap<Class<?>,CachedIntrospectionResults>ConcurrentHashMap<Class<?>,CachedIntrospectionResults>(int)? extends CachedIntrospectionResultsBiFunction<? super CachedIntrospectionResults,? super CachedIntrospectionResults,? extends CachedIntrospectionResults>merge(java.lang.Class,org.springframework.beans.CachedIntrospectionResults,java.util.function.BiFunction)BiFunction<? super Class<?>,? super CachedIntrospectionResults,? extends CachedIntrospectionResults>Function<? super Class<?>,? extends CachedIntrospectionResults>replace(java.lang.Class,org.springframework.beans.CachedIntrospectionResults)replace(java.lang.Class,org.springframework.beans.CachedIntrospectionResults,org.springframework.beans.CachedIntrospectionResults)putIfAbsent(java.lang.Class,org.springframework.beans.CachedIntrospectionResults)BiConsumer<? super Class<?>,? super CachedIntrospectionResults>getOrDefault(java.lang.Object,org.springframework.beans.CachedIntrospectionResults)Entry<Class<?>,CachedIntrospectionResults>Set<Entry<Class<?>,CachedIntrospectionResults>>Collection<Entry<Class<?>,CachedIntrospectionResults>>Iterable<Entry<Class<?>,CachedIntrospectionResults>>Collection<CachedIntrospectionResults>Iterable<CachedIntrospectionResults>Map<? extends Class<?>,? extends CachedIntrospectionResults>put(java.lang.Class,org.springframework.beans.CachedIntrospectionResults)AbstractMap<Class<?>,CachedIntrospectionResults>()ToIntFunction<Entry<Class<?>,CachedIntrospectionResults>>ToLongFunction<Entry<Class<?>,CachedIntrospectionResults>>ToDoubleFunction<Entry<Class<?>,CachedIntrospectionResults>>Function<Entry<Class<?>,CachedIntrospectionResults>,? extends U>? extends Entry<Class<?>,CachedIntrospectionResults>BiFunction<Entry<Class<?>,CachedIntrospectionResults>,Entry<Class<?>,CachedIntrospectionResults>,? extends Entry<Class<?>,CachedIntrospectionResults>>? super Entry<Class<?>,CachedIntrospectionResults>Consumer<? super Entry<Class<?>,CachedIntrospectionResults>>ToIntFunction<? super CachedIntrospectionResults>ToLongFunction<? super CachedIntrospectionResults>ToDoubleFunction<? super CachedIntrospectionResults>Function<? super CachedIntrospectionResults,? extends U>Consumer<? super CachedIntrospectionResults>ToIntBiFunction<? super Class<?>,? super CachedIntrospectionResults>ToLongBiFunction<? super Class<?>,? super CachedIntrospectionResults>ToDoubleBiFunction<? super Class<?>,? super CachedIntrospectionResults>BiFunction<? super Class<?>,? super CachedIntrospectionResults,? extends U>Node<Class<?>,CachedIntrospectionResults>Node<Class<?>,CachedIntrospectionResults>[]KeySetView<Class<?>,CachedIntrospectionResults>CollectionView<Class<?>,CachedIntrospectionResults,Class<?>>keySet(org.springframework.beans.CachedIntrospectionResults)Enumeration<CachedIntrospectionResults>Predicate<? super CachedIntrospectionResults>Predicate<? super Entry<Class<?>,CachedIntrospectionResults>>replaceNode(java.lang.Object,org.springframework.beans.CachedIntrospectionResults,java.lang.Object)putVal(java.lang.Class,org.springframework.beans.CachedIntrospectionResults,boolean)ConcurrentHashMap<Class<?>,CachedIntrospectionResults>(int,float,int)ConcurrentHashMap<Class<?>,CachedIntrospectionResults>(int,float)ConcurrentHashMap<Class<?>,CachedIntrospectionResults>(java.util.Map)ConcurrentHashMap<Class<?>,CachedIntrospectionResults>()ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>(int)Reference<Class<?>,CachedIntrospectionResults>ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>(int,float,int,org.springframework.util.ConcurrentReferenceHashMap.ReferenceType)ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>(int,float,int)ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>(int,org.springframework.util.ConcurrentReferenceHashMap.ReferenceType)ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>(int,int)ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>(int,float)ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>()add(java.lang.ClassLoader)Spliterator<ClassLoader>? super ClassLoaderConsumer<? super ClassLoader>Iterator<ClassLoader>Stream<ClassLoader>BaseStream<ClassLoader,Stream<ClassLoader>>Predicate<? super ClassLoader>? extends ClassLoaderCollection<? extends ClassLoader>Iterable<? extends ClassLoader>Predicate<ClassLoader>test(java.lang.ClassLoader)registeredLoaderPredicate<Class<?>>test(java.lang.Class)resultsclassCacheToUseexisting"Not strongly caching class ["Not strongly caching class ["] because it is not cache-safe"] because it is not cache-safeacceptedLoaderclassLoaderToCheckbeanInfoFactoryreadMethodNames"Getting BeanInfo for class ["Getting BeanInfo for class ["Caching PropertyDescriptors for class ["Caching PropertyDescriptors for class [LinkedHashMap<String,PropertyDescriptor>HashMap<String,PropertyDescriptor>AbstractMap<String,PropertyDescriptor>LinkedHashMap<String,PropertyDescriptor>()? super PropertyDescriptor? extends PropertyDescriptorBiFunction<? super PropertyDescriptor,? super PropertyDescriptor,? extends PropertyDescriptor>merge(java.lang.String,java.beans.PropertyDescriptor,java.util.function.BiFunction)BiFunction<? super String,? super PropertyDescriptor,? extends PropertyDescriptor>Function<? super String,? extends PropertyDescriptor>replace(java.lang.String,java.beans.PropertyDescriptor)replace(java.lang.String,java.beans.PropertyDescriptor,java.beans.PropertyDescriptor)putIfAbsent(java.lang.String,java.beans.PropertyDescriptor)BiConsumer<? super String,? super PropertyDescriptor>getOrDefault(java.lang.Object,java.beans.PropertyDescriptor)Entry<String,PropertyDescriptor>Set<Entry<String,PropertyDescriptor>>Collection<Entry<String,PropertyDescriptor>>Iterable<Entry<String,PropertyDescriptor>>Collection<PropertyDescriptor>Iterable<PropertyDescriptor>Map<? extends String,? extends PropertyDescriptor>put(java.lang.String,java.beans.PropertyDescriptor)AbstractMap<String,PropertyDescriptor>()Node<String,PropertyDescriptor>TreeNode<String,PropertyDescriptor>newTreeNode(int,java.lang.String,java.beans.PropertyDescriptor,java.util.HashMap.Node)newNode(int,java.lang.String,java.beans.PropertyDescriptor,java.util.HashMap.Node)Node<String,PropertyDescriptor>[]putVal(int,java.lang.String,java.beans.PropertyDescriptor,boolean,boolean)HashMap<String,PropertyDescriptor>(java.util.Map)HashMap<String,PropertyDescriptor>()HashMap<String,PropertyDescriptor>(int)HashMap<String,PropertyDescriptor>(int,float)removeEldestEntryremoveEldestEntry(java.util.Map.Entry)LinkedHashMap(int,float,boolean)LinkedHashMap<String,PropertyDescriptor>(int,float,boolean)LinkedHashMap(java.util.Map)LinkedHashMap<String,PropertyDescriptor>(java.util.Map)LinkedHashMap()LinkedHashMap(int)LinkedHashMap<String,PropertyDescriptor>(int)LinkedHashMap(int,float)LinkedHashMap<String,PropertyDescriptor>(int,float)accessOrdertailhead"classLoader""protectionDomain""Found bean property '"Found bean property '"; editor ["; editor [ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>AbstractMap<PropertyDescriptor,TypeDescriptor>ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>()BiFunction<? super TypeDescriptor,? super TypeDescriptor,? extends TypeDescriptor>merge(java.beans.PropertyDescriptor,org.springframework.core.convert.TypeDescriptor,java.util.function.BiFunction)BiFunction<? super PropertyDescriptor,? super TypeDescriptor,? extends TypeDescriptor>compute(java.beans.PropertyDescriptor,java.util.function.BiFunction)computeIfPresent(java.beans.PropertyDescriptor,java.util.function.BiFunction)Function<? super PropertyDescriptor,? extends TypeDescriptor>computeIfAbsent(java.beans.PropertyDescriptor,java.util.function.Function)replace(java.beans.PropertyDescriptor,org.springframework.core.convert.TypeDescriptor)replace(java.beans.PropertyDescriptor,org.springframework.core.convert.TypeDescriptor,org.springframework.core.convert.TypeDescriptor)putIfAbsent(java.beans.PropertyDescriptor,org.springframework.core.convert.TypeDescriptor)BiConsumer<? super PropertyDescriptor,? super TypeDescriptor>getOrDefault(java.lang.Object,org.springframework.core.convert.TypeDescriptor)Entry<PropertyDescriptor,TypeDescriptor>Set<Entry<PropertyDescriptor,TypeDescriptor>>Collection<Entry<PropertyDescriptor,TypeDescriptor>>Iterable<Entry<PropertyDescriptor,TypeDescriptor>>Set<PropertyDescriptor>Map<? extends PropertyDescriptor,? extends TypeDescriptor>put(java.beans.PropertyDescriptor,org.springframework.core.convert.TypeDescriptor)AbstractMap<PropertyDescriptor,TypeDescriptor>()Reference<PropertyDescriptor,TypeDescriptor>ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>(int,float,int,org.springframework.util.ConcurrentReferenceHashMap.ReferenceType)ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>(int,float,int)ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>(int,org.springframework.util.ConcurrentReferenceHashMap.ReferenceType)ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>(int,int)ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>(int,float)ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>(int)"Failed to obtain BeanInfo for class ["Failed to obtain BeanInfo for class [existingPdSpliterator<PropertyDescriptor>Consumer<? super PropertyDescriptor>Iterator<PropertyDescriptor>Stream<PropertyDescriptor>BaseStream<PropertyDescriptor,Stream<PropertyDescriptor>>Predicate<? super PropertyDescriptor>Collection<? extends PropertyDescriptor>Iterable<? extends PropertyDescriptor>add(java.beans.PropertyDescriptor)"Failed to re-introspect class ["Failed to re-introspect class [Internal class that caches JavaBeans {@link java.beans.PropertyDescriptor}information for a Java class. Not intended for direct use by application code.<p>Necessary for Spring's own caching of bean descriptors within the application{@link ClassLoader}, rather than relying on the JDK's system-wide {@link BeanInfo}cache (in order to avoid leaks on individual application shutdown in a shared JVM).<p>Information is cached statically, so we don't need to create newobjects of this class for every JavaBean we manipulate. Hence, this classimplements the factory design pattern, using a private constructor anda static {@link #forClass(Class)} factory method to obtain instances.<p>Note that for caching to work effectively, some preconditions need to be met:Prefer an arrangement where the Spring jars live in the same ClassLoader as theapplication classes, which allows for clean caching along with the application'slifecycle in any case. For a web application, consider declaring a local{@link org.springframework.web.util.IntrospectorCleanupListener} in {@code web.xml}in case of a multi-ClassLoader layout, which will allow for effective caching as well.<p>In case of a non-clean ClassLoader arrangement without a cleanup listener havingbeen set up, this class will fall back to a weak-reference-based caching model thatrecreates much-requested entries every time the garbage collector removed them. Insuch a scenario, consider the {@link #IGNORE_BEANINFO_PROPERTY_NAME} system property.05 May 2001#acceptClassLoader(ClassLoader)#clearClassLoader(ClassLoader)#forClass(Class)System property that instructs Spring to use the {@link Introspector#IGNORE_ALL_BEANINFO}mode when calling the JavaBeans {@link Introspector}: "spring.beaninfo.ignore", with avalue of "true" skipping the search for {@code BeanInfo} classes (typically for scenarioswhere no such classes are being defined for beans in the application in the first place).<p>The default is "false", considering all {@code BeanInfo} metadata classes, like forstandard {@link Introspector#getBeanInfo(Class)} calls. Consider switching this flag to"true" if you experience repeated ClassLoader access for non-existing {@code BeanInfo}classes, in case such access is expensive on startup or on lazy loading.<p>Note that such an effect may also indicate a scenario where caching doesn't workeffectively: Prefer an arrangement where the Spring jars live in the same ClassLoaderas the application classes, which allows for clean caching along with the application'sIntrospector#getBeanInfo(Class, int)Stores the BeanInfoFactory instances.Set of ClassLoaders that this CachedIntrospectionResults class will alwaysaccept classes from, even if the classes do not qualify as cache-safe.Map keyed by Class containing CachedIntrospectionResults, strongly held.This variant is being used for cache-safe bean classes.Map keyed by Class containing CachedIntrospectionResults, softly held.This variant is being used for non-cache-safe bean classes.Accept the given ClassLoader as cache-safe, even if its classes wouldnot qualify as cache-safe in this CachedIntrospectionResults class.<p>This configuration method is only relevant in scenarios where the Springclasses reside in a 'common' ClassLoader (e.g. the system ClassLoader)whose lifecycle is not coupled to the application. In such a scenario,CachedIntrospectionResults would by default not cache any of the application'sclasses, since they would create a leak in the common ClassLoader.<p>Any {@code acceptClassLoader} call at application startup shouldbe paired with a {@link #clearClassLoader} call at application shutdown.the ClassLoader to acceptClear the introspection cache for the given ClassLoader, removing theintrospection results for all classes underneath that ClassLoader, andremoving the ClassLoader (and its children) from the acceptance list.the ClassLoader to clear the cache forCreate CachedIntrospectionResults for the given bean class.the bean class to analyzethe corresponding CachedIntrospectionResultsCheck whether this CachedIntrospectionResults class is configuredto accept the given ClassLoader.the ClassLoader to checkwhether the given ClassLoader is accepted#acceptClassLoaderCheck whether the given ClassLoader is underneath the given parent,that is, whether the parent is within the candidate's hierarchy.the candidate ClassLoader to checkthe parent ClassLoader to check forRetrieve a {@link BeanInfo} descriptor for the given target class.the target class to introspectthe resulting {@code BeanInfo} descriptor (never {@code null})from the underlying {@link Introspector}The BeanInfo object for the introspected bean class.PropertyDescriptor objects keyed by property name String.TypeDescriptor objects keyed by PropertyDescriptor.Create a new CachedIntrospectionResults instance for the given class. This call is slow so we do it once. Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those Explicitly check implemented interfaces for setter/getter methods as well, in particular for Java 8 default methods... Check for record-style accessors without prefix: e.g. "lastName()" - accessor method directly referring to instance field of same name - same convention for component accessors of Java 15 record classes GenericTypeAwarePropertyDescriptor leniently resolves a set* write method against a declared read method, so we prefer read method descriptors here. Accessor method referring to instance field of same name? Same lenient fallback checking as in Property...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/ConfigurablePropertyAccessor.javaConfigurablePropertyAccessorInterface that encapsulates configuration methods for a PropertyAccessor.Also extends the PropertyEditorRegistry interface, which defines methodsfor PropertyEditor management.<p>Serves as base interface for {@link BeanWrapper}.Specify a Spring 3.0 ConversionService to use for convertingproperty values, as an alternative to JavaBeans PropertyEditors.Return the associated ConversionService, if any.Set whether to extract the old property value when applying aproperty editor to a new value for a property.Return whether to extract the old property value when applying aSet whether this instance should attempt to "auto-grow" anested path that contains a {@code null} value.<p>If {@code true}, a {@code null} path location will be populatedwith a default object value and traversed instead of resulting in a{@link NullValueInNestedPathException}.<p>Default is {@code false} on a plain PropertyAccessor instance.Return whether "auto-growing" of nested paths has been activated.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/ConversionNotSupportedException.javaConversionNotSupportedExceptionException thrown when no suitable editor or converter can be found for a bean property.Create a new ConversionNotSupportedException.the PropertyChangeEvent that resulted in the problemthe required target type (or {@code null} if not known)the root cause (may be {@code null})the offending value that couldn't be converted (may be {@code null})C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/DirectFieldAccessor.javaDirectFieldAccessorMap<String,FieldPropertyHandler>fieldMapC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/DirectFieldAccessor.classHashMap<String,FieldPropertyHandler>AbstractMap<String,FieldPropertyHandler>HashMap<String,FieldPropertyHandler>()? super FieldPropertyHandler? extends FieldPropertyHandlerBiFunction<? super FieldPropertyHandler,? super FieldPropertyHandler,? extends FieldPropertyHandler>merge(java.lang.String,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler,java.util.function.BiFunction)BiFunction<? super String,? super FieldPropertyHandler,? extends FieldPropertyHandler>Function<? super String,? extends FieldPropertyHandler>replace(java.lang.String,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler)replace(java.lang.String,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler)putIfAbsent(java.lang.String,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler)BiConsumer<? super String,? super FieldPropertyHandler>getOrDefault(java.lang.Object,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler)Entry<String,FieldPropertyHandler>Set<Entry<String,FieldPropertyHandler>>Collection<Entry<String,FieldPropertyHandler>>Iterable<Entry<String,FieldPropertyHandler>>Collection<FieldPropertyHandler>Iterable<FieldPropertyHandler>Map<? extends String,? extends FieldPropertyHandler>put(java.lang.String,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler)AbstractMap<String,FieldPropertyHandler>()Node<String,FieldPropertyHandler>TreeNode<String,FieldPropertyHandler>newTreeNode(int,java.lang.String,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler,java.util.HashMap.Node)newNode(int,java.lang.String,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler,java.util.HashMap.Node)Node<String,FieldPropertyHandler>[]putVal(int,java.lang.String,org.springframework.beans.DirectFieldAccessor.FieldPropertyHandler,boolean,boolean)HashMap<String,FieldPropertyHandler>(java.util.Map)HashMap<String,FieldPropertyHandler>(int)HashMap<String,FieldPropertyHandler>(int,float)propertyHandlerC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/DirectFieldAccessor$FieldPropertyHandler.classDirectFieldAccessor$FieldPropertyHandler"Field is not accessible"Field is not accessible{@link ConfigurablePropertyAccessor} implementation that directly accessesinstance fields. Allows for direct binding to fields instead of going throughJavaBean setters.<p>As of Spring 4.2, the vast majority of the {@link BeanWrapper} features havebeen merged to {@link AbstractPropertyAccessor}, which means that propertytraversal as well as collections and map access is now supported here as well.<p>A DirectFieldAccessor's default for the "extractOldValueForEditor" settingis "true", since a field can always be read without side effects.#setExtractOldValueForEditororg.springframework.validation.DirectFieldBindingResultorg.springframework.validation.DataBinder#initDirectFieldAccess()Create a new DirectFieldAccessor for the given object.the object wrapped by this DirectFieldAccessorCreate a new DirectFieldAccessor for the given object,the containing DirectFieldAccessor (must not be {@code null})C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfo.javaExtendedBeanInfopropertyNameForpropertyNameFor(java.lang.reflect.Method)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/ExtendedBeanInfo.classfindExistingPropertyDescriptorfindExistingPropertyDescriptor(java.lang.String,java.lang.Class)handleCandidateWriteMethodhandleCandidateWriteMethod(java.lang.reflect.Method)MethodDescriptor[]findCandidateWriteMethodsfindCandidateWriteMethods(java.beans.MethodDescriptor[])TreeSet<PropertyDescriptor>C:/modules/java.base/java/util/TreeSet.classTreeSetAbstractSet<PropertyDescriptor>AbstractCollection<PropertyDescriptor>NavigableSet<PropertyDescriptor>C:/modules/java.base/java/util/NavigableSet.classNavigableSetSortedSet<PropertyDescriptor>C:/modules/java.base/java/util/SortedSet.classSortedSetComparator<? super PropertyDescriptor>TreeSet<PropertyDescriptor>(java.util.Comparator)AbstractCollection<PropertyDescriptor>()AbstractSet<PropertyDescriptor>()SortedSet<>tailSettailSet(java.lang.Object)tailSet(java.beans.PropertyDescriptor)headSetheadSet(java.lang.Object)headSet(java.beans.PropertyDescriptor)subSetsubSet(java.lang.Object,java.lang.Object)subSet(java.beans.PropertyDescriptor,java.beans.PropertyDescriptor)comparator()SortedSet<E>NavigableSet<>tailSet(java.lang.Object,boolean)tailSet(java.beans.PropertyDescriptor,boolean)headSet(java.lang.Object,boolean)headSet(java.beans.PropertyDescriptor,boolean)subSet(java.lang.Object,boolean,java.lang.Object,boolean)subSet(java.beans.PropertyDescriptor,boolean,java.beans.PropertyDescriptor,boolean)descendingIteratordescendingIterator()descendingSetdescendingSet()pollLastpollLast()pollFirstpollFirst()higherhigher(java.lang.Object)higher(java.beans.PropertyDescriptor)ceilingceiling(java.lang.Object)ceiling(java.beans.PropertyDescriptor)floorfloor(java.lang.Object)floor(java.beans.PropertyDescriptor)lowerlower(java.lang.Object)lower(java.beans.PropertyDescriptor)NavigableSet<E>TreeSet(java.util.SortedSet)TreeSet<PropertyDescriptor>(java.util.SortedSet)TreeSet(java.util.Collection)TreeSet<PropertyDescriptor>(java.util.Collection)TreeSet(java.util.Comparator)TreeSet()TreeSet<PropertyDescriptor>()NavigableMap<E,Object>C:/modules/java.base/java/util/NavigableMap.classNavigableMapSortedMap<E,Object>C:/modules/java.base/java/util/SortedMap.classSortedMapMap<E,Object>TreeSet(java.util.NavigableMap)NavigableMap<PropertyDescriptor,Object>SortedMap<PropertyDescriptor,Object>Map<PropertyDescriptor,Object>TreeSet<PropertyDescriptor>(java.util.NavigableMap)Class<ExtendedBeanInfo>methodDescriptors"Ignoring invalid bean property '"Ignoring invalid bean property '"': "': "Ignoring candidate write method ["Ignoring candidate write method [methodDescriptorm1m2nParamsMap<String,Void>Void[]Constructor<Void>? super VoidClass<? super Void>TypeVariable<Class<Void>>TypeVariable<Class<Void>>[]"Write method must have exactly 1 or 2 parameters: "Write method must have exactly 1 or 2 parameters: candidateTypecandidateNameipdBeanInfo[]EventSetDescriptor[]iconKindpropertyEditorClassC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/ExtendedBeanInfo$SimplePropertyDescriptor.classExtendedBeanInfo$SimplePropertyDescriptororiginal"%s[name=%s, propertyType=%s, readMethod=%s, writeMethod=%s]"%s[name=%s, propertyType=%s, readMethod=%s, writeMethod=%s]? extends SimplePropertyDescriptorClass<? extends SimplePropertyDescriptor>Map<String,? extends SimplePropertyDescriptor>SimplePropertyDescriptor[]? extends SimplePropertyDescriptor[]Constructor<? extends SimplePropertyDescriptor>? super ? extends SimplePropertyDescriptorClass<? super ? extends SimplePropertyDescriptor>TypeVariable<Class<? extends SimplePropertyDescriptor>>TypeVariable<Class<? extends SimplePropertyDescriptor>>[]C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/ExtendedBeanInfo$SimpleIndexedPropertyDescriptor.classExtendedBeanInfo$SimpleIndexedPropertyDescriptorindexedPropertyTypeindexedWriteMethodindexedReadMethodotherPd"%s[name=%s, propertyType=%s, indexedPropertyType=%s, " +
							"readMethod=%s, writeMethod=%s, indexedReadMethod=%s, indexedWriteMethod=%s]"%s[name=%s, propertyType=%s, indexedPropertyType=%s, readMethod=%s, writeMethod=%s, indexedReadMethod=%s, indexedWriteMethod=%s]? extends SimpleIndexedPropertyDescriptorClass<? extends SimpleIndexedPropertyDescriptor>Map<String,? extends SimpleIndexedPropertyDescriptor>SimpleIndexedPropertyDescriptor[]? extends SimpleIndexedPropertyDescriptor[]Constructor<? extends SimpleIndexedPropertyDescriptor>? super ? extends SimpleIndexedPropertyDescriptorClass<? super ? extends SimpleIndexedPropertyDescriptor>TypeVariable<Class<? extends SimpleIndexedPropertyDescriptor>>TypeVariable<Class<? extends SimpleIndexedPropertyDescriptor>>[]PropertyDescriptorComparatorPropertyDescriptorComparator()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/ExtendedBeanInfo$PropertyDescriptorComparator.classExtendedBeanInfo$PropertyDescriptorComparatorComparator<PropertyDescriptor>desc1desc2leftrightleftBytesrightBytesDecorator for a standard {@link BeanInfo} object, e.g. as created by{@link Introspector#getBeanInfo(Class)}, designed to discover and registerstatic and/or non-void returning setter methods. For example:public class Bean {private Foo foo;public Foo getFoo() {return this.foo;public Bean setFoo(Foo foo) {this.foo = foo;return this;}</pre>The standard JavaBeans {@code Introspector} will discover the {@code getFoo} readmethod, but will bypass the {@code #setFoo(Foo)} write method, because its non-voidreturning signature does not comply with the JavaBeans specification.{@code ExtendedBeanInfo}, on the other hand, will recognize and include it. This isdesigned to allow APIs with "builder" or method-chaining style setter signatures to beused within Spring {@code <beans>} XML. {@link #getPropertyDescriptors()} returns allexisting property descriptors from the wrapped {@code BeanInfo} as well any added fornon-void returning setters. Both standard ("non-indexed") and<a href="https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html">indexed properties</a> are fully supported.#ExtendedBeanInfo(BeanInfo)ExtendedBeanInfoFactoryWrap the given {@link BeanInfo} instance; copy all its existing property descriptorslocally, wrapping each in a custom {@link SimpleIndexedPropertyDescriptor indexed}or {@link SimplePropertyDescriptor non-indexed} {@code PropertyDescriptor}variant that bypasses default JDK weak/soft reference management; then searchthrough its method descriptors to find any non-void returning write methods andupdate or create the corresponding {@link PropertyDescriptor} for each one found.the wrapped {@code BeanInfo}, which is never modified#getPropertyDescriptors() Probably simply a method that wasn't meant to follow the JavaBeans pattern... We're only trying to find candidates, can easily ignore extra ones here... Sort non-void returning write methods to guard against the ill effects of non-deterministic sorting of methods returned from Class#getDeclaredMethods under JDK 7. See https://bugs.java.com/view_bug.do?bug_id=7023180Return the set of {@link PropertyDescriptor PropertyDescriptors} from the wrapped{@link BeanInfo} object as well as {@code PropertyDescriptors} for each non-voidreturning setter method found during construction.A simple {@link PropertyDescriptor}. Ignore, as does PropertyDescriptor#getPropertyTypeA simple {@link IndexedPropertyDescriptor}. Ignore, as does IndexedPropertyDescriptor#getPropertyType Ignore, as does IndexedPropertyDescriptor#getIndexedPropertyTypeSee java.beans.IndexedPropertyDescriptor#equalsSorts PropertyDescriptor instances alpha-numerically to emulate the behavior of{@link java.beans.BeanInfo#getPropertyDescriptors()}.ExtendedBeanInfo#propertyDescriptorsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/ExtendedBeanInfoFactory.javasupportssupports(java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/ExtendedBeanInfoFactory.class{@link BeanInfoFactory} implementation that evaluates whether bean classes have"non-standard" JavaBeans setter methods and are thus candidates for introspectionby Spring's (package-visible) {@code ExtendedBeanInfo} implementation.<p>Ordered at {@link Ordered#LOWEST_PRECEDENCE} to allow other user-defined{@link BeanInfoFactory} types to take precedence.Return an {@link ExtendedBeanInfo} for the given bean class, if applicable.Return whether the given bean class declares or inherits any non-voidreturning bean property or indexed property setter methods.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/FatalBeanException.javaFatalBeanExceptionThrown on an unrecoverable problem encountered in thebeans packages or sub-packages, e.g. bad class or field.Create a new FatalBeanException with the specified message.Create a new FatalBeanException with the specified messageC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/GenericTypeAwarePropertyDescriptor.javaGenericTypeAwarePropertyDescriptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/GenericTypeAwarePropertyDescriptor.classwriteMethodParameterambiguousWriteMethodsreadMethodToUsewriteMethodToUseambiguousCandidatesHashSet<Method>AbstractSet<Method>HashSet<Method>()AbstractSet<Method>()HashSet<Method>(int,float,boolean)HashSet<Method>(int)HashSet<Method>(int,float)HashSet<Method>(java.util.Collection)Class<GenericTypeAwarePropertyDescriptor>"Invalid JavaBean property '"Invalid JavaBean property '"' being accessed! Ambiguous write methods found next to actually used ["' being accessed! Ambiguous write methods found next to actually used [Extension of the standard JavaBeans {@link PropertyDescriptor} class,overriding {@code getPropertyType()} such that a generically declaredtype variable will be resolved against the containing bean class.2.5.2 Fallback: Original JavaBeans introspection might not have found matching setter method due to lack of bridge method resolution, in case of the getter using a covariant return type whereas the setter is defined for the concrete property type. Write method not matched against read method: potentially ambiguous through several overloaded variants, in which case an arbitrary winner has been chosen by the JDK's JavaBeans Introspector...C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/InvalidPropertyException.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/InvalidPropertyException.class"Invalid property '"Invalid property '"' of bean class ["' of bean class [Exception thrown when referring to an invalid bean property.Carries the offending bean class and property name.1.0.2Create a new InvalidPropertyException.the offending propertyReturn the offending bean class.Return the name of the offending property.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/Mergeable.javaMergeableInterface representing an object whose value set can be merged withthat of a parent object.org.springframework.beans.factory.support.ManagedSetorg.springframework.beans.factory.support.ManagedListorg.springframework.beans.factory.support.ManagedMaporg.springframework.beans.factory.support.ManagedPropertiesIs merging enabled for this particular instance?Merge the current value set with that of the supplied object.<p>The supplied object is considered the parent, and values inthe callee's value set must override those of the supplied object.the object to merge withthe result of the merge operationif the supplied parent is {@code null}if merging is not enabled for this instance(i.e. {@code mergeEnabled} equals {@code false}).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/MethodInvocationException.javaMethodInvocationException"methodInvocation""Property '"Property 'Thrown when a bean property getter or setter method throws an exception,analogous to an InvocationTargetException.Error code that a method invocation error will be registered with.Create a new MethodInvocationException.the PropertyChangeEvent that resulted in an exceptionthe Throwable raised by the invoked methodC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/MutablePropertyValues.javaMutablePropertyValuesmergeIfRequiredmergeIfRequired(org.springframework.beans.PropertyValue,org.springframework.beans.PropertyValue)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/MutablePropertyValues.classconvertedprocessedPropertiespropertyValueListArrayList<PropertyValue>AbstractList<PropertyValue>AbstractCollection<PropertyValue>ArrayList<PropertyValue>(int)Spliterator<PropertyValue>? super PropertyValueConsumer<? super PropertyValue>Iterator<PropertyValue>Stream<PropertyValue>BaseStream<PropertyValue,Stream<PropertyValue>>Predicate<? super PropertyValue>? extends PropertyValueCollection<? extends PropertyValue>Iterable<? extends PropertyValue>add(org.springframework.beans.PropertyValue)AbstractCollection<PropertyValue>()ListIterator<PropertyValue>add(int,org.springframework.beans.PropertyValue)set(int,org.springframework.beans.PropertyValue)Comparator<? super PropertyValue>UnaryOperator<PropertyValue>Function<PropertyValue,PropertyValue>AbstractList<PropertyValue>()ArrayList<PropertyValue>(java.util.Collection)ArrayList<PropertyValue>()BiFunction<? super ?,? super ?,? extends Object>Function<? super ?,? extends Object>BiConsumer<? super ?,? super ?>Entry<?,?>Set<Entry<?,?>>Collection<Entry<?,?>>Iterable<Entry<?,?>>BiConsumer<?,?>andThen(java.util.function.BiConsumer)accept(java.lang.Object,java.lang.Object)attrNameattrValuecurrentPvpropertyValuenewPvmergeablemergedchangespvOld"PropertyValues: length="PropertyValues: length="PropertyValues: length=0"PropertyValues: length=0The default implementation of the {@link PropertyValues} interface.Allows simple manipulation of properties, and provides constructorsto support deep copy and construction from a Map.13 May 2001Creates a new empty MutablePropertyValues object.<p>Property values can be added with the {@code add} method.#add(String, Object)Deep copy constructor. Guarantees PropertyValue referencesare independent, although it can't deep copy objects currentlyreferenced by individual PropertyValue objects.the PropertyValues to copy#addPropertyValues(PropertyValues) We can optimize this because it's all new: There is no replacement of existing property values.Construct a new MutablePropertyValues object from a Map.a Map with property values keyed by property name Strings#addPropertyValues(Map)Construct a new MutablePropertyValues object using the given List ofPropertyValue objects as-is.<p>This is a constructor for advanced usage scenarios.It is not intended for typical programmatic use.a List of PropertyValue objectsReturn the underlying List of PropertyValue objects in its raw form.The returned List can be modified directly, although this is not recommended.<p>This is an accessor for optimized access to all PropertyValue objects.Return the number of PropertyValue entries in the list.Copy all given PropertyValues into this object. Guarantees PropertyValuereferences are independent, although it can't deep copy objects currentlythis in order to allow for adding multiple property values in a chainAdd all property values from the given Map.a Map with property values keyed by property name,which must be a StringAdd a PropertyValue object, replacing any existing one for thecorresponding property or getting merged with it (if applicable).the PropertyValue object to addOverloaded version of {@code addPropertyValue} that takesa property name and a property value.<p>Note: As of Spring 3.0, we recommend using the more conciseand chaining-capable variant {@link #add}.name of the propertyvalue of the property#addPropertyValue(PropertyValue)Modify a PropertyValue object held in this object.Indexed from 0.Merges the value of the supplied 'new' {@link PropertyValue} with that ofthe current {@link PropertyValue} if merging is supported and enabled.Remove the given PropertyValue, if contained.the PropertyValue to removeOverloaded version of {@code removePropertyValue} that takes a property name.#removePropertyValue(PropertyValue)Get the raw property value, if any.the name to search forthe raw property value, or {@code null} if none found#getPropertyValue(String)PropertyValue#getValue() for each property value in the new set if there wasn't an old one, add itRegister the specified property as "processed" in the senseof some processor calling the corresponding setter methodoutside of the PropertyValue(s) mechanism.<p>This will lead to {@code true} being returned froma {@link #contains} call for the specified property.the name of the property.Clear the "processed" registration of the given property, if any.Mark this holder as containing converted values only(i.e. no runtime resolution needed anymore).Return whether this holder contains converted values only ({@code true}),or whether the values still need to be converted ({@code false}).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/NotReadablePropertyException.javaNotReadablePropertyException"Bean property '"Bean property '"' is not readable or has an invalid getter method: " +
				"Does the return type of the getter match the parameter type of the setter?"' is not readable or has an invalid getter method: Does the return type of the getter match the parameter type of the setter?Exception thrown on an attempt to get the value of a propertythat isn't readable, because there's no getter method.Create a new NotReadablePropertyException.4.0.9C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/NotWritablePropertyException.javaNotWritablePropertyExceptionpossibleMatchesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/NotWritablePropertyException.class"' is not writable or has an invalid setter method: " +
				"Does the return type of the getter match the parameter type of the setter?"' is not writable or has an invalid setter method: Does the return type of the getter match the parameter type of the setter?Exception thrown on an attempt to set the value of a property thatis not writable (typically because there is no setter method).Alef ArendsenCreate a new NotWritablePropertyException.the offending property namesuggestions for actual bean property namesthat closely match the invalid property nameReturn suggestions for actual bean property names that closely matchthe invalid property name, if any.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/NullValueInNestedPathException.javaNullValueInNestedPathException"Value of nested property '"Value of nested property '"' is null"' is nullException thrown when navigation of a valid nested propertypath encounters a NullPointerException.<p>For example, navigating "spouse.age" could fail because thespouse property of the target object has a null value.Create a new NullValueInNestedPathException.4.3.2C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyAccessException.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyAccessException.classSuperclass for exceptions related to a property access,such as type mismatch or invocation target exception.Create a new PropertyAccessException.Create a new PropertyAccessException without PropertyChangeEvent.Return the PropertyChangeEvent that resulted in the problem.<p>May be {@code null}; only available if an actual bean propertywas affected.Return the name of the affected property, if available.Return the affected value that was about to be set, if any.Return a corresponding error code for this type of exception.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyAccessor.javaCommon interface for classes that can access named properties(such as bean properties of an object or fields in an object)Serves as base interface for {@link BeanWrapper}.PropertyAccessorFactory#forDirectFieldAccessPath separator for nested properties.Follows normal Java conventions: getFoo().getBar() would be "foo.bar".Marker that indicates the start of a property key for anindexed or mapped property like "person.addresses[0]".Marker that indicates the end of a property key for anDetermine whether the specified property is readable.<p>Returns {@code false} if the property doesn't exist.the property to check(may be a nested path and/or an indexed/mapped property)whether the property is readableDetermine whether the specified property is writable.whether the property is writableDetermine the property type for the specified property,either checking the property descriptor or checking the valuein case of an indexed or mapped element.the property type for the particular property,or {@code null} if not determinableReturn a type descriptor for the specified property:preferably from the read method, falling back to the write method.Get the current value of the specified property.the name of the property to get the value ofSet the specified value as current property value.the name of the property to set the value ofan object containing the new property valuePerform a batch update from a Map.<p>Bulk updates from PropertyValues are more powerful: This method isprovided for convenience. Behavior will be identical to that ofthe {@link #setPropertyValues(PropertyValues)} method.a Map to take properties from. Contains property value objects,keyed by property namePropertyBatchUpdateExceptionif one or more PropertyAccessExceptionsoccurred for specific properties during the batch update. This exception bundlesall individual PropertyAccessExceptions. All other properties will have beensuccessfully updated.The preferred way to perform a batch update.<p>Note that performing a batch update differs from performing a single update,in that an implementation of this class will continue to update propertiesif a <b>recoverable</b> error (such as a type mismatch, but <b>not</b> aninvalid field name or the like) is encountered, throwing a{@link PropertyBatchUpdateException} containing all the individual errors.This exception can be examined later to see all binding errors.Properties that were successfully updated remain changed.<p>Does not allow unknown fields or invalid fields.a PropertyValues to set on the target object#setPropertyValues(PropertyValues, boolean, boolean)Perform a batch update with more control over behavior.should we ignore unknown properties (not found in the bean)Perform a batch update with full control over behavior.should we ignore invalid properties (found but not accessible)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyAccessorFactory.javaPropertyAccessorFactoryPropertyAccessorFactory()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyAccessorFactory.classSimple factory facade for obtaining {@link PropertyAccessor} instances,in particular for {@link BeanWrapper} instances. Conceals the actualtarget implementation classes and their extended public signature.Obtain a BeanWrapper for the given target object,accessing properties in JavaBeans style.the target object to wrapthe property accessorObtain a PropertyAccessor for the given target object,accessing properties in direct field style.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyAccessorUtils.javaPropertyAccessorUtilsgetNestedPropertySeparatorIndexgetNestedPropertySeparatorIndex(java.lang.String,boolean)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyAccessorUtils.classseparatorIndexchinKeyregisteredPathpropertyNamesUtility methods for classes that perform bean property accessaccording to the {@link PropertyAccessor} interface.1.2.6Return the actual property name for the given property path.the property path to determine the property namefor (can include property keys, for example for specifying a map entry)the actual property name, without any key elementsCheck whether the given property path indicates an indexed or nested property.the property path to checkwhether the path indicates an indexed or nested propertyDetermine the first nested property separator in thegiven property path, ignoring dots in keys (like "map[my.key]").the index of the nested property separator, or -1 if noneDetermine the first (or last) nested property separator in thewhether to return the last separator rather than the firstDetermine whether the given registered path matches the given property path,either indicating the property itself or an indexed element of the property.the property path (typically without index)the registered path (potentially with index)whether the paths matchDetermine the canonical name for the given property path.Removes surrounding quotes from map keys:<br>{@code map['key']} -> {@code map[key]}<br>{@code map["key"]} -> {@code map[key]}the bean property paththe canonical representation of the property pathDetermine the canonical names for the given property paths.the bean property paths (as array)the canonical representation of the property paths(as array of the same size)#canonicalPropertyName(String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyBatchUpdateException.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyBatchUpdateException.class"At least 1 PropertyAccessException required"At least 1 PropertyAccessException requiredstringJoiner"Failed properties: "Failed properties: ? extends PropertyBatchUpdateExceptionClass<? extends PropertyBatchUpdateException>Map<String,? extends PropertyBatchUpdateException>PropertyBatchUpdateException[]? extends PropertyBatchUpdateException[]Constructor<? extends PropertyBatchUpdateException>? super ? extends PropertyBatchUpdateExceptionClass<? super ? extends PropertyBatchUpdateException>TypeVariable<Class<? extends PropertyBatchUpdateException>>TypeVariable<Class<? extends PropertyBatchUpdateException>>[]"; nested PropertyAccessExceptions ("; nested PropertyAccessExceptions (") are:") are:'\n'
"PropertyAccessException "PropertyAccessException ps"; nested PropertyAccessException details ("; nested PropertyAccessException details (pwexTypeCombined exception, composed of individual PropertyAccessException instances.An object of this class is created at the beginning of the bindingprocess, and errors added to it as necessary.<p>The binding process continues when it encounters application-levelPropertyAccessExceptions, applying those changes that can be appliedand storing rejected changes in an object of this class.18 April 2001List of PropertyAccessException objects.Create a new PropertyBatchUpdateException.the List of PropertyAccessExceptionsIf this returns 0, no errors were encountered during binding.Return an array of the propertyAccessExceptions stored in this object.<p>Will return the empty array (not {@code null}) if there were no errors.Return the exception for this field, or {@code null} if there isn't any.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyDescriptorUtils.javaPropertyDescriptorUtilsPropertyDescriptorUtils()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyDescriptorUtils.classhasMoreElementshasMoreElements()asIteratorasIterator()nextElementnextElement()"Bad read method arg count: "Bad read method arg count: "Read method returns void: "Read method returns void: "Bad write method arg count: "Bad write method arg count: "Type mismatch between read and write methods: "Type mismatch between read and write methods: " - " - "Bad indexed read method arg count: "Bad indexed read method arg count: "Non int index to indexed read method: "Non int index to indexed read method: "Indexed read method returns void: "Indexed read method returns void: "Bad indexed write method arg count: "Bad indexed write method arg count: "Non int index to indexed write method: "Non int index to indexed write method: "Type mismatch between indexed read and write methods: "Type mismatch between indexed read and write methods: "Type mismatch between indexed and non-indexed methods: "Type mismatch between indexed and non-indexed methods: Common delegate methods for Spring's internal {@link PropertyDescriptor} implementations.See {@link java.beans.FeatureDescriptor}. Copy all attributes (emulating behavior of private FeatureDescriptor#addTable) See java.beans.PropertyDescriptor#PropertyDescriptor(PropertyDescriptor)See {@link java.beans.PropertyDescriptor#findPropertyType}. Write method's property type potentially more specific Proceed with read method's property typeSee {@link java.beans.IndexedPropertyDescriptor#findIndexedPropertyType}.Compare the given {@code PropertyDescriptors} and return {@code true} ifthey are equivalent, i.e. their read method, write method, property type,property editor and flags are equivalent.java.beans.PropertyDescriptor#equals(Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyEditorRegistrar.javaPropertyEditorRegistrarInterface for strategies that register custom{@link java.beans.PropertyEditor property editors} with a{@link org.springframework.beans.PropertyEditorRegistry property editor registry}.<p>This is particularly useful when you need to use the same set ofproperty editors in several different situations: write a correspondingregistrar and reuse that in each case.java.beans.PropertyEditorRegister custom {@link java.beans.PropertyEditor PropertyEditors} withthe given {@code PropertyEditorRegistry}.<p>The passed-in registry will usually be a {@link BeanWrapper} or a{@link org.springframework.validation.DataBinder DataBinder}.<p>It is expected that implementations will create brand new{@code PropertyEditors} instances for each invocation of thismethod (since {@code PropertyEditors} are not threadsafe).the {@code PropertyEditorRegistry} to register thecustom {@code PropertyEditors} withC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyEditorRegistry.javapropertyEditorEncapsulates methods for registering JavaBeans {@link PropertyEditor PropertyEditors}.This is the central interface that a {@link PropertyEditorRegistrar} operates on.<p>Extended by {@link BeanWrapper}; implemented by {@link BeanWrapperImpl}and {@link org.springframework.validation.DataBinder}.org.springframework.validation.DataBinderRegister the given custom property editor for all properties of the given type.the type of the propertythe editor to registerRegister the given custom property editor for the given type andproperty, or for all properties of the given type.<p>If the property path denotes an array or Collection property,the editor will get applied either to the array/Collection itself(the {@link PropertyEditor} has to create an array or Collection value) orto each element (the {@code PropertyEditor} has to create the element type),depending on the specified required type.<p>Note: Only one single registered custom editor per property pathis supported. In the case of a Collection/array, do not register an editorfor both the Collection/array and each element on the same property.<p>For example, if you wanted to register an editor for "items[n].quantity"(for all values n), you would use "items.quantity" as the value of the'propertyPath' argument to this method.the type of the property. This may be {@code null}if a property is given but should be specified in any case, in particular incase of a Collection - making clear whether the editor is supposed to applyto the entire Collection itself or to each of its entries. So as a general rule:<b>Do not specify {@code null} here in case of a Collection/array!</b>the path of the property (name or nested path), or{@code null} if registering an editor for all properties of the given typeeditor to registerFind a custom property editor for the given type and property.the type of the property (can be {@code null} if a propertyis given but should be specified in any case for consistency checking){@code null} if looking for an editor for all properties of the given typethe registered editor, or {@code null} if noneC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyEditorRegistrySupport.javaaddStrippedPropertyPathsaddStrippedPropertyPaths(java.util.List,java.lang.String,java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyEditorRegistrySupport.classgetCustomEditorgetCustomEditor(java.lang.Class)getCustomEditor(java.lang.String,java.lang.Class)createDefaultEditorscreateDefaultEditors()Map<Class<?>,PropertyEditor>customEditorCacheMap<String,CustomEditorHolder>customEditorsForPathcustomEditorsoverriddenDefaultEditorsdefaultEditorsconfigValueEditorsActivedefaultEditorsActiveshouldIgnoreXml"spring.xml.ignore"spring.xml.ignoreHashMap<Class<?>,PropertyEditor>AbstractMap<Class<?>,PropertyEditor>HashMap<Class<?>,PropertyEditor>()? extends PropertyEditorBiFunction<? super PropertyEditor,? super PropertyEditor,? extends PropertyEditor>merge(java.lang.Class,java.beans.PropertyEditor,java.util.function.BiFunction)BiFunction<? super Class<?>,? super PropertyEditor,? extends PropertyEditor>Function<? super Class<?>,? extends PropertyEditor>replace(java.lang.Class,java.beans.PropertyEditor)replace(java.lang.Class,java.beans.PropertyEditor,java.beans.PropertyEditor)putIfAbsent(java.lang.Class,java.beans.PropertyEditor)BiConsumer<? super Class<?>,? super PropertyEditor>getOrDefault(java.lang.Object,java.beans.PropertyEditor)Entry<Class<?>,PropertyEditor>Set<Entry<Class<?>,PropertyEditor>>Collection<Entry<Class<?>,PropertyEditor>>Iterable<Entry<Class<?>,PropertyEditor>>Collection<PropertyEditor>Iterable<PropertyEditor>Map<? extends Class<?>,? extends PropertyEditor>put(java.lang.Class,java.beans.PropertyEditor)AbstractMap<Class<?>,PropertyEditor>()Node<Class<?>,PropertyEditor>TreeNode<Class<?>,PropertyEditor>newTreeNode(int,java.lang.Class,java.beans.PropertyEditor,java.util.HashMap.Node)newNode(int,java.lang.Class,java.beans.PropertyEditor,java.util.HashMap.Node)Node<Class<?>,PropertyEditor>[]putVal(int,java.lang.Class,java.beans.PropertyEditor,boolean,boolean)HashMap<Class<?>,PropertyEditor>(java.util.Map)HashMap<Class<?>,PropertyEditor>(int)HashMap<Class<?>,PropertyEditor>(int,float)Class<Charset>Class<Class<>[]>Class<Currency>Class<File>Class<InputStream>Class<InputSource>Class<Path>Class<Pattern>Class<Properties>Class<Reader>Resource[]Class<Resource[]>Class<TimeZone>Class<UUID>Class<ZoneId>? extends Collection<>Class<? extends Collection<>>Class<Set<>>Class<SortedSet<>>SortedMap<>Class<SortedMap<>>? extends Map<>Class<? extends Map<>>Class<byte[]>char[]Class<char[]>Class<Character>? extends NumberClass<? extends Number>Class<BigDecimal>Class<BigInteger>saeClass<String[]>short[]Class<short[]>Class<int[]>long[]Class<long[]>"Either requiredType or propertyPath is required"Either requiredType or propertyPath is requiredLinkedHashMap<String,CustomEditorHolder>HashMap<String,CustomEditorHolder>AbstractMap<String,CustomEditorHolder>LinkedHashMap<String,CustomEditorHolder>(int)? super CustomEditorHolder? extends CustomEditorHolderBiFunction<? super CustomEditorHolder,? super CustomEditorHolder,? extends CustomEditorHolder>merge(java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder,java.util.function.BiFunction)BiFunction<? super String,? super CustomEditorHolder,? extends CustomEditorHolder>Function<? super String,? extends CustomEditorHolder>replace(java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder)replace(java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder)putIfAbsent(java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder)BiConsumer<? super String,? super CustomEditorHolder>getOrDefault(java.lang.Object,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder)Entry<String,CustomEditorHolder>Set<Entry<String,CustomEditorHolder>>Collection<Entry<String,CustomEditorHolder>>Iterable<Entry<String,CustomEditorHolder>>Collection<CustomEditorHolder>Iterable<CustomEditorHolder>Map<? extends String,? extends CustomEditorHolder>put(java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder)AbstractMap<String,CustomEditorHolder>()Node<String,CustomEditorHolder>TreeNode<String,CustomEditorHolder>newTreeNode(int,java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder,java.util.HashMap.Node)newNode(int,java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder,java.util.HashMap.Node)Node<String,CustomEditorHolder>[]putVal(int,java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder,boolean,boolean)HashMap<String,CustomEditorHolder>(java.util.Map)HashMap<String,CustomEditorHolder>()HashMap<String,CustomEditorHolder>(int)HashMap<String,CustomEditorHolder>(int,float)LinkedHashMap<String,CustomEditorHolder>(int,float,boolean)LinkedHashMap<String,CustomEditorHolder>(java.util.Map)LinkedHashMap<String,CustomEditorHolder>()LinkedHashMap<String,CustomEditorHolder>(int,float)LinkedHashMap<Class<?>,PropertyEditor>LinkedHashMap<Class<?>,PropertyEditor>(int)LinkedHashMap<Class<?>,PropertyEditor>(int,float,boolean)LinkedHashMap<Class<?>,PropertyEditor>(java.util.Map)LinkedHashMap<Class<?>,PropertyEditor>()LinkedHashMap<Class<?>,PropertyEditor>(int,float)requiredTypeToUsestrippedPathsstrippedPathgetKeygetKey()comparingByValuecomparingByValue(java.util.Comparator)Comparator<? super V>comparingByKeycomparingByKey(java.util.Comparator)Comparator<? super K>Comparable<? super V>comparingByValue()Comparable<? super K>comparingByKey()setValuesetValue(java.lang.Object)setValue(org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder)editorHolderstrippedNameactualPropertyNameBiConsumer<Class<?>,PropertyEditor>accept(java.lang.Class,java.beans.PropertyEditor)BiConsumer<String,CustomEditorHolder>accept(java.lang.String,org.springframework.beans.PropertyEditorRegistrySupport.CustomEditorHolder)editorPatheditorNestedPropertyeditorNestedPathgetPropertyEditorgetPropertyEditor(java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyEditorRegistrySupport$CustomEditorHolder.classPropertyEditorRegistrySupport$CustomEditorHoldergetRegisteredTypegetRegisteredType()getPropertyEditor()CustomEditorHolderCustomEditorHolder(java.beans.PropertyEditor,java.lang.Class)registeredTypeBase implementation of the {@link PropertyEditorRegistry} interface.Provides management of default editors and custom editors.Mainly serves as base class for {@link BeanWrapperImpl}.java.beans.PropertyEditorManagerjava.beans.PropertyEditorSupport#setAsTextjava.beans.PropertyEditorSupport#setValueBoolean flag controlled by a {@code spring.xml.ignore} system property that instructs Spring toignore XML, i.e. to not initialize the XML-related infrastructure.<p>The default is "false". Management of default editorsActivate the default editors for this registry instance,allowing for lazily registering default editors when needed.Activate config value editors which are only intended for configuration purposes,such as {@link org.springframework.beans.propertyeditors.StringArrayPropertyEditor}.<p>Those editors are not registered by default simply because they are ingeneral inappropriate for data binding purposes. Of course, you may registerthem individually in any case, through {@link #registerCustomEditor}.Override the default editor for the specified type with the given property editor.<p>Note that this is different from registering a custom editor in that the editorsemantically still is a default editor. A ConversionService will override such adefault editor, whereas custom editors usually override the ConversionService.#registerCustomEditor(Class, PropertyEditor)Retrieve the default editor for the given property type, if any.<p>Lazily registers the default editors, if they are active.type of the propertythe default editor, or {@code null} if none found#registerDefaultEditorsActually register the default editors for this registry instance. Simple editors, without parameterization capabilities. The JDK does not contain a default editor for any of these target types. Default instances of collection editors. Can be overridden by registering custom instances of those as custom editors. Default editors for primitive arrays. The JDK does not contain a default editor for char! Spring's CustomBooleanEditor accepts more flag values than the JDK's default editor. The JDK does not contain default editors for number wrapper types! Override JDK primitive number editors with our own CustomNumberEditor. Only register config value editors if explicitly requested.Copy the default editors registered in this instance to the given target registry.the target registry to copy to Management of custom editors Check property-specific editor first. No property-specific editor -> check type-specific editor.Determine whether this registry contains a custom editorfor the specified array/collection element.the target type of the element(can be {@code null} if not known)the property path (typically of the array/collection;can be {@code null} if not known)whether a matching custom editor has been foundDetermine the property type for the given property path.<p>Called by {@link #findCustomEditor} if no required type has been specified,to be able to find a type-specific editor even if just given a property path.<p>The default implementation always returns {@code null}.BeanWrapperImpl overrides this with the standard {@code getPropertyType}method as defined by the BeanWrapper interface.the property path to determine the type forthe type of the property, or {@code null} if not determinableBeanWrapper#getPropertyType(String)Get custom editor that has been registered for the given property.the property path to look forthe type to look forthe custom editor, or {@code null} if none specific for this propertyGet custom editor for the given type. If no direct match found,try custom editor for superclass (which will in any case be ableto render a value as String via {@code getAsText}).the custom editor, or {@code null} if none found for this typejava.beans.PropertyEditor#getAsText() Check directly registered editor for type. Check cached editor for type, registered for superclass or interface. Find editor for superclass or interface. Cache editor for search type, to avoid the overhead of repeated assignable-from checks.Guess the property type of the specified property from the registeredcustom editors (provided that they were registered for a specific type).the property type, or {@code null} if not determinableCopy the custom editors registered in this instance to the given target registry.the nested property path of the target registry, if any.If this is non-null, only editors registered for a path below this nested propertywill be copied. If this is null, all editors will be copied.Add property paths with all variations of stripped keys and/or indexes.Invokes itself recursively with nested paths.the result list to add tothe current nested paththe property path to check for keys/indexes to strip Strip the first key. Search for further keys to strip, with the first key stripped. Search for further keys to strip, with the first key not stripped.Holder for a registered custom editor with property name.Keeps the PropertyEditor itself plus the type it was registered for. Special case: If no required type specified, which usually only happens for Collection elements, or required type is not assignable to registered type, which usually only happens for generic properties of type Object - then return PropertyEditor if not registered for Collection or array type. (If not registered for Collection or array, it is assumed to be intended for elements.)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyMatches.javaPropertyMatchescalculateStringDistancecalculateStringDistance(java.lang.String,java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyMatches.classPropertyMatches(java.lang.String,java.lang.String[])maxDistance"Did you mean "Did you mean '\''"', "', "', or "', or "'?"'?s1s2int[][]c1costc2calculateMatchescalculateMatches(java.lang.String,java.beans.PropertyDescriptor[],int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyMatches$BeanPropertyMatches.classPropertyMatches$BeanPropertyMatchesdescriptorspossibleAlternative160"' is not writable or has an invalid setter method. "' is not writable or has an invalid setter method. "Does the parameter type of the setter match the return type of the getter?"Does the parameter type of the setter match the return type of the getter?calculateMatches(java.lang.String,java.lang.Class,int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyMatches$FieldPropertyMatches.classPropertyMatches$FieldPropertyMatchesdoWith(java.lang.reflect.Field)80"' has no matching field."' has no matching field.' 'Helper class for calculating property matches, according to a configurabledistance. Provide the list of potential matches and an easy way to generatean error message. Works for both java bean properties and fields.<p>Mainly for use within the framework and in particular the binding facility.#forProperty(String, Class)#forField(String, Class)Default maximum property distance: 2.Create PropertyMatches for the given bean property.the name of the property to find possible matches forthe bean class to search for matchesthe maximum property distance allowed for matchesCreate PropertyMatches for the given field property.the name of the field to find possible matches for Instance stateCreate a new PropertyMatches instance for the given property and possible matches.Return the name of the requested property.Return the calculated possible matches.Build an error message for the given invalid property name,indicating the possible property matches. Implementation support for subclassesCalculate the distance between the given two Stringsaccording to the Levenshtein algorithm.the first Stringthe second Stringthe distance value Concrete subclassesGenerate possible property alternatives for the given property and class.Internally uses the {@code getStringDistance} method, which in turn usesthe Levenshtein algorithm to determine the distance between two Strings.the JavaBeans property descriptors to searchthe maximum distance to acceptC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyValue.javaPropertyValueresolvedTokensC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyValue.classconversionNecessaryoptional"Original must not be null"Original must not be nullotherPv"bean property '"bean property 'Object to hold information and value for an individual bean property.Using an object here, rather than just storing all properties ina map keyed by property name, allows for more flexibility, and theability to handle indexed properties etc in an optimized way.<p>Note that the value doesn't need to be the final required type:A {@link BeanWrapper} implementation should handle any necessary conversion,as this object doesn't know anything about the objects it will be applied to.PropertyValuesPackage-visible field that indicates whether conversion is necessary.Package-visible field for caching the resolved property path tokens.Create a new PropertyValue instance.the name of the property (never {@code null})the value of the property (possibly before type conversion)Copy constructor.the PropertyValue to copy (never {@code null})Constructor that exposes a new value for an original value holder.The original holder will be exposed as source of the new holder.the PropertyValue to link to (never {@code null})the new value to applyReturn the name of the property.Return the value of the property.<p>Note that type conversion will <i>not</i> have occurred here.It is the responsibility of the BeanWrapper implementation toperform type conversion.Return the original PropertyValue instance for this value holder.the original PropertyValue (either a source of thisvalue holder or this value holder itself).Set whether this is an optional value, that is, to be ignoredwhen no corresponding property exists on the target class.Return whether this is an optional value, that is, to be ignoredReturn whether this holder contains a converted value already ({@code true}),or whether the value still needs to be converted ({@code false}).Set the converted value of this property value,after processed type conversion.Return the converted value of this property value,C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyValues.javaHolder containing one or more {@link PropertyValue} objects,typically comprising one update for a specific target bean.Return an {@link Iterator} over the property values.Return a {@link Spliterator} over the property values.Return a sequential {@link Stream} containing the property values.Return an array of the PropertyValue objects held in this object.Return the property value with the given name, if any.the property value, or {@code null} if noneReturn the changes since the previous PropertyValues.Subclasses should also override {@code equals}.the old property valuesthe updated or new properties.Return empty PropertyValues if there are no changes.Object#equalsIs there a property value (or other processing entry) for this property?the name of the property we're interested inwhether there is a property value for this propertyDoes this holder not contain any PropertyValue objects at all?C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/PropertyValuesEditor.javaPropertyValuesEditorpropertiesEditorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/PropertyValuesEditor.classprops{@link java.beans.PropertyEditor Editor} for a {@link PropertyValues} object.<p>The required format is defined in the {@link java.util.Properties}documentation. Each property must be on a new line.<p>The present implementation relies on a{@link org.springframework.beans.propertyeditors.PropertiesEditor}underneath.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/SimpleTypeConverter.javaSimpleTypeConverterSimple implementation of the {@link TypeConverter} interface that does not operate ona specific target object. This is an alternative to using a full-blown BeanWrapperImplinstance for arbitrary type conversion needs, while using the very same conversionalgorithm (including delegation to {@link java.beans.PropertyEditor} and{@link org.springframework.core.convert.ConversionService}) underneath.<p><b>Note:</b> Due to its reliance on {@link java.beans.PropertyEditor PropertyEditors},SimpleTypeConverter is <em>not</em> thread-safe. Use a separate instance for each thread.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/TypeConverter.javaTypeConvertermethodParam"TypeDescriptor resolution not supported"TypeDescriptor resolution not supportedInterface that defines type conversion methods. Typically (but not necessarily)implemented in conjunction with the {@link PropertyEditorRegistry} interface.<p><b>Note:</b> Since TypeConverter implementations are typically based on{@link java.beans.PropertyEditor PropertyEditors} which aren't thread-safe,TypeConverters themselves are <em>not</em> to be considered as thread-safe either.Convert the value to the required type (if necessary from a String).<p>Conversions from String to any type will typically use the {@code setAsText}method of the PropertyEditor class, or a Spring Converter in a ConversionService.the type we must convert to(or {@code null} if not known, for example in case of a collection element)java.beans.PropertyEditor#setAsText(String)java.beans.PropertyEditor#getValue()org.springframework.core.convert.ConversionServiceorg.springframework.core.convert.converter.Converterthe method parameter that is the target of the conversion(for analysis of generic types; may be {@code null})the reflective field that is the target of the conversionthe type descriptor to use (may be {@code null}))5.1.4C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.javaTypeConverterDelegatecanCreateCopycanCreateCopy(java.lang.Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/TypeConverterDelegate.classbuildKeyedPropertyNamebuildKeyedPropertyName(java.lang.String,java.lang.Object)buildIndexedPropertyNamebuildIndexedPropertyName(java.lang.String,int)convertToTypedMapconvertToTypedMap(java.util.Map,java.lang.String,java.lang.Class,org.springframework.core.convert.TypeDescriptor)convertToTypedCollectionconvertToTypedCollection(java.util.Collection,java.lang.String,java.lang.Class,org.springframework.core.convert.TypeDescriptor)convertToTypedArrayconvertToTypedArray(java.lang.Object,java.lang.String,java.lang.Class)doConvertTextValuedoConvertTextValue(java.lang.Object,java.lang.String,java.beans.PropertyEditor)doConvertValuedoConvertValue(java.lang.Object,java.lang.Object,java.lang.Class,java.beans.PropertyEditor)findDefaultEditorfindDefaultEditor(java.lang.Class)attemptToConvertStringToEnumattemptToConvertStringToEnum(java.lang.Class,java.lang.String,java.lang.Object)propertyEditorRegistryClass<TypeConverterDelegate>conversionAttemptExstandardConversionsourceTypeDescelementTypeDesctrimmedValuestrCtor"No String constructor found on type ["No String constructor found on type ["Construction via String failed for type ["Construction via String failed for type [Class<Optional<>>Optional<Object>"Cannot convert value of type '"Cannot convert value of type '"' to required type '"' to required type '": PropertyEditor [": PropertyEditor [Class<? extends PropertyEditor>Map<String,? extends PropertyEditor>? extends PropertyEditor[]Constructor<? extends PropertyEditor>? super ? extends PropertyEditorClass<? super ? extends PropertyEditor>TypeVariable<Class<? extends PropertyEditor>>TypeVariable<Class<? extends PropertyEditor>>[]"] returned inappropriate value of type '"] returned inappropriate value of type '": no matching editors or conversion strategy found": no matching editors or conversion strategy found"Original ConversionService attempt failed - ignored since " +
					"PropertyEditor based conversion eventually succeeded"Original ConversionService attempt failed - ignored since PropertyEditor based conversion eventually succeededcurrentConvertedValueenumTypefieldNameenumValueTypeenumField"Enum class ["Enum class ["] cannot be loaded"] cannot be loaded"Field ["Field ["] isn't an enum value for type ["] isn't an enum value for type ["] isn't an enum value"] isn't an enum valuenewConvertedValue"PropertyEditor ["PropertyEditor ["] does not support setValue call"] does not support setValue call"Converting String array to comma-delimited String ["Converting String array to comma-delimited String [newTextValue"Converting String to ["Converting String to ["] using property editor ["] using property editor [inputcollarrayLengthapproximableoriginalAllowedconvertedCopy"Custom Collection type ["Custom Collection type [Map<String,? extends Collection<>>? extends Collection<>[]Constructor<? extends Collection<>>? super ? extends Collection<>Class<? super ? extends Collection<>>TypeVariable<Class<? extends Collection<>>>TypeVariable<Class<? extends Collection<>>>[]"] does not allow for creating a copy - injecting original Collection as-is"] does not allow for creating a copy - injecting original Collection as-is"Cannot access Collection of type ["Cannot access Collection of type ["] - injecting original Collection as-is: "] - injecting original Collection as-is: "Cannot create copy of Collection type ["Cannot create copy of Collection type [convertedElement"Collection type ["Collection type ["] seems to be read-only - injecting original Collection as-is: "] seems to be read-only - injecting original Collection as-is: keyTypevalueType"Custom Map type ["Custom Map type [Map<String,? extends Map<>>? extends Map<>[]Constructor<? extends Map<>>? super ? extends Map<>Class<? super ? extends Map<>>TypeVariable<Class<? extends Map<>>>TypeVariable<Class<? extends Map<>>>[]"] does not allow for creating a copy - injecting original Map as-is"] does not allow for creating a copy - injecting original Map as-isIterator<Entry<?,?>>Spliterator<Entry<?,?>>? super Entry<?,?>Consumer<? super Entry<?,?>>Stream<Entry<?,?>>BaseStream<Entry<?,?>,Stream<Entry<?,?>>>Predicate<? super Entry<?,?>>? extends Entry<?,?>Collection<? extends Entry<?,?>>Iterable<? extends Entry<?,?>>add(java.util.Map.Entry)"Cannot access Map of type ["Cannot access Map of type ["] - injecting original Map as-is: "] - injecting original Map as-is: "Cannot create copy of Map type ["Cannot create copy of Map type [keyedPropertyNameconvertedKey"Map type ["Map type ["] seems to be read-only - injecting original Map as-is: "] seems to be read-only - injecting original Map as-is: Internal helper class for converting property values to target types.<p>Works on a given {@link PropertyEditorRegistrySupport} instance.Used as a delegate by {@link BeanWrapperImpl} and {@link SimpleTypeConverter}.Create a new TypeConverterDelegate for the given editor registry.the editor registry to useCreate a new TypeConverterDelegate for the given editor registry and bean instance.the target object to work on (as context that can be passed to editors)Convert the value to the required type for the specified property.the previous value, if available (may be {@code null})the proposed new valueConvert the value to the required type (if necessary from a String),for the specified property.the descriptor for the target property or field Custom editor for this type? No custom editor but custom ConversionService specified? fallback to default conversion logic below Value not of required type? Try to apply some standard type conversion rules if appropriate. Array required -> apply appropriate conversion of elements. Convert elements to target type, if determined. Convert keys and values to respective target type, if determined. We can stringify any primitive value... proceed with field lookup It's an empty enum identifier: reset the enum value to null. convertedValue == null Original exception from former ConversionService call above... ConversionService not tried before, probably custom editor found but editor couldn't produce the required type... Definitely doesn't match: throw IllegalArgumentException/IllegalStateException target type is declared as raw enum, treat the trimmed value as <enum.fqn>.FIELD_NAME Try field lookup as fallback: for JDK 1.5 enum or custom enum with values defined as static fields. Resulting value still needs to be checked, hence we don't return it right away.Find a default editor for the given type.the corresponding editor, or {@code null} if none No custom editor -> check BeanWrapperImpl's default editors. No BeanWrapper default editor -> check standard JavaBean editor.using the given property editor.the PropertyEditor to use Not a String -> use PropertyEditor's setValue. With standard PropertyEditors, this will return the very same object; we just want to allow special PropertyEditors to override setValue for type conversion from non-String values to the required type. Reset PropertyEditor: It already did a proper conversion. Don't use it again for a setAsText call. Swallow and proceed. Convert String array to a comma-separated String. Only applies if no PropertyEditor converted the String array before. The CSV String will be passed into a PropertyEditor's setAsText method, if any. Use PropertyEditor's setAsText in case of a String value.Convert the given text value using the given property editor.the proposed text valuethe converted value Convert Collection elements to array elements. Convert array elements, if necessary. A plain value: convert it to an array with a single component.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/TypeConverterSupport.javaTypeConverterSupporttypeConverterDelegateC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/TypeConverterSupport.classBase implementation of the {@link TypeConverter} interface, using a package-private delegate.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/TypeMismatchException.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/TypeMismatchException.class"typeMismatch"typeMismatch"Failed to convert property value of type '"Failed to convert property value of type '" to required type '" to required type '"Failed to convert value of type '"Failed to convert value of type '"Property name already initialized"Property name already initializedException thrown on a type mismatch when trying to set a bean property.Error code that a type mismatch error will be registered with.Create a new {@code TypeMismatchException}.the required target typeCreate a new {@code TypeMismatchException} without a {@code PropertyChangeEvent}.#initPropertyNameInitialize this exception's property name for exposure through {@link #getPropertyName()},as an alternative to having it initialized via a {@link PropertyChangeEvent}.the property name to expose5.0.4#TypeMismatchException(Object, Class)#TypeMismatchException(Object, Class, Throwable)Return the offending value (may be {@code null}).Return the required target type, if any.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/annotation/AnnotationBeanUtils.javaAnnotationBeanUtilsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/annotationorg.springframework.beans.annotationexcludedPropertiesvalueResolverannotationPropertiesMap<String,? extends Annotation>? extends Annotation[]Constructor<? extends Annotation>? super ? extends AnnotationClass<? super ? extends Annotation>TypeVariable<Class<? extends Annotation>>TypeVariable<Class<? extends Annotation>>[]bwannotationPropertyGeneral utility methods for working with annotations in JavaBeans style.as of 5.2, in favor of custom annotation attribute processingCopy the properties of the supplied {@link Annotation} to the supplied target bean.Any properties defined in {@code excludedProperties} will not be copied.the annotation to copy fromthe bean instance to copy tothe names of excluded properties, if anyorg.springframework.beans.BeanWrapper<p>A specified value resolver may resolve placeholders in property values, for example.a resolve to post-process String property values (may be {@code null})C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/annotation/package-info.javaSupport package for beans-style handling of Java 5 annotations.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/Aware.javaAwareC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factoryA marker superinterface indicating that a bean is eligible to be notified by theSpring container of a particular framework object through a callback-style method.The actual method signature is determined by individual subinterfaces but shouldtypically consist of just one void-returning method that accepts a single argument.<p>Note that merely implementing {@link Aware} provides no default functionality.Rather, processing must be done explicitly, for example in a{@link org.springframework.beans.factory.config.BeanPostProcessor}.Refer to {@link org.springframework.context.support.ApplicationContextAwareProcessor}for an example of processing specific {@code *Aware} interface callbacks.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanClassLoaderAware.javaBeanClassLoaderAwareCallback that allows a bean to be aware of the bean{@link ClassLoader class loader}; that is, the class loader used by thepresent bean factory to load bean classes.<p>This is mainly intended to be implemented by framework classes whichhave to pick up application classes by name despite themselves potentiallybeing loaded from a shared class loader.<p>For a list of all bean lifecycle methods, see the{@link BeanFactory BeanFactory javadocs}.BeanNameAwareBeanFactoryAwareInitializingBeanCallback that supplies the bean {@link ClassLoader class loader} toa bean instance.<p>Invoked <i>after</i> the population of normal bean properties but<i>before</i> an initialization callback such as{@link InitializingBean InitializingBean's}{@link InitializingBean#afterPropertiesSet()}method or a custom init-method.the owning class loaderC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanCreationException.javaBeanCreationExceptionList<Throwable>Collection<Throwable>Iterable<Throwable>relatedCausesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/BeanCreationException.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factoryresourceDescription"Error creating bean with name '"Error creating bean with name '" defined in " defined in ArrayList<Throwable>AbstractList<Throwable>AbstractCollection<Throwable>ArrayList<Throwable>()Spliterator<Throwable>Consumer<? super Throwable>Iterator<Throwable>Stream<Throwable>BaseStream<Throwable,Stream<Throwable>>Collection<? extends Throwable>Iterable<? extends Throwable>add(java.lang.Throwable)AbstractCollection<Throwable>()ListIterator<Throwable>add(int,java.lang.Throwable)set(int,java.lang.Throwable)UnaryOperator<Throwable>Function<Throwable,Throwable>AbstractList<Throwable>()ArrayList<Throwable>(java.util.Collection)ArrayList<Throwable>(int)relatedCause"\nRelated cause: "
Related cause: "Related cause:"Related cause:exClassException thrown when a BeanFactory encounters an error whenattempting to create a bean from a bean definition.Create a new BeanCreationException.the name of the bean requesteddescription of the resourcethat the bean definition came fromReturn the description of the resource that the beandefinition came from, if any.Return the name of the bean requested, if any.Add a related cause to this bean creation exception,not being a direct cause of the failure but having occurredearlier in the creation of the same bean instance.the related cause to addReturn the related causes, if any.the array of related causes, or {@code null} if noneC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanCreationNotAllowedException.javaBeanCreationNotAllowedExceptionException thrown in case of a bean being requested despitebean creation currently not being allowed (for example, duringthe shutdown phase of a bean factory).Create a new BeanCreationNotAllowedException.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanCurrentlyInCreationException.javaBeanCurrentlyInCreationException"Requested bean is currently in creation: Is there an unresolvable circular reference?"Requested bean is currently in creation: Is there an unresolvable circular reference?Exception thrown in case of a reference to a bean that's currently in creation.Typically happens when constructor autowiring matches the currently constructed bean.Create a new BeanCurrentlyInCreationException,with a default error message that indicates a circular reference.Create a new BeanCurrentlyInCreationException.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanDefinitionStoreException.javaBeanDefinitionStoreExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/BeanDefinitionStoreException.class"Invalid bean definition with name '"Invalid bean definition with name '"' defined in "' defined in Exception thrown when a BeanFactory encounters an invalid bean definition:e.g. in case of incomplete or contradictory bean metadata.Create a new BeanDefinitionStoreException.the detail message (used as exception message as-is)description of the resource that the bean definition came fromthe detail message (appended to an introductory message that indicatesthe resource and the name of the bean)Return the description of the resource that the bean definition came from, if available.Return the name of the bean, if available.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanExpressionException.javaBeanExpressionExceptionException that indicates an expression evaluation attempt having failed.Create a new BeanExpressionException with the specified message.Create a new BeanExpressionException with the specified messageC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory.javaBeanFactory"&"&ObjectProvider<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/ObjectProvider.classObjectProviderObjectFactory<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/ObjectFactory.classObjectFactoryObjectProvider<T>ObjectFactory<T>Iterable<T>typeToMatchallowFactoryBeanInitThe root interface for accessing a Spring bean container.<p>This is the basic client view of a bean container;further interfaces such as {@link ListableBeanFactory} and{@link org.springframework.beans.factory.config.ConfigurableBeanFactory}are available for specific purposes.<p>This interface is implemented by objects that hold a number of bean definitions,each uniquely identified by a String name. Depending on the bean definition,the factory will return either an independent instance of a contained object(the Prototype design pattern), or a single shared instance (a superioralternative to the Singleton design pattern, in which the instance is asingleton in the scope of the factory). Which type of instance will be returneddepends on the bean factory configuration: the API is the same. Since Spring2.0, further scopes are available depending on the concrete applicationcontext (e.g. "request" and "session" scopes in a web environment).<p>The point of this approach is that the BeanFactory is a central registryof application components, and centralizes configuration of applicationcomponents (no more do individual objects need to read properties files,for example). See chapters 4 and 11 of "Expert One-on-One J2EE Design andDevelopment" for a discussion of the benefits of this approach.<p>Note that it is generally better to rely on Dependency Injection("push" configuration) to configure application objects through settersor constructors, rather than use any form of "pull" configuration like aBeanFactory lookup. Spring's Dependency Injection functionality isimplemented using this BeanFactory interface and its subinterfaces.<p>Normally a BeanFactory will load bean definitions stored in a configurationsource (such as an XML document), and use the {@code org.springframework.beans}package to configure the beans. However, an implementation could simply returnJava objects it creates as necessary directly in Java code. There are noconstraints on how the definitions could be stored: LDAP, RDBMS, XML,properties file, etc. Implementations are encouraged to support referencesamongst beans (Dependency Injection).<p>In contrast to the methods in {@link ListableBeanFactory}, all of theoperations in this interface will also check parent factories if this is a{@link HierarchicalBeanFactory}. If a bean is not found in this factory instance,the immediate parent factory will be asked. Beans in this factory instanceare supposed to override beans of the same name in any parent factory.<p>Bean factory implementations should support the standard bean lifecycle interfacesas far as possible. The full set of initialization methods and their standard order is:<li>BeanNameAware's {@code setBeanName}<li>BeanClassLoaderAware's {@code setBeanClassLoader}<li>BeanFactoryAware's {@code setBeanFactory}<li>EnvironmentAware's {@code setEnvironment}<li>EmbeddedValueResolverAware's {@code setEmbeddedValueResolver}<li>ResourceLoaderAware's {@code setResourceLoader}(only applicable when running in an application context)<li>ApplicationEventPublisherAware's {@code setApplicationEventPublisher}<li>MessageSourceAware's {@code setMessageSource}<li>ApplicationContextAware's {@code setApplicationContext}<li>ServletContextAware's {@code setServletContext}(only applicable when running in a web application context)<li>{@code postProcessBeforeInitialization} methods of BeanPostProcessors<li>InitializingBean's {@code afterPropertiesSet}<li>a custom init-method definition<li>{@code postProcessAfterInitialization} methods of BeanPostProcessors<p>On shutdown of a bean factory, the following lifecycle methods apply:<li>{@code postProcessBeforeDestruction} methods of DestructionAwareBeanPostProcessors<li>DisposableBean's {@code destroy}<li>a custom destroy-method definitionBeanNameAware#setBeanNameBeanClassLoaderAware#setBeanClassLoaderBeanFactoryAware#setBeanFactoryorg.springframework.context.ResourceLoaderAware#setResourceLoaderorg.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisherorg.springframework.context.MessageSourceAware#setMessageSourceorg.springframework.context.ApplicationContextAware#setApplicationContextorg.springframework.web.context.ServletContextAware#setServletContextorg.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitializationInitializingBean#afterPropertiesSetorg.springframework.beans.factory.support.RootBeanDefinition#getInitMethodNameorg.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitializationDisposableBean#destroyorg.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodNameUsed to dereference a {@link FactoryBean} instance and distinguish it frombeans <i>created</i> by the FactoryBean. For example, if the bean named{@code myJndiObject} is a FactoryBean, getting {@code &myJndiObject}will return the factory, not the instance returned by the factory.Return an instance, which may be shared or independent, of the specified bean.<p>This method allows a Spring BeanFactory to be used as a replacement for theSingleton or Prototype design pattern. Callers may retain references toreturned objects in the case of Singleton beans.<p>Translates aliases back to the corresponding canonical bean name.<p>Will ask the parent factory if the bean cannot be found in this factory instance.the name of the bean to retrievean instance of the beanNoSuchBeanDefinitionExceptionif there is no bean with the specified nameif the bean could not be obtained<p>Behaves the same as {@link #getBean(String)}, but provides a measure of typesafety by throwing a BeanNotOfRequiredTypeException if the bean is not of therequired type. This means that ClassCastException can't be thrown on castingthe result correctly, as can happen with {@link #getBean(String)}.type the bean must match; can be an interface or superclassif there is no such bean definitionBeanNotOfRequiredTypeExceptionif the bean is not of the required typeif the bean could not be created<p>Allows for specifying explicit constructor arguments / factory method arguments,overriding the specified default arguments (if any) in the bean definition.arguments to use when creating a bean instance using explicit arguments(only applied when creating a new instance as opposed to retrieving an existing one)if arguments have been given butthe affected bean isn't a prototypeReturn the bean instance that uniquely matches the given object type, if any.<p>This method goes into {@link ListableBeanFactory} by-type lookup territorybut may also be translated into a conventional by-name lookup based on the nameof the given type. For more extensive retrieval operations across sets of beans,use {@link ListableBeanFactory} and/or {@link BeanFactoryUtils}.an instance of the single bean matching the required typeif no bean of the given type was foundNoUniqueBeanDefinitionExceptionif more than one bean of the given type was foundListableBeanFactoryReturn a provider for the specified bean, allowing for lazy on-demand retrievalof instances, including availability and uniqueness options.a corresponding provider handle#getBeanProvider(ResolvableType)type the bean must match; can be a generic type declaration.Note that collection types are not supported here, in contrast to reflectiveinjection points. For programmatically retrieving a list of beans matching aspecific type, specify the actual bean type as an argument here and subsequentlyuse {@link ObjectProvider#orderedStream()} or its lazy streaming/iteration options.ObjectProvider#iterator()ObjectProvider#stream()ObjectProvider#orderedStream()Does this bean factory contain a bean definition or externally registered singletoninstance with the given name?<p>If the given name is an alias, it will be translated back to the correspondingcanonical bean name.<p>If this factory is hierarchical, will ask any parent factory if the bean cannotbe found in this factory instance.<p>If a bean definition or singleton instance matching the given name is found,this method will return {@code true} whether the named bean definition is concreteor abstract, lazy or eager, in scope or not. Therefore, note that a {@code true}return value from this method does not necessarily indicate that {@link #getBean}will be able to obtain an instance for the same name.the name of the bean to querywhether a bean with the given name is presentIs this bean a shared singleton? That is, will {@link #getBean} alwaysreturn the same instance?<p>Note: This method returning {@code false} does not clearly indicateindependent instances. It indicates non-singleton instances, which may correspondto a scoped bean as well. Use the {@link #isPrototype} operation to explicitlycheck for independent instances.whether this bean corresponds to a singleton instanceif there is no bean with the given name#getBean#isPrototypeIs this bean a prototype? That is, will {@link #getBean} always returnindependent instances?a singleton object. It indicates non-independent instances, which may correspondto a scoped bean as well. Use the {@link #isSingleton} operation to explicitlycheck for a shared singleton instance.whether this bean will always deliver independent instances#isSingletonCheck whether the bean with the given name matches the specified type.More specifically, check whether a {@link #getBean} call for the given namewould return an object that is assignable to the specified target type.the type to match against (as a {@code ResolvableType}){@code true} if the bean type matches,{@code false} if it doesn't match or cannot be determined yet#getTypethe type to match against (as a {@code Class})Determine the type of the bean with the given name. More specifically,determine the type of object that {@link #getBean} would return for the given name.<p>For a {@link FactoryBean}, return the type of object that the FactoryBean creates,as exposed by {@link FactoryBean#getObjectType()}. This may lead to the initializationof a previously uninitialized {@code FactoryBean} (see {@link #getType(String, boolean)}).the type of the bean, or {@code null} if not determinable#isTypeMatchas exposed by {@link FactoryBean#getObjectType()}. Depending on the{@code allowFactoryBeanInit} flag, this may lead to the initialization of a previouslyuninitialized {@code FactoryBean} if no early type information is available.whether a {@code FactoryBean} may get initializedjust for the purpose of determining its object typeReturn the aliases for the given bean name, if any.<p>All of those aliases point to the same bean when used in a {@link #getBean} call.<p>If the given name is an alias, the corresponding original bean nameand other aliases (if any) will be returned, with the original bean namebeing the first element in the array.the bean name to check for aliasesthe aliases, or an empty array if noneC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactoryAware.javaInterface to be implemented by beans that wish to be aware of theirowning {@link BeanFactory}.<p>For example, beans can look up collaborating beans via the factory(Dependency Lookup). Note that most beans will choose to receive referencesto collaborating beans via corresponding bean properties or constructorarguments (Dependency Injection).11.03.2003org.springframework.context.ApplicationContextAwareCallback that supplies the owning factory to a bean instance.<p>Invoked after the population of normal bean propertiesbut before an initialization callback such as{@link InitializingBean#afterPropertiesSet()} or a custom init-method.owning BeanFactory (never {@code null}).The bean can immediately call methods on the factory.in case of initialization errorsBeanInitializationExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactoryUtils.javaBeanFactoryUtilsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/BeanFactoryUtils.classuniqueBeanuniqueBean(java.lang.Class,java.util.Map)mergeNamesWithParentmergeNamesWithParent(java.lang.String[],java.lang.String[],org.springframework.beans.factory.HierarchicalBeanFactory)transformedBeanNameCache"#"#ConcurrentHashMap<String,String>AbstractMap<String,String>ConcurrentMap<String,String>ConcurrentHashMap<String,String>()merge(java.lang.String,java.lang.String,java.util.function.BiFunction)Function<? super String,? extends String>replace(java.lang.String,java.lang.String)replace(java.lang.String,java.lang.String,java.lang.String)putIfAbsent(java.lang.String,java.lang.String)BiConsumer<? super String,? super String>getOrDefault(java.lang.Object,java.lang.String)Entry<String,String>Set<Entry<String,String>>Collection<Entry<String,String>>Iterable<Entry<String,String>>Map<? extends String,? extends String>put(java.lang.String,java.lang.String)AbstractMap<String,String>()ToIntFunction<Entry<String,String>>ToLongFunction<Entry<String,String>>ToDoubleFunction<Entry<String,String>>Function<Entry<String,String>,? extends U>? extends Entry<String,String>BiFunction<Entry<String,String>,Entry<String,String>,? extends Entry<String,String>>? super Entry<String,String>Consumer<? super Entry<String,String>>ToIntBiFunction<? super String,? super String>ToLongBiFunction<? super String,? super String>ToDoubleBiFunction<? super String,? super String>BiFunction<? super String,? super String,? extends U>Node<String,String>Node<String,String>[]KeySetView<String,String>CollectionView<String,String,String>keySet(java.lang.String)Predicate<? super Entry<String,String>>replaceNode(java.lang.Object,java.lang.String,java.lang.Object)putVal(java.lang.String,java.lang.String,boolean)ConcurrentHashMap<String,String>(int,float,int)ConcurrentHashMap<String,String>(int,float)ConcurrentHashMap<String,String>(java.util.Map)ConcurrentHashMap<String,String>(int)"'name' must not be null"'name' must not be nullFunction<String,V>Function<? super String,? extends V>Function<V,String>Function<? super V,? extends String>apply(java.lang.String)lbfhbfparentResultincludeNonSingletonsallowEagerInitLinkedHashMap<String,T>HashMap<String,T>AbstractMap<String,T>LinkedHashMap<String,T>(int)BiFunction<? super T,? super T,? extends T>BiFunction<? super String,? super T,? extends T>BiConsumer<? super String,? super T>Entry<String,T>Set<Entry<String,T>>Collection<Entry<String,T>>Iterable<Entry<String,T>>Collection<T>Map<? extends String,? extends T>AbstractMap<String,T>()Node<String,T>TreeNode<String,T>Node<String,T>[]HashMap<String,T>(java.util.Map)HashMap<String,T>()HashMap<String,T>(int)HashMap<String,T>(int,float)LinkedHashMap<String,T>(int,float,boolean)LinkedHashMap<String,T>(java.util.Map)LinkedHashMap<String,T>()LinkedHashMap<String,T>(int,float)BiConsumer<String,T>accept(java.lang.String,java.lang.Object)beansOfTypematchingBeansCollection<? extends T>Iterable<? extends T>Convenience methods operating on bean factories, in particularon the {@link ListableBeanFactory} interface.<p>Returns bean counts, bean names or bean instances,taking into account the nesting hierarchy of a bean factory(which the methods defined on the ListableBeanFactory interface don't,in contrast to the methods defined on the BeanFactory interface).04.07.2003Separator for generated bean names. If a class name or parent name is notunique, "#1", "#2" etc will be appended, until the name becomes unique.Cache from name with factory bean prefix to stripped name without dereference.BeanFactory#FACTORY_BEAN_PREFIXReturn whether the given name is a factory dereference(beginning with the factory dereference prefix).whether the given name is a factory dereferenceReturn the actual bean name, stripping out the factory dereferenceprefix (if any, also stripping repeated factory prefixes if found).the transformed nameReturn whether the given name is a bean name which has been generatedby the default naming strategy (containing a "#..." part).whether the given name is a generated bean name#GENERATED_BEAN_NAME_SEPARATORorg.springframework.beans.factory.support.BeanDefinitionReaderUtils#generateBeanNameorg.springframework.beans.factory.support.DefaultBeanNameGeneratorExtract the "raw" bean name from the given (potentially generated) bean name,excluding any "#..." suffixes which might have been added for uniqueness.the potentially generated bean namethe raw bean name Retrieval of bean namesCount all beans in any hierarchy in which this factory participates.Includes counts of ancestor bean factories.<p>Beans that are "overridden" (specified in a descendant factorywith the same name) are only counted once.the bean factorycount of beans including those defined in ancestor factories#beanNamesIncludingAncestorsReturn all bean names in the factory, including ancestor factories.the array of matching bean names, or an empty array if none#beanNamesForTypeIncludingAncestorsGet all bean names for the given type, including those defined in ancestorfactories. Will return unique names in case of overridden bean definitions.<p>Does consider objects created by FactoryBeans, which means that FactoryBeanswill get initialized. If the object created by the FactoryBean doesn't match,the raw FactoryBean itself will be matched against the type.<p>This version of {@code beanNamesForTypeIncludingAncestors} automaticallyincludes prototypes and FactoryBeans.the type that beans must match (as a {@code ResolvableType})ListableBeanFactory#getBeanNamesForType(ResolvableType)<p>Does consider objects created by FactoryBeans if the "allowEagerInit"flag is set, which means that FactoryBeans will get initialized. If theobject created by the FactoryBean doesn't match, the raw FactoryBean itselfwill be matched against the type. If "allowEagerInit" is not set,only raw FactoryBeans will be checked (which doesn't require initializationof each FactoryBean).whether to include prototype or scoped beans tooor just singletons (also applies to FactoryBeans)whether to initialize <i>lazy-init singletons</i> and<i>objects created by FactoryBeans</i> (or by factory methods with a"factory-bean" reference) for the type check. Note that FactoryBeans need to beeagerly initialized to determine their type: So be aware that passing in "true"for this flag will initialize FactoryBeans and "factory-bean" references.ListableBeanFactory#getBeanNamesForType(ResolvableType, boolean, boolean)the type that beans must match (as a {@code Class})ListableBeanFactory#getBeanNamesForType(Class)the type that beans must matchListableBeanFactory#getBeanNamesForType(Class, boolean, boolean)Get all bean names whose {@code Class} has the supplied {@link Annotation}type, including those defined in ancestor factories, without creating any beaninstances yet. Will return unique names in case of overridden bean definitions.the type of annotation to look forListableBeanFactory#getBeanNamesForAnnotation(Class) Retrieval of bean instancesReturn all beans of the given type or subtypes, also picking up beans defined inancestor bean factories if the current bean factory is a HierarchicalBeanFactory.The returned Map will only contain beans of this type.<p><b>Note: Beans of the same name will take precedence at the 'lowest' factory level,i.e. such beans will be returned from the lowest factory that they are being found in,hiding corresponding beans in ancestor factories.</b> This feature allows for'replacing' beans by explicitly choosing the same bean name in a child factory;the bean in the ancestor factory won't be visible then, not even for by-type lookups.type of bean to matchthe Map of matching bean instances, or an empty Map if noneif a bean could not be createdListableBeanFactory#getBeansOfType(Class)<p>Does consider objects created by FactoryBeans if the "allowEagerInit" flag is set,which means that FactoryBeans will get initialized. If the object created by theFactoryBean doesn't match, the raw FactoryBean itself will be matched against thetype. If "allowEagerInit" is not set, only raw FactoryBeans will be checked(which doesn't require initialization of each FactoryBean).ListableBeanFactory#getBeansOfType(Class, boolean, boolean)Return a single bean of the given type or subtypes, also picking up beansdefined in ancestor bean factories if the current bean factory is aHierarchicalBeanFactory. Useful convenience method when we expect asingle bean and don't care about the bean name.<p>This version of {@code beanOfTypeIncludingAncestors} automatically includesprototypes and FactoryBeans.the matching bean instance#beansOfTypeIncludingAncestors(ListableBeanFactory, Class)#beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)Return a single bean of the given type or subtypes, not looking in ancestorfactories. Useful convenience method when we expect a single bean anddon't care about the bean name.<p>This version of {@code beanOfType} automatically includesMerge the given bean names result with the given parent result.the local bean name resultthe parent bean name result (possibly empty)the local bean factorythe merged result (possibly the local result as-is)Extract a unique bean for the given type from the given Map of matching beans.all matching beans foundthe unique bean instanceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanInitializationException.javaException that a bean implementation is suggested to throw if its ownfactory-aware initialization code fails. BeansExceptions thrown bybean factory methods themselves should simply be propagated as-is.<p>Note that {@code afterPropertiesSet()} or a custom "init-method"can throw any exception.13.11.2003Create a new BeanInitializationException with the specified message.Create a new BeanInitializationException with the specified messageC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanIsAbstractException.javaBeanIsAbstractException"Bean definition is abstract"Bean definition is abstractException thrown when a bean instance has been requested fora bean definition which has been marked as abstract.org.springframework.beans.factory.support.AbstractBeanDefinition#setAbstractCreate a new BeanIsAbstractException.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanIsNotAFactoryException.javaBeanIsNotAFactoryExceptionactualTypeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/FactoryBean.classException thrown when a bean is not a factory, but a user tries to getat the factory for the given bean name. Whether a bean is a factory isdetermined by whether it implements the FactoryBean interface.10.03.2003Create a new BeanIsNotAFactoryException.the actual type returned, which did not matchthe expected typeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanNameAware.javaInterface to be implemented by beans that want to be aware of theirbean name in a bean factory. Note that it is not usually recommendedthat an object depends on its bean name, as this represents a potentiallybrittle dependence on external configuration, as well as a possiblyunnecessary dependence on a Spring API.01.11.2003Set the name of the bean in the bean factory that created this bean.<p>Invoked after population of normal bean properties but before aninit callback such as {@link InitializingBean#afterPropertiesSet()}or a custom init-method.the name of the bean in the factory.Note that this name is the actual bean name used in the factory, which maydiffer from the originally specified name: in particular for inner beannames, the actual bean name might have been made unique through appending"#..." suffixes. Use the {@link BeanFactoryUtils#originalBeanName(String)}method to extract the original bean name (without suffix), if desired.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/BeanNotOfRequiredTypeException.javaC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/BeanNotOfRequiredTypeException.class"Bean named '"Bean named '"' is expected to be of type '"' is expected to be of type '"' but was actually of type '"' but was actually of type 'Thrown when a bean doesn't match the expected type.The name of the instance that was of the wrong type.The required type.The offending type.Create a new BeanNotOfRequiredTypeException.the required typeReturn the name of the instance that was of the wrong type.Return the expected type for the bean.Return the actual type of the instance found.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/CannotLoadBeanClassException.javaCannotLoadBeanClassExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/CannotLoadBeanClassException.class"Cannot find class ["Cannot find class ["] for bean with name '"] for bean with name '"Error loading class ["Error loading class [": problem with class file or dependent class": problem with class file or dependent classException thrown when the BeanFactory cannot load the specified classof a given bean.Create a new CannotLoadBeanClassException.the name of the bean classdefinition came from.Return the name of the bean requested.Return the name of the class we were trying to load.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/DisposableBean.javaDisposableBeanInterface to be implemented by beans that want to release resources on destruction.A {@link BeanFactory} will invoke the destroy method on individual destruction of ascoped bean. An {@link org.springframework.context.ApplicationContext} is supposedto dispose all of its singletons on shutdown, driven by the application lifecycle.<p>A Spring-managed bean may also implement Java's {@link AutoCloseable} interfacefor the same purpose. An alternative to implementing an interface is specifying acustom destroy method, for example in an XML bean definition. For a list of allbean lifecycle methods, see the {@link BeanFactory BeanFactory javadocs}.12.08.2003org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName()org.springframework.beans.factory.config.ConfigurableBeanFactory#destroySingletons()org.springframework.context.ConfigurableApplicationContext#close()Invoked by the containing {@code BeanFactory} on destruction of a bean.in case of shutdown errors. Exceptions will get loggedbut not rethrown to allow other beans to release their resources as well.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/FactoryBean.java"factoryBeanObjectType"factoryBeanObjectTypeInterface to be implemented by objects used within a {@link BeanFactory} whichare themselves factories for individual objects. If a bean implements thisinterface, it is used as a factory for an object to expose, not directly as abean instance that will be exposed itself.<p><b>NB: A bean that implements this interface cannot be used as a normal bean.</b>A FactoryBean is defined in a bean style, but the object exposed for beanreferences ({@link #getObject()}) is always the object that it creates.<p>FactoryBeans can support singletons and prototypes, and can either createobjects lazily on demand or eagerly on startup. The {@link SmartFactoryBean}interface allows for exposing more fine-grained behavioral metadata.<p>This interface is heavily used within the framework itself, for example forthe AOP {@link org.springframework.aop.framework.ProxyFactoryBean} or the{@link org.springframework.jndi.JndiObjectFactoryBean}. It can be used forcustom components as well; however, this is only common for infrastructure code.<p><b>{@code FactoryBean} is a programmatic contract. Implementations are notsupposed to rely on annotation-driven injection or other reflective facilities.</b>{@link #getObjectType()} {@link #getObject()} invocations may arrive early in thebootstrap process, even ahead of any post-processor setup. If you need access toother beans, implement {@link BeanFactoryAware} and obtain them programmatically.<p><b>The container is only responsible for managing the lifecycle of the FactoryBeaninstance, not the lifecycle of the objects created by the FactoryBean.</b> Therefore,a destroy method on an exposed bean object (such as {@link java.io.Closeable#close()}will <i>not</i> be called automatically. Instead, a FactoryBean should implement{@link DisposableBean} and delegate any such close call to the underlying object.<p>Finally, FactoryBean objects participate in the containing BeanFactory'ssynchronization of bean creation. There is usually no need for internalsynchronization other than for purposes of lazy initialization within theFactoryBean itself (or the like).08.03.2003<T>the bean typeorg.springframework.aop.framework.ProxyFactoryBeanorg.springframework.jndi.JndiObjectFactoryBeanThe name of an attribute that can be{@link org.springframework.core.AttributeAccessor#setAttribute set} on a{@link org.springframework.beans.factory.config.BeanDefinition} so thatfactory beans can signal their object type when it can't be deduced fromthe factory bean class.Return an instance (possibly shared or independent) of the objectmanaged by this factory.<p>As with a {@link BeanFactory}, this allows support for both theSingleton and Prototype design pattern.<p>If this FactoryBean is not fully initialized yet at the time ofthe call (for example because it is involved in a circular reference),throw a corresponding {@link FactoryBeanNotInitializedException}.<p>As of Spring 2.0, FactoryBeans are allowed to return {@code null}objects. The factory will consider this as normal value to be used; itwill not throw a FactoryBeanNotInitializedException in this case anymore.FactoryBean implementations are encouraged to throwFactoryBeanNotInitializedException themselves now, as appropriate.an instance of the bean (can be {@code null})in case of creation errorsFactoryBeanNotInitializedExceptionReturn the type of object that this FactoryBean creates,or {@code null} if not known in advance.<p>This allows one to check for specific types of beans withoutinstantiating objects, for example on autowiring.<p>In the case of implementations that are creating a singleton object,this method should try to avoid singleton creation as far as possible;it should rather estimate the type in advance.For prototypes, returning a meaningful type here is advisable too.<p>This method can be called <i>before</i> this FactoryBean hasbeen fully initialized. It must not rely on state created duringinitialization; of course, it can still use such state if available.<p><b>NOTE:</b> Autowiring will simply ignore FactoryBeans that return{@code null} here. Therefore it is highly recommended to implementthis method properly, using the current state of the FactoryBean.the type of object that this FactoryBean creates,or {@code null} if not known at the time of the callListableBeanFactory#getBeansOfTypeIs the object managed by this factory a singleton? That is,will {@link #getObject()} always return the same object(a reference that can be cached)?<p><b>NOTE:</b> If a FactoryBean indicates to hold a singleton object,the object returned from {@code getObject()} might get cachedby the owning BeanFactory. Hence, do not return {@code true}unless the FactoryBean always exposes the same reference.<p>The singleton status of the FactoryBean itself will generallybe provided by the owning BeanFactory; usually, it has to bedefined as singleton there.<p><b>NOTE:</b> This method returning {@code false} does notnecessarily indicate that returned objects are independent instances.An implementation of the extended {@link SmartFactoryBean} interfacemay explicitly indicate independent instances through its{@link SmartFactoryBean#isPrototype()} method. Plain {@link FactoryBean}implementations which do not implement this extended interface aresimply assumed to always return independent instances if the{@code isSingleton()} implementation returns {@code false}.<p>The default implementation returns {@code true}, since a{@code FactoryBean} typically manages a singleton instance.whether the exposed object is a singleton#getObject()SmartFactoryBean#isPrototype()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/FactoryBeanNotInitializedException.java"FactoryBean is not fully initialized yet"FactoryBean is not fully initialized yetException to be thrown from a FactoryBean's {@code getObject()} methodif the bean is not fully initialized yet, for example because it is involvedin a circular reference.<p>Note: A circular reference with a FactoryBean cannot be solved by eagerlycaching singleton instances like with normal beans. The reason is that<i>every</i> FactoryBean needs to be fully initialized before it canreturn the created bean, while only <i>specific</i> normal beans needto be initialized - that is, if a collaborating bean actually invokesthem on initialization instead of just storing the reference.30.10.2003FactoryBean#getObject()Create a new FactoryBeanNotInitializedException with the default message.Create a new FactoryBeanNotInitializedException with the given message.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/HierarchicalBeanFactory.javaHierarchicalBeanFactorySub-interface implemented by bean factories that can be partof a hierarchy.<p>The corresponding {@code setParentBeanFactory} method for beanfactories that allow setting the parent in a configurablefashion can be found in the ConfigurableBeanFactory interface.07.07.2003org.springframework.beans.factory.config.ConfigurableBeanFactory#setParentBeanFactoryReturn the parent bean factory, or {@code null} if there is none.Return whether the local bean factory contains a bean of the given name,ignoring beans defined in ancestor contexts.<p>This is an alternative to {@code containsBean}, ignoring a beanof the given name from an ancestor bean factory.whether a bean with the given name is defined in the local factoryBeanFactory#containsBeanC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/InitializingBean.javaInterface to be implemented by beans that need to react once all their propertieshave been set by a {@link BeanFactory}: e.g. to perform custom initialization,or merely to check that all mandatory properties have been set.<p>An alternative to implementing {@code InitializingBean} is specifying a custominit method, for example in an XML bean definition. For a list of all beanlifecycle methods, see the {@link BeanFactory BeanFactory javadocs}.org.springframework.beans.factory.config.BeanDefinition#getPropertyValues()org.springframework.beans.factory.support.AbstractBeanDefinition#getInitMethodName()Invoked by the containing {@code BeanFactory} after it has set all bean propertiesand satisfied {@link BeanFactoryAware}, {@code ApplicationContextAware} etc.<p>This method allows the bean instance to perform validation of its overallconfiguration and final initialization when all bean properties have been set.in the event of misconfiguration (such as failure to set anessential property) or if initialization fails for any other reasonC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/InjectionPoint.javaInjectionPointfieldAnnotationsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/InjectionPoint.classmethodParameter"MethodParameter must not be null"MethodParameter must not be null"Field must not be null"Field must not be null"Neither Field nor MethodParameter"Neither Field nor MethodParameterotherPoint? extends InjectionPointClass<? extends InjectionPoint>"field '"field 'A simple descriptor for an injection point, pointing to a method/constructorparameter or a field. Exposed by {@link UnsatisfiedDependencyException}.Also available as an argument for factory methods, reacting to therequesting injection point for building a customized bean instance.UnsatisfiedDependencyException#getInjectionPoint()org.springframework.beans.factory.config.DependencyDescriptorCreate an injection point descriptor for a method or constructor parameter.the MethodParameter to wrapCreate an injection point descriptor for a field.the field to wrapthe original descriptor to create a copy fromJust available for serialization purposes in subclasses.Return the wrapped MethodParameter, if any.<p>Note: Either MethodParameter or Field is available.the MethodParameter, or {@code null} if noneReturn the wrapped Field, if any.the Field, or {@code null} if noneReturn the wrapped MethodParameter, assuming it is present.the MethodParameter (never {@code null})if no MethodParameter is availableObtain the annotations associated with the wrapped field or method/constructor parameter.Retrieve a field/parameter annotation of the given type, if any.the annotation type to retrievethe annotation instance, or {@code null} if none found4.3.9Return the type declared by the underlying field or method/constructor parameter,indicating the injection type.Returns the wrapped member, containing the injection point.the Field / Method / Constructor as MemberReturn the wrapped annotated element.<p>Note: In case of a method/constructor parameter, this exposesthe annotations declared on the method or constructor itself(i.e. at the method/constructor level, not at the parameter level).Use {@link #getAnnotations()} to obtain parameter-level annotations insuch a scenario, transparently with corresponding field annotations.the Field / Method / Constructor as AnnotatedElementC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/ListableBeanFactory.javaExtension of the {@link BeanFactory} interface to be implemented by bean factoriesthat can enumerate all their bean instances, rather than attempting bean lookupby name one by one as requested by clients. BeanFactory implementations thatpreload all their bean definitions (such as XML-based factories) may implementthis interface.<p>If this is a {@link HierarchicalBeanFactory}, the return values will <i>not</i>take any BeanFactory hierarchy into account, but will relate only to the beansdefined in the current factory. Use the {@link BeanFactoryUtils} helper classto consider beans in ancestor factories too.<p>The methods in this interface will just respect bean definitions of this factory.They will ignore any singleton beans that have been registered by other means like{@link org.springframework.beans.factory.config.ConfigurableBeanFactory}'s{@code registerSingleton} method, with the exception of{@code getBeanNamesForType} and {@code getBeansOfType} which will checksuch manually registered singletons too. Of course, BeanFactory's {@code getBean}does allow transparent access to such special beans as well. However, in typicalscenarios, all beans will be defined by external bean definitions anyway, so mostapplications don't need to worry about this differentiation.<p><b>NOTE:</b> With the exception of {@code getBeanDefinitionCount}and {@code containsBeanDefinition}, the methods in this interfaceare not designed for frequent invocation. Implementations may be slow.16 April 2001Check if this bean factory contains a bean definition with the given name.<p>Does not consider any hierarchy this factory may participate in,and ignores any singleton beans that have been registered byother means than bean definitions.the name of the bean to look forif this bean factory contains a bean definition with the given name#containsBeanReturn the number of beans defined in the factory.the number of beans defined in the factoryReturn the names of all beans defined in this factory.the names of all beans defined in this factory,or an empty array if none definedwhether stream-based access may initialize <i>lazy-initsingletons</i> and <i>objects created by FactoryBeans</i> (or by factory methodswith a "factory-bean" reference) for the type check#getBeanProvider(ResolvableType, boolean)#getBeanProvider(Class)#getBeansOfType(Class, boolean, boolean)#getBeanNamesForType(Class, boolean, boolean)#getBeanNamesForType(ResolvableType, boolean, boolean)Return the names of beans matching the given type (including subclasses),judging from either bean definitions or the value of {@code getObjectType}in the case of FactoryBeans.<p><b>NOTE: This method introspects top-level beans only.</b> It does <i>not</i>check nested beans which might match the specified type as well.<p>Does not consider any hierarchy this factory may participate in.Use BeanFactoryUtils' {@code beanNamesForTypeIncludingAncestors}to include beans in ancestor factories too.<p>Note: Does <i>not</i> ignore singleton beans that have been registeredby other means than bean definitions.<p>This version of {@code getBeanNamesForType} matches all kinds of beans,be it singletons, prototypes, or FactoryBeans. In most implementations, theresult will be the same as for {@code getBeanNamesForType(type, true, true)}.<p>Bean names returned by this method should always return bean names <i>in theorder of definition</i> in the backend configuration, as far as possible.the generically typed class or interface to matchthe names of beans (or objects created by FactoryBeans) matchingthe given object type (including subclasses), or an empty array if none#isTypeMatch(String, ResolvableType)FactoryBean#getObjectTypeBeanFactoryUtils#beanNamesForTypeIncludingAncestors(ListableBeanFactory, ResolvableType)BeanFactoryUtils#beanNamesForTypeIncludingAncestors(ListableBeanFactory, ResolvableType, boolean, boolean)the class or interface to match, or {@code null} for all bean namesBeanFactoryUtils#beanNamesForTypeIncludingAncestors(ListableBeanFactory, Class)BeanFactoryUtils#beanNamesForTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)Return the bean instances that match the given object type (includingsubclasses), judging from either bean definitions or the value of{@code getObjectType} in the case of FactoryBeans.Use BeanFactoryUtils' {@code beansOfTypeIncludingAncestors}<p>This version of getBeansOfType matches all kinds of beans, be itsingletons, prototypes, or FactoryBeans. In most implementations, theresult will be the same as for {@code getBeansOfType(type, true, true)}.<p>The Map returned by this method should always return bean names andcorresponding bean instances <i>in the order of definition</i> in thebackend configuration, as far as possible.the class or interface to match, or {@code null} for all concrete beansa Map with the matching beans, containing the bean names askeys and the corresponding bean instances as valuesBeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class)BeanFactoryUtils#beansOfTypeIncludingAncestors(ListableBeanFactory, Class, boolean, boolean)Find all names of beans which are annotated with the supplied {@link Annotation}type, without creating corresponding bean instances yet.<p>Note that this method considers objects created by FactoryBeans, which meansthat FactoryBeans will get initialized in order to determine their object type.(at class, interface or factory method level of the specified bean)the names of all matching beans#findAnnotationOnBeanFind all beans which are annotated with the supplied {@link Annotation} type,returning a Map of bean names with corresponding bean instances.Find an {@link Annotation} of {@code annotationType} on the specified bean,traversing its interfaces and super classes if no annotation can be found onthe given class itself, as well as checking the bean's factory method (if any).the name of the bean to look for annotations onthe annotation of the given type if found, or {@code null} otherwise#getBeanNamesForAnnotation#getBeansWithAnnotationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/NamedBean.javaNamedBeanCounterpart of {@link BeanNameAware}. Returns the bean name of an object.<p>This interface can be introduced to avoid a brittle dependence onbean name in objects used with Spring IoC and Spring AOP.Return the name of this bean in a Spring bean factory, if known.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/NoSuchBeanDefinitionException.javaresolvableTypeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/NoSuchBeanDefinitionException.class"No bean named '"No bean named '"' available"' available"' available: "' available: "No qualifying bean of type '"No qualifying bean of type 'Exception thrown when a {@code BeanFactory} is asked for a bean instance for which itcannot find a definition. This may point to a non-existing bean, a non-unique bean,or a manually registered singleton instance without an associated bean definition.BeanFactory#getBean(String)BeanFactory#getBean(Class)Create a new {@code NoSuchBeanDefinitionException}.the name of the missing beandetailed message describing the problemrequired type of the missing beanfull type declaration of the missing bean4.3.4Return the name of the missing bean, if it was a lookup <em>by name</em> that failed.Return the required type of the missing bean, if it was a lookup <em>by type</em>that failed.Return the required {@link ResolvableType} of the missing bean, if it was a lookup<em>by type</em> that failed.Return the number of beans found when only one matching bean was expected.For a regular NoSuchBeanDefinitionException, this will always be 0.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/NoUniqueBeanDefinitionException.javabeanNamesFoundC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/NoUniqueBeanDefinitionException.classnumberOfBeansFound"expected single matching bean but found "expected single matching bean but found Exception thrown when a {@code BeanFactory} is asked for a bean instance for whichmultiple matching candidates have been found when only one matching bean was expected.3.2.1Create a new {@code NoUniqueBeanDefinitionException}.required type of the non-unique beanthe number of matching beansthe names of all matching beans (as a Collection)the names of all matching beans (as an array)For a NoUniqueBeanDefinitionException, this will usually be higher than 1.#getBeanType()Return the names of all beans found when only one matching bean was expected.Note that this may be {@code null} if not specified at construction time.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/ObjectFactory.javaDefines a factory which can return an Object instance(possibly shared or independent) when invoked.<p>This interface is typically used to encapsulate a generic factory whichreturns a new instance (prototype) of some target object on each invocation.<p>This interface is similar to {@link FactoryBean}, but implementationsof the latter are normally meant to be defined as SPI instances in a{@link BeanFactory}, while implementations of this class are normally meantto be fed as an API to other beans (through injection). As such, the{@code getObject()} method has different exception handling behavior.the object typeReturn an instance (possibly shared or independent)of the object managed by this factory.the resulting instanceC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/ObjectProvider.javadefaultSupplierdependencydependencyConsumer"Multi element access not supported"Multi element access not supported"Ordered element access not supported"Ordered element access not supportedA variant of {@link ObjectFactory} designed specifically for injection points,allowing for programmatic optionality and lenient not-unique handling.<p>As of 5.1, this interface extends {@link Iterable} and provides {@link Stream}support. It can be therefore be used in {@code for} loops, provides {@link #forEach}iteration and allows for collection-style {@link #stream} access.BeanFactory#getBeanProviderorg.springframework.beans.factory.annotation.Autowired<p>Allows for specifying explicit construction arguments, along thelines of {@link BeanFactory#getBean(String, Object...)}.arguments to use when creating a corresponding instancean instance of the bean, or {@code null} if not availablea callback for supplying a default objectif none is present in the factoryan instance of the bean, or the supplied default objectif no such bean is available#getIfAvailable()Consume an instance (possibly shared or independent) of the objectmanaged by this factory, if available.a callback for processing the target objectif available (not called otherwise)an instance of the bean, or {@code null} if not available ornot unique (i.e. multiple candidates found with none marked as primary)if no unique candidate is present in the factoryif no such bean is available or if it is not unique in the factory(i.e. multiple candidates found with none marked as primary)#getIfUnique()managed by this factory, if unique.if unique (not called otherwise)Return an {@link Iterator} over all matching object instances,without specific ordering guarantees (but typically in registration order).#stream()Return a sequential {@link Stream} over all matching object instances,#iterator()#orderedStream()pre-ordered according to the factory's common order comparator.<p>In a standard Spring application context, this will be orderedaccording to {@link org.springframework.core.Ordered} conventions,and in case of annotation-based configuration also considering the{@link org.springframework.core.annotation.Order} annotation,analogous to multi-element injection points of list/array type.org.springframework.core.OrderComparatorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/SmartFactoryBean.javaSmartFactoryBeanFactoryBean<T>Extension of the {@link FactoryBean} interface. Implementations mayindicate whether they always return independent instances, for thecase where their {@link #isSingleton()} implementation returning{@code false} does not clearly indicate independent instances.<p>Plain {@link FactoryBean} implementations which do not implementthis extended interface are simply assumed to always return independentinstances if their {@link #isSingleton()} implementation returns{@code false}; the exposed object is only accessed on demand.<p><b>NOTE:</b> This interface is a special purpose interface, mainly forinternal use within the framework and within collaborating frameworks.In general, application-provided FactoryBeans should simply implementthe plain {@link FactoryBean} interface. New methods might be addedto this extended interface even in point releases.#isPrototype()#isSingleton()Is the object managed by this factory a prototype? That is,will {@link #getObject()} always return an independent instance?<p>The prototype status of the FactoryBean itself will generallybe provided by the owning {@link BeanFactory}; usually, it has to be<p>This method is supposed to strictly check for independent instances;it should not return {@code true} for scoped objects or otherkinds of non-singleton, non-independent objects. For this reason,this is not simply the inverted form of {@link #isSingleton()}.<p>The default implementation returns {@code false}.whether the exposed object is a prototypeDoes this FactoryBean expect eager initialization, that is,eagerly initialize itself as well as expect eager initializationof its singleton object (if any)?<p>A standard FactoryBean is not expected to initialize eagerly:Its {@link #getObject()} will only be called for actual access, evenin case of a singleton object. Returning {@code true} from thismethod suggests that {@link #getObject()} should be called eagerly,also applying post-processors eagerly. This may make sense in caseof a {@link #isSingleton() singleton} object, in particular ifpost-processors expect to be applied on startup.whether eager initialization appliesorg.springframework.beans.factory.config.ConfigurableListableBeanFactory#preInstantiateSingletons()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/SmartInitializingSingleton.javaSmartInitializingSingletonCallback interface triggered at the end of the singleton pre-instantiation phaseduring {@link BeanFactory} bootstrap. This interface can be implemented bysingleton beans in order to perform some initialization after the regularsingleton instantiation algorithm, avoiding side effects with accidental earlyinitialization (e.g. from {@link ListableBeanFactory#getBeansOfType} calls).In that sense, it is an alternative to {@link InitializingBean} which getstriggered right at the end of a bean's local construction phase.<p>This callback variant is somewhat similar to{@link org.springframework.context.event.ContextRefreshedEvent} but doesn'trequire an implementation of {@link org.springframework.context.ApplicationListener},with no need to filter context references across a context hierarchy etc.It also implies a more minimal dependency on just the {@code beans} packageand is being honored by standalone {@link ListableBeanFactory} implementations,not just in an {@link org.springframework.context.ApplicationContext} environment.<p><b>NOTE:</b> If you intend to start/manage asynchronous tasks, preferablyimplement {@link org.springframework.context.Lifecycle} instead which offersa richer model for runtime management and allows for phased startup/shutdown.Invoked right at the end of the singleton pre-instantiation phase,with a guarantee that all regular singleton beans have been createdalready. {@link ListableBeanFactory#getBeansOfType} calls withinthis method won't trigger accidental side effects during bootstrap.<p><b>NOTE:</b> This callback won't be triggered for singleton beanslazily initialized on demand after {@link BeanFactory} bootstrap,and not for any other bean scope either. Carefully use it for beanswith the intended bootstrap semantics only.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/UnsatisfiedDependencyException.javaUnsatisfiedDependencyExceptioninjectionPointC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/UnsatisfiedDependencyException.class"Unsatisfied dependency expressed through bean property '"Unsatisfied dependency expressed through bean property '"Unsatisfied dependency expressed through "Unsatisfied dependency expressed through Exception thrown when a bean depends on other beans or simple propertiesthat were not specified in the bean factory definition, althoughdependency checking was enabled.03.09.2003Create a new UnsatisfiedDependencyException.the name of the bean property that couldn't be satisfiedthe bean creation exception that indicated the unsatisfied dependencythe injection point (field or method/constructor parameter)Return the injection point (field or method/constructor parameter), if known.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AnnotatedBeanDefinition.javaAnnotatedBeanDefinitionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotationorg.springframework.beans.factory.annotationExtended {@link org.springframework.beans.factory.config.BeanDefinition}interface that exposes {@link org.springframework.core.type.AnnotationMetadata}about its bean class - without requiring the class to be loaded yet.AnnotatedGenericBeanDefinitionorg.springframework.core.type.AnnotationMetadataObtain the annotation metadata (as well as basic class metadata)for this bean definition's bean class.the annotation metadata object (never {@code null})Obtain metadata for this bean definition's factory method, if any.the factory method metadata, or {@code null} if none4.1.1C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AnnotatedGenericBeanDefinition.javafactoryMethodMetadataC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/AnnotatedGenericBeanDefinition.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation"AnnotationMetadata must not be null"AnnotationMetadata must not be null"MethodMetadata must not be null"MethodMetadata must not be nullExtension of the {@link org.springframework.beans.factory.support.GenericBeanDefinition}class, adding support for annotation metadata exposed through the{@link AnnotatedBeanDefinition} interface.<p>This GenericBeanDefinition variant is mainly useful for testing code that expectsto operate on an AnnotatedBeanDefinition, for example strategy implementationsin Spring's component scanning support (where the default definition class is{@link org.springframework.context.annotation.ScannedGenericBeanDefinition},which also implements the AnnotatedBeanDefinition interface).AnnotatedBeanDefinition#getMetadata()org.springframework.core.type.StandardAnnotationMetadataCreate a new AnnotatedGenericBeanDefinition for the given bean class.the loaded bean classCreate a new AnnotatedGenericBeanDefinition for the given annotation metadata,allowing for ASM-based processing and avoidance of early loading of the bean class.Note that this constructor is functionally equivalent to{@link org.springframework.context.annotation.ScannedGenericBeanDefinitionScannedGenericBeanDefinition}, however the semantics of the latter indicate that abean was discovered specifically via component-scanning as opposed to other means.the annotation metadata for the bean class in question3.1.1based on an annotated class and a factory method on that class.metadata for the selected factory methodC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AnnotationBeanWiringInfoResolver.javaAnnotationBeanWiringInfoResolverClass<Configurable>"Bean instance must not be null"Bean instance must not be nullEnum<Autowire>Comparable<Autowire>compareTo(org.springframework.beans.factory.annotation.Autowire)finalize()Enum<T>Comparable<T>valueOfvalueOf(java.lang.Class,java.lang.String)EnumDesc<E>C:/modules/java.base/java/lang/Enum$EnumDesc.classEnum$EnumDescjava.lang.constantDynamicConstantDesc<E>C:/modules/java.base/java/lang/constant/DynamicConstantDesc.classDynamicConstantDescC:/modules/java.base/java/lang/constantconstantOptional<EnumDesc<E>>EnumDesc<Autowire>DynamicConstantDesc<Autowire>Optional<EnumDesc<Autowire>>Class<E>Class<Autowire>compareTo(java.lang.Enum)Enum(java.lang.String,int)Enum<Autowire>(java.lang.String,int)ordinalordinal()name(){@link org.springframework.beans.factory.wiring.BeanWiringInfoResolver} thatuses the Configurable annotation to identify which classes need autowiring.The bean name to look up will be taken from the {@link Configurable} annotationif specified; otherwise the default will be the fully-qualified name of theclass being configured.Configurableorg.springframework.beans.factory.wiring.ClassNameBeanWiringInfoResolverBuild the {@link BeanWiringInfo} for the given {@link Configurable} annotation.the Configurable annotation found on the bean classthe resolved BeanWiringInfo Autowiring by name or by type Explicitly specified bean name for bean definition to take property values from Default bean name for bean definition to take property values fromDetermine the default bean name for the specified bean instance.<p>The default implementation returns the superclass name for a CGLIBproxy and the name of the plain bean class else.the bean instance to build a default name forthe default bean name to useorg.springframework.util.ClassUtils#getUserClass(Class)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Autowire.javaAutowireAutowire(int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/Autowire.classCopyright 2002-2009 the original author or authors.Enumeration determining autowiring status: that is, whether a bean shouldhave its dependencies automatically injected by the Spring container usingsetter injection. This is a core concept in Spring DI.<p>Available for use in annotation-based configurations, such as for theAspectJ AnnotationBeanConfigurer aspect.org.springframework.beans.factory.annotation.Configurableorg.springframework.beans.factory.config.AutowireCapableBeanFactoryConstant that indicates no autowiring at all.Constant that indicates autowiring bean properties by name.Constant that indicates autowiring bean properties by type.Return whether this represents an actual autowiring value.whether actual autowiring was specified(either BY_NAME or BY_TYPE)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Autowired.javaAutowiredMarks a constructor, field, setter method, or config method as to be autowired bySpring's dependency injection facilities. This is an alternative to the JSR-330{@link javax.inject.Inject} annotation, adding required-vs-optional semantics.<h3>Autowired Constructors</h3><p>Only one constructor of any given bean class may declare this annotation with the{@link #required} attribute set to {@code true}, indicating <i>the</i> constructorto autowire when used as a Spring bean. Furthermore, if the {@code required}attribute is set to {@code true}, only a single constructor may be annotatedwith {@code @Autowired}. If multiple <i>non-required</i> constructors declare theannotation, they will be considered as candidates for autowiring. The constructorwith the greatest number of dependencies that can be satisfied by matching beansin the Spring container will be chosen. If none of the candidates can be satisfied,then a primary/default constructor (if present) will be used. Similarly, if aclass declares multiple constructors but none of them is annotated with{@code @Autowired}, then a primary/default constructor (if present) will be used.If a class only declares a single constructor to begin with, it will always be used,even if not annotated. An annotated constructor does not have to be public.<h3>Autowired Fields</h3><p>Fields are injected right after construction of a bean, before any config methodsare invoked. Such a config field does not have to be public.<h3>Autowired Methods</h3><p>Config methods may have an arbitrary name and any number of arguments; each ofthose arguments will be autowired with a matching bean in the Spring container.Bean property setter methods are effectively just a special case of such a generalconfig method. Such config methods do not have to be public.<h3>Autowired Parameters</h3><p>Although {@code @Autowired} can technically be declared on individual methodor constructor parameters since Spring Framework 5.0, most parts of theframework ignore such declarations. The only part of the core Spring Frameworkthat actively supports autowired parameters is the JUnit Jupiter support inthe {@code spring-test} module (see the<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#testcontext-junit-jupiter-di">TestContext framework</a>reference documentation for details).<h3>Multiple Arguments and 'required' Semantics</h3><p>In the case of a multi-arg constructor or method, the {@link #required} attributeis applicable to all arguments. Individual parameters may be declared as Java-8 style{@link java.util.Optional} or, as of Spring Framework 5.0, also as {@code @Nullable}or a not-null parameter type in Kotlin, overriding the base 'required' semantics.<h3>Autowiring Arrays, Collections, and Maps</h3><p>In case of an array, {@link java.util.Collection}, or {@link java.util.Map}dependency type, the container autowires all beans matching the declared valuetype. For such purposes, the map keys must be declared as type {@code String}which will be resolved to the corresponding bean names. Such a container-providedcollection will be ordered, taking into account{@link org.springframework.core.Ordered Ordered} and{@link org.springframework.core.annotation.Order @Order} values of the targetcomponents, otherwise following their registration order in the container.Alternatively, a single matching target bean may also be a generally typed{@code Collection} or {@code Map} itself, getting injected as such.<h3>Not supported in {@code BeanPostProcessor} or {@code BeanFactoryPostProcessor}</h3><p>Note that actual injection is performed through a{@link org.springframework.beans.factory.config.BeanPostProcessorBeanPostProcessor} which in turn means that you <em>cannot</em>use {@code @Autowired} to inject references intoBeanPostProcessor} or{@link org.springframework.beans.factory.config.BeanFactoryPostProcessor BeanFactoryPostProcessor}types. Please consult the javadoc for the {@link AutowiredAnnotationBeanPostProcessor}class (which, by default, checks for the presence of this annotation).AutowiredAnnotationBeanPostProcessorQualifierValueDeclares whether the annotated dependency is required.<p>Defaults to {@code true}.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.javaresolvedCachedArgumentresolvedCachedArgument(java.lang.String,java.lang.Object)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.classregisterDependentBeansregisterDependentBeans(java.lang.String,java.util.Set)org.springframework.core.annotationMergedAnnotation<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/annotationC:/Users/Semiu/Java/spring-projects_spring-framework/spring-core/build/libs/spring-core-5.3.4-SNAPSHOT.jar/org/springframework/core/annotation/MergedAnnotation.classMergedAnnotationMergedAnnotation<?>findAutowiredAnnotationfindAutowiredAnnotation(java.lang.reflect.AccessibleObject)buildAutowiringMetadatabuildAutowiringMetadata(java.lang.Class)findAutowiringMetadatafindAutowiringMetadata(java.lang.String,java.lang.Class,org.springframework.beans.PropertyValues)Map<String,InjectionMetadata>injectionMetadataCacheMap<Class<?>,Constructor<?>[]>candidateConstructorsCachelookupMethodsCheckedrequiredParameterValuerequiredParameterNameSet<Class<? extends Annotation>>Collection<Class<? extends Annotation>>Iterable<Class<? extends Annotation>>autowiredAnnotationTypes? extends AutowiredAnnotationBeanPostProcessorClass<? extends AutowiredAnnotationBeanPostProcessor>LinkedHashSet<Class<? extends Annotation>>HashSet<Class<? extends Annotation>>AbstractSet<Class<? extends Annotation>>AbstractCollection<Class<? extends Annotation>>LinkedHashSet<Class<? extends Annotation>>(int)Spliterator<Class<? extends Annotation>>? super Class<? extends Annotation>Consumer<? super Class<? extends Annotation>>Iterator<Class<? extends Annotation>>Stream<Class<? extends Annotation>>BaseStream<Class<? extends Annotation>,Stream<Class<? extends Annotation>>>Predicate<? super Class<? extends Annotation>>? extends Class<? extends Annotation>Collection<? extends Class<? extends Annotation>>Iterable<? extends Class<? extends Annotation>>AbstractCollection<Class<? extends Annotation>>()AbstractSet<Class<? extends Annotation>>()HashSet<Class<? extends Annotation>>(int,float,boolean)HashSet<Class<? extends Annotation>>(int)HashSet<Class<? extends Annotation>>(int,float)HashSet<Class<? extends Annotation>>(java.util.Collection)HashSet<Class<? extends Annotation>>()LinkedHashSet<Class<? extends Annotation>>(java.util.Collection)LinkedHashSet<Class<? extends Annotation>>()LinkedHashSet<Class<? extends Annotation>>(int,float)"required"requiredConcurrentHashMap<Class<?>,Constructor<?>[]>AbstractMap<Class<?>,Constructor<?>[]>ConcurrentMap<Class<?>,Constructor<?>[]>ConcurrentHashMap<Class<?>,Constructor<?>[]>(int)? super Constructor<?>[]? extends Constructor<?>[]BiFunction<? super Constructor<?>[],? super Constructor<?>[],? extends Constructor<?>[]>merge(java.lang.Class,java.lang.reflect.Constructor[],java.util.function.BiFunction)BiFunction<? super Class<?>,? super Constructor<?>[],? extends Constructor<?>[]>Function<? super Class<?>,? extends Constructor<?>[]>replace(java.lang.Class,java.lang.reflect.Constructor[])replace(java.lang.Class,java.lang.reflect.Constructor[],java.lang.reflect.Constructor[])putIfAbsent(java.lang.Class,java.lang.reflect.Constructor[])BiConsumer<? super Class<?>,? super Constructor<?>[]>getOrDefault(java.lang.Object,java.lang.reflect.Constructor[])Entry<Class<?>,Constructor<?>[]>Set<Entry<Class<?>,Constructor<?>[]>>Collection<Entry<Class<?>,Constructor<?>[]>>Iterable<Entry<Class<?>,Constructor<?>[]>>Collection<Constructor<?>[]>Iterable<Constructor<?>[]>Map<? extends Class<?>,? extends Constructor<?>[]>put(java.lang.Class,java.lang.reflect.Constructor[])AbstractMap<Class<?>,Constructor<?>[]>()ToIntFunction<Entry<Class<?>,Constructor<?>[]>>ToLongFunction<Entry<Class<?>,Constructor<?>[]>>ToDoubleFunction<Entry<Class<?>,Constructor<?>[]>>Function<Entry<Class<?>,Constructor<?>[]>,? extends U>? extends Entry<Class<?>,Constructor<?>[]>BiFunction<Entry<Class<?>,Constructor<?>[]>,Entry<Class<?>,Constructor<?>[]>,? extends Entry<Class<?>,Constructor<?>[]>>? super Entry<Class<?>,Constructor<?>[]>Consumer<? super Entry<Class<?>,Constructor<?>[]>>ToIntFunction<? super Constructor<?>[]>ToLongFunction<? super Constructor<?>[]>ToDoubleFunction<? super Constructor<?>[]>Function<? super Constructor<?>[],? extends U>Consumer<? super Constructor<?>[]>ToIntBiFunction<? super Class<?>,? super Constructor<?>[]>ToLongBiFunction<? super Class<?>,? super Constructor<?>[]>ToDoubleBiFunction<? super Class<?>,? super Constructor<?>[]>BiFunction<? super Class<?>,? super Constructor<?>[],? extends U>Node<Class<?>,Constructor<?>[]>Node<Class<?>,Constructor<?>[]>[]KeySetView<Class<?>,Constructor<?>[]>CollectionView<Class<?>,Constructor<?>[],Class<?>>keySet(java.lang.reflect.Constructor[])Enumeration<Constructor<?>[]>Predicate<? super Constructor<?>[]>Predicate<? super Entry<Class<?>,Constructor<?>[]>>replaceNode(java.lang.Object,java.lang.reflect.Constructor[],java.lang.Object)putVal(java.lang.Class,java.lang.reflect.Constructor[],boolean)ConcurrentHashMap<Class<?>,Constructor<?>[]>(int,float,int)ConcurrentHashMap<Class<?>,Constructor<?>[]>(int,float)ConcurrentHashMap<Class<?>,Constructor<?>[]>(java.util.Map)ConcurrentHashMap<Class<?>,Constructor<?>[]>()ConcurrentHashMap<String,InjectionMetadata>AbstractMap<String,InjectionMetadata>ConcurrentMap<String,InjectionMetadata>ConcurrentHashMap<String,InjectionMetadata>(int)? super InjectionMetadata? extends InjectionMetadataBiFunction<? super InjectionMetadata,? super InjectionMetadata,? extends InjectionMetadata>merge(java.lang.String,org.springframework.beans.factory.annotation.InjectionMetadata,java.util.function.BiFunction)BiFunction<? super String,? super InjectionMetadata,? extends InjectionMetadata>Function<? super String,? extends InjectionMetadata>replace(java.lang.String,org.springframework.beans.factory.annotation.InjectionMetadata)replace(java.lang.String,org.springframework.beans.factory.annotation.InjectionMetadata,org.springframework.beans.factory.annotation.InjectionMetadata)putIfAbsent(java.lang.String,org.springframework.beans.factory.annotation.InjectionMetadata)BiConsumer<? super String,? super InjectionMetadata>getOrDefault(java.lang.Object,org.springframework.beans.factory.annotation.InjectionMetadata)Entry<String,InjectionMetadata>Set<Entry<String,InjectionMetadata>>Collection<Entry<String,InjectionMetadata>>Iterable<Entry<String,InjectionMetadata>>Collection<InjectionMetadata>Iterable<InjectionMetadata>Map<? extends String,? extends InjectionMetadata>put(java.lang.String,org.springframework.beans.factory.annotation.InjectionMetadata)AbstractMap<String,InjectionMetadata>()ToIntFunction<Entry<String,InjectionMetadata>>ToLongFunction<Entry<String,InjectionMetadata>>ToDoubleFunction<Entry<String,InjectionMetadata>>Function<Entry<String,InjectionMetadata>,? extends U>? extends Entry<String,InjectionMetadata>BiFunction<Entry<String,InjectionMetadata>,Entry<String,InjectionMetadata>,? extends Entry<String,InjectionMetadata>>? super Entry<String,InjectionMetadata>Consumer<? super Entry<String,InjectionMetadata>>ToIntFunction<? super InjectionMetadata>ToLongFunction<? super InjectionMetadata>ToDoubleFunction<? super InjectionMetadata>Function<? super InjectionMetadata,? extends U>Consumer<? super InjectionMetadata>ToIntBiFunction<? super String,? super InjectionMetadata>ToLongBiFunction<? super String,? super InjectionMetadata>ToDoubleBiFunction<? super String,? super InjectionMetadata>BiFunction<? super String,? super InjectionMetadata,? extends U>Node<String,InjectionMetadata>Node<String,InjectionMetadata>[]KeySetView<String,InjectionMetadata>CollectionView<String,InjectionMetadata,String>keySet(org.springframework.beans.factory.annotation.InjectionMetadata)Enumeration<InjectionMetadata>Predicate<? super InjectionMetadata>Predicate<? super Entry<String,InjectionMetadata>>replaceNode(java.lang.Object,org.springframework.beans.factory.annotation.InjectionMetadata,java.lang.Object)putVal(java.lang.String,org.springframework.beans.factory.annotation.InjectionMetadata,boolean)ConcurrentHashMap<String,InjectionMetadata>(int,float,int)ConcurrentHashMap<String,InjectionMetadata>(int,float)ConcurrentHashMap<String,InjectionMetadata>(java.util.Map)ConcurrentHashMap<String,InjectionMetadata>()Class<Autowired>Class<Value>"javax.inject.Inject"javax.inject.InjectClass<AutowiredAnnotationBeanPostProcessor>Map<String,AutowiredAnnotationBeanPostProcessor>AutowiredAnnotationBeanPostProcessor[]Constructor<AutowiredAnnotationBeanPostProcessor>? super AutowiredAnnotationBeanPostProcessorClass<? super AutowiredAnnotationBeanPostProcessor>TypeVariable<Class<AutowiredAnnotationBeanPostProcessor>>TypeVariable<Class<AutowiredAnnotationBeanPostProcessor>>[]"JSR-330 'javax.inject.Inject' annotation found and supported for autowiring"JSR-330 'javax.inject.Inject' annotation found and supported for autowiringautowiredAnnotationType"'autowiredAnnotationType' must not be null"'autowiredAnnotationType' must not be null"'autowiredAnnotationTypes' must not be empty"'autowiredAnnotationTypes' must not be empty"AutowiredAnnotationBeanPostProcessor requires a ConfigurableListableBeanFactory: "AutowiredAnnotationBeanPostProcessor requires a ConfigurableListableBeanFactory: candidateConstructorsClass<Lookup>lookupoverride"No BeanFactory available"No BeanFactory availablembd"Cannot apply @Lookup to beans without corresponding bean definition"Cannot apply @Lookup to beans without corresponding bean definition"Lookup method resolution failed"Lookup method resolution failedrawCandidatesList<Constructor<?>>Collection<Constructor<?>>Iterable<Constructor<?>>ArrayList<Constructor<?>>AbstractList<Constructor<?>>AbstractCollection<Constructor<?>>ArrayList<Constructor<?>>(int)Spliterator<Constructor<?>>? super Constructor<?>Consumer<? super Constructor<?>>Iterator<Constructor<?>>Stream<Constructor<?>>BaseStream<Constructor<?>,Stream<Constructor<?>>>Predicate<? super Constructor<?>>? extends Constructor<?>Collection<? extends Constructor<?>>Iterable<? extends Constructor<?>>add(java.lang.reflect.Constructor)AbstractCollection<Constructor<?>>()ListIterator<Constructor<?>>add(int,java.lang.reflect.Constructor)set(int,java.lang.reflect.Constructor)Comparator<? super Constructor<?>>UnaryOperator<Constructor<?>>Function<Constructor<?>,Constructor<?>>AbstractList<Constructor<?>>()ArrayList<Constructor<?>>(java.util.Collection)ArrayList<Constructor<?>>()requiredConstructordefaultConstructorprimaryConstructornonSyntheticConstructors"Resolution of declared constructors on bean Class ["Resolution of declared constructors on bean Class ["] from ClassLoader ["] from ClassLoader ["] failed"] faileduserClasssuperCtor"Invalid autowire-marked constructor: "Invalid autowire-marked constructor: ". Found constructor with 'required' Autowired annotation already: ". Found constructor with 'required' Autowired annotation already: "Invalid autowire-marked constructors: "Invalid autowire-marked constructors: ". Found constructor with 'required' Autowired annotation: ". Found constructor with 'required' Autowired annotation: "Inconsistent constructor declaration on bean with name '"Inconsistent constructor declaration on bean with name '"': single autowire-marked constructor flagged as optional - " +
										"this constructor is effectively required since there is no " +
										"default constructor to fall back to: "': single autowire-marked constructor flagged as optional - this constructor is effectively required since there is no default constructor to fall back to: "Injection of autowired dependencies failed"Injection of autowired dependencies failed"Injection of autowired dependencies failed for class ["Injection of autowired dependencies failed for class [List<InjectedElement>Collection<InjectedElement>Iterable<InjectedElement>ArrayList<InjectedElement>AbstractList<InjectedElement>AbstractCollection<InjectedElement>ArrayList<InjectedElement>()Spliterator<InjectedElement>? super InjectedElementConsumer<? super InjectedElement>Iterator<InjectedElement>Stream<InjectedElement>BaseStream<InjectedElement,Stream<InjectedElement>>Predicate<? super InjectedElement>? extends InjectedElementCollection<? extends InjectedElement>Iterable<? extends InjectedElement>add(org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement)AbstractCollection<InjectedElement>()ListIterator<InjectedElement>add(int,org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement)set(int,org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement)Comparator<? super InjectedElement>UnaryOperator<InjectedElement>Function<InjectedElement,InjectedElement>AbstractList<InjectedElement>()ArrayList<InjectedElement>(java.util.Collection)ArrayList<InjectedElement>(int)currElements"Autowired annotation is not supported on static fields: "Autowired annotation is not supported on static fields: bridgedMethod"Autowired annotation is not supported on static methods: "Autowired annotation is not supported on static methods: "Autowired annotation should only be used on methods with parameters: "Autowired annotation should only be used on methods with parameters: aoannotationsMergedAnnotation<? extends Annotation>MergedAnnotation<A>of(java.lang.ClassLoader,java.lang.Object,java.lang.Class,java.util.Map)of(java.lang.reflect.AnnotatedElement,java.lang.Class,java.util.Map)of(java.lang.Class,java.util.Map)of(java.lang.Class)fromfrom(java.lang.Object,java.lang.annotation.Annotation)from(java.lang.annotation.Annotation)missingmissing()? super MergedAnnotationPredicate<? super MergedAnnotation>Optional<A>synthesizesynthesize(java.util.function.Predicate)? super MergedAnnotation<?>Predicate<? super MergedAnnotation<?>>synthesize()Adapt[]asMapasMap(java.util.function.Function,org.springframework.core.annotation.MergedAnnotation.Adapt[])Function<MergedAnnotation<?>,T>asMap(org.springframework.core.annotation.MergedAnnotation.Adapt[])asAnnotationAttributesasAnnotationAttributes(org.springframework.core.annotation.MergedAnnotation.Adapt[])withNonMergedAttributeswithNonMergedAttributes()filterAttributesfilterAttributes(java.util.function.Predicate)filterDefaultValuesfilterDefaultValues()getDefaultValuegetDefaultValue(java.lang.String,java.lang.Class)getDefaultValue(java.lang.String)getValue(java.lang.String,java.lang.Class)getValue(java.lang.String)MergedAnnotation[]MergedAnnotation<>[]MergedAnnotation<T>MergedAnnotation<T>[]getAnnotationArraygetAnnotationArray(java.lang.String,java.lang.Class)getAnnotation(java.lang.String,java.lang.Class)Enum<E>Comparable<E>Enum<E>[]getEnumArraygetEnumArray(java.lang.String,java.lang.Class)getEnumgetEnum(java.lang.String,java.lang.Class)getClassArraygetClassArray(java.lang.String)getClassgetClass(java.lang.String)getStringArraygetStringArray(java.lang.String)getStringgetString(java.lang.String)float[]getFloatArraygetFloatArray(java.lang.String)getFloatgetFloat(java.lang.String)double[]getDoubleArraygetDoubleArray(java.lang.String)getDoublegetDouble(java.lang.String)getLongArraygetLongArray(java.lang.String)getLonggetLong(java.lang.String)getIntArraygetIntArray(java.lang.String)getIntgetInt(java.lang.String)getShortArraygetShortArray(java.lang.String)getShortgetShort(java.lang.String)getCharArraygetCharArray(java.lang.String)getChargetChar(java.lang.String)boolean[]getBooleanArraygetBooleanArray(java.lang.String)getBooleangetBoolean(java.lang.String)getByteArraygetByteArray(java.lang.String)getBytegetByte(java.lang.String)hasDefaultValuehasDefaultValue(java.lang.String)hasNonDefaultValuehasNonDefaultValue(java.lang.String)List<Class<? extends Annotation>>getMetaTypesgetMetaTypes()getMetaSourcegetMetaSource()getAggregateIndexgetAggregateIndex()getDistancegetDistance()isMetaPresentisMetaPresent()isDirectlyPresentisDirectlyPresent()getTypegetType()VALUE"cast"Function<MergedAnnotation<?>,AnnotationAttributes>Function<MergedAnnotation<?>,V>? super AnnotationAttributesFunction<? super AnnotationAttributes,? extends V>Function<V,AnnotationAttributes>? extends MergedAnnotation<?>Function<? super V,? extends MergedAnnotation<?>>apply(org.springframework.core.annotation.MergedAnnotation)mergedAnnotation"No BeanFactory configured - " +
					"override the getBeanOfType method or specify the 'beanFactory' property"No BeanFactory configured - override the getBeanOfType method or specify the 'beanFactory' propertyautowiredBeanNamesautowiredBeanName"Autowiring by type from bean name '"Autowiring by type from bean name '"' to bean named '"' to bean named 'cachedArgumentdescriptorcachedFieldValueC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.classAutowiredAnnotationBeanPostProcessor$AutowiredFieldElementLinkedHashSet<String>LinkedHashSet<String>(int)LinkedHashSet<String>(java.util.Collection)LinkedHashSet<String>()LinkedHashSet<String>(int,float)resolveCachedArgumentsresolveCachedArguments(java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.classAutowiredAnnotationBeanPostProcessor$AutowiredMethodElementcachedMethodArgumentsargumentCountDependencyDescriptor[]autowiredBeanscurrDescargC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor$ShortcutDependencyDescriptor.classAutowiredAnnotationBeanPostProcessor$ShortcutDependencyDescriptorshortcut{@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor}implementation that autowires annotated fields, setter methods, and arbitraryconfig methods. Such members to be injected are detected through annotations:by default, Spring's {@link Autowired @Autowired} and {@link Value @Value}annotations.<p>Also supports JSR-330's {@link javax.inject.Inject @Inject} annotation,if available, as a direct alternative to Spring's own {@code @Autowired}.<p>Only one constructor of any given bean class may declare this annotation withthe 'required' attribute set to {@code true}, indicating <i>the</i> constructorto autowire when used as a Spring bean. Furthermore, if the 'required' attributeis set to {@code true}, only a single constructor may be annotated with{@code @Autowired}. If multiple <i>non-required</i> constructors declare thethen a primary/default constructor (if present) will be used. If a class onlydeclares a single constructor to begin with, it will always be used, even if notannotated. An annotated constructor does not have to be public.<p>Fields are injected right after construction of a bean, before anyconfig methods are invoked. Such a config field does not have to be public.Bean property setter methods are effectively just a special case of such ageneral config method. Config methods do not have to be public.<h3>Annotation Config vs. XML Config</h3><p>A default {@code AutowiredAnnotationBeanPostProcessor} will be registeredby the "context:annotation-config" and "context:component-scan" XML tags.Remove or turn off the default annotation configuration there if you intendto specify a custom {@code AutowiredAnnotationBeanPostProcessor} bean definition.<p><b>NOTE:</b> Annotation injection will be performed <i>before</i> XML injection;thus the latter configuration will override the former for properties wired throughboth approaches.<h3>{@literal @}Lookup Methods</h3><p>In addition to regular injection points as discussed above, this post-processoralso handles Spring's {@link Lookup @Lookup} annotation which identifies lookupmethods to be replaced by the container at runtime. This is essentially a type-safeversion of {@code getBean(Class, args)} and {@code getBean(String, args)}.See {@link Lookup @Lookup's javadoc} for details.#setAutowiredAnnotationTypeCreate a new {@code AutowiredAnnotationBeanPostProcessor} for Spring'sstandard {@link Autowired @Autowired} and {@link Value @Value} annotations.if available. JSR-330 API not available - simply skip.Set the 'autowired' annotation type, to be used on constructors, fields,setter methods, and arbitrary config methods.<p>The default autowired annotation types are the Spring-provided{@link Autowired @Autowired} and {@link Value @Value} annotations as wellas JSR-330's {@link javax.inject.Inject @Inject} annotation, if available.<p>This setter property exists so that developers can provide their own(non-Spring-specific) annotation type to indicate that a member is supposedto be autowired.Set the 'autowired' annotation types, to be used on constructors, fields,(non-Spring-specific) annotation types to indicate that a member is supposedSet the name of an attribute of the annotation that specifies whether it is required.#setRequiredParameterValue(boolean)Set the boolean value that marks a dependency as required.<p>For example if using 'required=true' (the default), this value should be{@code true}; but if using 'optional=false', this value should be {@code false}.#setRequiredParameterName(String) Let's check for lookup methods here... Quick check on the concurrent map first, with minimal locking. Fully synchronized resolution now... Simply proceed, no equivalent superclass constructor found... Add default constructor to list of optional constructors, as fallback.'Native' processing method for direct calls with an arbitrary target instance,resolving all of its fields and methods which are annotated with one of theconfigured 'autowired' annotation types.the target instance to processif autowiring failed#setAutowiredAnnotationTypes(Set) Fall back to class name as cache key, for backwards compatibility with custom callers.Determine if the annotated field or method requires its dependency.<p>A 'required' dependency means that autowiring should fail when no beansare found. Otherwise, the autowiring process will simply bypass the fieldor method when no beans are found.the Autowired annotationwhether the annotation indicates that a dependency is required The following (AnnotationAttributes) cast is required on JDK 9+.since 5.2, in favor of {@link #determineRequiredStatus(MergedAnnotation)}Obtain all beans of the given type as autowire candidates.the type of the beanthe target beans, or an empty Collection if no bean of this type is foundif bean retrieval failedRegister the specified bean as dependent on the autowired beans.Resolve the specified cached method argument or field value.Class representing injection information about an annotated field.Class representing injection information about an annotated method. Shortcut for avoiding synchronization...DependencyDescriptor variant with a pre-resolved target bean name.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.javaBeanFactoryAnnotationUtilsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/BeanFactoryAnnotationUtils.classqualifiedBeanOfTypequalifiedBeanOfType(org.springframework.beans.factory.ListableBeanFactory,java.lang.Class,java.lang.String)candidateBeans"No matching "No matching " bean found for bean name '" bean found for bean name '"'! (Note: Qualifier matching not supported because given " +
					"BeanFactory does not implement ConfigurableListableBeanFactory.)"'! (Note: Qualifier matching not supported because given BeanFactory does not implement ConfigurableListableBeanFactory.)matchingBean" bean found for qualifier '" bean found for qualifier '"' - neither qualifier match nor bean name match!"' - neither qualifier match nor bean name match!abdfactoryMethodtargetAnnotationConvenience methods performing bean lookups related to Spring-specific annotations,for example Spring's {@link Qualifier @Qualifier} annotation.Retrieve all bean of type {@code T} from the given {@code BeanFactory} declaring aqualifier (e.g. via {@code <qualifier>} or {@code @Qualifier}) matching the givenqualifier, or having a bean name matching the given qualifier.the factory to get the target beans from (also searching ancestors)the type of beans to retrievethe qualifier for selecting among all type matchesthe matching beans of type {@code T}if any of the matching beans could not be created5.1.1Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring athe factory to get the target bean from (also searching ancestors)the type of bean to retrievethe qualifier for selecting between multiple bean matchesthe matching bean of type {@code T} (never {@code null})if multiple matching beans of type {@code T} foundif no matching bean of type {@code T} foundBeanFactoryUtils#beanOfTypeIncludingAncestors(ListableBeanFactory, Class) Full qualifier matching supported. Fallback: target bean at least found by bean name.Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier(e.g. {@code <qualifier>} or {@code @Qualifier}) matching the given qualifier).the factory to get the target bean from Fallback: target bean at least found by bean name - probably a manually registered singleton.Check whether the named bean declares a qualifier of the given name.the qualifier to matchthe name of the candidate beanthe factory from which to retrieve the named bean{@code true} if either the bean definition (in the XML case)or the bean's factory method (in the {@code @Bean} case) defines a matchingqualifier value (through {@code <qualifier>} or {@code @Qualifier}) Try quick bean name or alias match first... Explicit qualifier metadata on bean definition? (typically in XML definition) Corresponding qualifier on factory method? (typically in configuration class) Corresponding qualifier on bean implementation class? (for custom user types) Ignore - can't compare qualifiers for a manually registered singleton objectC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Configurable.javaMarks a class as being eligible for Spring-driven configuration.<p>Typically used with the AspectJ {@code AnnotationBeanConfigurerAspect}.The name of the bean definition that serves as the configuration template.Are dependencies to be injected via autowiring?Is dependency checking to be performed for configured objects?Are dependencies to be injected prior to the construction of an object?C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.javaCustomAutowireConfigurerbeanClassLoaderC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.classcustomQualifierTypesdlbf"CustomAutowireConfigurer needs to operate on a DefaultListableBeanFactory"CustomAutowireConfigurer needs to operate on a DefaultListableBeanFactorycustomType"Invalid value ["Invalid value ["] for custom qualifier type: needs to be Class or String."] for custom qualifier type: needs to be Class or String.Map<String,Annotation>Constructor<Annotation>Class<? super Annotation>TypeVariable<Class<Annotation>>TypeVariable<Class<Annotation>>[]"Qualifier type ["Qualifier type ["] needs to be annotation type"] needs to be annotation typeA {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor}implementation that allows for convenient registration of custom autowirequalifier types.&lt;bean id="customAutowireConfigurer" class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt;&lt;property name="customQualifierTypes"&gt;&lt;set&gt;&lt;value&gt;mypackage.MyQualifier&lt;/value&gt;&lt;/set&gt;org.springframework.beans.factory.annotation.Qualifier default: same as non-OrderedRegister custom qualifier annotation types to be consideredwhen autowiring beans. Each element of the provided set maybe either a Class instance or a String representation of thefully-qualified class name of the custom annotation.<p>Note that any annotation that is itself annotated with Spring's{@link org.springframework.beans.factory.annotation.Qualifier}does not require explicit registration.the custom types to registerC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.javaInitDestroyAnnotationBeanPostProcessorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor.classbuildLifecycleMetadatabuildLifecycleMetadata(java.lang.Class)findLifecycleMetadatafindLifecycleMetadata(java.lang.Class)Map<Class<?>,LifecycleMetadata>lifecycleMetadataCachedestroyAnnotationTypeinitAnnotationTypeemptyLifecycleMetadataC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor$1.classInitDestroyAnnotationBeanPostProcessor$1hasDestroyMethodshasDestroyMethods()invokeDestroyMethodsinvokeDestroyMethods(java.lang.Object,java.lang.String)invokeInitMethodsinvokeInitMethods(java.lang.Object,java.lang.String)checkConfigMemberscheckConfigMembers(org.springframework.beans.factory.support.RootBeanDefinition)Collection<LifecycleElement>Iterable<LifecycleElement>(java.lang.Class,java.util.Collection,java.util.Collection)List<LifecycleElement>initMethodsdestroyMethods? extends InitDestroyAnnotationBeanPostProcessorClass<? extends InitDestroyAnnotationBeanPostProcessor>ConcurrentHashMap<Class<?>,LifecycleMetadata>AbstractMap<Class<?>,LifecycleMetadata>ConcurrentMap<Class<?>,LifecycleMetadata>ConcurrentHashMap<Class<?>,LifecycleMetadata>(int)? super LifecycleMetadata? extends LifecycleMetadataBiFunction<? super LifecycleMetadata,? super LifecycleMetadata,? extends LifecycleMetadata>merge(java.lang.Class,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata,java.util.function.BiFunction)BiFunction<? super Class<?>,? super LifecycleMetadata,? extends LifecycleMetadata>Function<? super Class<?>,? extends LifecycleMetadata>replace(java.lang.Class,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata)replace(java.lang.Class,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata)putIfAbsent(java.lang.Class,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata)BiConsumer<? super Class<?>,? super LifecycleMetadata>getOrDefault(java.lang.Object,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata)Entry<Class<?>,LifecycleMetadata>Set<Entry<Class<?>,LifecycleMetadata>>Collection<Entry<Class<?>,LifecycleMetadata>>Iterable<Entry<Class<?>,LifecycleMetadata>>Collection<LifecycleMetadata>Iterable<LifecycleMetadata>Map<? extends Class<?>,? extends LifecycleMetadata>put(java.lang.Class,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata)AbstractMap<Class<?>,LifecycleMetadata>()ToIntFunction<Entry<Class<?>,LifecycleMetadata>>ToLongFunction<Entry<Class<?>,LifecycleMetadata>>ToDoubleFunction<Entry<Class<?>,LifecycleMetadata>>Function<Entry<Class<?>,LifecycleMetadata>,? extends U>? extends Entry<Class<?>,LifecycleMetadata>BiFunction<Entry<Class<?>,LifecycleMetadata>,Entry<Class<?>,LifecycleMetadata>,? extends Entry<Class<?>,LifecycleMetadata>>? super Entry<Class<?>,LifecycleMetadata>Consumer<? super Entry<Class<?>,LifecycleMetadata>>ToIntFunction<? super LifecycleMetadata>ToLongFunction<? super LifecycleMetadata>ToDoubleFunction<? super LifecycleMetadata>Function<? super LifecycleMetadata,? extends U>Consumer<? super LifecycleMetadata>ToIntBiFunction<? super Class<?>,? super LifecycleMetadata>ToLongBiFunction<? super Class<?>,? super LifecycleMetadata>ToDoubleBiFunction<? super Class<?>,? super LifecycleMetadata>BiFunction<? super Class<?>,? super LifecycleMetadata,? extends U>Node<Class<?>,LifecycleMetadata>Node<Class<?>,LifecycleMetadata>[]KeySetView<Class<?>,LifecycleMetadata>CollectionView<Class<?>,LifecycleMetadata,Class<?>>keySet(org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata)Enumeration<LifecycleMetadata>Predicate<? super LifecycleMetadata>Predicate<? super Entry<Class<?>,LifecycleMetadata>>replaceNode(java.lang.Object,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata,java.lang.Object)putVal(java.lang.Class,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleMetadata,boolean)ConcurrentHashMap<Class<?>,LifecycleMetadata>(int,float,int)ConcurrentHashMap<Class<?>,LifecycleMetadata>(int,float)ConcurrentHashMap<Class<?>,LifecycleMetadata>(java.util.Map)ConcurrentHashMap<Class<?>,LifecycleMetadata>()"Invocation of init method failed"Invocation of init method failed"Failed to invoke init method"Failed to invoke init method"Failed to invoke destroy method on bean with name '"Failed to invoke destroy method on bean with name 'ArrayList<LifecycleElement>AbstractList<LifecycleElement>AbstractCollection<LifecycleElement>ArrayList<LifecycleElement>()Spliterator<LifecycleElement>? super LifecycleElementConsumer<? super LifecycleElement>Iterator<LifecycleElement>Stream<LifecycleElement>BaseStream<LifecycleElement,Stream<LifecycleElement>>Predicate<? super LifecycleElement>? extends LifecycleElementCollection<? extends LifecycleElement>Iterable<? extends LifecycleElement>add(org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleElement)AbstractCollection<LifecycleElement>()ListIterator<LifecycleElement>add(int,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleElement)set(int,org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.LifecycleElement)Comparator<? super LifecycleElement>UnaryOperator<LifecycleElement>Function<LifecycleElement,LifecycleElement>AbstractList<LifecycleElement>()ArrayList<LifecycleElement>(java.util.Collection)ArrayList<LifecycleElement>(int)currInitMethodscurrDestroyMethods"Found init method on class ["Found init method on class ["Found destroy method on class ["Found destroy method on class [Set<LifecycleElement>checkedDestroyMethodsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.classInitDestroyAnnotationBeanPostProcessor$LifecycleMetadatacheckedInitMethodsLinkedHashSet<LifecycleElement>HashSet<LifecycleElement>AbstractSet<LifecycleElement>LinkedHashSet<LifecycleElement>(int)AbstractSet<LifecycleElement>()HashSet<LifecycleElement>(int,float,boolean)HashSet<LifecycleElement>(int)HashSet<LifecycleElement>(int,float)HashSet<LifecycleElement>(java.util.Collection)HashSet<LifecycleElement>()LinkedHashSet<LifecycleElement>(java.util.Collection)LinkedHashSet<LifecycleElement>()LinkedHashSet<LifecycleElement>(int,float)methodIdentifier"Registered init method on class ["Registered init method on class ["Registered destroy method on class ["Registered destroy method on class [initMethodsToIterate"Invoking init method on bean '"Invoking init method on bean 'destroyMethodsToUse"Invoking destroy method on bean '"Invoking destroy method on bean 'identifierC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/InitDestroyAnnotationBeanPostProcessor$LifecycleElement.classInitDestroyAnnotationBeanPostProcessor$LifecycleElement"Lifecycle method annotation requires a no-arg method: "Lifecycle method annotation requires a no-arg method: otherElementthat invokes annotated init and destroy methods. Allows for an annotationalternative to Spring's {@link org.springframework.beans.factory.InitializingBean}and {@link org.springframework.beans.factory.DisposableBean} callback interfaces.<p>The actual annotation types that this post-processor checks for can beconfigured through the {@link #setInitAnnotationType "initAnnotationType"}and {@link #setDestroyAnnotationType "destroyAnnotationType"} properties.Any custom annotation can be used, since there are no required annotationattributes.<p>Init and destroy annotations may be applied to methods of any visibility:public, package-protected, protected, or private. Multiple such methodsmay be annotated, but it is recommended to only annotate one singleinit method and destroy method, respectively.<p>Spring's {@link org.springframework.context.annotation.CommonAnnotationBeanPostProcessor}supports the JSR-250 {@link javax.annotation.PostConstruct} and {@link javax.annotation.PreDestroy}annotations out of the box, as init annotation and destroy annotation, respectively.Furthermore, it also supports the {@link javax.annotation.Resource} annotationfor annotation-driven injection of named beans.#setInitAnnotationType#setDestroyAnnotationTypeSpecify the init annotation to check for, indicating initializationmethods to call after configuration of a bean.<p>Any custom annotation can be used, since there are no requiredannotation attributes. There is no default, although a typical choiceis the JSR-250 {@link javax.annotation.PostConstruct} annotation.Specify the destroy annotation to check for, indicating destructionmethods to call when the context is shutting down.is the JSR-250 {@link javax.annotation.PreDestroy} annotation. Happens after deserialization, during destruction...Class representing information about annotated init and destroy methods.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata.javaInjectionMetadataSet<InjectedElement>checkedElementsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/InjectionMetadata.classinjectedElementsC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/InjectionMetadata$1.classInjectionMetadata$1clear(org.springframework.beans.PropertyValues)injectinject(java.lang.Object,java.lang.String,org.springframework.beans.PropertyValues)needsRefreshneedsRefresh(java.lang.Class)(java.lang.Class,java.util.Collection)LinkedHashSet<InjectedElement>HashSet<InjectedElement>AbstractSet<InjectedElement>LinkedHashSet<InjectedElement>(int)AbstractSet<InjectedElement>()HashSet<InjectedElement>(int,float,boolean)HashSet<InjectedElement>(int)HashSet<InjectedElement>(int,float)HashSet<InjectedElement>(java.util.Collection)HashSet<InjectedElement>()LinkedHashSet<InjectedElement>(java.util.Collection)LinkedHashSet<InjectedElement>()LinkedHashSet<InjectedElement>(int,float)memberelementsToIterateresourceTypefieldType"Specified field type ["Specified field type ["] is incompatible with resource type ["] is incompatible with resource type [paramType"Specified parameter type ["Specified parameter type [requestingBeanName? extends MemberClass<? extends Member>Class<? extends InjectedElement>Map<String,? extends InjectedElement>InjectedElement[]? extends InjectedElement[]Constructor<? extends InjectedElement>? super ? extends InjectedElementClass<? super ? extends InjectedElement>TypeVariable<Class<? extends InjectedElement>>TypeVariable<Class<? extends InjectedElement>>[]" for " for Internal class for managing injection metadata.Not intended for direct use in applications.<p>Used by {@link AutowiredAnnotationBeanPostProcessor},{@link org.springframework.context.annotation.CommonAnnotationBeanPostProcessor} and{@link org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor}.An empty {@code InjectionMetadata} instance with no-op callbacks.Create a new {@code InjectionMetadata instance}.<p>Preferably use {@link #forElements} for reusing the {@link #EMPTY}instance in case of no elements.the associated elements to inject#forElementsDetermine whether this metadata instance needs to be refreshed.the current target class{@code true} indicating a refresh, {@code false} otherwise5.2.4Clear property skipping for the contained elements.Return an {@code InjectionMetadata} instance, possibly for empty elements.the elements to inject (possibly empty)a new {@link #InjectionMetadata(Class, Collection)} instanceCheck whether the given injection metadata needs to be refreshed.the existing metadata instance#needsRefresh(Class)A single injected element.Either this or {@link #getResourceToInject} needs to be overridden.Check whether this injector's property needs to be skipped due toan explicit property value having been specified. Also marks theaffected property as processed for other processors to ignore it. Explicit value provided as part of the bean definition.Clear property skipping for this element.Either this or {@link #inject} needs to be overridden.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Lookup.javaLookupAn annotation that indicates 'lookup' methods, to be overridden by the containerto redirect them back to the {@link org.springframework.beans.factory.BeanFactory}for a {@code getBean} call. This is essentially an annotation-based version of theXML {@code lookup-method} attribute, resulting in the same runtime arrangement.<p>The resolution of the target bean can either be based on the return type({@code getBean(Class)}) or on a suggested bean name ({@code getBean(String)}),in both cases passing the method's arguments to the {@code getBean} callfor applying them as target factory method arguments or constructor arguments.<p>Such lookup methods can have default (stub) implementations that will simplyget replaced by the container, or they can be declared as abstract - for thecontainer to fill them in at runtime. In both cases, the container will generateruntime subclasses of the method's containing class via CGLIB, which is why suchlookup methods can only work on beans that the container instantiates throughregular constructors: i.e. lookup methods cannot get replaced on beans returnedfrom factory methods where we cannot dynamically provide a subclass for them.<p><b>Recommendations for typical Spring configuration scenarios:</b>When a concrete class may be needed in certain scenarios, consider providing stubimplementations of your lookup methods. And please remember that lookup methodswon't work on beans returned from {@code @Bean} methods in configuration classes;you'll have to resort to {@code @Inject Provider<TargetBean>} or the like instead.org.springframework.beans.factory.BeanFactory#getBean(Class, Object...)org.springframework.beans.factory.BeanFactory#getBean(String, Object...)This annotation attribute may suggest a target bean name to look up.If not specified, the target bean will be resolved based on theannotated method's return type declaration.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/ParameterResolutionDelegate.javaParameterResolutionDelegategetEffectiveAnnotatedParametergetEffectiveAnnotatedParameter(java.lang.reflect.Parameter,int)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/ParameterResolutionDelegate.classParameterResolutionDelegate()EMPTY_ANNOTATED_ELEMENTC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/ParameterResolutionDelegate$1.classParameterResolutionDelegate$1annotationClassparameterIndexannotatedParameter"Parameter must not be null"Parameter must not be nullcontainingClass"Containing class must not be null"Containing class must not be null"AutowireCapableBeanFactory must not be null"AutowireCapableBeanFactory must not be nullexecutableParameter[]Public delegate for resolving autowirable parameters on externally managedconstructors and methods.#isAutowirable#resolveDependencyDetermine if the supplied {@link Parameter} can <em>potentially</em> beautowired from an {@link AutowireCapableBeanFactory}.<p>Returns {@code true} if the supplied parameter is annotated ormeta-annotated with {@link Autowired @Autowired},{@link Qualifier @Qualifier}, or {@link Value @Value}.<p>Note that {@link #resolveDependency} may still be able to resolve thedependency for the supplied parameter even if this method returns {@code false}.the parameter whose dependency should be autowired(must not be {@code null})the index of the parameter in the constructor or methodthat declares the parameterResolve the dependency for the supplied {@link Parameter} from thesupplied {@link AutowireCapableBeanFactory}.<p>Provides comprehensive autowiring support for individual method parameterson par with Spring's dependency injection facilities for autowired fields andmethods, including support for {@link Autowired @Autowired},{@link Qualifier @Qualifier}, and {@link Value @Value} with support for propertyplaceholders and SpEL expressions in {@code @Value} declarations.<p>The dependency is required unless the parameter is annotated or meta-annotatedwith {@link Autowired @Autowired} with the {@link Autowired#required required}flag set to {@code false}.<p>If an explicit <em>qualifier</em> is not declared, the name of the parameterwill be used as the qualifier for resolving ambiguities.the parameter whose dependency should be resolved (must not be{@code null})the concrete class that contains the parameter; this maydiffer from the class that declares the parameter in that it may be a subclassthereof, potentially substituting type variables (must not be {@code null})the {@code AutowireCapableBeanFactory} from which to resolvethe dependency (must not be {@code null})the resolved object, or {@code null} if none foundif dependency resolution failedAutowired#requiredSynthesizingMethodParameter#forExecutable(Executable, int)AutowireCapableBeanFactory#resolveDependency(DependencyDescriptor, String)Due to a bug in {@code javac} on JDK versions prior to JDK 9, looking upannotations directly on a {@link Parameter} will fail for inner classconstructors.<h4>Bug in javac in JDK &lt; 9</h4><p>The parameter annotations array in the compiled byte code excludes an entryfor the implicit <em>enclosing instance</em> parameter for an inner classconstructor.<h4>Workaround</h4><p>This method provides a workaround for this off-by-one error by allowing thecaller to access annotations on the preceding {@link Parameter} object (i.e.,{@code index - 1}). If the supplied {@code index} is zero, this method returnsan empty {@code AnnotatedElement}.<h4>WARNING</h4><p>The {@code AnnotatedElement} returned by this method should never be cast andtreated as a {@code Parameter} since the metadata (e.g., {@link Parameter#getName()},{@link Parameter#getType()}, etc.) will not match those for the declared parameterat the given index in an inner class constructor.the supplied {@code parameter} or the <em>effective</em> {@code Parameter}if the aforementioned bug is in effect Bug in javac in JDK <9: annotation array excludes enclosing instance parameter for inner classes, so access it with the actual parameter index lowered by 1C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Qualifier.javaCopyright 2002-2011 the original author or authors.This annotation may be used on a field or parameter as a qualifier forcandidate beans when autowiring. It may also be used to annotate othercustom annotations that can then in turn be used as qualifiers.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.javaQualifierAnnotationAutowireCandidateResolvervalueAnnotationTypeC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/QualifierAnnotationAutowireCandidateResolver.classqualifierTypes"javax.inject.Qualifier"javax.inject.QualifierClass<QualifierAnnotationAutowireCandidateResolver>Map<String,QualifierAnnotationAutowireCandidateResolver>QualifierAnnotationAutowireCandidateResolver[]Constructor<QualifierAnnotationAutowireCandidateResolver>? super QualifierAnnotationAutowireCandidateResolverClass<? super QualifierAnnotationAutowireCandidateResolver>TypeVariable<Class<QualifierAnnotationAutowireCandidateResolver>>TypeVariable<Class<QualifierAnnotationAutowireCandidateResolver>>[]qualifierType"'qualifierType' must not be null"'qualifierType' must not be null"'qualifierTypes' must not be null"'qualifierTypes' must not be nullbdHolderannotationsToSearchcheckMetafallbackToMetafoundMetametaAnnmetaTypeattributesdbdexpectedValueactualValuequalifiedElementresolvedFactoryMethodattrLinkedHashMap<String,Object>LinkedHashMap<String,Object>(int,float,boolean)LinkedHashMap<String,Object>(java.util.Map)LinkedHashMap<String,Object>()LinkedHashMap<String,Object>(int)LinkedHashMap<String,Object>(int,float)"Value annotation must have a value attribute"Value annotation must have a value attribute{@link AutowireCandidateResolver} implementation that matches bean definition qualifiersagainst {@link Qualifier qualifier annotations} on the field or parameter to be autowired.Also supports suggested expression values through a {@link Value value} annotation.<p>Also supports JSR-330's {@link javax.inject.Qualifier} annotation, if available.AutowireCandidateQualifierCreate a new QualifierAnnotationAutowireCandidateResolverfor Spring's standard {@link Qualifier} annotation.for the given qualifier annotation type.the qualifier annotation to look forfor the given qualifier annotation types.the qualifier annotations to look forRegister the given type to be used as a qualifier when autowiring.<p>This identifies qualifier annotations for direct use (on fields,method parameters and constructor parameters) as well as metaannotations that in turn identify actual qualifier annotations.<p>This implementation only supports annotations as qualifier types.The default is Spring's {@link Qualifier} annotation which servesas a qualifier for direct use and also as a meta annotation.the annotation type to registerSet the 'value' annotation type, to be used on fields, method parametersand constructor parameters.<p>The default value annotation type is the Spring-provided{@link Value} annotation.(non-Spring-specific) annotation type to indicate a default valueexpression for a specific argument.Determine whether the provided bean definition is an autowire candidate.<p>To be considered a candidate the bean's <em>autowire-candidate</em>attribute must not have been set to 'false'. Also, if an annotation onthe field or parameter to be autowired is recognized by this bean factoryas a <em>qualifier</em>, the bean must 'match' against the annotation aswell as any attributes it may contain. The bean definition must containthe same qualifier or match by meta attributes. A "value" attribute willfallback to match against the bean name or an alias if a qualifier orattribute does not match.Match the given qualifier annotations against the candidate bean definition. Only accept fallback match if @Qualifier annotation has a value... Otherwise it is just a marker for a custom qualifier annotation.Checks whether the given annotation type is a recognized qualifier type.Match the given qualifier annotation against the candidate bean definition. First, check annotation on qualified element, if any Then, check annotation on factory method, if applicable Look for matching annotation on the target class Not the usual case - simply forget about the type check... If no attributes, the qualifier must be present Check qualifier first Fall back on bean definition attribute Fall back on bean name (or alias) match Fall back on default, but only if the qualifier is presentDetermine whether the given dependency declares an autowired annotation,checking its required flag.Autowired#required()Determine whether the given dependency declares a qualifier annotation.#isQualifier(Class)Determine whether the given dependency declares a value annotation.Determine a suggested value from any of the given candidate annotations. qualifier annotations have to be localExtract the value attribute from the given annotation.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Required.javaRequiredMarks a method (typically a JavaBean setter method) as being 'required': that is,the setter method must be configured to be dependency-injected with a value.<p>Please do consult the javadoc for the {@link RequiredAnnotationBeanPostProcessor}RequiredAnnotationBeanPostProcessoras of 5.1, in favor of using constructor injection for required settings(or a custom {@link org.springframework.beans.factory.InitializingBean} implementation)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.javabuildExceptionMessagebuildExceptionMessage(java.util.List,java.lang.String)C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.classvalidatedBeanNamesrequiredAnnotationTypeClass<Required>Class<RequiredAnnotationBeanPostProcessor>"skipRequiredCheck"skipRequiredCheck"'requiredAnnotationType' must not be null"'requiredAnnotationType' must not be nullinvalidPropertiespropertyDescriptor"Property"Property"Properties"Properties" and" and" is" is" are" are" required for bean '" required for bean 'that enforces required JavaBean properties to have been configured.Required bean properties are detected through a Java 5 annotation:by default, Spring's {@link Required} annotation.<p>The motivation for the existence of this BeanPostProcessor is to allowdevelopers to annotate the setter properties of their own classes with anarbitrary JDK 1.5 annotation to indicate that the container must checkfor the configuration of a dependency injected value. This neatly pushesresponsibility for such checking onto the container (where it arguably belongs),and obviates the need (<b>in part</b>) for a developer to code a method thatsimply checks that all required properties have actually been set.<p>Please note that an 'init' method may still need to be implemented (and maystill be desirable), because all that this class does is enforcing that a'required' property has actually been configured with a value. It does<b>not</b> check anything else... In particular, it does not check that aconfigured value is not {@code null}.<p>Note: A default RequiredAnnotationBeanPostProcessor will be registeredto specify a custom RequiredAnnotationBeanPostProcessor bean definition.#setRequiredAnnotationTypeto be skipped when performing this post-processor's required property check.Cache for validated bean names, skipping re-validation for the same bean.Set the 'required' annotation type, to be used on bean propertysetter methods.<p>The default required annotation type is the Spring-provided{@link Required} annotation.(non-Spring-specific) annotation type to indicate that a property valueis required.Return the 'required' annotation type.Check whether the given bean definition is not subject to the annotation-basedrequired property check as performed by this post-processor.<p>The default implementations check for the presence of the{@link #SKIP_REQUIRED_CHECK_ATTRIBUTE} attribute in the bean definition, if any.It also suggests skipping in case of a bean definition with a "factory-bean"reference set, assuming that instance-based factories pre-populate the bean.the BeanFactory to check againstthe name of the bean to check against{@code true} to skip the bean; {@code false} to process itIs the supplied property required to have a value (that is, to be dependency-injected)?<p>This implementation looks for the existence of a{@link #setRequiredAnnotationType "required" annotation}on the supplied {@link PropertyDescriptor property}.the target PropertyDescriptor (never {@code null}){@code true} if the supplied property has been marked as being required;{@code false} if not, or if the supplied property does not have a setter methodBuild an exception message for the given list of invalid properties.the list of names of invalid propertiesC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/Value.javaAnnotation used at the field or method/constructor parameter levelthat indicates a default value expression for the annotated element.<p>Typically used for expression-driven or property-driven dependency injection.Also supported for dynamic resolution of handler method arguments &mdash; forexample, in Spring MVC.<p>A common use case is to inject values using<code>#{systemProperties.myProp}</code> style SpEL (Spring Expression Language)expressions. Alternatively, values may be injected using<code>${my.app.myProp}</code> style property placeholders.<p>Note that actual processing of the {@code @Value} annotation is performedby a {@link org.springframework.beans.factory.config.BeanPostProcessorBeanPostProcessor} which in turn means that you <em>cannot</em> use{@code @Value} withinorg.springframework.beans.factory.config.BeanExpressionResolverorg.springframework.beans.factory.support.AutowireCandidateResolver#getSuggestedValueThe actual value expression such as <code>#{systemProperties.myProp}</code>or property placeholder such as <code>${my.app.myProp}</code>.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/annotation/package-info.javaSupport package for annotation-driven bean configuration.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/AbstractFactoryBean.javaAbstractFactoryBeanC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/configorg.springframework.beans.factory.configC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/config/AbstractFactoryBean.classC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/configgetEarlySingletonInstancegetEarlySingletonInstance()earlySingletonInstanceinitializedAbstractFactoryBean<>? extends AbstractFactoryBean<>Class<? extends AbstractFactoryBean<>>Map<String,? extends AbstractFactoryBean<>>AbstractFactoryBean[]AbstractFactoryBean<>[]? extends AbstractFactoryBean<>[]Constructor<? extends AbstractFactoryBean<>>? super ? extends AbstractFactoryBean<>Class<? super ? extends AbstractFactoryBean<>>TypeVariable<Class<? extends AbstractFactoryBean<>>>TypeVariable<Class<? extends AbstractFactoryBean<>>>[]" does not support circular references" does not support circular references"Singleton instance not initialized yet"Singleton instance not initialized yetEarlySingletonInvocationHandlerEarlySingletonInvocationHandler()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/config/AbstractFactoryBean$EarlySingletonInvocationHandler.classAbstractFactoryBean$EarlySingletonInvocationHandler"Early singleton proxy for interfaces "Early singleton proxy for interfaces Simple template superclass for {@link FactoryBean} implementations thatcreates a singleton or a prototype object, depending on a flag.<p>If the "singleton" flag is {@code true} (the default),this class will create the object that it creates exactly onceon initialization and subsequently return said singleton instanceon all calls to the {@link #getObject()} method.<p>Else, this class will create a new instance every time the{@link #getObject()} method is invoked. Subclasses are responsiblefor implementing the abstract {@link #createInstance()} templatemethod to actually create the object(s) to expose.Keith Donald#setSingleton#createInstance()Set if a singleton should be created, or a new object on each requestotherwise. Default is {@code true} (a singleton).Return the BeanFactory that this bean runs in.Obtain a bean type converter from the BeanFactory that this beanruns in. This is typically a fresh instance for each call,since TypeConverters are usually <i>not</i> thread-safe.<p>Falls back to a SimpleTypeConverter when not running in a BeanFactory.ConfigurableBeanFactory#getTypeConverter()org.springframework.beans.SimpleTypeConverterEagerly create the singleton instance, if necessary.Expose the singleton instance or create a new prototype instance.#getEarlySingletonInterfaces()Determine an 'early singleton' instance, exposed in case of acircular reference. Not called in a non-circular scenario.Expose the singleton instance (for access through the 'early singleton' proxy).the singleton instance that this FactoryBean holdsif the singleton instance is not initializedDestroy the singleton instance, if any.#destroyInstance(Object)This abstract method declaration mirrors the method in the FactoryBeaninterface, for a consistent offering of abstract template methods.org.springframework.beans.factory.FactoryBean#getObjectType()Template method that subclasses must override to constructthe object returned by this factory.<p>Invoked on initialization of this FactoryBean in case ofa singleton; else, on each {@link #getObject()} call.the object returned by this factoryif an exception occurred during object creationReturn an array of interfaces that a singleton object exposed by thisFactoryBean is supposed to implement, for use with an 'early singletonproxy' that will be exposed in case of a circular reference.<p>The default implementation returns this FactoryBean's object type,provided that it is an interface, or {@code null} otherwise. The latterindicates that early singleton access is not supported by this FactoryBean.This will lead to a FactoryBeanNotInitializedException getting thrown.the interfaces to use for 'early singletons',or {@code null} to indicate a FactoryBeanNotInitializedExceptionorg.springframework.beans.factory.FactoryBeanNotInitializedExceptionCallback for destroying a singleton instance. Subclasses mayoverride this to destroy the previously created instance.the singleton instance, as returned by{@link #createInstance()}in case of shutdown errorsReflective InvocationHandler for lazy access to the actual singleton object. Only consider equal when proxies are identical. Use hashCode of reference proxy.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/AutowireCapableBeanFactory.javaAutowireCapableBeanFactory".ORIGINAL".ORIGINALexistingBeanautowireModedependencyCheckNamedBeanHolder<>C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/config/NamedBeanHolder.classNamedBeanHolderNamedBeanHolder<T>Extension of the {@link org.springframework.beans.factory.BeanFactory}interface to be implemented by bean factories that are capable ofautowiring, provided that they want to expose this functionality forexisting bean instances.<p>This subinterface of BeanFactory is not meant to be used in normalapplication code: stick to {@link org.springframework.beans.factory.BeanFactory}or {@link org.springframework.beans.factory.ListableBeanFactory} fortypical use cases.<p>Integration code for other frameworks can leverage this interface towire and populate existing bean instances that Spring does not controlthe lifecycle of. This is particularly useful for WebWork Actions andTapestry Page objects, for example.<p>Note that this interface is not implemented by{@link org.springframework.context.ApplicationContext} facades,as it is hardly ever used by application code. That said, it is availablefrom an application context too, accessible through ApplicationContext's{@link org.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()}method.<p>You may also implement the {@link org.springframework.beans.factory.BeanFactoryAware}interface, which exposes the internal BeanFactory even when running in anApplicationContext, to get access to an AutowireCapableBeanFactory:simply cast the passed-in BeanFactory to AutowireCapableBeanFactory.04.12.2003org.springframework.beans.factory.BeanFactoryAwareorg.springframework.beans.factory.config.ConfigurableListableBeanFactoryorg.springframework.context.ApplicationContext#getAutowireCapableBeanFactory()Constant that indicates no externally defined autowiring. Note thatBeanFactoryAware etc and annotation-driven injection will still be applied.#createBean#autowire#autowireBeanPropertiesConstant that indicates autowiring bean properties by name(applying to all bean property setters).Constant that indicates autowiring bean properties by typeConstant that indicates autowiring the greediest constructor thatcan be satisfied (involves resolving the appropriate constructor).Constant that indicates determining an appropriate autowire strategythrough introspection of the bean class.as of Spring 3.0: If you are using mixed autowiring strategies,prefer annotation-based autowiring for clearer demarcation of autowiring needs.Suffix for the "original instance" convention when initializing an existingbean instance: to be appended to the fully-qualified bean class name,e.g. "com.mypackage.MyClass.ORIGINAL", in order to enforce the given instanceto be returned, i.e. no proxies etc.#initializeBean(Object, String)#applyBeanPostProcessorsBeforeInitialization(Object, String)#applyBeanPostProcessorsAfterInitialization(Object, String)------------------------------------------------------------------------- Typical methods for creating and populating external bean instancesFully create a new bean instance of the given class.<p>Performs full initialization of the bean, including all applicable{@link BeanPostProcessor BeanPostProcessors}.<p>Note: This is intended for creating a fresh instance, populating annotatedfields and methods as well as applying all standard bean initialization callbacks.It does <i>not</i> imply traditional by-name or by-type autowiring of properties;use {@link #createBean(Class, int, boolean)} for those purposes.the class of the bean to createthe new bean instanceif instantiation or wiring failedPopulate the given bean instance through applying after-instantiation callbacksand bean property post-processing (e.g. for annotation-driven injection).<p>Note: This is essentially intended for (re-)populating annotated fields andmethods, either for new instances or for deserialized instances. It does<i>not</i> imply traditional by-name or by-type autowiring of properties;use {@link #autowireBeanProperties} for those purposes.the existing bean instanceif wiring failedConfigure the given raw bean: autowiring bean properties, applyingbean property values, applying factory callbacks such as {@code setBeanName}and {@code setBeanFactory}, and also applying all bean post processors(including ones which might wrap the given raw bean).<p>This is effectively a superset of what {@link #initializeBean} provides,fully applying the configuration specified by the corresponding bean definition.<b>Note: This method requires a bean definition for the given name!</b>the name of the bean, to be passed to it if necessary(a bean definition of that name has to be available)the bean instance to use, either the original or a wrapped oneorg.springframework.beans.factory.NoSuchBeanDefinitionExceptionif there is no bean definition with the given nameif the initialization failed#initializeBean Specialized methods for fine-grained control over the bean lifecycleFully create a new bean instance of the given class with the specifiedautowire strategy. All constants defined in this interface are supported here.{@link BeanPostProcessor BeanPostProcessors}. This is effectively a supersetof what {@link #autowire} provides, adding {@link #initializeBean} behavior.by name or type, using the constants in this interfacewhether to perform a dependency check for objects(not applicable to autowiring a constructor, thus ignored there)#AUTOWIRE_NO#AUTOWIRE_BY_NAME#AUTOWIRE_BY_TYPE#AUTOWIRE_CONSTRUCTORInstantiate a new bean instance of the given class with the specified autowirestrategy. All constants defined in this interface are supported here.Can also be invoked with {@code AUTOWIRE_NO} in order to just applybefore-instantiation callbacks (e.g. for annotation-driven injection).<p>Does <i>not</i> apply standard {@link BeanPostProcessor BeanPostProcessors}callbacks or perform any further initialization of the bean. This interfaceoffers distinct, fine-grained operations for those purposes, for example{@link #initializeBean}. However, {@link InstantiationAwareBeanPostProcessor}callbacks are applied, if applicable to the construction of the instance.the class of the bean to instantiatewhether to perform a dependency check for objectreferences in the bean instance (not applicable to autowiring a constructor,thus ignored there)#AUTOWIRE_AUTODETECT#applyBeanPostProcessorsBeforeInitialization#applyBeanPostProcessorsAfterInitializationAutowire the bean properties of the given bean instance by name or type.after-instantiation callbacks (e.g. for annotation-driven injection).callbacks are applied, if applicable to the configuration of the instance.references in the bean instanceApply the property values of the bean definition with the given name tothe given bean instance. The bean definition can either define a fullyself-contained bean, reusing its property values, or just property valuesmeant to be used for existing bean instances.<p>This method does <i>not</i> autowire bean properties; it just appliesexplicitly defined property values. Use the {@link #autowireBeanProperties}method to autowire an existing bean instance.the name of the bean definition in the bean factoryif applying the property values failedInitialize the given raw bean, applying factory callbackssuch as {@code setBeanName} and {@code setBeanFactory},also applying all bean post processors (including ones whichmight wrap the given raw bean).<p>Note that no bean definition of the given name has to existin the bean factory. The passed-in bean name will simply be usedfor callbacks but not checked against the registered bean definitions.(only passed to {@link BeanPostProcessor BeanPostProcessors};can follow the {@link #ORIGINAL_INSTANCE_SUFFIX} convention in order toenforce the given instance to be returned, i.e. no proxies etc)#ORIGINAL_INSTANCE_SUFFIXApply {@link BeanPostProcessor BeanPostProcessors} to the given existing beaninstance, invoking their {@code postProcessBeforeInitialization} methods.The returned bean instance may be a wrapper around the original.if any post-processing failedBeanPostProcessor#postProcessBeforeInitializationinstance, invoking their {@code postProcessAfterInitialization} methods.BeanPostProcessor#postProcessAfterInitializationDestroy the given bean instance (typically coming from {@link #createBean}),applying the {@link org.springframework.beans.factory.DisposableBean} contract as well asregistered {@link DestructionAwareBeanPostProcessor DestructionAwareBeanPostProcessors}.<p>Any exception that arises during destruction should be caughtand logged instead of propagated to the caller of this method. Delegate methods for resolving injection pointsResolve the bean instance that uniquely matches the given object type, if any,including its bean name.<p>This is effectively a variant of {@link #getBean(Class)} which preserves thebean name of the matching instance.the bean name plus bean instanceif no matching bean was foundif more than one matching bean was found4.3.3#getBean(Class)Resolve a bean instance for the given bean name, providing a dependency descriptorfor exposure to target factory methods.<p>This is effectively a variant of {@link #getBean(String, Class)} which supportsfactory methods with an {@link org.springframework.beans.factory.InjectionPoint}argument.the name of the bean to look upthe dependency descriptor for the requesting injection pointthe corresponding bean instance5.1.5#getBean(String, Class)Resolve the specified dependency against the beans defined in this factory.the descriptor for the dependency (field/method/constructor)the name of the bean which declares the given dependencyif dependency resolution failed for any other reason#resolveDependency(DependencyDescriptor, String, Set, TypeConverter)a Set that all names of autowired beans (used forresolving the given dependency) are supposed to be added tothe TypeConverter to use for populating arrays and collectionsDependencyDescriptorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/AutowiredPropertyMarker.javaAutowiredPropertyMarkerC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/config/AutowiredPropertyMarker.classAutowiredPropertyMarker()Class<AutowiredPropertyMarker>"(autowired)"(autowired)Simple marker class for an individually autowired property value, to be addedto {@link BeanDefinition#getPropertyValues()} for a specific bean property.<p>At runtime, this will be replaced with a {@link DependencyDescriptor}for the corresponding bean property's write method, eventually to be resolvedthrough a {@link AutowireCapableBeanFactory#resolveDependency} step.AutowireCapableBeanFactory#resolveDependencyBeanDefinition#getPropertyValues()org.springframework.beans.factory.support.BeanDefinitionBuilder#addAutowiredPropertyThe canonical instance for the autowired marker value.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanDefinition.javaBeanDefinitionparentNamelazyInitdependsOnautowireCandidatefactoryBeanNamefactoryMethodNameinitMethodNamedestroyMethodNameroleA BeanDefinition describes a bean instance, which has property values,constructor argument values, and further information supplied byconcrete implementations.<p>This is just a minimal interface: The main intention is to allow a{@link BeanFactoryPostProcessor} to introspect and modify property valuesand other bean metadata.19.03.2004ConfigurableListableBeanFactory#getBeanDefinitionorg.springframework.beans.factory.support.RootBeanDefinitionorg.springframework.beans.factory.support.ChildBeanDefinitionScope identifier for the standard singleton scope: {@value}.<p>Note that extended bean factories might support further scopes.#setScopeConfigurableBeanFactory#SCOPE_SINGLETONScope identifier for the standard prototype scope: {@value}.ConfigurableBeanFactory#SCOPE_PROTOTYPERole hint indicating that a {@code BeanDefinition} is a major partof the application. Typically corresponds to a user-defined bean.Role hint indicating that a {@code BeanDefinition} is a supportingpart of some larger configuration, typically an outer{@link org.springframework.beans.factory.parsing.ComponentDefinition}.{@code SUPPORT} beans are considered important enough to be awareof when looking more closely at a particular{@link org.springframework.beans.factory.parsing.ComponentDefinition},but not when looking at the overall configuration of an application.Role hint indicating that a {@code BeanDefinition} is providing anentirely background role and has no relevance to the end-user. This hint isused when registering beans that are completely part of the internal workingsof a {@link org.springframework.beans.factory.parsing.ComponentDefinition}. Modifiable attributesSet the name of the parent definition of this bean definition, if any.Return the name of the parent definition of this bean definition, if any.Specify the bean class name of this bean definition.<p>The class name can be modified during bean factory post-processing,typically replacing the original class name with a parsed variant of it.#setParentName#setFactoryBeanName#setFactoryMethodNameReturn the current bean class name of this bean definition.<p>Note that this does not have to be the actual class name used at runtime, incase of a child definition overriding/inheriting the class name from its parent.Also, this may just be the class that a factory method is called on, or it mayeven be empty in case of a factory bean reference that a method is called on.Hence, do <i>not</i> consider this to be the definitive bean type at runtime butrather only use it for parsing purposes at the individual bean definition level.#getParentName()#getFactoryBeanName()#getFactoryMethodName()Override the target scope of this bean, specifying a new scope name.#SCOPE_SINGLETON#SCOPE_PROTOTYPEReturn the name of the current target scope for this bean,or {@code null} if not known yet.Set whether this bean should be lazily initialized.<p>If {@code false}, the bean will get instantiated on startup by beanfactories that perform eager initialization of singletons.Return whether this bean should be lazily initialized, i.e. noteagerly instantiated on startup. Only applicable to a singleton bean.Set the names of the beans that this bean depends on being initialized.The bean factory will guarantee that these beans get initialized first.Return the bean names that this bean depends on.Set whether this bean is a candidate for getting autowired into some other bean.<p>Note that this flag is designed to only affect type-based autowiring.It does not affect explicit references by name, which will get resolved evenif the specified bean is not marked as an autowire candidate. As a consequence,autowiring by name will nevertheless inject a bean if the name matches.Return whether this bean is a candidate for getting autowired into some other bean.Set whether this bean is a primary autowire candidate.<p>If this value is {@code true} for exactly one bean among multiplematching candidates, it will serve as a tie-breaker.Return whether this bean is a primary autowire candidate.Specify the factory bean to use, if any.This the name of the bean to call the specified factory method on.Return the factory bean name, if any.Specify a factory method, if any. This method will be invoked withconstructor arguments, or with no arguments if none are specified.The method will be invoked on the specified factory bean, if any,or otherwise as a static method on the local bean class.#setBeanClassNameReturn a factory method, if any.Return the constructor argument values for this bean.<p>The returned instance can be modified during bean factory post-processing.the ConstructorArgumentValues object (never {@code null})Return if there are constructor argument values defined for this bean.5.0.2Return the property values to be applied to a new instance of the bean.the MutablePropertyValues object (never {@code null})Return if there are property values defined for this bean.Set the name of the initializer method.Return the name of the initializer method.Set the name of the destroy method.Return the name of the destroy method.Set the role hint for this {@code BeanDefinition}. The role hintprovides the frameworks as well as tools an indication ofthe role and importance of a particular {@code BeanDefinition}.#ROLE_APPLICATION#ROLE_SUPPORT#ROLE_INFRASTRUCTUREGet the role hint for this {@code BeanDefinition}. The role hintSet a human-readable description of this bean definition.Return a human-readable description of this bean definition. Read-only attributesReturn a resolvable type for this bean definition,based on the bean class or other specific metadata.<p>This is typically fully resolved on a runtime-merged bean definitionbut not necessarily on a configuration-time definition instance.the resolvable type (potentially {@link ResolvableType#NONE})ConfigurableBeanFactory#getMergedBeanDefinitionReturn whether this a <b>Singleton</b>, with a single, shared instancereturned on all calls.Return whether this a <b>Prototype</b>, with an independent instancereturned for each call.Return whether this bean is "abstract", that is, not meant to be instantiated.Return a description of the resource that this bean definitioncame from (for the purpose of showing context in case of errors).Return the originating BeanDefinition, or {@code null} if none.<p>Allows for retrieving the decorated bean definition, if any.<p>Note that this method returns the immediate originator. Iterate through theoriginator chain to find the original BeanDefinition as defined by the user.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanDefinitionCustomizer.javaBeanDefinitionCustomizerCallback for customizing a given bean definition.Designed for use with a lambda expression or method reference.org.springframework.beans.factory.support.BeanDefinitionBuilder#applyCustomizersCustomize the given bean definition.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanDefinitionHolder.javaBeanDefinitionHolderC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/config/BeanDefinitionHolder.class"BeanDefinition must not be null"BeanDefinition must not be nullbeanDefinitionHolder"BeanDefinitionHolder must not be null"BeanDefinitionHolder must not be null"Bean definition with name '"Bean definition with name '"' and aliases ["' and aliases [otherHolderHolder for a BeanDefinition with name and aliases.Can be registered as a placeholder for an inner bean.<p>Can also be used for programmatic registration of inner beandefinitions. If you don't care about BeanNameAware and the like,registering RootBeanDefinition or ChildBeanDefinition is good enough.org.springframework.beans.factory.BeanNameAwareCreate a new BeanDefinitionHolder.the BeanDefinition to wrapthe name of the bean, as specified for the bean definitionalias names for the bean, or {@code null} if noneCopy constructor: Create a new BeanDefinitionHolder with thesame contents as the given BeanDefinitionHolder instance.<p>Note: The wrapped BeanDefinition reference is taken as-is;it is {@code not} deeply copied.the BeanDefinitionHolder to copyReturn the wrapped BeanDefinition.Return the primary name of the bean, as specified for the bean definition.Return the alias names for the bean, as specified directly for the bean definition.the array of alias names, or {@code null} if noneExpose the bean definition's source object.BeanDefinition#getSource()Determine whether the given candidate name matches the bean nameor the aliases stored in this bean definition.Return a friendly, short description for the bean, stating name and aliases.#getBeanName()#getAliases()Return a long description for the bean, including name and aliasesas well as a description of the contained {@link BeanDefinition}.#getShortDescription()#getBeanDefinition()This implementation returns the long description. Can be overriddento return the short description or any kind of custom description instead.#getLongDescription()C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanDefinitionVisitor.javaBeanDefinitionVisitorC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/config/BeanDefinitionVisitor.class"StringValueResolver must not be null"StringValueResolver must not be nullcasMap<Integer,ValueHolder>List<ValueHolder>Collection<ValueHolder>Iterable<ValueHolder>resolvedNameresolvedScopepvArraynewValias? super ValueHolder? extends ValueHolderBiFunction<? super ValueHolder,? super ValueHolder,? extends ValueHolder>merge(java.lang.Integer,org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder,java.util.function.BiFunction)BiFunction<? super Integer,? super ValueHolder,? extends ValueHolder>compute(java.lang.Integer,java.util.function.BiFunction)computeIfPresent(java.lang.Integer,java.util.function.BiFunction)Function<? super Integer,? extends ValueHolder>computeIfAbsent(java.lang.Integer,java.util.function.Function)replace(java.lang.Integer,org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder)replace(java.lang.Integer,org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder,org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder)putIfAbsent(java.lang.Integer,org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder)BiConsumer<? super Integer,? super ValueHolder>getOrDefault(java.lang.Object,org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder)Entry<Integer,ValueHolder>Set<Entry<Integer,ValueHolder>>Collection<Entry<Integer,ValueHolder>>Iterable<Entry<Integer,ValueHolder>>Set<Integer>Map<? extends Integer,? extends ValueHolder>put(java.lang.Integer,org.springframework.beans.factory.config.ConstructorArgumentValues.ValueHolder)gasnewBeanNametypedStringValuestringValuevisitedStringarrayVallistValsetValnewContentLinkedHashSet<>HashSet<>AbstractSet<>AbstractCollection<>LinkedHashSet<>()AbstractCollection<>()AbstractSet<>()HashSet<>(int,float,boolean)HashSet<>(int)HashSet<>(int,float)HashSet<>(java.util.Collection)HashSet<>()LinkedHashSet<>(java.util.Collection)LinkedHashSet<>(int)LinkedHashSet<>(int,float)entriesModifiedelemHashnewValHashmapValLinkedHashMap<>()AbstractMap<>()HashMap<>(java.util.Map)HashMap<>()HashMap<>(int)HashMap<>(int,float)LinkedHashMap<>(int,float,boolean)LinkedHashMap<>(java.util.Map)LinkedHashMap<>(int)LinkedHashMap<>(int,float)keyHashnewKeynewKeyHashstrValresolvedValue"No StringValueResolver specified - pass a resolver " +
					"object into the constructor or override the 'resolveStringValue' method"No StringValueResolver specified - pass a resolver object into the constructor or override the 'resolveStringValue' methodVisitor class for traversing {@link BeanDefinition} objects, in particularthe property values and constructor argument values contained in them,resolving bean metadata values.<p>Used by {@link PlaceholderConfigurerSupport} to parse all String valuescontained in a BeanDefinition, resolving any placeholders found.BeanDefinition#getPropertyValuesBeanDefinition#getConstructorArgumentValuesPlaceholderConfigurerSupportCreate a new BeanDefinitionVisitor, applying the specifiedvalue resolver to all bean metadata values.the StringValueResolver to applyCreate a new BeanDefinitionVisitor for subclassing.Subclasses need to override the {@link #resolveStringValue} method.Traverse the given BeanDefinition object and the MutablePropertyValuesand ConstructorArgumentValues contained in them.the BeanDefinition object to traverse#resolveStringValue(String)Resolve the given String value, for example parsing placeholders.the original String valuethe resolved String value Return original String if not modified.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanExpressionContext.javaBeanExpressionContextC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/build/classes/groovy/main/org/springframework/beans/factory/config/BeanExpressionContext.classotherContextContext object for evaluating an expression within a bean definition.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanExpressionResolver.javaBeanExpressionResolverevalContextStrategy interface for resolving a value through evaluating itas an expression, if applicable.<p>A raw {@link org.springframework.beans.factory.BeanFactory} does notcontain a default implementation of this strategy. However,{@link org.springframework.context.ApplicationContext} implementationswill provide expression support out of the box.Evaluate the given value as an expression, if applicable;return the value as-is otherwise.the value to checkthe evaluation contextthe resolved value (potentially the given value as-is)if evaluation failedC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanFactoryPostProcessor.javaBeanFactoryPostProcessorFactory hook that allows for custom modification of an application context'sbean definitions, adapting the bean property values of the context's underlyingbean factory.<p>Useful for custom config files targeted at system administrators thatoverride bean properties configured in the application context. See{@link PropertyResourceConfigurer} and its concrete implementations forout-of-the-box solutions that address such configuration needs.<p>A {@code BeanFactoryPostProcessor} may interact with and modify beandefinitions, but never bean instances. Doing so may cause premature beaninstantiation, violating the container and causing unintended side-effects.If bean instance interaction is required, consider implementing{@link BeanPostProcessor} instead.<h3>Registration</h3><p>An {@code ApplicationContext} auto-detects {@code BeanFactoryPostProcessor}beans in its bean definitions and applies them before any other beans get created.A {@code BeanFactoryPostProcessor} may also be registered programmaticallywith a {@code ConfigurableApplicationContext}.<h3>Ordering</h3><p>{@code BeanFactoryPostProcessor} beans that are autodetected in an{@code ApplicationContext} will be ordered according to{@link org.springframework.core.PriorityOrdered} and{@link org.springframework.core.Ordered} semantics. In contrast,{@code BeanFactoryPostProcessor} beans that are registered programmaticallywith a {@code ConfigurableApplicationContext} will be applied in the order ofregistration; any ordering semantics expressed through implementing the{@code PriorityOrdered} or {@code Ordered} interface will be ignored forprogrammatically registered post-processors. Furthermore, the{@link org.springframework.core.annotation.Order @Order} annotation is nottaken into account for {@code BeanFactoryPostProcessor} beans.06.07.2003BeanPostProcessorPropertyResourceConfigurerModify the application context's internal bean factory after its standardinitialization. All bean definitions will have been loaded, but no beanswill have been instantiated yet. This allows for overriding or addingproperties even to eager-initializing beans.the bean factory used by the application contextorg.springframework.beans.BeansExceptionC:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanPostProcessor.javaFactory hook that allows for custom modification of new bean instances &mdash;for example, checking for marker interfaces or wrapping beans with proxies.<p>Typically, post-processors that populate beans via marker interfacesor the like will implement {@link #postProcessBeforeInitialization},while post-processors that wrap beans with proxies will normallyimplement {@link #postProcessAfterInitialization}.<p>An {@code ApplicationContext} can autodetect {@code BeanPostProcessor} beansin its bean definitions and apply those post-processors to any beans subsequentlycreated. A plain {@code BeanFactory} allows for programmatic registration ofpost-processors, applying them to all beans created through the bean factory.<p>{@code BeanPostProcessor} beans that are autodetected in an{@code BeanPostProcessor} beans that are registered programmatically with a{@code BeanFactory} will be applied in the order of registration; any orderingsemantics expressed through implementing thetaken into account for {@code BeanPostProcessor} beans.InstantiationAwareBeanPostProcessorDestructionAwareBeanPostProcessorConfigurableBeanFactory#addBeanPostProcessorApply this {@code BeanPostProcessor} to the given new bean instance <i>before</i> any beaninitialization callbacks (like InitializingBean's {@code afterPropertiesSet}or a custom init-method). The bean will already be populated with property values.<p>The default implementation returns the given {@code bean} as-is.the bean instance to use, either the original or a wrapped one;if {@code null}, no subsequent BeanPostProcessors will be invokedorg.springframework.beans.factory.InitializingBean#afterPropertiesSetApply this {@code BeanPostProcessor} to the given new bean instance <i>after</i> any bean<p>In case of a FactoryBean, this callback will be invoked for both the FactoryBeaninstance and the objects created by the FactoryBean (as of Spring 2.0). Thepost-processor can decide whether to apply to either the FactoryBean or createdobjects or both through corresponding {@code bean instanceof FactoryBean} checks.<p>This callback will also be invoked after a short-circuiting triggered by a{@link InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation} method,in contrast to all other {@code BeanPostProcessor} callbacks.C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanReference.javaBeanReferenceInterface that exposes a reference to a bean name in an abstract fashion.This interface does not necessarily imply a reference to an actual beaninstance; it just expresses a logical reference to the name of a bean.<p>Serves as common interface implemented by any kind of bean referenceholder, such as {@link RuntimeBeanReference RuntimeBeanReference} and{@link RuntimeBeanNameReference RuntimeBeanNameReference}.Return the target bean name that this reference points to (never {@code null}).C:/Users/Semiu/Java/spring-projects_spring-framework/spring-beans/src/main/java/org/springframework/beans/factory/config/ConfigurableBeanFactory.javaConfigurableBeanFactoryparentBeanFactorytempClassLoadercacheBeanMetadataregistrarscopeNameapplicationStartupotherFactoryinCreationdependentBeanNameConfiguration interface to be implemented by most bean factories. Providesfacilities to configure a bean factory, in addition to the bean factoryclient methods in the {@link org.springframework.beans.factory.BeanFactory}interface.<p>This bean factory interface is not meant to be used in normal applicationcode: Stick to {@link org.springframework.beans.factory.BeanFactory} or{@link org.springframework.beans.factory.ListableBeanFactory} for typicalneeds. This extended interface is just meant to allow for framework-internalplug'n'play and for special access to bean factory configuration methods.03.11.2003org.springframework.beans.factory.ListableBeanFactoryConfigurableListableBeanFactory<p>Custom scopes can be added via {@code registerScope}.#registerScopeSet the parent of this bean factory.<p>Note that the parent cannot be changed: It should only be set outsidea constructor if it isn't available at the time of factory instantiation.the parent BeanFactoryif this factory is already associated witha parent BeanFactory#getParentBeanFactory()Set the class loader to use for loading bean classes.Default is the thread context class loader.<p>Note that this class loader will only apply to bean definitionsthat do not carry a resolved bean class yet. This is the case as ofSpring 2.0 by default: Bean definitions only carry bean class names,to be resolved once the factory processes the bean definition.the class loader to use,or {@code null} to suggest the default class loaderReturn this factory's class loader for loading bean classes(only {@code null} if even the system ClassLoader isn't accessible).org.springframework.util.ClassUtils#forName(String, ClassLoader)Specify a temporary ClassLoader to use for type matching purposes.Default is none, simply using the standard bean ClassLoader.<p>A temporary ClassLoader is usually just specified if<i>load-time weaving</i> is involved, to make sure that actual beanclasses are loaded as lazily as possible. The temporary loader isthen removed once the BeanFactory completes its bootstrap phase.Return the temporary ClassLoader to use for type matching purposes,if any.Set whether to cache bean metadata such as given bean definitions(in merged fashion) and resolved bean classes. Default is on.<p>Turn this flag off to enable hot-refreshing of bean definition objectsand in particular bean classes. If this flag is off, any creation of a beaninstance will re-query the bean class loader for newly resolved classes.Return whether to cache bean metadata such as given bean definitions(in merged fashion) and resolved bean classes.Specify the resolution strategy for expressions in bean definition values.<p>There is no expression support active in a BeanFactory by default.An ApplicationContext will typically set a standard expression strategyhere, supporting "#{...}" expressions in a Unified EL compatible style.Return the resolution strategy for expressions in bean definition values.Add a PropertyEditorRegistrar to be applied to all bean creation processes.<p>Such a registrar creates new PropertyEditor instances and registers themon the given registry, fresh for each bean creation attempt. This avoidsthe need for synchronization on custom editors; hence, it is generallypreferable to use this method instead of {@link #registerCustomEditor}.the PropertyEditorRegistrar to registerRegister the given custom property editor for all properties of thegiven type. To be invoked during factory configuration.<p>Note that this method will register a shared custom editor instance;access to that instance will be synchronized for thread-safety. It isgenerally preferable to use {@link #addPropertyEditorRegistrar} insteadof this method, to avoid for the need for synchronization on custom editors.the {@link PropertyEditor} class to registerInitialize the given PropertyEditorRegistry with the custom editorsthat have been registered with this BeanFactory.the PropertyEditorRegistry to initializeSet a custom type converter that this BeanFactory should use for convertingbean property values, constructor argument values, etc.<p>This will override the default PropertyEditor mechanism and hence makeany custom editors or custom editor registrars irrelevant.#addPropertyEditorRegistrarObtain a type converter as used by this BeanFactory. This may be a freshinstance for each call, since TypeConver    5N    