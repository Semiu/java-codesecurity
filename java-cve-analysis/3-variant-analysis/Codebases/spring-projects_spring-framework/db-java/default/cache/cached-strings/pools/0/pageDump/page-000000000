import ArrayListimport Listimport ProceedingJoinPointimport Nestedimport Testimport Autowiredimport DirtiesContextimport SpringJUnitConfigimport static Assertions.assertThatimport static Assertions.assertThatExceptionOfType/** Integration tests for advice invocation order for advice configured via the ... */super(...)isEmpty(...)assertThat(...)aspect.invocationsisEqualTo(...)echo(...)containsExactly(...)clear(...)isThrownBy(...)assertThatExceptionOfType(...)...->...Exception.classnew ThrowingCallable(...) { ... }new Exception(...)...instanceof...(...)......=...new ArrayList<String>(...)<obinit>(...)List<String> invocations, ...;add(...)proceed(...)/* Copyright 2002-2020 the original author or authors. ... */import Advisedimport AopUtilsimport ITestBeanimport TestBeanimport SerializationTestUtilsimport MockHttpServletRequestimport MockHttpSessionimport SpringJUnitWebConfigimport RequestContextHolderimport ServletRequestAttributes/** Integration tests for scoped proxy use in conjunction with aop: namespace. ... */ITestBean singletonScoped, ...;ITestBean requestScoped, ...;ITestBean sessionScoped, ...;ITestBean sessionScopedAlias, ...;ITestBean testBean, ...;boolean conditionString robString bramITestBean deserializedserializeAndDeserialize(...)isTrue(...)as(...)isAopProxy(...)getName(...)setName(...)MockHttpServletRequest oldRequestnew MockHttpServletRequest(...)MockHttpServletRequest newRequestboolean condition1setRequestAttributes(...)new ServletRequestAttributes(...)isFalse(...)... > ...getAdvisors(...).lengthgetAdvisors(...)MockHttpSession oldSessionnew MockHttpSession(...)MockHttpSession newSessionMockHttpServletRequest requestsetSession(...)isSameAs(...)/* Copyright 2002-2019 the original author or authors. ... */import IOExceptionimport Methodimport ServletExceptionimport StaticMethodMatcherPointcutAdvisorimport CountingBeforeAdviceimport MethodCounterimport NopInterceptorimport BeanFactoryimport InitializingBeanimport ClassPathXmlApplicationContextimport Nullableimport NoTransactionExceptionimport TransactionInterceptorimport CallCountingTransactionManager/** Integration tests for auto proxy creation by advisor recognition working in ... */AdvisorAutoProxyCreatorIntegrationTests.classgetSimpleName(...)... + ...Class<?> CLASS, ...;? ...String CLASSNAME, ...;String DEFAULT_CONTEXT, ...;String ADVISOR_APC_BEAN_NAME, ...;String TXMANAGER_BEAN_NAME, ...;/** Return a bean factory with attributes and EnterpriseServices configured. */new ClassPathXmlApplicationContext(...)DefaultAdvisorAutoProxyCreator aapcgetBean(...)getBeanFactory(...)getAdvisorBeanNamePrefix(...)DefaultAdvisorAutoProxyCreator.SEPARATORisUsePrefix(...)/** If no pointcuts match (no attrs) there should be proxying. */BeanFactory bfObject oITestBean testMethodCounter countergetCalls(...)CallCountingTransactionManager txManOrderedTxCheckAdvisor txcint newAgegetCountingBeforeAdvice(...)txMan.commitsgetAge(...)setAge(...)/** Should not roll back on servlet exception. */Rollback rbException exechoException(...)txMan.rollbacksException actualnew ServletException(...)ServletException exObject beanrollbackOnly(...)new NopInterceptor(...)/** This method is solely to allow us to create a mixture of dependencies in ... *//** @see */-...boolean requireTransactionContext, ...;/** Should we insist on the presence of a transaction attribute or refuse to accept one? */this.requireTransactionContextgetAdvice(...)setAdvice(...)new TxCountingBeforeAdvice(...)startsWith(...)...[]currentTransactionStatus(...)new RuntimeException(...)NoTransactionException exbefore(...)/** Inherits transaction attribute. ... */setRollbackOnly(...)/** Extracted in a protected method to facilitate testing *//** @org.springframework.transaction.interceptor.RuleBasedTransaction ... */... != ...// Fires only on setters// Should NOT roll back on ServletException// Will cause rollback only// do transaction checks// this is Okimport Afterimport AfterReturningimport AfterThrowingimport Aroundimport Aspectimport Beforeimport Pointcutimport Beanimport Configurationimport EnableAspectJAutoProxy/** Integration tests for advice invocation order for advice configured via ... *//** {@link After @After} advice declared as first <em>after</em> method in source code. */AfterAdviceFirstConfig.class/** This test class uses {@link AfterAdviceLastAspect} which declares its ... */AfterAdviceLastConfig.class{...}new AfterAdviceFirstAspect(...)new Echo(...)new AfterAdviceLastAspect(...)/** {@link After @After} advice declared as last <em>after</em> method in source code. */new ArrayList<Component>(...)String name, ...;List<Component> components, ...;// mmm, there is no setter method for the 'components'this.componentsthis.nameimport Elementimport BeanDefinitionimport AbstractBeanDefinitionimport BeanDefinitionBuilderimport ManagedListimport CollectionUtilsimport DomUtilsparseComponentElement(...)BeanDefinitionBuilder factoryrootBeanDefinition(...)ComponentFactoryBean.classList<Element> childElementsgetChildElementsByTagName(...)addPropertyValue(...)parseComponent(...)!...parseChildComponents(...)getBeanDefinition(...)BeanDefinitionBuilder componentComponent.classgetAttribute(...)ManagedList<BeanDefinition> childrennew ManagedList<BeanDefinition>(...)size(...)Element elementimport AfterAllimport BeforeAllimport TestInstanceimport Lifecycleimport DefaultListableBeanFactoryimport ClassPathResource/** @author */Lifecycle.PER_CLASSnew DefaultListableBeanFactory(...)DefaultListableBeanFactory bf, ...;loadBeanDefinitions(...)new XmlBeanDefinitionReader(...)new ClassPathResource(...)ComponentBeanDefinitionParserTests.classdestroySingletons(...)Component cpgetBionicFamily(...)List<Component> componentsgetComponents(...)get(...)import FactoryBeanComponent parent, ...;List<Component> children, ...;this.parentthis.children... && ...Component childaddComponent(...)registerBeanDefinitionParser(...)new ComponentBeanDefinitionParser(...)import Collectionsimport Advisorimport CacheManagerimport BeanFactoryCacheOperationSourceAdvisorimport NoOpCacheManagerimport AdviceModeimport AnnotationConfigApplicationContextimport Repository/** Integration tests for the @EnableCaching annotation. ... */AnnotationConfigApplicationContext ctxnew AnnotationConfigApplicationContext(...)register(...)Config.classProxyTargetClassCachingConfig.classrefresh(...)assertCacheProxying(...)isCglibProxy(...)FooRepository.classAspectJCacheConfig.classwithMessageContaining(...)...::...FooRepository repoisCacheProxy(...)Advisor advisornew NoOpCacheManager(...)new DummyFooRepository(...)AdviceMode.ASPECTJemptyList(...)// this test is a bit fragile, but gets the job done, proving that an// attempt was made to look up the AJ aspect. It's due to classpath issues// in .integration-tests that it's not found.import ElementTypeimport Retentionimport RetentionPolicyimport Targetimport Namedimport Singletonimport AfterEachimport BeforeEachimport AnnotatedBeanDefinitionimport ApplicationContextimport ClassPathBeanDefinitionScannerimport ScopeMetadataimport ScopeMetadataResolverimport ScopedProxyModeimport GenericWebApplicationContext/** @author ... */String DEFAULT_NAME, ...;String MODIFIED_NAME, ...;ServletRequestAttributes oldRequestAttributes, ...;ServletRequestAttributes newRequestAttributes, ...;ServletRequestAttributes oldRequestAttributesWithSession, ...;ServletRequestAttributes newRequestAttributesWithSession, ...;MockHttpServletRequest oldRequestWithSessionMockHttpServletRequest newRequestWithSessionthis.oldRequestAttributesthis.newRequestAttributesthis.oldRequestAttributesWithSessionthis.newRequestAttributesWithSessionApplicationContext contextcreateContext(...)ScopedProxyMode.NOScopedTestBean beanisNotNull(...)isPrototype(...)isSingleton(...)ScopedTestBean bean2ScopedProxyMode.INTERFACESScopedProxyMode.TARGET_CLASSIScopedTestBean beanisJdkDynamicProxy(...)IScopedTestBean bean2GenericWebApplicationContext contextnew GenericWebApplicationContext(...)ClassPathBeanDefinitionScanner scannernew ClassPathBeanDefinitionScanner(...)setIncludeAnnotationConfig(...)setScopeMetadataResolver(...)new (...)new ScopeMetadataResolver(...) { ... }ScopeMetadata metadatanew ScopeMetadata(...)AnnotatedBeanDefinition annDefString typegetAnnotationTypes(...)getMetadata(...)equals(...)Singleton.classsetScopeName(...)BeanDefinition.SCOPE_SINGLETONcontains(...)getMetaAnnotationTypes(...)Scope.classtoLowerCase(...)substring(...)... - ...length(...)setScopedProxyMode(...)BeanDefinition.SCOPE_PROTOTYPEscan(...)getPackage(...)getClass(...)registerAlias(...)RetentionPolicy.RUNTIMEElementType.FIELDElementType.PARAMETERElementType.TYPE// should not be a proxy// not a proxy so this should not have changed// singleton bean, so name should be modified even after lookup// but a newly retrieved bean should have the default name// should be dynamic proxy, implementing both interfaces// this is a proxy so it should be reset to default// should be a class-based proxy// Scan twice in order to find errors in the bean definition compatibility check.import Componentimport RequestScopeimport SessionScopeimport static ScopedProxyMode.DEFAULTimport static ScopedProxyMode.INTERFACESimport static ScopedProxyMode.NOimport static ScopedProxyMode.TARGET_CLASSresetRequestAttributes(...)setBeanNameGenerator(...)new BeanNameGenerator(...) { ... }getScope(...)import Fileimport BeanDefinitionRegistryimport XmlBeanDefinitionReaderimport ConfigurableApplicationContextimport EnvironmentAwareimport AnnotatedBeanDefinitionReaderimport Importimport Profileimport FileSystemXmlApplicationContextimport GenericApplicationContextimport GenericXmlApplicationContextimport StaticApplicationContextimport ResourceAdapterApplicationContextimport SimpleBootstrapContextimport SimpleTaskWorkManagerimport MockEnvironmentimport MockPropertySourceimport MockServletConfigimport MockServletContextimport FileCopyUtilsimport WebApplicationContextimport AbstractRefreshableWebApplicationContextimport AnnotationConfigWebApplicationContextimport StandardServletEnvironmentimport StaticWebApplicationContextimport XmlWebApplicationContextimport static BeanDefinitionBuilder.rootBeanDefinitionimport static ConfigurableApplicationContext.ENVIRONMENT_BEAN_NAMEimport static Constants.DERIVED_DEV_BEAN_NAMEimport static Constants.DERIVED_DEV_ENV_NAMEimport static Constants.DEV_BEAN_NAMEimport static Constants.DEV_ENV_NAMEimport static Constants.ENVIRONMENT_AWARE_BEAN_NAMEimport static Constants.PROD_BEAN_NAMEimport static Constants.PROD_ENV_NAMEimport static Constants.TRANSITIVE_BEAN_NAMEimport static Constants.XML_PATH/** System integration tests for container support of the {@link Environment} API. ... */new StandardEnvironment(...)new StandardServletEnvironment(...)ConfigurableEnvironment prodEnv, ...;ConfigurableEnvironment devEnv, ...;ConfigurableEnvironment prodWebEnv, ...;setActiveProfiles(...)ConfigurableApplicationContext ctxnew GenericApplicationContext(...)newBeanFactoryWithEnvironmentAwareBean(...)assertHasStandardEnvironment(...)assertEnvironmentBeanRegistered(...)assertEnvironmentAwareInvoked(...)getEnvironment(...)GenericApplicationContext ctxsetEnvironment(...)assertHasEnvironment(...)containsBean(...)new AnnotatedBeanDefinitionReader(...)GenericXmlApplicationContext ctxnew GenericXmlApplicationContext(...)load(...)ClassPathResource xmlFile tmpFilecreateTempFile(...)new FileSystemXmlApplicationContext(...)getPath(...)copy(...)getFile(...)EnvironmentAwareBean.classProdConfig.classDevConfig.classStandardEnvironment derivedDevEnvDerivedDevConfig.classtestProfileExpression(...)StandardEnvironment environmentProfileExpressionConfig.classGenericWebApplicationContext ctxassertHasStandardServletEnvironment(...)AbstractRefreshableWebApplicationContext ctxnew XmlWebApplicationContext(...)setConfigLocation(...)StaticApplicationContext ctxnew StaticApplicationContext(...)registerEnvironmentBeanDefinition(...)StaticWebApplicationContext ctxnew StaticWebApplicationContext(...)AnnotationConfigWebApplicationContext ctxnew AnnotationConfigWebApplicationContext(...)MockServletContext servletContextnew MockServletContext(...)MockServletConfig servletConfignew MockServletConfig(...)ConfigurableEnvironment environmentMutablePropertySources propertySourcesgetPropertySources(...)MockPropertySource mockSystemPropertiesnew MockPropertySource(...)StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAMEaddInitParameter(...)setServletConfig(...)isInstanceOf(...)StandardServletEnvironment.classStandardServletEnvironment.SERVLET_CONTEXT_PROPERTY_SOURCE_NAMEStandardServletEnvironment.SERVLET_CONFIG_PROPERTY_SOURCE_NAMEgetProperty(...)isLessThan(...)precedenceOf(...)named(...)setProperty(...)replace(...)setServletContext(...)ResourceAdapterApplicationContext ctxnew ResourceAdapterApplicationContext(...)new SimpleBootstrapContext(...)new SimpleTaskWorkManager(...)setRequiredProperties(...)MissingRequiredPropertiesException.classwithProperty(...)new MockEnvironment(...)DefaultListableBeanFactory bfregisterBeanDefinition(...)Environment defaultEnvStandardEnvironment.classEnvironment actualEnvgetBean(...).environmentEnvironment environment, ...;this.environment/** Mirrors the structure of beans and environment-specific config files in ... */new EnvironmentAwareBean(...)TransitiveConfig.classnew Object(...)/** Constants used both locally and in scan* sub-packages */String XML_PATH, ...;String ENVIRONMENT_AWARE_BEAN_NAME, ...;String PROD_BEAN_NAME, ...;String DEV_BEAN_NAME, ...;String DERIVED_DEV_BEAN_NAME, ...;String TRANSITIVE_BEAN_NAME, ...;String PROD_ENV_NAME, ...;String DEV_ENV_NAME, ...;String DERIVED_DEV_ENV_NAME, ...;// it's actually ConfigurationClassPostProcessor's Environment that gets the job done here.// strange - FSXAC strips leading '/' unless prefixed with 'file:'// ServletConfig gets precedence// but all params are available// Servlet* PropertySources have precedence over System* PropertySources// Replace system properties with a mock property source for convenience// assert that servletconfig params resolve with higher precedence than sysprops// ServletContext params are available// assert that servletcontext init params resolve with higher precedence than sysprops// should succeed// ensure environment is registered as a bean// ensure a default servlet environment exists// ensure the custom environment tookPropertyPlaceholderConfigurer.classclose(...)EnvironmentSystemIntegrationTests.Constants.DEV_ENV_NAMEEnvironmentSystemIntegrationTests.ConstantsEnvironmentSystemIntegrationTests.Constants.PROD_ENV_NAMEEnvironmentSystemIntegrationTests.Constants.DEV_BEAN_NAMEEnvironmentSystemIntegrationTests.Constants.PROD_BEAN_NAMEimport PropertyEditorimport BeansExceptionimport SimpleTypeConverterimport BeanFactoryAwareimport ConfigurableBeanFactoryimport ConversionServiceimport TypeDescriptorimport DefaultConversionServiceimport TypeConverter/** Copied from Spring Integration for purposes of reproducing ... */new SimpleTypeConverter(...)SimpleTypeConverter delegate, ...;ConversionService defaultConversionService, ...;ConversionService conversionService, ...;... == ...new DefaultConversionService(...)this.conversionServiceObject typeConvertergetTypeConverter(...)canConvert(...)isAssignableFrom(...)... || ...findCustomEditor(...)getDefaultEditor(...)Class<?> sourceTypegetObjectType(...)Class<?> targetTypegetType(...)Void.classVoid.TYPEconvert(...)PropertyEditor editorsetValue(...)getAsText(...)convertIfNecessary(...)/* Copyright 2002-2012 the original author or authors. ... */// PropertyEditor cannot convert non-Strings// TODO: what does this mean? This method is not used in SpEL so probably ignorable?import MethodParameterimport MethodExecutorAlwaysTrueReleaseStrategy targetnew AlwaysTrueReleaseStrategy(...)BeanFactoryTypeConverter converternew BeanFactoryTypeConverter(...)StandardEvaluationContext contextnew StandardEvaluationContext(...)List<Foo> argumentsList<TypeDescriptor> paramDescriptorsnew ArrayList<TypeDescriptor>(...)Method methodgetMethod(...)AlwaysTrueReleaseStrategy.classList<>.classList<TypeDescriptor> argumentTypesReflectiveMethodResolver resolvernew ReflectiveMethodResolver(...)MethodExecutor executorresolve(...)Object resultexecute(...)setTypeConverter(...)new TypeDescriptor(...)new MethodParameter(...)forObject(...)println(...)System.outimport AtomicIntegerimport AnnotationAwareAspectJAutoProxyCreatorimport BeanCreationExceptionimport EnabledForTestGroupsimport PersistenceExceptionTranslationPostProcessorimport PersistenceExceptionTranslatorimport PlatformTransactionManagerimport EnableTransactionManagementimport Transactionalimport static Mockito.mockimport static TestGroup.LONG_RUNNING/** Integration tests cornering bug SPR-8651, which revealed that @Scheduled methods may ... */JdkProxyTxConfig.classRepoConfigA.classwithCauseInstanceOf(...)IllegalStateException.classBeanCreationException.classMyRepository repositoryMyRepository.classCallCountingTransactionManager txManagerCallCountingTransactionManager.classSubclassProxyTxConfig.classsleep(...)isGreaterThan(...)getInvocationCount(...)txManager.commitsMyRepositoryWithScheduledMethod repositoryMyRepositoryWithScheduledMethod.classRepoConfigB.classAspectConfig.classMyRepositoryWithScheduledMethodImpl.classnew MyRepositoryImpl(...)new MyRepositoryWithScheduledMethodImpl(...)new CallCountingTransactionManager(...)mock(...)PersistenceExceptionTranslator.classnew PersistenceExceptionTranslationPostProcessor(...)AnnotationAwareAspectJAutoProxyCreator apcnew AnnotationAwareAspectJAutoProxyCreator(...)setProxyTargetClass(...)new MyAspect(...)new AtomicInteger(...)AtomicInteger count, ...;incrementAndGet(...)this.countMyAspect myAspect, ...;this.myAspectthis.myAspect.count// allow @Scheduled method to be called several timesimport Arraysimport DataSourceimport Cacheimport ConcurrentMapCacheimport SimpleCacheManagerimport ImportResourceimport DataSourceTransactionManagerimport EmbeddedDatabaseBuilderimport EmbeddedDatabaseTypeimport BeanFactoryTransactionAttributeSourceAdvisor/** Integration tests for the @EnableTransactionManagement annotation. ... */isTxProxy(...)DefaultTxManagerNameConfig.classassertTxProxying(...)CustomTxManagerNameConfig.classNonConventionalTxManagerNameConfig.classProxyTargetClassTxConfig.classAspectJTxConfig.classImplicitTxManagerConfig.classFooRepository fooRepositoryfindAll(...)txManager.beguntxManager.rollbacksExplicitTxManagerConfig.classCallCountingTransactionManager txManager1CallCountingTransactionManager txManager2txManager1.beguntxManager1.commitstxManager1.rollbackstxManager2.beguntxManager2.commitstxManager2.rollbacksEnableTxAndCachingConfig.classanyMatch(...)stream(...)new Predicate<Advisor>(...) { ... }isInstance(...)BeanFactoryTransactionAttributeSourceAdvisor.classSimpleCacheManager mgrnew SimpleCacheManager(...)ArrayList<Cache> cachesnew ArrayList<Cache>(...)new ConcurrentMapCache(...)setCaches(...)txManager1(...)new DataSourceTransactionManager(...)JdbcFooRepository reposnew JdbcFooRepository(...)setDataSource(...)dataSource(...)build(...)setType(...)new EmbeddedDatabaseBuilder(...)EmbeddedDatabaseType.HSQL// trigger a transaction/** Tests proving that regardless the proxy strategy used (JDK interface-based vs. CGLIB ... */AnnotatedServiceWithoutInterface sAnnotatedServiceWithoutInterface.classPTCTrue.classPTCFalse.classNonAnnotatedService sNonAnnotatedService.classAnnotatedServiceImpl.classisNotInstanceOf(...)AnnotatedService sAnnotatedService.classNonAnnotatedServiceImpl.class/** Tag interface for Advice. Implementations can be any type ... *//* Copyright 2002-2016 the original author or authors. ... *//** Superclass for all AOP infrastructure exceptions. ... *//** Constructor for AspectException. ... *//* Copyright 2002-2018 the original author or authors. ... */import Nonnull/** Intercepts the construction of a new object. ... *//** Implement this method to perform extra treatments before and ... */import Constructor/** Description of an invocation to a constructor, given to an ... *//** Get the constructor being called. ... */import Advice/** This interface represents a generic interceptor. ... *//** This interface represents an invocation in the program. ... *//** Get the arguments as an array object. ... */import AccessibleObject/** This interface represents a generic runtime joinpoint (in the AOP ... *//** Proceed to the next interceptor in the chain. ... *//** Return the object that holds the current joinpoint's static part. ... *//** Return the static part of this joinpoint. ... *//** Intercepts calls on an interface on its way to the target. These ... *//** Description of an invocation to a method, given to an interceptor ... *//** Get the method being called. ... *//** Base interface holding AOP <b>advice</b> (action to take at a joinpoint) ... */new Advice(...) { ... }Advice EMPTY_ADVICE, ...;/** Common placeholder for an empty {@code Advice} to be returned from ... *//** Return the advice part of this aspect. An advice may be an ... *//** Return whether this advice is associated with a particular instance ... *//* Copyright 2002-2017 the original author or authors. ... *//** Common marker interface for after advice, ... *//* Copyright 2002-2007 the original author or authors. ... *//** After returning advice is invoked only on normal method return, not if an ... *//** Callback after a given method successfully returned. ... */import NestedRuntimeException/** Exception that gets thrown when an AOP invocation failed ... *//** Constructor for AopInvocationException. ... *//** Common marker interface for before advice, such as {@link MethodBeforeAdvice}. ... *//** Filter that restricts matching of a pointcut or introduction to ... */TrueClassFilter.INSTANCE/** Should the pointcut apply to the given interface or target class? ... */ClassFilter TRUE, ...;/** Canonical instance of a ClassFilter that matches all classes. *//** Subinterface of AOP Alliance Advice that allows additional interfaces ... *//** Does this introduction advice implement the given interface? ... *//** Superinterface for advisors that perform one or more AOP <b>introductions</b>. ... *//** Return the filter determining which target classes this introduction ... *//** Can the advised interfaces be implemented by the introduction advice? ... *//** A specialized type of {@link MethodMatcher} that takes into account introductions ... *//** Perform static checking whether the given method matches. This may be invoked ... *//** Interface supplying the information necessary to describe an introduction. ... *//** Return the additional interfaces introduced by this Advisor or Advice. ... */import MethodInterceptor/** Subinterface of AOP Alliance MethodInterceptor that allows additional interfaces ... *//** Advice invoked before a method is invoked. Such advices cannot ... *//** Callback before a given method is invoked. ... *//** Part of a {@link Pointcut}: Checks whether the target method is eligible for advice. ... */TrueMethodMatcher.INSTANCE/** Perform static checking whether the given method matches. ... *//** Is this MethodMatcher dynamic, that is, must a final call be made on the ... *//** Check whether there a runtime (dynamic) match for this method, ... */MethodMatcher TRUE, ...;/** Canonical instance that matches all methods. *//** Core Spring pointcut abstraction. ... */TruePointcut.INSTANCE/** Return the ClassFilter for this pointcut. ... *//** Return the MethodMatcher for this pointcut. ... */Pointcut TRUE, ...;/** Canonical Pointcut instance that always matches. *//** Superinterface for all Advisors that are driven by a pointcut. ... *//** Get the Pointcut that drives this advisor. */import MethodInvocation/** Extension of the AOP Alliance {@link org.aopalliance.intercept.MethodInvocation} ... *//** Return the proxy that this method invocation was made through. ... *//** Create a clone of this object. If cloning is done before {@code proceed()} ... *//** Set the arguments to be used on subsequent invocations in the any advice ... *//** Add the specified user attribute with the given value to this invocation. ... *//** Return the value of the specified user attribute. ... *//* Copyright 2002-2015 the original author or authors. ... *//** Marker for AOP proxy interfaces (in particular: introduction interfaces) ... *//** Marker interface implemented by all AOP proxies. Used to detect ... *//** Minimal interface for exposing the target class behind a proxy. ... *//** Return the target class behind the implementing object ... *//** A {@code TargetSource} is used to obtain the current "target" of ... *//** Return the type of targets returned by this {@link TargetSource}. ... *//** Will all calls to {@link #getTarget()} return the same object? ... *//** Return a target instance. Invoked immediately before the ... *//** Release the given target object obtained from the ... *//** Tag interface for throws advice. ... *//* Copyright 2002-2008 the original author or authors. ... */import Serializable/** Canonical ClassFilter instance that matches all classes. ... */new TrueClassFilter(...)TrueClassFilter INSTANCE, ...;/** Enforce Singleton pattern. *//** Required to support serialization. Replaces with canonical ... *//** Canonical MethodMatcher instance that matches all methods. ... */new TrueMethodMatcher(...)TrueMethodMatcher INSTANCE, ...;new UnsupportedOperationException(...)// Should never be invoked as isRuntime returns false./** Canonical Pointcut instance that always matches. ... */new TruePointcut(...)TruePointcut INSTANCE, ...;import ObjectInputStreamimport InvocationTargetExceptionimport Typeimport HashMapimport Mapimport JoinPointimport JoinPointMatchimport PointcutParameterimport AopInvocationExceptionimport MethodMatcherimport ProxyMethodInvocationimport ExposeInvocationInterceptorimport ComposablePointcutimport MethodMatchersimport StaticMethodMatcherimport DefaultParameterNameDiscovererimport ParameterNameDiscovererimport Assertimport ClassUtilsimport ReflectionUtilsimport StringUtils/** Base class for AOP Alliance {@link org.aopalliance.aop.Advice} classes ... */Object.classJoinPoint.classString JOIN_POINT_KEY, ...;/** Key used in ReflectiveMethodInvocation userAttributes map for the current joinpoint. *//** Lazily instantiate joinpoint for the current invocation. ... */MethodInvocation micurrentInvocation(...)ProxyMethodInvocation pmiJoinPoint jpgetUserAttribute(...)new IllegalStateException(...)new MethodInvocationProceedingJoinPoint(...)setUserAttribute(...)Class<?> declaringClass, ...;String methodName, ...;...[] parameterTypes, ...;Method aspectJAdviceMethod, ...;AspectJExpressionPointcut pointcut, ...;AspectInstanceFactory aspectInstanceFactory, ...;String aspectName, ...;/** The name of the aspect (ref bean) in which this advice was defined ... */int declarationOrder, ...;/** The order of declaration of this advice within the aspect. */...[] argumentNames, ...;/** This will be non-null if the creator of this advice object knows the argument names ... */String throwingName, ...;/** Non-null if after throwing advice binds the thrown value. */String returningName, ...;/** Non-null if after returning advice binds the return value. */Class<?> discoveredReturningType, ...;Class<?> discoveredThrowingType, ...;int joinPointArgumentIndex, ...;/** Index for thisJoinPoint argument (currently only ... */int joinPointStaticPartArgumentIndex, ...;/** Index for thisJoinPointStaticPart argument (currently only ... */Map<String,Integer> argumentBindings, ...;boolean argumentsIntrospected, ...;Type discoveredReturningGenericType, ...;/** Create a new AbstractAspectJAdvice for the given advice method. ... */// since Java doesn't allow exception types to be parameterized.// Note: Unlike return type, no such generic information is needed for the throwing type,notNull(...)this.declaringClassgetDeclaringClass(...)this.methodNamethis.parameterTypesgetParameterTypes(...)this.aspectJAdviceMethodthis.pointcutthis.aspectInstanceFactory/** Return the AspectJ-style advice method. *//** Return the AspectJ expression pointcut. */calculateArgumentBindings(...)/** Build a 'safe' pointcut that excludes the AspectJ advice method itself. ... */Pointcut pcgetPointcut(...)MethodMatcher safeMethodMatcherintersection(...)new AdviceExcludingMethodMatcher(...)getMethodMatcher(...)new ComposablePointcut(...)getClassFilter(...)/** Return the factory for aspect instances. *//** Return the ClassLoader for aspect instances. */getAspectClassLoader(...)getOrder(...)/** Set the name of the aspect (bean) in which the advice was declared. */this.aspectName/** Set the declaration order of this advice within the aspect. */this.declarationOrder/** Set by creator of this advice object if the argument names are known. ... */String[] tokenscommaDelimitedListToStringArray(...)setArgumentNamesFromStringArray(...)this.argumentNamesargs.lengthint i... < ......++...[...]trimWhitespace(...)isVariableName(...)new IllegalArgumentException(...)getParameterCount(...)this.argumentNames.lengthClass<?> firstArgTypeProceedingJoinPoint.classJoinPoint.StaticPart.classJoinPoint.StaticPartString[] oldNamesoldNames.lengtharraycopy(...)/** We need to hold the returning name at this level for argument binding calculations, ... */this.returningNamethis.discoveredReturningTypeforName(...)Throwable exthis.discoveredReturningGenericType/** We need to hold the throwing name at this level for argument binding calculations, ... */this.throwingNamethis.discoveredThrowingType/** Do as much work as we can as part of the set-up so that argument binding ... */int numUnboundArgsthis.parameterTypes.lengthClass<?>[] parameterTypesthis.argumentsIntrospectedmaybeBindJoinPointStaticPart(...)maybeBindJoinPoint(...)maybeBindProceedingJoinPoint(...)...--bindArgumentsByName(...)this.joinPointArgumentIndexsupportsProceedingJoinPoint(...)this.joinPointStaticPartArgumentIndexgetParameterNames(...)createParameterNameDiscoverer(...)bindExplicitArguments(...)/** Create a ParameterNameDiscoverer to be used for argument binding. ... */DefaultParameterNameDiscoverer discoverernew DefaultParameterNameDiscoverer(...)AspectJAdviceParameterNameDiscoverer adviceParameterNameDiscoverernew AspectJAdviceParameterNameDiscoverer(...)getExpression(...)setReturningName(...)setThrowingName(...)setRaiseExceptions(...)addDiscoverer(...)int numExpectedArgumentNamesint argumentIndexOffsetstate(...)this.argumentBindingsnew HashMap<String,Integer>(...)p12p13p14p15p16p17p18p19put(...)containsKey(...)Integer indexgetGenericParameterTypes(...)configurePointcutParameters(...)/** All parameters from argumentIndexOffset onwards are candidates for ... */int numParametersToRemoveString[] pointcutParameterNamesargumentNames.lengthClass<?>[] pointcutParameterTypesnew Class<?>[]pointcutParameterNames.lengthClass<?>[] methodParameterTypesint indexsetParameterNames(...)setParameterTypes(...)/** Take the arguments at the method execution join point and output a set of arguments ... */Object[] adviceInvocationArgsnew Object[]int numBoundgetStaticPart(...)PointcutParameter[] parameterBindingsgetParameterBindings(...)PointcutParameter parameterString namegetBinding(...)...?...:.../** Invoke the advice method. ... */invokeAdviceMethodWithGivenArgs(...)argBinding(...)getJoinPoint(...)// As above, but in this case we are given the join point.Object[] actualArgsmakeAccessible(...)invoke(...)getAspectInstance(...)IllegalArgumentException exnew AopInvocationException(...)getPointcutExpression(...)InvocationTargetException exgetTargetException(...)/** Overridden in around advice to return proceeding join point. */currentJoinPoint(...)/** Get the current join point match at the join point we are being dispatched on. */getJoinPointMatch(...)// are guaranteed to bind in exactly the same way.// Using the expression is guaranteed to be safe, since 2 identical expressions// 'last man wins' which is not what we want at all.// Under this scenario, if we just use JoinPointMatch as the key, then// Spring AOP does all the matching at a join point, and then all the invocations.// Note: We can't use JoinPointMatch.getClass().getName() as the key, sinceString expressiondefaultReadObject(...)NoSuchMethodException ex/** MethodMatcher that excludes the specified advice method. ... */Method adviceMethod, ...;this.adviceMethodAdviceExcludingMethodMatcher otherMmotherMm.adviceMethodhashCode(...)// May need to add implicit join point arg name...// name could be a variable or a type...// assume a type// The simple case... nothing to bind.// need to bind arguments by name as returned from the pointcut match// We have been able to determine the arg names.// We need to discover them, or if that fails, guess,// and if we can't guess with 100% accuracy, fail.// Last in chain, so if we're called and we fail, that's bad...// So we match in number...// Check that returning and throwing were in the argument names list if// specified, and find the discovered argument types.// configure the pointcut expression accordingly.// AMC start// binding from pointcut match// binding from returning clause// binding from thrown exceptionimport Ordered/** Interface implemented to provide an instance of an AspectJ aspect. ... *//** Create an instance of this factory's aspect. ... *//** Expose the aspect class loader that this factory uses. ... */import Annotationimport HashSetimport Setimport PointcutParserimport PointcutPrimitive/** {@link ParameterNameDiscoverer} implementation that tries to deduce parameter names ... */new HashSet<String>(...)Set<PointcutPrimitive> pointcutPrimitivesgetAllSupportedPointcutPrimitives(...)PointcutPrimitive primitiveString THIS_JOIN_POINT, ...;String THIS_JOIN_POINT_STATIC_PART, ...;int STEP_JOIN_POINT_BINDING, ...;// Steps in the binding algorithm...int STEP_THROWING_BINDING, ...;int STEP_ANNOTATION_BINDING, ...;int STEP_RETURNING_BINDING, ...;int STEP_PRIMITIVE_ARGS_BINDING, ...;int STEP_THIS_TARGET_ARGS_BINDING, ...;int STEP_REFERENCE_PCUT_BINDING, ...;int STEP_FINISHED, ...;Set<String> singleValuedAnnotationPcds, ...;Set<String> nonReferencePointcutTokens, ...;String pointcutExpression, ...;/** The pointcut expression associated with the advice, as a simple String. */boolean raiseExceptions, ...;/** If the advice is afterReturning, and binds the return value, this is the parameter name used. *//** If the advice is afterThrowing, and binds the thrown value, this is the parameter name used. */...[] argumentTypes, ...;...[] parameterNameBindings, ...;int numberOfRemainingUnboundArguments, ...;/** Create a new discoverer that attempts to discover parameter names. ... */this.pointcutExpression/** Indicate whether {@link IllegalArgumentException} and {@link AmbiguousBindingException} ... */this.raiseExceptions/** If {@code afterReturning} advice binds the return value, the ... *//** If {@code afterThrowing} advice binds the thrown value, the ... *//** Deduce the parameter names for an advice method. ... */int minimumNumberUnboundArgsthis.argumentTypesthis.numberOfRemainingUnboundArgumentsthis.argumentTypes.lengththis.parameterNameBindingsint algorithmicStepmaybeBindThisJoinPoint(...)maybeBindThisJoinPointStaticPart(...)maybeBindThrowingVariable(...)maybeBindAnnotationsFromPointcutExpression(...)maybeBindReturningVariable(...)maybeBindPrimitiveArgsFromPointcutExpression(...)maybeBindThisOrTargetOrArgsFromPointcutExpression(...)maybeBindReferencePointcutParameter(...)RuntimeException ex...|.../** An advice method can never be a constructor in Spring. ... *//** If the first parameter is of type JoinPoint or ProceedingJoinPoint,bind "thisJoinPoint" as ... */bindParameterName(...)/** If a throwing name was specified and there is exactly one choice remaining ... */int throwableIndexisUnbound(...)isSubtypeOf(...)Throwable.classnew AmbiguousBindingException(...)/** If a returning variable was specified and there is only one choice remaining, bind it. */this.parameterNameBindings.length/** Parse the string pointcut expression looking for: ... */List<String> varNamestokenizeToStringArray(...)tokens.lengthString toMatchint firstParenIndexindexOf(...)PointcutBody bodygetPointcutBody(...)String varNamemaybeExtractVariableName(...)body.text...+=...body.numTokensConsumedmaybeExtractVariableNamesFromArgs(...)bindAnnotationsFromVarNames(...)/** Match the given list of extracted variable names to argument slots. */int numAnnotationSlotscountNumberOfUnboundAnnotationArguments(...)findAndBind(...)Annotation.class/* If the token starts meets Java identifier conventions, it's in. *//** Given an args pointcut body (could be {@code args} or {@code at_args}), ... *//** Parse the string pointcut expression looking for this(), target() and args() expressions. ... */List<String> candidateVarNamesalreadyBound(...)int jString nextTokencharAt(...)/* We've found the start of a binding pointcut at the given index into the ... */int numTokensConsumedString currentTokenint bodyStartnew PointcutBody(...)StringBuilder sbnew StringBuilder(...)int currentIndex... >= ...append(...)String toAppendendsWith(...)trim(...)toString(...)/** Match up args against unbound arguments of primitive types. */int numUnboundPrimitivescountNumberOfUnboundPrimitiveArguments(...)isPrimitive(...)/* Return true if the parameter name binding for the given parameter ... *//* Return {@code true} if the given argument type is a subclass ... */int count/* Find the argument index with the given type, and bind the given ... *//** Simple struct to hold the extracted text from a pointcut body, together ... */int numTokensConsumed, ...;String text, ...;this.numTokensConsumedthis.text/** Thrown in response to an ambiguous binding being detected when ... *//** Construct a new AmbiguousBindingException with the specified message. ... */// convention for failing is to return null, allowing participation in a chain of responsibility// we return null rather than throw an exception so that we behave well// in a chain-of-responsibility.// So there is binding work to do...// Second candidate we've found - ambiguous binding// We're all set... find the unbound parameter, and bind it.// we have work to do...// it's a match// multiple candidate vars, but only one slot// no slots so presume those candidate vars were actually type names// we may have found some var names that were bound in previous primitive args binding step,// filter them out...// else varNames.size must be 0 and we have nothing to bind.// no "(" and nothing following// next token is not "(" either, can't be a pc...// eat the body// then it could be a reference pointcut// It's an all in one... get the text between the first (and the last)// We looked and failed...// Look for arg variable and bind it if we find exactly one...// 1 primitive arg, and one candidate...import AfterAdvice/** Spring AOP advice wrapping an AspectJ after advice method. ... */invokeAdviceMethod(...)import AfterReturningAdviceimport TypeUtils/** Spring AOP advice wrapping an AspectJ after-returning advice method. ... */setReturningNameNoCheck(...)shouldInvokeOnReturnValueOf(...)/** Following AspectJ semantics, if a returning clause was specified, then the ... */Class<?> typegetDiscoveredReturningType(...)Type genericTypegetDiscoveredReturningGenericType(...)matchesReturnValue(...)isAssignable(...)getGenericReturnType(...)/** Following AspectJ semantics, if a return value is null (or return type is void), ... */isAssignableValue(...)void.classgetReturnType(...)// If we aren't dealing with a raw type, check if generic parameters are assignable./** Spring AOP advice wrapping an AspectJ after-throwing advice method. ... */setThrowingNameNoCheck(...)shouldInvokeOnThrowing(...)/** In AspectJ semantics, after throwing advice that specifies a throwing clause ... */getDiscoveredThrowingType(...)import BeforeAdvice/** Utility methods for dealing with AspectJ advisors. ... *//** Return {@code true} if the advisor is a form of before advice. */AspectJPrecedenceInformation precedenceInfogetAspectJPrecedenceInformationFor(...)isBeforeAdvice(...)/** Return {@code true} if the advisor is a form of after advice. */isAfterAdvice(...)/** Return the AspectJPrecedenceInformation provided by this advisor or its advice. ... */Advice advice/** Spring AOP around advice (MethodInterceptor) that wraps ... */ProceedingJoinPoint pjplazyGetProceedingJoinPoint(...)JoinPointMatch jpm/** Return the ProceedingJoinPoint for the current invocation, ... */import Proxyimport ConcurrentHashMapimport Logimport LogFactoryimport NamePatternimport ReflectionWorldExceptionimport ShadowMatchImplimport ContextBasedMatcherimport FuzzyBooleanimport MatchingContextimport PointcutDesignatorHandlerimport PointcutExpressionimport ShadowMatchimport ClassFilterimport IntroductionAwareMethodMatcherimport ProxyCreationContextimport AbstractExpressionPointcutimport BeanFactoryUtilsimport BeanFactoryAnnotationUtilsimport ObjectUtils/** Spring {@link org.springframework.aop.Pointcut} implementation ... */new ConcurrentHashMap<Method,ShadowMatch>(...)new HashSet<PointcutPrimitive>(...)PointcutPrimitive.EXECUTIONPointcutPrimitive.ARGSPointcutPrimitive.REFERENCEPointcutPrimitive.THISPointcutPrimitive.TARGETPointcutPrimitive.WITHINPointcutPrimitive.AT_ANNOTATIONPointcutPrimitive.AT_WITHINPointcutPrimitive.AT_ARGSPointcutPrimitive.AT_TARGETgetLog(...)AspectJExpressionPointcut.classSet<PointcutPrimitive> SUPPORTED_PRIMITIVES, ...;Log logger, ...;Class<?> pointcutDeclarationScope, ...;...[] pointcutParameterNames, ...;...[] pointcutParameterTypes, ...;BeanFactory beanFactory, ...;ClassLoader pointcutClassLoader, ...;PointcutExpression pointcutExpression, ...;Map<Method,ShadowMatch> shadowMatchCache, ...;/** Create a new default AspectJExpressionPointcut. *//** Create a new AspectJExpressionPointcut with the given settings. ... */this.pointcutDeclarationScopeparamNames.lengthparamTypes.lengththis.pointcutParameterNamesthis.pointcutParameterTypes/** Set the declaration scope for the pointcut. *//** Set the parameter names for the pointcut. *//** Set the parameter types for the pointcut. */this.beanFactoryobtainPointcutExpression(...)/** Check whether this pointcut is ready to match, ... */this.pointcutClassLoaderdeterminePointcutClassLoader(...)buildPointcutExpression(...)/** Determine the ClassLoader to use for pointcut evaluation. */getBeanClassLoader(...)getClassLoader(...)getDefaultClassLoader(...)/** Build the underlying AspectJ pointcut expression. */PointcutParser parserinitializePointcutParser(...)PointcutParameter[] pointcutParametersnew PointcutParameter[]this.pointcutParameterNames.lengthpointcutParameters.lengthcreatePointcutParameter(...)parsePointcutExpression(...)replaceBooleanOperators(...)resolveExpression(...)/** Initialize the underlying AspectJ pointcut parser. */getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(...)registerPointcutDesignatorHandler(...)new BeanPointcutDesignatorHandler(...)/** If a pointcut expression has been specified in XML, the user cannot ... */String result/** Return the underlying AspectJ pointcut expression. */PointcutExpression pointcutExpressioncouldMatchJoinPointsInType(...)ReflectionWorldException exPointcutExpression fallbackExpressiongetFallbackPointcutExpression(...)debug(...)ShadowMatch shadowMatchgetTargetShadowMatch(...)alwaysMatches(...)neverMatches(...)RuntimeTestWalker walkergetRuntimeTestWalker(...)testTargetInstanceOfResidue(...)testsSubtypeSensitiveVars(...)matches(...)mayNeedDynamicTest(...)Object targetObjectObject thisObjectgetThis(...)getProxy(...)IllegalStateException exisDebugEnabled(...)JoinPointMatch joinPointMatchmatchesJoinPoint(...)RuntimeTestWalker originalMethodResidueTestgetShadowMatch(...)testThisInstanceOfResidue(...)bindParameters(...)asList(...)getCurrentProxiedBeanName(...)/** Get a new pointcut expression based on a target class's loader rather than the default. */ClassLoader classLoadernew RuntimeTestWalker(...)(...).primaryMethod targetMethodgetMostSpecificMethod(...)isInterface(...)Set<Class<?>> ifcsgetAllInterfacesForClassAsSet(...)Class<?> compositeInterfacecreateCompositeInterface(...)toClassArray(...)this.shadowMatchCacheMethod methodToMatchmatchesMethodExecution(...)ReflectionWorldException ex2isProxyClass(...)new ShadowMatchImpl(...)FuzzyBoolean.NOmaybeMatches(...)new DefensiveShadowMatch(...)AspectJExpressionPointcut otherPcnullSafeEquals(...)otherPc.pointcutDeclarationScopeotherPc.pointcutParameterNamesotherPc.pointcutParameterTypesint hashCodenullSafeHashCode(...)... * ...this.pointcutParameterTypes.length//---------------------------------------------------------------------// Serialization support/** Handler for the Spring-specific {@code bean()} pointcut designator ... */String BEAN_DESIGNATOR_NAME, ...;new BeanContextMatcher(...)/** Matcher class for the BeanNamePointcutDesignatorHandler. ... */NamePattern expressionPattern, ...;this.expressionPatternnew NamePattern(...)contextMatch(...)FuzzyBoolean.YESString advisedBeanNameFuzzyBoolean.MAYBEisGeneratedBeanName(...)boolean isFactoryFactoryBean<>.classfromBoolean(...)matchesBean(...)BeanFactory.FACTORY_BEAN_PREFIXisQualifierMatch(...)new Predicate<String>(...) { ... }ShadowMatch primary, ...;ShadowMatch other, ...;this.primarythis.othersetMatchingContext(...)// Actually this is still a "maybe" - treat the pointcut as dynamic if we don't know enough yet// Special handling for this, target, @this, @target, @annotation// in Spring - we can optimize since we know we have exactly this class,// and there will never be matching subclass at runtime.// the maybe case// A match test returned maybe - if there are any subtype sensitive variables// involved in the test (this, target, at_this, at_target, at_annotation) then// we say this is not a match as in Spring there will never be a different// runtime subtype.// Bind Spring AOP proxy to AspectJ "this" and Spring AOP target to AspectJ target,// consistent with return of MethodInvocationProceedingJoinPoint// No current invocation.../* Do a final check to see if any this(TYPE) kind of residue match. For ... */// there is a current invocation// Note: Can't use JoinPointMatch.getClass().getName() as the key, since// Spring AOP does all the matching at a join point, and then all the invocations// under this scenario, if we just use JoinPointMatch as the key, then// Try to build the most specific interface possible for inherited methods to be// considered for sub-interface matches as well, in particular for proxy classes.// Note: AspectJ is only going to take Method.getDeclaringClass() into account.// Implemented interfaces probably expose conflicting method signatures...// Proceed with original target method.// Avoid lock contention for known Methods through concurrent access...// Not found - now check again with full lock...// Failed to introspect target method, probably because it has been loaded// in a special ClassLoader. Let's try the declaring ClassLoader instead...// Fall back to the plain original method in case of no resolvable match or a// negative match on a proxy class (which doesn't carry any annotations on its// redeclared methods).// Could neither introspect the target class nor the proxy class ->// let's try the original method's declaring class before we give up...// Possibly AspectJ 1.8.10 encountering an invalid signature// Rely on default serialization, just initialize state after deserialization.// Initialize transient fields.// pointcutExpression will be initialized lazily by checkReadyToMatch()// no proxy creation in progress// abstain; can't return YES, since that will make pointcut with negation failimport AbstractGenericPointcutAdvisor/** Spring AOP Advisor that can be used for any AspectJ pointcut expression. ... */new AspectJExpressionPointcut(...)setExpression(...)setLocation(...)getLocation(...)setBeanFactory(...)import MethodBeforeAdvice/** Spring AOP advice that wraps an AspectJ before method. ... */import PointcutAdvisor/** AspectJPointcutAdvisor that adapts an {@link AbstractAspectJAdvice} ... */AbstractAspectJAdvice advice, ...;Pointcut pointcut, ...;Integer order, ...;/** Create a new AspectJPointcutAdvisor for the given advice. ... */this.advicebuildSafePointcut(...)this.order/** Return the name of the aspect (bean) in which the advice was declared. ... */getAspectName(...)AspectJPointcutAdvisor otherAdvisorotherAdvisor.adviceAspectJPointcutAdvisor.class/** Interface to be implemented by types that can supply the information ... *//** Return the name of the aspect (bean) in which the advice was declared. */// its advice for aspects with non-singleton instantiation models.// InstantiationModelAwarePointcutAdvisor which needs to delay creating// in order to sort advisors. This causes problems with the// AspectJPrecedenceComparator must ask an Advisor for its Advice in all cases// We need the level of indirection this interface provides as otherwise the// Implementation note:/** Return the declaration order of the advice member within the aspect. *//** Return whether this is a before advice. *//** Return whether this is an after advice. *//** Utility methods for working with AspectJ proxies. ... *//** Add special advisors if necessary to work with a proxy chain that contains AspectJ advisors: ... */boolean foundAspectJAdviceisAspectJAdvice(...)ExposeInvocationInterceptor.ADVISOR/** Determine whether the given Advisor contains an AspectJ advice. ... */hasLength(...)isJavaIdentifierStart(...)isJavaIdentifierPart(...)// Don't add advisors to an empty list; may indicate that proxying is just not required// Be careful not to get the Advice without a guard, as this might eagerly// instantiate a non-singleton AspectJ aspect...import AbortExceptionimport IMessageimport Kindimport IMessageHandler/** Implementation of AspectJ's {@link IMessageHandler} interface that ... */String AJ_ID, ...;Kind messageKindgetKind(...)IMessage.DEBUGmakeMessageFor(...)IMessage.INFOIMessage.WEAVEINFOisInfoEnabled(...)info(...)IMessage.WARNINGisWarnEnabled(...)warn(...)IMessage.ERRORisErrorEnabled(...)error(...)IMessage.ABORTisFatalEnabled(...)fatal(...)getMessage(...)/* Copyright 2002-2013 the original author or authors. ... */// We want to see everything, and allow configuration of log levels dynamically.// We weren't ignoring anything anyway...import IntroductionAdvisorimport IntroductionInterceptorimport ClassFiltersimport DelegatePerTargetObjectIntroductionInterceptorimport DelegatingIntroductionInterceptor/** Introduction advisor delegating to the given object. ... */Advice advice, ...;Class<?> introducedInterface, ...;ClassFilter typePatternClassFilter, ...;/** Create a new advisor for this DeclareParents field. ... */this(...)new DelegatePerTargetObjectIntroductionInterceptor(...)new DelegatingIntroductionInterceptor(...)/** Private constructor to share common code between impl-based delegate and reference-based delegate ... */ClassFilter typePatternFilternew TypePatternClassFilter(...)ClassFilter exclusionnew ClassFilter(...) { ... }this.introducedInterfacethis.typePatternClassFilter// Excludes methods implemented.// Do nothing/** Interface to be implemented by Spring AOP Advisors wrapping AspectJ ... *//** Return whether this advisor is lazily initializing its underlying advice. *//** Return whether this advisor has already instantiated its advice. *//* Copyright 2002-2006 the original author or authors. ... */import Modifierimport Signatureimport MethodSignatureimport SourceLocationimport AroundClosure/** An implementation of the AspectJ {@link ProceedingJoinPoint} interface ... */ParameterNameDiscoverer parameterNameDiscoverer, ...;ProxyMethodInvocation methodInvocation, ...;...[] args, ...;Signature signature, ...;/** Lazily initialized signature object. */SourceLocation sourceLocation, ...;/** Lazily initialized source location object. *//** Create a new MethodInvocationProceedingJoinPoint, wrapping the given ... */this.methodInvocationinvocableClone(...)arguments.lengthgetArguments(...).lengthgetArguments(...)setArguments(...)/** Returns the Spring AOP proxy. Cannot be {@code null}. *//** Returns the Spring AOP target. May be {@code null} if there is no target. */this.argsclone(...)this.signaturenew MethodSignatureImpl(...)this.sourceLocationnew SourceLocationImpl(...)ProceedingJoinPoint.METHOD_EXECUTIONtoShortString(...)getSignature(...)toLongString(...)/** Lazily initialized MethodSignature. */...[] parameterNames, ...;getModifiers(...)String[] parameterNamesthis.parameterNamesgetExceptionTypes(...)Class<?>[] parametersTypesappendType(...)getDeclaringType(...)appendTypes(...)int sizetypes.lengthisArray(...)getComponentType(...)/** Lazily initialized SourceLocation. */// TODO: It's just an adapter but returning 0 might still have side effects...import Fieldimport ReferenceTypeimport ReferenceTypeDelegateimport ResolvedTypeimport Andimport Callimport FieldGetCallimport HasAnnotationimport ITestVisitorimport Instanceofimport Literalimport Notimport Orimport MatchingContextBasedTestimport ReflectionBasedReferenceTypeDelegateimport ReflectionVar/** This class encapsulates some AspectJ internal knowledge that should be ... */getDeclaredField(...)ShadowMatchImpl.classReflectionVar.classReflectionBasedReferenceTypeDelegate.classNoSuchFieldException exField residualTestField, ...;Field varTypeField, ...;Field myClassField, ...;Test runtimeTest, ...;this.runtimeTestIllegalAccessException ex/** If the test uses any of the this, target, at_this, at_target, and at_annotation vars, ... */new SubtypeSensitiveVarTypeTestVisitor(...)thisInstanceOfMatches(...)new ThisInstanceOfResidueTestVisitor(...)targetInstanceOfMatches(...)new TargetInstanceOfResidueTestVisitor(...)int THIS_VAR, ...;int TARGET_VAR, ...;int AT_THIS_VAR, ...;int AT_TARGET_VAR, ...;int AT_ANNOTATION_VAR, ...;accept(...)getLeft(...)getRight(...)getBody(...)Class<?> matchClass, ...;boolean matches, ...;int matchVarType, ...;this.matchClassthis.matchesthis.matchVarTypeint varTypegetVarType(...)getVar(...)Class<?> typeClassResolvedType typeReferenceTypeDelegate delegategetDelegate(...)ClassNotFoundException ex/** Check if residue of target(TYPE) kind. See SPR-3783 for more details. */instanceOfMatches(...)/** Check if residue of this(TYPE) kind. See SPR-2979 for more details. */// TODO: Optimization: Process only if this() specifies a type and not an identifier.Object thisObj, ...;Object targetObj, ...;...[] argsObjs, ...;boolean testsSubtypeSensitiveVars, ...;this.testsSubtypeSensitiveVarsReflectionVar vObject varUnderTestgetBindingAtJoinPoint(...)this.thisObjthis.targetObjthis.argsObjs// Don't use ResolvedType.isAssignableFrom() as it won't be aware of (Spring) mixins// If you thought things were bad before, now we sink to new levels of horror...import AopConfigException/** Implementation of {@link AspectInstanceFactory} that creates a new instance ... */Class<?> aspectClass, ...;/** Create a new SimpleAspectInstanceFactory for the given aspect class. ... */this.aspectClass/** Return the specified aspect class (never {@code null}). */newInstance(...)accessibleConstructor(...)new AopConfigException(...)InstantiationException ex/** Determine the order for this factory's aspect instance, ... */getOrderForAspectClass(...)/** Determine a fallback order for the case that the aspect instance ... */Ordered.LOWEST_PRECEDENCE/** Implementation of {@link AspectInstanceFactory} that is backed by a ... */Object aspectInstance, ...;/** Create a new SingletonAspectInstanceFactory for the given aspect instance. ... */this.aspectInstanceimport TypePatternMatcher/** Spring AOP {@link ClassFilter} implementation using AspectJ type matching. ... */String typePattern, ...;TypePatternMatcher aspectJTypePatternMatcher, ...;/** Creates a new instance of the {@link TypePatternClassFilter} class. ... *//** Create a fully configured {@link TypePatternClassFilter} using the ... */setTypePattern(...)/** Set the AspectJ type pattern to match. ... */this.typePatternthis.aspectJTypePatternMatcherparseTypePattern(...)getPointcutParserSupportingAllPrimitivesAndUsingContextClassloaderForResolution(...)/** Return the AspectJ type pattern to match. *//** If a type pattern has been specified in XML, the user cannot ... */(...).typePatternimport StringTokenizerimport AjTypeimport AjTypeSystemimport PerClauseKindimport AnnotationUtils/** Abstract base class for factories that can create Spring AOP Advisors ... */new AspectJAnnotationParameterNameDiscoverer(...)Pointcut.classAround.classBefore.classAfter.classAfterReturning.classAfterThrowing.classString AJC_MAGIC, ...;...[] ASPECTJ_ANNOTATION_CLASSES, ...;/** Logger available to subclasses. *//** We consider something to be an AspectJ aspect suitable for use by the Spring AOP system ... */hasAspectAnnotation(...)compiledByAjc(...)findAnnotation(...)Aspect.class/** We need to detect this as "code-style" AspectJ aspects should not be ... */Field fieldgetDeclaredFields(...)AjType<?> ajTypegetAjType(...)getAnnotation(...)getSuperclass(...)isAbstract(...)isAspect(...)new NotAnAtAspectException(...)PerClauseKind.PERCFLOWgetPerClause(...)PerClauseKind.PERCFLOWBELOW/** Find and return the first AspectJ annotation on the given method ... */Class<?> clazzAspectJAnnotation<?> foundAnnotationA resultnew AspectJAnnotation<A>(...)/** Enum for AspectJ annotation types. ... */new AspectJAnnotationType(...)AspectJAnnotationType AtPointcut, ...;AspectJAnnotationType AtAround, ...;AspectJAnnotationType AtBefore, ...;AspectJAnnotationType AtAfter, ...;AspectJAnnotationType AtAfterReturning, ...;AspectJAnnotationType AtAfterThrowing, ...;/** Class modelling an AspectJ annotation, exposing its type enumeration and ... */new HashMap<Class<?>,AspectJAnnotationType>(...)AspectJAnnotationType.AtPointcutAspectJAnnotationType.AtAroundAspectJAnnotationType.AtBeforeAspectJAnnotationType.AtAfterAspectJAnnotationType.AtAfterReturningAspectJAnnotationType.AtAfterThrowing...[] EXPRESSION_ATTRIBUTES, ...;Map<Class<?>,AspectJAnnotationType> annotationTypeMap, ...;A annotation, ...;AspectJAnnotationType annotationType, ...;String argumentNames, ...;this.annotationthis.annotationTypedetermineAnnotationType(...)Object argNamesgetValue(...)AspectJAnnotationType typeannotationType(...)String attributeNameObject valString str/** ParameterNameDiscoverer implementation that analyzes the arg names ... */AspectJAnnotation<?> annotationfindAspectJAnnotationOnMethod(...)StringTokenizer nameTokensnew StringTokenizer(...)getArgumentNames(...)countTokens(...)String[] namesnames.lengthnextToken(...)// The AJTypeSystem goes to great lengths to provide a uniform appearance between code-style and// annotation-style aspects. Therefore there is no 'clean' way to tell them apart. Here we rely on// an implementation detail of the AspectJ compiler.// If the parent has the annotation and isn't abstract it's an errorimport Patternimport AspectJAwareAdvisorAutoProxyCreatorimport ListableBeanFactoryimport ConfigurableListableBeanFactory/** {@link AspectJAwareAdvisorAutoProxyCreator} subclass that processes all AspectJ ... */List<Pattern> includePatterns, ...;AspectJAdvisorFactory aspectJAdvisorFactory, ...;BeanFactoryAspectJAdvisorsBuilder aspectJAdvisorsBuilder, ...;/** Set a list of regex patterns, matching eligible @AspectJ bean names. ... */this.includePatternsnew ArrayList<Pattern>(...)String patternTextcompile(...)this.aspectJAdvisorFactoryinitBeanFactory(...)new ReflectiveAspectJAdvisorFactory(...)this.aspectJAdvisorsBuildernew BeanFactoryAspectJAdvisorsBuilderAdapter(...)List<Advisor> advisorsfindCandidateAdvisors(...)addAll(...)buildAspectJAdvisors(...)isInfrastructureClass(...)/** Check whether the given aspect bean is eligible for auto-proxying. ... */Pattern patternmatcher(...)/** Subclass of BeanFactoryAspectJAdvisorsBuilderAdapter that delegates to ... */isEligibleAspectBean(...)AnnotationAwareAspectJAutoProxyCreator.this// Add all the Spring advisors found according to superclass rules.// Build Advisors for all AspectJ aspects in the bean factory.// Previously we setProxyTargetClass(true) in the constructor, but that has too// broad an impact. Instead we now override isInfrastructureClass to avoid proxying// aspects. I'm not entirely happy with that as there is no good reason not// to advise aspects, except that it causes advice invocation to go through a// proxy, and if the aspect implements e.g the Ordered interface it will be// proxied by that interface and fail at runtime as the advice method is not// defined on the interface. We could potentially relax the restriction about// not advising aspects in the future.import AspectJExpressionPointcut/** Interface for factories that can create Spring AOP Advisors from classes ... *//** Determine whether or not the given class is an aspect, as reported ... *//** Is the given class a valid AspectJ aspect class? ... *//** Build Spring AOP Advisors for all annotated At-AspectJ methods ... *//** Build a Spring AOP Advisor for the given AspectJ advice method. ... *//** Build a Spring AOP Advice for the given AspectJ advice method. ... */import AspectJProxyUtilsimport SimpleAspectInstanceFactoryimport ProxyCreatorSupportimport AnnotationAwareOrderComparator/** AspectJ-based proxy factory, allowing for programmatic building ... */new ConcurrentHashMap<Class<?>,Object>(...)Map<Class<?>,Object> aspectCache, ...;/** Cache for singleton aspect instances. */AspectJAdvisorFactory aspectFactory, ...;/** Create a new AspectJProxyFactory. *//** Create a new AspectJProxyFactory. ... */setInterfaces(...)getAllInterfaces(...)setTarget(...)/** Create a new {@code AspectJProxyFactory}. ... *//** Add the supplied aspect instance to the chain. The type of the aspect instance ... */Class<?> aspectClassString aspectNameAspectMetadata amcreateAspectMetadata(...)PerClauseKind.SINGLETONaddAdvisorsFromAspectInstanceFactory(...)new SingletonMetadataAwareAspectInstanceFactory(...)/** Add an aspect of the supplied type to the end of the advice chain. ... */MetadataAwareAspectInstanceFactory instanceFactorycreateAspectInstanceFactory(...)/** Add all {@link Advisor Advisors} from the supplied {@link MetadataAwareAspectInstanceFactory} ... */this.aspectFactoryClass<?> targetClassgetTargetClass(...)findAdvisorsThatCanApply(...)makeAdvisorChainAspectJCapableIfNecessary(...)sort(...)addAdvisors(...)/** Create an {@link AspectMetadata} instance for the supplied aspect type. */new AspectMetadata(...)/** Create a {@link MetadataAwareAspectInstanceFactory} for the supplied aspect type. If the aspect type ... */Object instancegetSingletonAspectInstance(...)new SimpleMetadataAwareAspectInstanceFactory(...)/** Get the singleton aspect instance for the supplied aspect type. ... */computeIfAbsent(...)new Function<Class<?>,Object>(...) { ... }new SimpleAspectInstanceFactory(...)/** Create a new proxy according to the settings in this factory. ... */createAopProxy(...)// Create a shared aspect instance.// Create a factory for independent aspect instances.import TypePatternClassFilter/** Metadata for an AspectJ aspect class, with an additional Spring AOP pointcut ... *//** The name of this aspect as defined to Spring (the bean name) - ... *//** The aspect class, stored separately for re-resolution of the ... */AjType<?> ajType, ...;/** AspectJ reflection information (AspectJ 5 / Java 5 specific). ... */Pointcut perClausePointcut, ...;/** Spring AOP pointcut corresponding to the per clause of the ... *//** Create a new AspectMetadata instance for the given aspect class. ... */Class<?> currClassAjType<?> ajTypeToCheckgetDeclarePrecedence(...).lengthgetDeclarePrecedence(...)getJavaClass(...)this.ajTypeAspectJExpressionPointcut ajexpthis.perClausePointcutfindPerClause(...)setPointcutDeclarationScope(...)/** Extract contents from String of form {@code pertarget(contents)}. */value(...)int beginIndexint endIndex/** Return AspectJ reflection information. *//** Return the aspect class. *//** Return the aspect name. *//** Return a Spring pointcut expression for a singleton aspect. ... *//** Return whether the aspect is defined as "perthis" or "pertarget". */PerClauseKind kindPerClauseKind.PERTARGETPerClauseKind.PERTHIS/** Return whether the aspect is defined as "pertypewithin". */PerClauseKind.PERTYPEWITHIN/** Return whether the aspect needs to be lazily instantiated. */isPerThisOrPerTarget(...)isPerTypeWithin(...)// Works with a type patternimport OrderUtils/** {@link org.springframework.aop.aspectj.AspectInstanceFactory} implementation ... */AspectMetadata aspectMetadata, ...;/** Create a BeanFactoryAspectInstanceFactory. AspectJ will be called to ... *//** Create a BeanFactoryAspectInstanceFactory, providing a type that AspectJ should ... */Class<?> resolvedTypethis.aspectMetadatagetSingletonMutex(...)/** Determine the order for this factory's target aspect, either ... */Ordered.class// Rely on singleton semantics provided by the factory -> no local lock.// No singleton guarantees from the factory -> let's lock locally but// reuse the factory's singleton lock, just in case a lazy dependency// of our advice bean happens to trigger the singleton lock implicitly.../** Helper for retrieving @AspectJ beans from a BeanFactory and building ... */new ConcurrentHashMap<String,List<Advisor>>(...)new ConcurrentHashMap<String,MetadataAwareAspectInstanceFactory>(...)ListableBeanFactory beanFactory, ...;AspectJAdvisorFactory advisorFactory, ...;List<String> aspectBeanNames, ...;Map<String,List<Advisor>> advisorsCache, ...;Map<String,MetadataAwareAspectInstanceFactory> aspectFactoryCache, ...;/** Create a new BeanFactoryAspectJAdvisorsBuilder for the given BeanFactory. ... */this.advisorFactory/** Look for AspectJ-annotated aspect beans in the current bean factory, ... */List<String> aspectNamesthis.aspectBeanNamesnew ArrayList<Advisor>(...)String[] beanNamesbeanNamesForTypeIncludingAncestors(...)String beanNameClass<?> beanTypeisEligibleBean(...)AspectMetadata amdMetadataAwareAspectInstanceFactory factorynew BeanFactoryAspectInstanceFactory(...)List<Advisor> classAdvisorsthis.advisorsCachethis.aspectFactoryCachenew PrototypeAspectInstanceFactory(...)List<Advisor> cachedAdvisors/** Return whether the aspect bean with the given name is eligible. ... */// We must be careful not to instantiate beans eagerly as in this case they// would be cached by the Spring container but would not have been weaved.// Per target or per this.import AspectJPrecedenceInformationimport InstantiationModelAwarePointcutAdvisorimport AspectJAnnotationimport DynamicMethodMatcherPointcutimport Pointcuts/** Internal implementation of AspectJPointcutAdvisor. ... */AspectJExpressionPointcut declaredPointcut, ...;MetadataAwareAspectInstanceFactory aspectInstanceFactory, ...;boolean lazy, ...;Advice instantiatedAdvice, ...;Boolean isBeforeAdvice, ...;Boolean isAfterAdvice, ...;this.declaredPointcutisLazilyInstantiated(...)getAspectMetadata(...)Pointcut preInstantiationPointcutunion(...)getPerClausePointcut(...)new PerTargetInstantiationModelPointcut(...)this.lazythis.instantiatedAdviceinstantiateAdvice(...)/** The pointcut for Spring AOP to use. ... *//** Lazily instantiate advice if necessary. *//** This is only of interest for Spring AOP: AspectJ instantiation semantics ... *//** Return the AspectJ AspectMetadata for this advisor. */this.isBeforeAdvicedetermineAdviceType(...)this.isAfterAdvice/** Duplicates some logic from getAdvice, but importantly does not force ... */AspectJAnnotation<?> aspectJAnnotationgetAnnotationType(...)getDeclaredPointcut(...)/** Pointcut implementation that changes its behaviour when the advice is instantiated. ... */Pointcut preInstantiationPointcut, ...;LazySingletonAspectInstanceFactoryDecorator aspectInstanceFactory, ...;this.preInstantiationPointcutisAspectMaterialized(...)isMaterialized(...)// Static part of the pointcut is a lazy type.// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.// If it's not a dynamic pointcut, it may be optimized out// by the Spring AOP infrastructure after the first evaluation.// A singleton aspect.// We're either instantiated and matching on declared pointcut,// or uninstantiated matching on either pointcut...// This can match only on declared pointcut./** Decorator to cause a {@link MetadataAwareAspectInstanceFactory} to instantiate only once. ... */MetadataAwareAspectInstanceFactory maaif, ...;Object materialized, ...;/** Create a new lazily initializing decorator for the given AspectInstanceFactory. ... */this.maaifObject aspectInstancethis.materializedObject mutexgetAspectCreationMutex(...)import AspectInstanceFactory/** Subinterface of {@link org.springframework.aop.aspectj.AspectInstanceFactory} ... *//** Return the AspectJ AspectMetadata for this factory's aspect. ... *//** Return the best possible creation mutex for this factory. ... *//** Extension of AopConfigException thrown when trying to perform ... */Class<?> nonAspectClass, ...;/** Create a new NotAnAtAspectException for the given class. ... */this.nonAspectClass/** Returns the offending class. *//** {@link org.springframework.aop.aspectj.AspectInstanceFactory} backed by a ... *//** Create a PrototypeAspectInstanceFactory. AspectJ will be called to ... */import Comparatorimport DeclareParentsimport AbstractAspectJAdviceimport AspectJAfterAdviceimport AspectJAfterReturningAdviceimport AspectJAfterThrowingAdviceimport AspectJAroundAdviceimport AspectJMethodBeforeAdviceimport DeclareParentsAdvisorimport DefaultPointcutAdvisorimport Converterimport ConvertingComparatorimport MethodFilterimport InstanceComparator/** Factory that can create Spring AOP Advisors given AspectJ classes from ... */and(...)ReflectionUtils.USER_DECLARED_METHODSnew MethodFilter(...) { ... }Comparator<Method> adviceKindComparatornew ConvertingComparator<Method,Annotation>(...)new InstanceComparator<T>(...)new Converter<Method,Annotation>(...) { ... }AspectJAnnotation<?> annComparator<Method> methodNameComparatornew ConvertingComparator<Method,String>(...)new Converter<Method,String>(...) { ... }thenComparing(...)MethodFilter adviceMethodFilter, ...;// Exclude @Pointcut methodsComparator<Method> adviceMethodComparator, ...;/** Create a new {@code ReflectiveAspectJAdvisorFactory}. *//** Create a new {@code ReflectiveAspectJAdvisorFactory}, propagating the given ... */getAspectClass(...)MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactorynew LazySingletonAspectInstanceFactoryDecorator(...)validate(...)getAdvisorMethods(...)getAdvisor(...)Advisor instantiationAdvisornew SyntheticInstantiationAdvisor(...)getDeclareParentsAdvisor(...)List<Method> methodsnew ArrayList<Method>(...)doWithMethods(...)new MethodCallback(...) { ... }/** Build a {@link org.springframework.aop.aspectj.DeclareParentsAdvisor} ... */DeclareParents declareParentsDeclareParents.classdefaultImpl(...)new DeclareParentsAdvisor(...)AspectJExpressionPointcut expressionPointcutnew InstantiationModelAwarePointcutAdvisorImpl(...)Class<?> candidateAspectClassAbstractAspectJAdvice springAdviceString[] argNamesthis.parameterNameDiscovererAfterReturning afterReturningAnnotationAfterThrowing afterThrowingAnnotationnew AspectJAroundAdvice(...)new AspectJMethodBeforeAdvice(...)new AspectJAfterAdvice(...)new AspectJAfterReturningAdvice(...)hasText(...)returning(...)new AspectJAfterThrowingAdvice(...)throwing(...)setAspectName(...)setDeclarationOrder(...)/** Synthetic advisor that instantiates the aspect. ... */new MethodBeforeAdvice(...) { ... }// Note: although @After is ordered before @AfterReturning and @AfterThrowing,// an @After advice method will actually be invoked after @AfterReturning and// @AfterThrowing methods due to the fact that AspectJAfterAdvice.invoke(MethodInvocation)// invokes proceed() in a `try` block and only invokes the @After advice method// in a corresponding `finally` block.// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator// so that it will only instantiate once.// Prior to Spring Framework 5.2.7, advisors.size() was supplied as the declarationOrderInAspect// to getAdvisor(...) to represent the "current position" in the declared methods list.// However, since Java 7 the "current position" is not valid since the JDK no longer// returns declared methods in the order in which they are declared in the source code.// Thus, we now hard code the declarationOrderInAspect to 0 for all advice methods// discovered via reflection in order to support reliable advice ordering across JVM launches.// Specifically, a value of 0 aligns with the default value used in// AspectJPrecedenceComparator.getAspectDeclarationOrder(Advisor).// If it's a per target aspect, emit the dummy instantiating aspect.// Find introduction fields.// Not an introduction field// If we get here, we know we have an AspectJ method.// Check that it's an AspectJ-annotated class// Now to configure the advice.../** Implementation of {@link MetadataAwareAspectInstanceFactory} that ... */AspectMetadata metadata, ...;/** Create a new SimpleMetadataAwareAspectInstanceFactory for the given aspect class. ... */this.metadataimport SingletonAspectInstanceFactory/** Implementation of {@link MetadataAwareAspectInstanceFactory} that is backed ... *//** Create a new SingletonMetadataAwareAspectInstanceFactory for the given aspect. ... */import NonNullApiimport NonNullFields/** Classes enabling AspectJ 5 @Annotated classes to be used in Spring AOP. ... */import PartialOrderimport PartialComparableimport AspectJPointcutAdvisorimport AbstractAdvisorAutoProxyCreator/** {@link org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator} ... */new AspectJPrecedenceComparator(...)Comparator<Advisor> DEFAULT_PRECEDENCE_COMPARATOR, ...;/** Sort the supplied {@link Advisor} instances according to AspectJ precedence. ... */List<PartiallyComparableAdvisorHolder> partiallyComparableAdvisorsnew ArrayList<PartiallyComparableAdvisorHolder>(...)List<PartiallyComparableAdvisorHolder> sortednew PartiallyComparableAdvisorHolder(...)List<Advisor> resultPartiallyComparableAdvisorHolder pcAdvisorsortAdvisors(...)/** Add an {@link ExposeInvocationInterceptor} to the beginning of the advice chain. ... */List<Advisor> candidateAdvisorsshouldSkip(...)/** Implements AspectJ's {@link PartialComparable} interface for defining partial orderings. */Advisor advisor, ...;Comparator<Advisor> comparator, ...;this.advisorthis.comparatorAdvisor otherAdvisor(...).advisorcompare(...)getShortName(...)boolean appendedAbstractAspectJAdvice ajAdvicegetDeclarationOrder(...)// TODO: Consider optimization by caching the list of the aspect namesimport AspectJAopUtils/** Orders AspectJ advice/advisors by precedence (<i>not</i> invocation order). ... */int HIGHER_PRECEDENCE, ...;int SAME_PRECEDENCE, ...;int LOWER_PRECEDENCE, ...;Comparator<? super Advisor> advisorComparator, ...;/** Create a default {@code AspectJPrecedenceComparator}. */this.advisorComparatorAnnotationAwareOrderComparator.INSTANCE/** Create an {@code AspectJPrecedenceComparator}, using the given {@link Comparator} ... */int advisorPrecedencedeclaredInSameAspect(...)comparePrecedenceWithinAspect(...)boolean oneOrOtherIsAfterAdviceint adviceDeclarationOrderDeltagetAspectDeclarationOrder(...)hasAspectName(...)// pre-condition is that hasAspectName returned truenew Supplier<String>(...) { ... }// the advice declared last has higher precedence// advice1 was declared before advice2// so advice1 has lower precedence// the advice declared first has higher precedence// so advice1 has higher precedence/** Base classes enabling auto-proxying based on AspectJ. ... *//** AspectJ integration package. Includes Spring AOP advice implementations for AspectJ 5 ... */import Nodeimport ProxyFactoryBeanimport BeanDefinitionHolderimport BeanDefinitionReaderUtilsimport RootBeanDefinitionimport BeanDefinitionDecoratorimport ParserContext/** Base implementation for ... */BeanDefinitionRegistry registrygetRegistry(...)String existingBeanNamegetBeanName(...)BeanDefinition targetDefinitionBeanDefinitionHolder targetHoldernew BeanDefinitionHolder(...)BeanDefinition interceptorDefinitioncreateInterceptorDefinition(...)String interceptorNamegetInterceptorNameSuffix(...)BeanDefinitionHolder resultisProxyFactoryBeanDefinition(...)RootBeanDefinition proxyDefinitionnew RootBeanDefinition(...)setBeanClass(...)ProxyFactoryBean.classsetScope(...)setLazyInit(...)isLazyInit(...)setDecoratedDefinition(...)getPropertyValues(...)new ManagedList<String>(...)setAutowireCandidate(...)isAutowireCandidate(...)setPrimary(...)isPrimary(...)copyQualifiersFrom(...)addInterceptorNameToList(...)List<String> listgetBeanClassName(...)String beanClassNameuncapitalize(...)/** Subclasses should implement this method to return the {@code BeanDefinition} ... */// get the root bean name - will be the name of the generated proxy factory bean// delegate to subclass for interceptor definition// generate name and register the interceptor// create the proxy definition// create proxy factory bean definition// set the target// create the interceptor names list// copy autowire settings from original bean definition.// wrap it in a BeanDefinitionHolder with bean nameimport ParseState/** {@link ParseState} entry representing an advice element. ... */ParseState.EntryString kind, ...;/** Create a new {@code AdviceEntry} instance. ... */this.kindimport MutablePropertyValuesimport BeanReferenceimport AbstractComponentDefinition/** {@link org.springframework.beans.factory.parsing.ComponentDefinition} ... */String advisorBeanName, ...;BeanDefinition advisorDefinition, ...;String description, ...;...[] beanReferences, ...;...[] beanDefinitions, ...;MutablePropertyValues pvsBeanReference adviceReferencethis.advisorBeanNamethis.advisorDefinitionthis.beanReferencesnew BeanReference[]this.beanDefinitionsnew BeanDefinition[]this.descriptionbuildDescription(...)BeanReference pointcutReferencegetSource(...)/** {@link ParseState} entry representing an advisor. ... *//** Create a new {@code AdvisorEntry} instance. ... */import InfrastructureAdvisorAutoProxyCreator/** Utility class for handling registration of AOP auto-proxy creators. ... */new ArrayList<Class<?>>(...)InfrastructureAdvisorAutoProxyCreator.classAspectJAwareAdvisorAutoProxyCreator.classAnnotationAwareAspectJAutoProxyCreator.classString AUTO_PROXY_CREATOR_BEAN_NAME, ...;/** The bean name of the internally managed auto-proxy creator. */List<Class<?>> APC_PRIORITY_LIST, ...;/** Stores the auto proxy creator classes in escalation order. */registerAutoProxyCreatorIfNecessary(...)registerOrEscalateApcAsRequired(...)registerAspectJAutoProxyCreatorIfNecessary(...)registerAspectJAnnotationAutoProxyCreatorIfNecessary(...)containsBeanDefinition(...)BeanDefinition definitionBoolean.TRUERootBeanDefinition beanDefinitionBeanDefinition apcDefinitionint currentPriorityfindPriorityForClass(...)int requiredPrioritysetBeanClassName(...)setSource(...)Ordered.HIGHEST_PRECEDENCEsetRole(...)BeanDefinition.ROLE_INFRASTRUCTURE// Set up the escalation list...import BeanDefinitionParserimport NamespaceHandlerSupport/** {@code NamespaceHandler} for the {@code aop} namespace. ... *//** Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the ... */new ConfigBeanDefinitionParser(...)new AspectJAutoProxyBeanDefinitionParser(...)registerBeanDefinitionDecorator(...)new ScopedProxyBeanDefinitionDecorator(...)new SpringConfiguredBeanDefinitionParser(...)// In 2.0 XSD as well as in 2.5+ XSDs// Only in 2.0 XSD: moved to context namespace in 2.5+import BeanComponentDefinition/** Utility class for handling registration of auto-proxy creators used internally ... */String PROXY_TARGET_CLASS_ATTRIBUTE, ...;/** The {@code proxy-target-class} attribute as found on AOP-related XML tags. */String EXPOSE_PROXY_ATTRIBUTE, ...;/** The {@code expose-proxy} attribute as found on AOP-related XML tags. */BeanDefinition beanDefinitionextractSource(...)useClassProxyingIfNecessary(...)registerComponentIfNecessary(...)boolean proxyTargetClassparseBoolean(...)boolean exposeProxyforceAutoProxyCreatorToUseClassProxying(...)forceAutoProxyCreatorToExposeProxy(...)registerComponent(...)new BeanComponentDefinition(...)AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAMEimport CompositeComponentDefinition/** {@link ParseState} entry representing an aspect. ... */String id, ...;String ref, ...;/** Create a new {@code AspectEntry} instance. ... */this.idthis.refimport NodeListimport TypedStringValue/** {@link BeanDefinitionParser} for the {@code aspectj-autoproxy} tag, ... */extendBeanDefinition(...)BeanDefinition beanDefhasChildNodes(...)addIncludePatterns(...)ManagedList<TypedStringValue> includePatternsnew ManagedList<TypedStringValue>(...)NodeList childNodesgetChildNodes(...)getLength(...)Node nodeitem(...)Element includeElementTypedStringValue valueHoldernew TypedStringValue(...)import DefaultBeanFactoryPointcutAdvisorimport ConstructorArgumentValuesimport RuntimeBeanNameReferenceimport RuntimeBeanReference/** {@link BeanDefinitionParser} for the {@code <aop:config>} tag. ... */new ParseState(...)String ASPECT, ...;String EXPRESSION, ...;String ID, ...;String POINTCUT, ...;String ADVICE_BEAN_NAME, ...;String ADVISOR, ...;String ADVICE_REF, ...;String POINTCUT_REF, ...;String REF, ...;String BEFORE, ...;String DECLARE_PARENTS, ...;String TYPE_PATTERN, ...;String DEFAULT_IMPL, ...;String DELEGATE_REF, ...;String IMPLEMENT_INTERFACE, ...;String AFTER, ...;String AFTER_RETURNING_ELEMENT, ...;String AFTER_THROWING_ELEMENT, ...;String AROUND, ...;String RETURNING, ...;String RETURNING_PROPERTY, ...;String THROWING, ...;String THROWING_PROPERTY, ...;String ARG_NAMES, ...;String ARG_NAMES_PROPERTY, ...;String ASPECT_NAME_PROPERTY, ...;String DECLARATION_ORDER_PROPERTY, ...;String ORDER_PROPERTY, ...;int METHOD_INDEX, ...;int POINTCUT_INDEX, ...;int ASPECT_INSTANCE_FACTORY_INDEX, ...;ParseState parseState, ...;CompositeComponentDefinition compositeDefnew CompositeComponentDefinition(...)getTagName(...)List<Element> childEltsgetChildElements(...)pushContainingComponent(...)configureAutoProxyCreator(...)Element eltString localNamegetLocalName(...)parsePointcut(...)parseAdvisor(...)parseAspect(...)popAndRegisterContainingComponent(...)/** Configures the auto proxy creator needed to support the {@link BeanDefinition BeanDefinitions} ... *//** Parses the supplied {@code <advisor>} element and registers the resulting ... */AbstractBeanDefinition advisorDefcreateAdvisorBeanDefinition(...)String idString advisorBeanNameObject pointcutparsePointcutProperty(...)push(...)this.parseStatenew AdvisorEntry(...)registerWithGeneratedName(...)getReaderContext(...)new AdvisorComponentDefinition(...)new RuntimeBeanReference(...)pop(...)/** Create a {@link RootBeanDefinition} for the advisor described in the supplied. Does <strong>not</strong> ... */RootBeanDefinition advisorDefinitionDefaultBeanFactoryPointcutAdvisor.classString adviceRefsnapshot(...)new RuntimeBeanNameReference(...)hasAttribute(...)String aspectIdList<BeanDefinition> beanDefinitionsnew ArrayList<BeanDefinition>(...)List<BeanReference> beanReferencesnew ArrayList<BeanReference>(...)List<Element> declareParentsNodeList nodeListboolean adviceFoundAlreadyAspectComponentDefinition aspectComponentDefinitioncreateAspectComponentDefinition(...)List<Element> pointcutsnew AspectEntry(...)Element declareParentsElementparseDeclareParents(...)isAdviceNode(...)AbstractBeanDefinition advisorDefinitionparseAdvice(...)Element pointcutElementBeanDefinition[] beanDefArraytoArray(...)BeanReference[] beanRefArrayObject sourcenew AspectComponentDefinition(...)/** Return {@code true} if the supplied node describes an advice type. May be one of: ... *//** Parse a '{@code declare-parents}' element and register the appropriate ... */BeanDefinitionBuilder builderDeclareParentsAdvisor.classString defaultImplString delegateRefAbstractBeanDefinition definitionaddConstructorArgValue(...)addConstructorArgReference(...)/** Parses one of '{@code before}', '{@code after}', '{@code after-returning}', ... */RootBeanDefinition methodDefinitionMethodLocatingFactoryBean.classRootBeanDefinition aspectFactoryDefSimpleBeanFactoryAwareAspectInstanceFactory.classAbstractBeanDefinition adviceDefcreateAdviceDefinition(...)new AdviceEntry(...)setSynthetic(...)addGenericArgumentValue(...)getConstructorArgumentValues(...)/** Creates the RootBeanDefinition for a POJO advice bean. Also causes pointcut ... */RootBeanDefinition adviceDefinitiongetAdviceClass(...)ConstructorArgumentValues cavaddIndexedArgumentValue(...)RuntimeBeanReference pointcutRef/** Gets the advice implementation class corresponding to the supplied {@link Element}. */String elementNameAspectJMethodBeforeAdvice.classAspectJAfterAdvice.classAspectJAfterReturningAdvice.classAspectJAfterThrowingAdvice.classAspectJAroundAdvice.class/** Parses the supplied {@code <pointcut>} and registers the resulting ... */AbstractBeanDefinition pointcutDefinitionString pointcutBeanNamenew PointcutEntry(...)createPointcutDefinition(...)new PointcutComponentDefinition(...)/** Parses the {@code pointcut} or {@code pointcut-ref} attributes of the supplied ... */String pointcutRef/** Creates a {@link BeanDefinition} for the {@link AspectJExpressionPointcut} class using ... */// We have to parse "advice" and all the advice kinds in one loop, to get the// ordering semantics right.// create the method factory bean// create instance factory definition// register the pointcut// configure the advisor// register the final advisor// Create a pointcut for the anonymous pc and register it.import BeanUtils/** {@link FactoryBean} implementation that locates a {@link Method} on a specified bean. ... */String targetBeanName, ...;Method method, ...;/** Set the name of the bean to locate the {@link Method} on. ... */this.targetBeanName/** Set the name of the {@link Method} to locate. ... */Class<?> beanClassthis.methodresolveSignature(...)Method.classString pointcutBeanName, ...;BeanDefinition pointcutDefinition, ...;this.pointcutBeanNamethis.pointcutDefinition/** {@link ParseState} entry representing a pointcut. ... *//** Create a new {@code PointcutEntry} instance. ... */import ScopedProxyUtils/** {@link BeanDefinitionDecorator} responsible for parsing the ... */String PROXY_TARGET_CLASS, ...;BeanDefinitionHolder holdercreateScopedProxy(...)String targetBeanNamegetTargetBeanName(...)Element elefireComponentRegistered(...)// Register the original bean definition as it will be referenced by the scoped proxy// and is relevant for tooling (validation, navigation)./** Implementation of {@link AspectInstanceFactory} that locates the aspect from the ... */String aspectBeanName, ...;/** Set the name of the aspect bean. This is the bean that is returned when calling ... */this.aspectBeanName/** Look up the aspect bean from the {@link BeanFactory} and returns it. ... */isTypeMatch(...)/** {@link BeanDefinitionParser} responsible for parsing the ... */String BEAN_CONFIGURER_ASPECT_BEAN_NAME, ...;/** The bean name of the internally managed bean configurer aspect. */String BEAN_CONFIGURER_ASPECT_CLASS_NAME, ...;RootBeanDefinition defsetFactoryMethodName(...)registerBeanComponent(...)/** Support package for declarative AOP configuration, ... */import BeanPostProcessor/** Base class for {@link BeanPostProcessor} implementations that apply a ... */new ConcurrentHashMap<Class<?>,Boolean>(...)boolean beforeExistingAdvisors, ...;Map<Class<?>,Boolean> eligibleBeans, ...;/** Set whether this post-processor's advisor is supposed to apply before ... */this.beforeExistingAdvisorsAdvised advisedisEligible(...)isFrozen(...)addAdvisor(...)ProxyFactory proxyFactoryprepareProxyFactory(...)isProxyTargetClass(...)evaluateProxyInterfaces(...)customizeProxyFactory(...)getProxyClassLoader(...)/** Check whether the given bean is eligible for advising with this ... *//** Check whether the given class is eligible for advising with this ... */Boolean eligiblethis.eligibleBeanscanApply(...)/** Prepare a {@link ProxyFactory} for the given bean. ... */new ProxyFactory(...)copyFrom(...)/** Subclasses may choose to implement this: for example, ... */// Ignore AOP infrastructure such as scoped proxies.// Add our local Advisor to the existing proxy's Advisor chain...// No proxy needed.import TargetSourceimport AdvisorAdapterRegistryimport GlobalAdvisorAdapterRegistryimport SingletonTargetSourceimport BeanClassLoaderAwareimport FactoryBeanNotInitializedException/** Convenient superclass for {@link FactoryBean} types that produce singleton-scoped ... */getInstance(...)Object target, ...;...[] proxyInterfaces, ...;...[] preInterceptors, ...;...[] postInterceptors, ...;AdvisorAdapterRegistry advisorAdapterRegistry, ...;/** Default is global AdvisorAdapterRegistry. */ClassLoader proxyClassLoader, ...;Object proxy, ...;/** Set the target object, that is, the bean to be wrapped with a transactional proxy. ... */this.target/** Specify the set of interfaces being proxied. ... */this.proxyInterfaces/** Set additional interceptors (or advisors) to be applied before the ... */this.preInterceptors/** Set additional interceptors (or advisors) to be applied after the ... */this.postInterceptors/** Specify the AdvisorAdapterRegistry to use. ... */this.advisorAdapterRegistry/** Set the ClassLoader to generate the proxy class in. ... */this.proxyClassLoaderTargetSource targetSourcecreateTargetSource(...)Object interceptorwrap(...)createMainInterceptor(...)setTargetSource(...)getAllInterfacesForClass(...)postProcessProxyFactory(...)this.proxy/** Determine a TargetSource for the given target (or TargetSource). ... */new SingletonTargetSource(...)/** A hook for subclasses to post-process the {@link ProxyFactory} ... */new FactoryBeanNotInitializedException(...)this.proxyInterfaces.length/** Create the "main" interceptor for this proxy factory bean. ... */// Add the main interceptor (typically an Advisor).// Rely on AOP infrastructure to tell us what interfaces to proxy.import TargetClassAware/** Interface to be implemented by classes that hold the configuration ... *//** Return whether the Advised configuration is frozen, ... *//** Are we proxying the full target class instead of specified interfaces? *//** Return the interfaces proxied by the AOP proxy. ... *//** Determine whether the given interface is proxied. ... *//** Change the {@code TargetSource} used by this {@code Advised} object. ... *//** Return the {@code TargetSource} used by this {@code Advised} object. *//** Set whether the proxy should be exposed by the AOP framework as a ... *//** Return whether the factory should expose the proxy as a {@link ThreadLocal}. ... *//** Set whether this proxy configuration is pre-filtered so that it only ... *//** Return whether this proxy configuration is pre-filtered so that it only ... *//** Return the advisors applying to this proxy. ... *//** Return the number of advisors applying to this proxy. ... *//** Add an advisor at the end of the advisor chain. ... *//** Add an Advisor at the specified position in the chain. ... *//** Remove the given advisor. ... *//** Remove the advisor at the given index. ... *//** Return the index (from 0) of the given advisor, ... *//** Replace the given advisor. ... *//** Add the given AOP Alliance advice to the tail of the advice (interceptor) chain. ... *//** Add the given AOP Alliance Advice at the specified position in the advice chain. ... *//** Remove the Advisor containing the given advice. ... *//** Return the index (from 0) of the given AOP Alliance Advice, ... *//** As {@code toString()} will normally be delegated to the target, ... */import Collectionimport DynamicIntroductionAdviceimport IntroductionInfoimport DefaultIntroductionAdvisorimport EmptyTargetSource/** Base class for AOP proxy configuration managers. ... */new DefaultAdvisorChainFactory(...)EmptyTargetSource.INSTANCElong serialVersionUID, ...;/** use serialVersionUID from Spring 2.0 for interoperability. */TargetSource EMPTY_TARGET_SOURCE, ...;/** Canonical TargetSource when there's no target, and behavior is ... */TargetSource targetSource, ...;/** Package-protected to allow direct access for efficiency. */boolean preFiltered, ...;/** Whether the Advisors are already filtered for the specific target class. */AdvisorChainFactory advisorChainFactory, ...;/** The AdvisorChainFactory to use. */Map<MethodCacheKey,List<Object>> methodCache, ...;/** Cache with Method as key and advisor chain List as value. */List<Class<?>> interfaces, ...;/** Interfaces to be implemented by the proxy. Held in List to keep the order ... */List<Advisor> advisors, ...;/** List of Advisors. If an Advice is added, it will be wrapped ... *//** No-arg constructor for use as a JavaBean. */this.methodCachenew ConcurrentHashMap<MethodCacheKey,List<Object>>(...)/** Create a AdvisedSupport instance with the given parameters. ... *//** Set the given object as target. ... */this.targetSource/** Set a target class to be proxied, indicating that the proxy ... */forClass(...)this.preFiltered/** Set the advisor chain factory to use. ... */this.advisorChainFactory/** Return the advisor chain factory to use (never {@code null}). *//** Set the interfaces to be proxied. */this.interfacesClass<?> ifcaddInterface(...)/** Add a new proxied interface. ... */adviceChanged(...)/** Remove a proxied interface. ... */remove(...)Class<?> proxyIntfthis.advisorsnew Advisor[]int posvalidateIntroductionAdvisor(...)addAdvisorInternal(...)removeAdvisor(...)IntroductionAdvisor iagetInterfaces(...)removeInterface(...)/** Add all of the given advisors to this proxy configuration. ... */Class<?>[] ifcsvalidateInterfaces(...)/** Allows uncontrolled access to the {@link List} of {@link Advisor Advisors}. ... */addAdvice(...)/** Cannot add introductions this way unless the advice implements IntroductionInfo. */new DefaultIntroductionAdvisor(...)new DefaultPointcutAdvisor(...)/** Is the given advice included in any advisor within this proxy configuration? ... *//** Count advices of the given class. ... *//** Determine a list of {@link org.aopalliance.intercept.MethodInterceptor} objects ... */MethodCacheKey cacheKeynew MethodCacheKey(...)List<Object> cachedgetInterceptorsAndDynamicInterceptionAdvice(...)/** Invoked when advice has changed. *//** Call this method on a new instance created by the no-arg constructor ... */copyConfigurationFrom(...)other.targetSourceother.advisors/** Copy the AOP configuration from the given AdvisedSupport object, ... */other.advisorChainFactoryother.interfaces/** Build a configuration-only copy of this AdvisedSupport, ... */AdvisedSupport copynew AdvisedSupport(...)copy.targetSourceisStatic(...)getTargetSource(...)copy.advisorChainFactorycopy.interfacescopy.advisors/** For debugging/diagnostic use. */classNamesToString(...)/** Simple wrapper class around a Method. Used as the key when ... */int hashCode, ...;this.hashCode(...).methodint resultcompareTo(...)other.method// We need to remove introduction interfaces.// If the advisor passed validation, we can make the change.// We don't need an IntroductionAdvisor for this kind of introduction:// It's fully self-describing.// We need an IntroductionAdvisor for this kind of introduction.// Rely on default serialization; just initialize state after deserialization./** Listener to be registered on {@link ProxyCreatorSupport} objects ... *//** Invoked when the first proxy is created. ... *//** Invoked when advice is changed after a proxy is created. ... *//** Factory interface for advisor chains. ... *//** Exception that gets thrown on illegal AOP configuration arguments. ... *//** Constructor for AopConfigException. ... */import NamedThreadLocal/** Class containing static methods used to obtain information about the current AOP invocation. ... */new NamedThreadLocal<Object>(...)ThreadLocal<Object> currentProxy, ...;/** ThreadLocal holder for AOP proxy associated with this thread. ... *//** Try to return the current AOP proxy. This method is usable only if the ... */Object proxy/** Make the given proxy available via the {@code currentProxy()} method. ... */Object oldset(...)/** Marker interface that indicates a bean that is part of Spring's ... *//** Delegate interface for a configured AOP proxy, allowing for the creation ... *//** Create a new proxy object. ... *//** Interface to be implemented by factories that are able to create ... *//** Create an {@link AopProxy} for the given AOP configuration. ... */import Arrayimport SpringProxyimport DecoratingProxy/** Utility methods for AOP proxy factories. ... *//** Obtain the singleton target object behind the given proxy, if any. ... */getTarget(...)/** Determine the ultimate target class of the given bean instance, traversing ... */Object currentClass<?> resultgetSingletonTarget(...)/** Determine the complete set of interfaces to proxy for the given AOP configuration. ... */completeProxiedInterfaces(...)Class<?>[] specifiedInterfacesgetProxiedInterfaces(...)boolean addSpringProxyisInterfaceProxied(...)SpringProxy.classboolean addAdvisedisOpaque(...)Advised.classboolean addDecoratingProxyDecoratingProxy.classint nonUserIfcCountClass<?>[] proxiedInterfacesspecifiedInterfaces.length/** Extract the user-specified interfaces that the given proxy implements, ... */Class<?>[] proxyInterfacesClass<?>[] userInterfacescopyOf(...)proxyInterfaces.lengthnotEmpty(...)/** Check equality of the proxies behind the given AdvisedSupport objects. ... */equalsProxiedInterfaces(...)equalsAdvisors(...)/** Check equality of the proxied interfaces behind the given AdvisedSupport objects. *//** Check equality of the advisors behind the given AdvisedSupport objects. */getAdvisorCount(...)/** Adapt the given arguments to the target signature in the given method, ... */isVarArgs(...)Class<?>[] paramTypesint varargIndexClass<?> varargTypeObject varargArrayObject[] newArgumentsClass<?> targetElementTypeint varargLengthObject newVarargArray// No user-specified interfaces: check whether target class is an interface.import UndeclaredThrowableExceptionimport WeakHashMapimport RawTargetAccessimport ClassLoaderAwareGeneratorStrategyimport CodeGenerationExceptionimport SpringNamingPolicyimport Callbackimport CallbackFilterimport Dispatcherimport Enhancerimport Factoryimport MethodProxyimport NoOpimport KotlinDetectorimport SmartClassLoader/** CGLIB-based {@link AopProxy} implementation for the Spring AOP framework. ... */emptyMap(...)CglibAopProxy.classnew WeakHashMap<Class<?>,Boolean>(...)int AOP_PROXY, ...;// Constants for CGLIB callback array indicesint INVOKE_TARGET, ...;int NO_OVERRIDE, ...;int DISPATCH_TARGET, ...;int DISPATCH_ADVISED, ...;int INVOKE_EQUALS, ...;int INVOKE_HASHCODE, ...;/** Logger available to subclasses; static to optimize serialization. */Map<Class<?>,Boolean> validatedClasses, ...;/** Keeps track of the Classes that we have validated for final methods. */AdvisedSupport advised, ...;/** The configuration used to configure this proxy. */...[] constructorArgs, ...;...[] constructorArgTypes, ...;AdvisedDispatcher advisedDispatcher, ...;/** Dispatcher used for methods on Advised. */Map<Method,Integer> fixedInterceptorMap, ...;int fixedInterceptorOffset, ...;/** Create a new CglibAopProxy for the given AOP configuration. ... */AdvisedSupport.EMPTY_TARGET_SOURCEthis.advisedthis.advisedDispatchernew AdvisedDispatcher(...)/** Set constructor arguments to use for creating the proxy. ... */constructorArgs.lengthconstructorArgTypes.lengththis.constructorArgsthis.constructorArgTypesisTraceEnabled(...)trace(...)Class<?> rootClassClass<?> proxySuperClassEnhancer enhancercreateEnhancer(...)Callback[] callbacksgetCallbacks(...)Class<?>[] typescallbacks.lengthClassUtils.CGLIB_CLASS_SEPARATORClass<?>[] additionalInterfacesClass<?> additionalInterfacevalidateClassIfNecessary(...)setClassLoader(...)isClassReloadable(...)setUseCache(...)setSuperclass(...)setNamingPolicy(...)SpringNamingPolicy.INSTANCEsetStrategy(...)new ClassLoaderAwareGeneratorStrategy(...)int xsetCallbackFilter(...)new ProxyCallbackFilter(...)getConfigurationOnlyCopy(...)this.fixedInterceptorMapthis.fixedInterceptorOffsetsetCallbackTypes(...)createProxyClassAndInstance(...)setInterceptDuringConstruction(...)setCallbacks(...)create(...)/** Creates the CGLIB {@link Enhancer}. Subclasses may wish to override this to return a custom ... */new Enhancer(...)/** Checks to see whether the supplied {@code Class} has already been validated and ... */doValidateClass(...)/** Checks for final methods on the given {@code Class}, as well as package-visible ... */Method[] methodsgetDeclaredMethods(...)int modisPrivate(...)isFinal(...)implementsInterface(...)isPublic(...)isProtected(...)isExposeProxy(...)boolean isFrozenboolean isStaticCallback aopInterceptornew DynamicAdvisedInterceptor(...)Callback targetInterceptorCallback targetDispatchernew StaticDispatcher(...)new SerializableNoOp(...)Callback[] mainCallbacksnew Callback[]new EqualsInterceptor(...)new HashCodeInterceptor(...)new StaticUnadvisedExposedInterceptor(...)new DynamicUnadvisedExposedInterceptor(...)new StaticUnadvisedInterceptor(...)new DynamicUnadvisedInterceptor(...)getMethods(...)Callback[] fixedCallbacksmethods.lengthnewHashMap(...)List<Object> chainnew FixedChainStaticTargetInterceptor(...)mainCallbacks.lengthfixedCallbacks.lengthequalsInProxy(...)(...).advised/** Check whether the given method is declared on any of the given interfaces. */hasMethod(...)/** Process a return value. Wraps a return of {@code this} if necessary to be the ... */Class<?> returnTypeRawTargetAccess.class/** Serializable replacement for CGLIB's NoOp interface. ... *//** Method interceptor used for static targets with no advice chain. The call ... */Object retValprocessReturnType(...)/** Method interceptor used for static targets with no advice chain, when the ... */Object oldProxysetCurrentProxy(...)/** Interceptor used to invoke a dynamic target without creating a method ... */Object targetreleaseTarget(...)/** Interceptor for unadvised dynamic targets when the proxy needs exposing. *//** Dispatcher for a static target. Dispatcher is much faster than ... *//** Dispatcher for any methods declared on the Advised class. *//** Dispatcher for the {@code equals} method. ... */Object otherCallback callbackgetCallback(...)AdvisedSupport otherAdvised/** Dispatcher for the {@code hashCode} method. ... *//** Interceptor used specifically for advised methods on a frozen, static proxy. */List<Object> adviceChain, ...;Class<?> targetClass, ...;this.adviceChainthis.targetClassMethodInvocation invocationnew CglibMethodInvocation(...)/** General purpose AOP callback. Used when the target is dynamic or when the ... */boolean setProxyContextthis.advised.exposeProxyObject[] argsToUseadaptArgumentsIfNecessary(...)/** CGLIB uses this to drive proxy creation. *//** Implementation of AOP Alliance MethodInvocation used by this AOP proxy. */MethodProxy methodProxy, ...;this.methodProxyisEqualsMethod(...)isHashCodeMethod(...)isToStringMethod(...)declaresException(...)isKotlinType(...)new UndeclaredThrowableException(...)/** Gives a marginal performance improvement versus using reflection to ... */this.argumentsinvokeJoinpoint(...)/** CallbackFilter to assign Callbacks to methods. *//** Implementation of CallbackFilter.accept() to return the index of the ... */List<?> chainboolean haveAdviceisFinalizeMethod(...)ProxyCallbackFilter otherCallbackFilterotherCallbackFilter.advisedAdvisor[] thisAdvisorsAdvisor[] thatAdvisorsthisAdvisors.lengthAdvisor thisAdvisorAdvisor thatAdvisorequalsAdviceClasses(...)equalsPointcuts(...)Advisor[] advisorsisOptimize(...)// Validate the class, writing log messages as necessary.// Configure CGLIB Enhancer...// fixedInterceptorMap only populated at this point, after getCallbacks call above// Generate the proxy class and create a proxy instance.// TargetSource.getTarget() failed// Parameters used for optimization choices...// Choose an "aop" interceptor (used for AOP calls).// Choose a "straight to target" interceptor. (used for calls that are// unadvised but can return this). May be required to expose the proxy.// Choose a "direct to target" dispatcher (used for// unadvised calls to static targets that cannot return this).// for normal advice// invoke target without considering advice, if optimized// no override for methods mapped to this// If the target is a static one and the advice chain is frozen,// then we can make some optimizations by sending the AOP calls// direct to the target using the fixed chain for that method.// TODO: small memory optimization here (can skip creation for methods with no advice)// Now copy both the callbacks from mainCallbacks// and fixedCallbacks into the callbacks array.// Massage return value if necessary// Special case: it returned "this". Note that we can't help// if the target sets a reference to itself in another returned object.// If we get here, we need to create a MethodInvocation.// Make invocation available if necessary.// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...// Check whether we only have one InvokerInterceptor: that is,// no real advice, but just reflective invocation of the target.// We can skip creating a MethodInvocation: just invoke the target directly.// Note that the final invoker must be an InvokerInterceptor, so we know// it does nothing but a reflective operation on the target, and no hot// swapping or fancy proxying.// We need to create a method invocation...// Restore old proxy.// Only use method proxy for public methods not derived from java.lang.Object// Propagate original exception if declared on the target method// (with callers expecting it). Always propagate it for Kotlin code// since checked exceptions do not have to be explicitly declared there.// Checked exception thrown in the interceptor but not declared on the// target method signature -> apply an UndeclaredThrowableException,// aligned with standard JDK dynamic proxy behavior.// We must always proxy equals, to direct calls to this.// We must always calculate hashCode based on the proxy.// Proxy is not yet available, but that shouldn't matter.// If exposing the proxy, then AOP_PROXY must be used.// Check to see if we have fixed interceptor to serve this method.// Else use the AOP_PROXY.// We know that we are optimizing so we can use the FixedStaticChainInterceptors.// See if the return type of the method is outside the class hierarchy of the target type.// If so we know it never needs to have return type massage and can use a dispatcher.// If the proxy is being exposed, then must use the interceptor the correct one is already// configured. If the target is not static, then we cannot use a dispatcher because the// target needs to be explicitly released after the invocation.// Advice instance identity is unimportant to the proxy class:// All that matters is type and ordering.// If only one of the advisor (but not both) is PointcutAdvisor, then it is a mismatch.// Takes care of the situations where an IntroductionAdvisor is used (see SPR-3959).import Interceptor/** A simple but definitive way of working out an advice chain for a Method, ... */AdvisorAdapterRegistry registryList<Object> interceptorListnew ArrayList<Object>(...)advisors.lengthClass<?> actualClassBoolean hasIntroductionsPointcutAdvisor pointcutAdvisorisPreFiltered(...)MethodMatcher mmboolean matchhasMatchingIntroductions(...)MethodInterceptor[] interceptorsgetInterceptors(...)isRuntime(...)MethodInterceptor interceptornew InterceptorAndDynamicMethodMatcher(...)Interceptor[] interceptors/** Determine whether the Advisors contain matching introductions. */// This is somewhat tricky... We have to process introductions first,// but we need to preserve order in the ultimate list.// Add it conditionally.// Creating a new object instance in the getInterceptors() method// isn't a problem as we normally cache created chains./** Default {@link AopProxyFactory} implementation, creating either a CGLIB proxy ... */boolean IN_NATIVE_IMAGE, ...;/** Whether this environment lives within a native image. ... */hasNoUserSuppliedProxyInterfaces(...)new JdkDynamicAopProxy(...)new ObjenesisCglibAopProxy(...)/** Determine whether the supplied {@link AdvisedSupport} has only the ... */ifcs.length/** Internal framework class, combining a MethodInterceptor instance ... */MethodInterceptor interceptor, ...;MethodMatcher methodMatcher, ...;this.interceptorthis.methodMatcherimport InvocationHandler/** JDK-based {@link AopProxy} implementation for the Spring AOP framework, ... */JdkDynamicAopProxy.class/** use serialVersionUID from Spring 1.2 for interoperability. *//** We use a static Log to avoid serialization issues. *//* NOTE: We could avoid the code duplication between this class and the CGLIB ... *//** Config used to configure this proxy. */...[] proxiedInterfaces, ...;boolean equalsDefined, ...;/** Is the {@link #equals} method defined on the proxied interfaces? */boolean hashCodeDefined, ...;/** Is the {@link #hashCode} method defined on the proxied interfaces? *//** Construct a new JdkDynamicAopProxy for the given AOP configuration. ... */this.proxiedInterfacesfindDefinedEqualsAndHashCodeMethods(...)newProxyInstance(...)/** Finds any {@link #equals} or {@link #hashCode} method that may be defined ... */Class<?> proxiedInterfacethis.equalsDefinedthis.hashCodeDefined/** Implementation of {@code InvocationHandler.invoke}. ... */this.advised.targetSourceultimateTargetClass(...)this.advised.opaqueinvokeJoinpointUsingReflection(...)new ReflectiveMethodInvocation(...)/** Equality means interfaces, advisors and TargetSource are equal. ... */JdkDynamicAopProxy otherProxyInvocationHandler ihgetInvocationHandler(...)otherProxy.advised/** Proxy uses the hash code of the TargetSource. */// The target does not implement the equals(Object) method itself.// The target does not implement the hashCode() method itself.// There is only getDecoratedClass() declared -> dispatch to proxy config.// Service invocations on ProxyConfig with the proxy config...// Get as late as possible to minimize the time we "own" the target,// in case it comes from a pool.// Get the interception chain for this method.// Check whether we have any advice. If we don't, we can fallback on direct// reflective invocation of the target, and avoid creating a MethodInvocation.// We can skip creating a MethodInvocation: just invoke the target directly// Note that the final invoker must be an InvokerInterceptor so we know it does// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.// Proceed to the joinpoint through the interceptor chain.// Massage return value if necessary.// Special case: it returned "this" and the return type of the method// is type-compatible. Note that we can't help if the target sets// a reference to itself in another returned object.// Must have come from TargetSource.// Not a valid comparison...// If we get here, otherProxy is the other AopProxy.import SpringObjenesis/** Objenesis-based extension of {@link CglibAopProxy} to create proxy instances ... */ObjenesisCglibAopProxy.classnew SpringObjenesis(...)SpringObjenesis objenesis, ...;/** Create a new ObjenesisCglibAopProxy for the given AOP configuration. ... */Class<?> proxyClasscreateClass(...)Object proxyInstanceisWorthTrying(...)getUseCache(...)Constructor<?> ctorgetDeclaredConstructor(...)// Regular instantiation via default constructor.../** Convenience superclass for configuration used in creating proxies, ... */boolean proxyTargetClass, ...;boolean optimize, ...;boolean opaque, ...;boolean exposeProxy, ...;boolean frozen, ...;/** Set whether to proxy the target class directly, instead of just proxying ... */this.proxyTargetClass/** Return whether to proxy the target class directly as well as any interfaces. *//** Set whether proxies should perform aggressive optimizations. ... */this.optimize/** Return whether proxies should perform aggressive optimizations. *//** Set whether proxies created by this configuration should be prevented ... */this.opaque/** Return whether proxies created by this configuration should be ... */this.exposeProxy/** Return whether the AOP proxy will expose the AOP proxy for ... *//** Set whether this config should be frozen. ... */this.frozen/** Return whether the config is frozen, and no advice changes can be made. *//** Copy configuration from the other config object. ... */other.proxyTargetClassother.optimizeother.exposeProxyother.frozenother.opaque/** Base class for proxy factories. ... */new ArrayList<AdvisedSupportListener>(...)AopProxyFactory aopProxyFactory, ...;List<AdvisedSupportListener> listeners, ...;boolean active, ...;/** Set to true when the first AOP proxy has been created. *//** Create a new ProxyCreatorSupport instance. */this.aopProxyFactorynew DefaultAopProxyFactory(...)/** Create a new ProxyCreatorSupport instance. ... *//** Customize the AopProxyFactory, allowing different strategies ... *//** Return the AopProxyFactory that this ProxyConfig uses. *//** Add the given AdvisedSupportListener to this proxy configuration. ... */this.listeners/** Remove the given AdvisedSupportListener from this proxy configuration. ... *//** Subclasses should call this to get a new AOP proxy. They should <b>not</b> ... */this.activeactivate(...)getAopProxyFactory(...)/** Activate this proxy configuration. ... */AdvisedSupportListener listeneractivated(...)/** Propagate advice change event to all AdvisedSupportListeners. ... *//** Subclasses can call this to check whether any AOP proxies have been created yet. *//** Factory for AOP proxies for programmatic use, rather than via declarative ... *//** Create a new ProxyFactory. *//** Create a new ProxyFactory. ... *//** Create a new ProxyFactory for the given interface and interceptor. ... *//** Create a ProxyFactory for the specified {@code TargetSource}, ... *//** Create a new proxy for the given interface and interceptor. ... *//** Create a proxy for the specified {@code TargetSource}, ... *//** Create a proxy for the specified {@code TargetSource} that extends ... */import UnknownAdviceTypeException/** {@link org.springframework.beans.factory.FactoryBean} implementation that builds an ... */String GLOBAL_SUFFIX, ...;/** This suffix in a value in an interceptor list indicates to expand globals. */...[] interceptorNames, ...;String targetName, ...;boolean autodetectInterfaces, ...;boolean singleton, ...;boolean freezeProxy, ...;boolean classLoaderConfigured, ...;boolean advisorChainInitialized, ...;/** Whether the advisor chain has already been initialized. */Object singletonInstance, ...;/** If this is a singleton, the cached singleton proxy instance. *//** Set the names of the interfaces we're proxying. If no interface ... *//** Set the list of Advice/Advisor bean names. This must always be set ... */this.interceptorNames/** Set the name of the target bean. This is an alternative to specifying ... */this.targetName/** Set whether to autodetect proxy interfaces if none specified. ... */this.autodetectInterfaces/** Set the value of the singleton property. Governs whether this factory ... */this.singletonthis.freezeProxythis.classLoaderConfiguredcheckInterceptorNames(...)/** Return a proxy. Invoked when clients obtain beans from this factory bean. ... */initializeAdvisorChain(...)getSingletonInstance(...)newPrototypeInstance(...)/** Return the type of the proxy. Will check the singleton instance if ... */this.singletonInstance/** Create a composite interface Class for the given interfaces, ... *//** Return the singleton instance of this class's proxy object, ... */freshTargetSource(...)getProxiedInterfaces(...).lengthsetFrozen(...)/** Create a new prototype instance of this class's created proxy object, ... */ProxyCreatorSupport copynew ProxyCreatorSupport(...)freshAdvisorChain(...)/** Return the proxy object to expose. ... *//** Check the interceptorNames list whether it contains a target name as final element. ... */String finalNamethis.interceptorNames.lengthisNamedBeanAnAdvisorOrAdvice(...)/** Look at bean factory metadata to work out whether this bean name, ... */Class<?> namedBeanClassAdvisor.classAdvice.class/** Create the advisor (interceptor) chain. Advisors that are sourced ... */this.advisorChainInitializedaddGlobalAdvisors(...)Object advicenew PrototypePlaceholderAdvisor(...)addAdvisorOnChainCreation(...)/** Return an independent advisor chain. ... */List<Advisor> freshAdvisorsPrototypePlaceholderAdvisor paAdvisor refreshedAdvisornamedBeanToAdvisor(...)/** Add all global interceptors and pointcuts. */String[] globalAdvisorNamesString[] globalInterceptorNamesInterceptor.classglobalAdvisorNames.lengthglobalInterceptorNames.lengthList<Object> beans/** Invoked when advice chain is created. ... *//** Return a TargetSource to use when creating a proxy. If the target was not ... *//** Convert the following object sourced from calling getBean() on a name in the ... */UnknownAdviceTypeException ex/** Blow away and recache singleton on an advice change. *//** Used in the interceptor chain where we need to replace a bean with a prototype ... */String beanName, ...;String message, ...;this.beanNamethis.message// Initialize the shared singleton instance.// In the case of a prototype, we need to give the proxy// an independent instance of the configuration.// In this case, no proxy will have an instance of this object's configuration,// but will have an independent copy.// The copy needs a fresh advisor chain, and a fresh TargetSource.// The last name in the chain may be an Advisor/Advice or a target/TargetSource.// Unfortunately we don't know; we must look at type of the bean.// The target isn't an interceptor.// Treat it as an target bean if we can't tell.// Globals can't be last unless we specified a targetSource using the property...// Materialize interceptor chain from bean names.// If we get here, we need to add a named interceptor.// We must check if it's a singleton or prototype.// Add the real Advisor/Advice to the chain.// It's a prototype Advice or Advisor: replace with a prototype.// Avoid unnecessary creation of prototype bean just for advisor chain initialization.// Replace the placeholder with a fresh prototype instance resulting from a getBean lookup// Add the shared instance.// We need to convert to an Advisor if necessary so that our source reference// matches what we find from superclass interceptors.// Not refreshing target: bean name not specified in 'interceptorNames'// We expected this to be an Advisor or Advice,// but it wasn't. This is a configuration error.import Closeableimport Awareimport DisposableBean/** Base class with common functionality for proxy processors, in particular ... */int order, ...;/** This should run after all other processors, so that it can just add ... *//** Set the ordering which will apply to this processor's implementation ... *//** Return the configured proxy ClassLoader for this processor. *//** Check the interfaces on the given bean class and apply them to the {@link ProxyFactory}, ... */Class<?>[] targetInterfacesboolean hasReasonableProxyInterfaceisConfigurationCallbackInterface(...)isInternalLanguageInterface(...)getMethods(...).length/** Determine whether the given interface is just a container callback and ... */containsElement(...)InitializingBean.classDisposableBean.classCloseable.classAutoCloseable.classAware.class/** Determine whether the given interface is a well-known internal language interface ... */// Must allow for introductions; can't just set interfaces to the target's interfaces only.import BridgeMethodResolver/** Spring's implementation of the AOP Alliance ... */...[] arguments, ...;Map<String,Object> userAttributes, ...;/** Lazily initialized map of user-specific attributes for this invocation. */List<?> interceptorsAndDynamicMethodMatchers, ...;/** List of MethodInterceptor and InterceptorAndDynamicMethodMatcher ... */int currentInterceptorIndex, ...;/** Index from 0 of the current interceptor we're invoking. ... *//** Construct a new ReflectiveMethodInvocation with the given arguments. ... */findBridgedMethod(...)this.interceptorsAndDynamicMethodMatchers/** Return the method invoked on the proxied interface. ... */Object interceptorOrInterceptionAdvice++...this.currentInterceptorIndexInterceptorAndDynamicMethodMatcher dmdm.methodMatcherdm.interceptor/** Invoke the joinpoint using reflection. ... *//** This implementation returns a shallow copy of this invocation object, ... */Object[] cloneArgumentsthis.arguments.lengththis.userAttributesnew HashMap<String,Object>(...)ReflectiveMethodInvocation cloneclone.argumentsCloneNotSupportedException ex/** Return user attributes associated with this invocation. ... */// We start with an index of -1 and increment early.// Evaluate dynamic method matcher here: static part will already have// been evaluated and found to match.// Dynamic matching failed.// Skip this interceptor and invoke the next in the chain.// It's an interceptor, so we just invoke it: The pointcut will have// been evaluated statically before this object was constructed.// Build an independent copy of the arguments array.// Force initialization of the user attributes Map,// for having a shared Map reference in the clone.// Create the MethodInvocation clone.// Don't do toString on target, it may be proxied./** Interface allowing extension to the Spring AOP framework to allow ... *//** Does this adapter understand this advice object? Is it valid to ... *//** Return an AOP Alliance MethodInterceptor exposing the behavior of ... *//** BeanPostProcessor that registers {@link AdvisorAdapter} beans in the BeanFactory with ... *//** Specify the AdvisorAdapterRegistry to register AdvisorAdapter beans with. ... */registerAdvisorAdapter(...)/** Interface for registries of Advisor adapters. ... *//** Return an {@link Advisor} wrapping the given advice. ... *//** Return an array of AOP Alliance MethodInterceptors to allow use of the ... *//** Register the given {@link AdvisorAdapter}. Note that it is not necessary to register ... *//** Adapter to enable {@link org.springframework.aop.AfterReturningAdvice} ... */AfterReturningAdvice advicenew AfterReturningAdviceInterceptor(...)/** Interceptor to wrap an {@link org.springframework.aop.AfterReturningAdvice}. ... */AfterReturningAdvice advice, ...;/** Create a new AfterReturningAdviceInterceptor for the given advice. ... */afterReturning(...)/** Default implementation of the {@link AdvisorAdapterRegistry} interface. ... */new ArrayList<AdvisorAdapter>(...)List<AdvisorAdapter> adapters, ...;/** Create a new DefaultAdvisorAdapterRegistry, registering well-known adapters. */new MethodBeforeAdviceAdapter(...)new AfterReturningAdviceAdapter(...)new ThrowsAdviceAdapter(...)new UnknownAdviceTypeException(...)AdvisorAdapter adapterthis.adapterssupportsAdvice(...)List<MethodInterceptor> interceptorsnew ArrayList<MethodInterceptor>(...)getInterceptor(...)new MethodInterceptor[]// So well-known it doesn't even need an adapter.// Check that it is supported./** Singleton to publish a shared DefaultAdvisorAdapterRegistry instance. ... */new DefaultAdvisorAdapterRegistry(...)AdvisorAdapterRegistry instance, ...;/** Keep track of a single instance so we can return it to classes that request it. *//** Return the singleton {@link DefaultAdvisorAdapterRegistry} instance. *//** Reset the singleton {@link DefaultAdvisorAdapterRegistry}, removing any ... *//** Adapter to enable {@link org.springframework.aop.MethodBeforeAdvice} ... */MethodBeforeAdvice advicenew MethodBeforeAdviceInterceptor(...)/** Interceptor to wrap a {@link MethodBeforeAdvice}. ... */MethodBeforeAdvice advice, ...;/** Create a new MethodBeforeAdviceInterceptor for the given advice. ... */import ThrowsAdvicenew ThrowsAdviceInterceptor(...)/** Interceptor to wrap an after-throwing advice. ... */new HashMap<Class<?>,Method>(...)ThrowsAdviceInterceptor.classString AFTER_THROWING, ...;Object throwsAdvice, ...;Map<Class<?>,Method> exceptionHandlerMap, ...;/** Methods on throws advice, keyed by exception class. *//** Create a new ThrowsAdviceInterceptor for the given ThrowsAdvice. ... */this.throwsAdviceClass<?> throwableParamthis.exceptionHandlerMap/** Return the number of handler methods in this advice. */Method handlerMethodgetExceptionHandler(...)invokeHandlerMethod(...)/** Determine the exception handle method for the given exception. ... */Class<?> exceptionClassMethod handlerObject[] handlerArgsInvocationTargetException targetEx// An exception handler to register.../** Exception thrown when an attempt is made to use an unsupported ... *//** Create a new UnknownAdviceTypeException for the given advice object. ... *//** Create a new UnknownAdviceTypeException with the given message. ... *//** SPI package allowing Spring AOP framework to handle arbitrary advice types. ... *//** Generic auto proxy creator that builds AOP proxies for specific beans ... */BeanFactoryAdvisorRetrievalHelper advisorRetrievalHelper, ...;this.advisorRetrievalHelpernew BeanFactoryAdvisorRetrievalHelperAdapter(...)findEligibleAdvisors(...)/** Find all eligible Advisors for auto-proxying this class. ... */List<Advisor> eligibleAdvisorsextendAdvisors(...)/** Find all candidate Advisors to use in auto-proxying. ... */findAdvisorBeans(...)/** Search the given candidate Advisors to find all Advisors that ... */setCurrentProxiedBeanName(...)/** Return whether the Advisor bean with the given name is eligible ... *//** Sort advisors based on ordering. Subclasses may choose to override this ... *//** Extension hook that subclasses can override to register additional Advisors, ... *//** This auto-proxy creator always returns pre-filtered Advisors. *//** Subclass of BeanFactoryAdvisorRetrievalHelper that delegates to ... */isEligibleAdvisorBean(...)AbstractAdvisorAutoProxyCreator.thisimport AopInfrastructureBeanimport ProxyFactoryimport ProxyProcessorSupportimport PropertyValuesimport SmartInstantiationAwareBeanPostProcessor/** {@link org.springframework.beans.factory.config.BeanPostProcessor} implementation ... */newSetFromMap(...)new ConcurrentHashMap<K,V>(...)new ConcurrentHashMap<Object,Object>(...)new ConcurrentHashMap<Object,Class<?>>(...)new ConcurrentHashMap<Object,Boolean>(...)...[] DO_NOT_PROXY, ...;/** Convenience constant for subclasses: Return value for "do not proxy". ... */...[] PROXY_WITHOUT_ADDITIONAL_INTERCEPTORS, ...;/** Convenience constant for subclasses: Return value for ... *//** Indicates whether or not the proxy should be frozen. Overridden from super ... *//** Default is no common interceptors. */boolean applyCommonInterceptorsFirst, ...;...[] customTargetSourceCreators, ...;Set<String> targetSourcedBeans, ...;Map<Object,Object> earlyProxyReferences, ...;Map<Object,Class<?>> proxyTypes, ...;Map<Object,Boolean> advisedBeans, ...;/** Set whether or not the proxy should be frozen, preventing advice ... *//** Specify the {@link AdvisorAdapterRegistry} to use. ... *//** Set custom {@code TargetSourceCreators} to be applied in this order. ... */this.customTargetSourceCreators/** Set the common interceptors. These must be bean names in the current factory. ... *//** Set whether the common interceptors should be applied before bean-specific ones. ... */this.applyCommonInterceptorsFirst/** Return the owning {@link BeanFactory}. ... */Object cacheKeygetCacheKey(...)this.proxyTypesthis.earlyProxyReferenceswrapIfNecessary(...)getCustomTargetSource(...)this.targetSourcedBeansthis.advisedBeansBoolean.FALSEObject[] specificInterceptorsgetAdvicesAndAdvisorsForBean(...)createProxy(...)/** Create a proxy with the configured interceptors if the bean is ... *//** Build a cache key for the given bean class and bean name. ... *//** Wrap the given bean if necessary, i.e. if it is eligible for being proxied. ... *//** Return whether the given bean class represents an infrastructure class ... */boolean retValAopInfrastructureBean.class/** Subclasses should override this method to return {@code true} if the ... */isOriginalInstance(...)/** Create a target source for bean instances. Uses any TargetSourceCreators if set. ... */TargetSourceCreator tscTargetSource ts/** Create an AOP proxy for the given bean. ... */buildAdvisors(...)exposeTargetClass(...)shouldProxyTargetClass(...)advisorsPreFiltered(...)setPreFiltered(...)/** Determine whether the given bean should be proxied with its target class rather than its interfaces. ... *//** Return whether the Advisors returned by the subclass are pre-filtered ... *//** Determine the advisors for the given bean, including the specific interceptors ... */Advisor[] commonInterceptorsresolveInterceptorNames(...)List<Object> allInterceptorscommonInterceptors.lengthint nrOfCommonInterceptorsint nrOfSpecificInterceptorsspecificInterceptors.length/** Resolves the specified interceptor names to Advisor objects. ... */ConfigurableBeanFactory cbfisCurrentlyInCreation(...)Object next/** Return whether the given bean is to be proxied, what additional ... */// Create proxy here if we have a custom TargetSource.// Suppresses unnecessary default instantiation of the target bean:// The TargetSource will handle target instances in a custom fashion.// skip postProcessPropertyValues// Create proxy if we have advice.// We can't create fancy target sources for directly registered singletons.// Found a matching TargetSource.// No custom TargetSource found.// Handle prototypes correctly...import AbstractAdvisingBeanPostProcessor/** Extension of {@link AbstractAutoProxyCreator} which implements {@link BeanFactoryAware}, ... */ConfigurableListableBeanFactory beanFactory, ...;import AutowireCapableBeanFactoryimport Conventions/** Utilities for auto-proxy aware components. ... */getQualifiedAttributeName(...)AutoProxyUtils.classString PRESERVE_TARGET_CLASS_ATTRIBUTE, ...;/** Bean definition attribute that may indicate whether a given bean is supposed ... */String ORIGINAL_TARGET_CLASS_ATTRIBUTE, ...;/** Bean definition attribute that indicates the original target class of an ... *//** Determine whether the given bean should be proxied with its target ... */BeanDefinition bd/** Determine the original target class for the specified bean, if possible, ... */getMergedBeanDefinition(...)/** Expose the given target class for the specified bean, if possible. ... */setAttribute(...)/** Determine whether the given bean name indicates an "original instance" ... */AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIXimport BeanCurrentlyInCreationException/** Helper for retrieving standard Spring Advisors from a BeanFactory, ... */BeanFactoryAdvisorRetrievalHelper.class...[] cachedAdvisorBeanNames, ...;/** Create a new BeanFactoryAdvisorRetrievalHelper for the given BeanFactory. ... *//** Find all eligible Advisor beans in the current bean factory, ... */String[] advisorNamesthis.cachedAdvisorBeanNamesadvisorNames.lengthBeanCreationException exThrowable rootCausegetMostSpecificCause(...)BeanCreationException bceString bceBeanName/** Determine whether the aspect bean with the given name is eligible. ... */// Determine list of advisor bean names, if not cached already.// Do not initialize FactoryBeans here: We need to leave all regular beans// uninitialized to let the auto-proxy creator apply to them!// Ignore: indicates a reference back to the bean we're trying to advise.// We want to find advisors other than the currently created bean itself.import PatternMatchUtils/** Auto proxy creator that identifies beans to proxy via a list of names. ... */...[] NO_ALIASES, ...;List<String> beanNames, ...;/** Set the names of the beans that should automatically get wrapped with proxies. ... */this.beanNamesbeanNames.lengthString mappedName/** Delegate to {@link AbstractAutoProxyCreator#getCustomTargetSource(Class, String)} ... */isSupportedBeanName(...)/** Identify as a bean to proxy if the bean name matches one of the names in ... *//** Determine if the bean name for the given bean class matches one of the names ... */boolean isFactoryBeanBeanFactory beanFactoryString[] aliasesgetAliases(...)isMatch(...)String alias/** Determine if the given bean name matches the mapped name. ... */simpleMatch(...)import BeanNameAware/** {@code BeanPostProcessor} implementation that creates AOP proxies based on all ... */String SEPARATOR, ...;/** Separator between prefix and remainder of bean name. */boolean usePrefix, ...;String advisorBeanNamePrefix, ...;/** Set whether to only include advisors with a certain prefix in the bean name. ... */this.usePrefix/** Return whether to only include advisors with a certain prefix in the bean name. *//** Set the prefix for bean names that will cause them to be included for ... */this.advisorBeanNamePrefix/** Return the prefix for bean names that will cause them to be included ... *//** Consider {@code Advisor} beans with the specified prefix as eligible, if activated. ... */String prefix// If no infrastructure bean name prefix has been set, override it./** Auto-proxy creator that considers infrastructure Advisor beans only, ... */getRole(...)/** Holder for the current proxy creation context, as exposed by auto-proxy creators ... */new NamedThreadLocal<String>(...)ThreadLocal<String> currentProxiedBeanName, ...;/** ThreadLocal holding the current proxied bean name during Advisor matching. *//** Return the name of the currently proxied bean instance. ... *//** Set the name of the currently proxied bean instance. ... *//** Implementations can create special target sources, such as pooling target ... *//** Create a special TargetSource for the given bean, if any. ... *//** Bean post-processors for use in ApplicationContexts to simplify AOP usage ... */import TargetSourceCreatorimport AbstractBeanFactoryBasedTargetSourceimport GenericBeanDefinition/** Convenient superclass for ... */new HashMap<String,DefaultListableBeanFactory>(...)ConfigurableBeanFactory beanFactory, ...;Map<String,DefaultListableBeanFactory> internalBeanFactories, ...;/** Internally used DefaultListableBeanFactory instances, keyed by bean name. *//** Return the BeanFactory that this TargetSourceCreators runs in. */// Implementation of the TargetSourceCreator interfaceAbstractBeanFactoryBasedTargetSource targetSourcecreateBeanFactoryBasedTargetSource(...)DefaultListableBeanFactory internalBeanFactorygetInternalBeanFactoryForBean(...)GenericBeanDefinition bdCopynew GenericBeanDefinition(...)isPrototypeBased(...)setTargetBeanName(...)/** Return the internal BeanFactory to be used for the specified bean. ... */this.internalBeanFactoriesbuildInternalBeanFactory(...)/** Build an internal BeanFactory for resolving target beans. ... */removeIf(...)getBeanPostProcessors(...)new Predicate<BeanPostProcessor>(...) { ... }/** Destroys the internal BeanFactory on shutdown of the TargetSourceCreator. ... */values(...)/** Return whether this TargetSourceCreator is prototype-based. ... */// Template methods to be implemented by subclasses/** Subclasses must implement this method to return a new AbstractPrototypeBasedTargetSource ... */// We need to override just this bean definition, as it may reference other beans// and we're happy to take the parent's definition for those.// Always use prototype scope if demanded.// Complete configuring the PrototypeTargetSource.// Set parent so that references (up container hierarchies) are correctly resolved.// Required so that all BeanPostProcessors, Scopes, etc become available.// Filter out BeanPostProcessors that are part of the AOP infrastructure,// since those are only meant to apply to beans defined in the original factory.import LazyInitTargetSource/** {@code TargetSourceCreator} that enforces a {@link LazyInitTargetSource} for ... */new LazyInitTargetSource(...)import CommonsPool2TargetSourceimport PrototypeTargetSourceimport ThreadLocalTargetSource/** Convenient TargetSourceCreator using bean name prefixes to create one of three ... */String PREFIX_COMMONS_POOL, ...;/** The CommonsPool2TargetSource prefix. */String PREFIX_THREAD_LOCAL, ...;/** The ThreadLocalTargetSource prefix. */String PREFIX_PROTOTYPE, ...;/** The PrototypeTargetSource prefix. */CommonsPool2TargetSource cptsnew CommonsPool2TargetSource(...)setMaxSize(...)new ThreadLocalTargetSource(...)new PrototypeTargetSource(...)// No match. Don't create a custom target source./** Package containing Spring's basic AOP infrastructure, compliant with the ... *//** Base class for monitoring interceptors, such as performance monitors. ... */String prefix, ...;String suffix, ...;boolean logTargetClassInvocation, ...;/** Set the text that will get appended to the trace data. ... */this.prefix/** Return the text that will get appended to the trace data. *//** Set the text that will get prepended to the trace data. ... */this.suffix/** Return the text that will get prepended to the trace data. *//** Set whether to log the invocation on the target class, if applicable ... */this.logTargetClassInvocation/** Create a {@code String} name for the given {@code MethodInvocation} ... */String classNamegetSuffix(...)getPrefix(...)/** Base {@code MethodInterceptor} implementation for tracing. ... */Log defaultLogger, ...;/** The default {@code Log} instance used to write trace messages. ... */boolean hideProxyClassNames, ...;/** Indicates whether or not proxy class names should be hidden when using dynamic loggers. ... */boolean logExceptionStackTrace, ...;/** Indicates whether to pass an exception to the logger. ... *//** Set whether to use a dynamic logger or a static logger. ... */this.defaultLogger/** Set the name of the logger to use. The name will be passed to the ... *//** Set to "true" to have {@link #setUseDynamicLogger dynamic loggers} hide ... */this.hideProxyClassNames/** Set whether to pass an exception to the logger, suggesting inclusion ... */this.logExceptionStackTrace/** Determines whether or not logging is enabled for the particular {@code MethodInvocation}. ... */Log loggergetLoggerForInvocation(...)isInterceptorEnabled(...)invokeUnderTrace(...)/** Return the appropriate {@code Log} instance to use for the given ... */getClassForLogging(...)/** Determine the class to use for logging purposes. ... *//** Determine whether the interceptor should kick in, that is, ... */isLogEnabled(...)/** Determine whether the given {@link Log} instance is enabled. ... *//** Write the supplied trace message to the supplied {@code Log} instance. ... */writeToLog(...)/** Write the supplied trace message and {@link Throwable} to the ... *//** Subclasses must override this method to perform any tracing around the ... */// Release default logger if it is not being used.import Callableimport CompletableFutureimport CompletionExceptionimport Executorimport Futureimport Supplierimport NoSuchBeanDefinitionExceptionimport NoUniqueBeanDefinitionExceptionimport AsyncListenableTaskExecutorimport AsyncTaskExecutorimport TaskExecutorimport TaskExecutorAdapterimport ListenableFutureimport SingletonSupplier/** Base class for asynchronous method execution aspects, such as ... */new ConcurrentHashMap<Method,AsyncTaskExecutor>(...)String DEFAULT_TASK_EXECUTOR_BEAN_NAME, ...;/** The default name of the {@link TaskExecutor} bean to pick up: "taskExecutor". ... */Map<Method,AsyncTaskExecutor> executors, ...;SingletonSupplier<Executor> defaultExecutor, ...;SingletonSupplier<AsyncUncaughtExceptionHandler> exceptionHandler, ...;/** Create a new instance with a default {@link AsyncUncaughtExceptionHandler}. ... */this.defaultExecutornew SingletonSupplier<Executor>(...)new Supplier<Executor>(...) { ... }getDefaultExecutor(...)this.exceptionHandlerof(...)new Supplier<AsyncUncaughtExceptionHandler>(...) { ... }new SimpleAsyncUncaughtExceptionHandler(...)/** Create a new {@link AsyncExecutionAspectSupport} with the given exception handler. ... *//** Configure this aspect with the given executor and exception handler suppliers, ... */new SingletonSupplier<AsyncUncaughtExceptionHandler>(...)/** Supply the executor to be used when executing async methods. ... *//** Supply the {@link AsyncUncaughtExceptionHandler} to use to handle exceptions ... *//** Set the {@link BeanFactory} to be used when looking up executors by qualifier ... *//** Determine the specific executor to use when executing the given method. ... */AsyncTaskExecutor executorthis.executorsExecutor targetExecutorString qualifiergetExecutorQualifier(...)findQualifiedExecutor(...)new TaskExecutorAdapter(...)/** Return the qualifier or bean name of the executor to be used when executing the ... *//** Retrieve a target executor for the given qualifier. ... */qualifiedBeanOfType(...)Executor.class/** Retrieve or build a default executor for this advice instance. ... */TaskExecutor.classNoUniqueBeanDefinitionException exNoSuchBeanDefinitionException ex2getBeanNamesFound(...)NoSuchBeanDefinitionException ex/** Delegate for actually executing the given task with the chosen executor. ... */CompletableFuture<>.classsupplyAsync(...)new Supplier<Object>(...) { ... }call(...)new CompletionException(...)ListenableFuture<>.classsubmitListenable(...)Future<>.classsubmit(...)/** Handles a fatal error thrown while asynchronously invoking the specified ... */rethrowException(...)handleUncaughtException(...)obtain(...)Throwable ex2toGenericString(...)// Search for TaskExecutor bean... not plain Executor since that would// match with ScheduledExecutorService as well, which is unusable for// our purposes here. TaskExecutor is more clearly designed for it.// Giving up -> either using local default executor or none at all...// Could not transmit the exception to the caller with default executorimport ExecutionExceptionimport SimpleAsyncTaskExecutor/** AOP Alliance {@code MethodInterceptor} that processes method invocations ... *//** Create a new {@code AsyncExecutionInterceptor}. ... *//** Intercept the given method invocation, submit the actual calling of the method to ... */Method specificMethodMethod userDeclaredMethoddetermineAsyncExecutor(...)Callable<Object> tasknew Callable<Object>(...) { ... }ExecutionException exhandleError(...)getCause(...)doSubmit(...)/** This implementation is a no-op for compatibility in Spring 3.1.2. ... *//** This implementation searches for a unique {@link org.springframework.core.task.TaskExecutor} ... */Executor defaultExecutornew SimpleAsyncTaskExecutor(...)/** A strategy for handling uncaught exceptions thrown from asynchronous methods. ... *//** Handle the given uncaught exception thrown from an asynchronous method. ... */import ConcurrencyThrottleSupport/** Interceptor that throttles concurrent access, blocking invocations ... */setConcurrencyLimit(...)beforeAccess(...)afterAccess(...)import Matcherimport Constantsimport StopWatch/** {@code MethodInterceptor} implementation that allows for highly customizable ... */getValues(...)new Constants(...)CustomizableTraceInterceptor.classString PLACEHOLDER_METHOD_NAME, ...;/** The {@code $[methodName]} placeholder. ... */String PLACEHOLDER_TARGET_CLASS_NAME, ...;/** The {@code $[targetClassName]} placeholder. ... */String PLACEHOLDER_TARGET_CLASS_SHORT_NAME, ...;/** The {@code $[targetClassShortName]} placeholder. ... */String PLACEHOLDER_RETURN_VALUE, ...;/** The {@code $[returnValue]} placeholder. ... */String PLACEHOLDER_ARGUMENT_TYPES, ...;/** The {@code $[argumentTypes]} placeholder. ... */String PLACEHOLDER_ARGUMENTS, ...;/** The {@code $[arguments]} placeholder. ... */String PLACEHOLDER_EXCEPTION, ...;/** The {@code $[exception]} placeholder. ... */String PLACEHOLDER_INVOCATION_TIME, ...;/** The {@code $[invocationTime]} placeholder. ... */String DEFAULT_ENTER_MESSAGE, ...;/** The default message used for writing method entry messages. */String DEFAULT_EXIT_MESSAGE, ...;/** The default message used for writing method exit messages. */String DEFAULT_EXCEPTION_MESSAGE, ...;/** The default message used for writing exception messages. */Pattern PATTERN, ...;/** The {@code Pattern} used to match placeholders. */Set<Object> ALLOWED_PLACEHOLDERS, ...;/** The {@code Set} of allowed placeholders. */String enterMessage, ...;/** The message for method entry. */String exitMessage, ...;/** The message for method exit. */String exceptionMessage, ...;/** The message for exceptions during method execution. *//** Set the template used for method entry log messages. ... */checkForInvalidPlaceholders(...)doesNotContain(...)this.enterMessage/** Set the template used for method exit log messages. ... */this.exitMessage/** Set the template used for method exception log messages. ... */this.exceptionMessage/** Writes a log message before the invocation based on the value of {@code enterMessage}. ... */getQualifiedMethodName(...)StopWatch stopWatchnew StopWatch(...)Object returnValueboolean exitThroughExceptionstart(...)replacePlaceholders(...)isRunning(...)stop(...)getTotalTimeMillis(...)/** Replace the placeholders in the given message with the supplied values, ... */Matcher matcherStringBuffer outputnew StringBuffer(...)find(...)String matchgroup(...)appendReplacement(...)quoteReplacement(...)String shortNamearrayToCommaDelimitedString(...)appendArgumentTypes(...)appendReturnValue(...)appendTail(...)/** Adds the {@code String} representation of the method return value ... *//** Adds a comma-separated list of the short {@code Class} names of the ... */Class<?>[] argumentTypesString[] argumentTypeShortNamesargumentTypes.lengthargumentTypeShortNames.length/** Checks to see if the supplied {@code String} has any placeholders ... */// Should not happen since placeholders are checked earlier./** AOP Alliance {@code MethodInterceptor} that can be introduced in a chain ... */long count, ...;/** Create a new DebugInterceptor with a static logger. *//** Create a new DebugInterceptor with dynamic or static logger, ... */setUseDynamicLogger(...)/** Return the number of times this interceptor has been invoked. *//** Reset the invocation count to zero. */import NamedBean/** Convenient methods for creating advisors that may be used when autoproxying beans ... */ExposeBeanNameAdvisors.classString BEAN_NAME_ATTRIBUTE, ...;/** Binding for the bean name of the bean which is currently being invoked ... *//** Find the bean name for the current invocation. Assumes that an ExposeBeanNameAdvisor ... *//** Find the bean name for the given invocation. Assumes that an ExposeBeanNameAdvisor ... *//** Create a new advisor that will expose the given bean name, ... */new ExposeBeanNameInterceptor(...)/** Create a new advisor that will expose the given bean name, introducing ... */new ExposeBeanNameIntroduction(...)/** Interceptor that exposes the specified bean name as invocation attribute. *//** Introduction that exposes the specified bean name as invocation attribute. */import PriorityOrdered/** Interceptor that exposes the current {@link org.aopalliance.intercept.MethodInvocation} ... */new ExposeInvocationInterceptor(...)new DefaultPointcutAdvisor(...) { ... }ExposeInvocationInterceptor.classnew NamedThreadLocal<MethodInvocation>(...)ExposeInvocationInterceptor INSTANCE, ...;/** Singleton instance of this class. */Advisor ADVISOR, ...;/** Singleton advisor for this class. Use in preference to INSTANCE when using ... */ThreadLocal<MethodInvocation> invocation, ...;/** Return the AOP Alliance MethodInvocation object associated with the current invocation. ... *//** Ensures that only the canonical instance can be created. */MethodInvocation oldInvocationPriorityOrdered.HIGHEST_PRECEDENCE/** Required to support serialization. Replaces with canonical instance ... */import MonKeyimport MonKeyImpimport Monitorimport MonitorFactoryimport Misc/** Performance monitor interceptor that uses <b>JAMon</b> library to perform the ... */boolean trackAllInvocations, ...;/** Create a new JamonPerformanceMonitorInterceptor with a static logger. *//** Create a new JamonPerformanceMonitorInterceptor with a dynamic or static logger, ... */setTrackAllInvocations(...)/** Set whether to track all invocations that go through this interceptor, ... */this.trackAllInvocations/** Always applies the interceptor if the "trackAllInvocations" flag has been set; ... *//** Wraps the invocation with a JAMon Monitor and writes the current ... */createInvocationTraceName(...)MonKey keynew MonKeyImp(...)Monitor monitortrackException(...)/** Count the thrown exception and put the stack trace in the details portion of the key. ... */String stackTracegetExceptionTrace(...)setDetails(...)MonitorFactory.EXCEPTIONS_LABEL// Specific exception counter. Example: java.lang.RuntimeException// General exception counter which is a total for all exceptions thrown/** Simple AOP Alliance {@code MethodInterceptor} for performance monitoring. ... *//** Create a new PerformanceMonitorInterceptor with a static logger. *//** Create a new PerformanceMonitorInterceptor with a dynamic or static logger, ... */shortSummary(...)/** A default {@link AsyncUncaughtExceptionHandler} that simply logs the exception. ... */SimpleAsyncUncaughtExceptionHandler.class/** Simple AOP Alliance {@code MethodInterceptor} that can be introduced ... *//** Create a new SimpleTraceInterceptor with a static logger. *//** Create a new SimpleTraceInterceptor with dynamic or static logger, ... */String invocationDescriptiongetInvocationDescription(...)Object rval/** Return a description for the given method invocation. ... *//** Provides miscellaneous interceptor implementations. ... *//** Core Spring AOP interfaces, built on AOP Alliance AOP interoperability interfaces. ... *//** Default implementation of the {@link ScopedObject} interface. ... *//** Creates a new instance of the {@link DefaultScopedObject} class. ... */destroyScopedBean(...)/** An AOP introduction interface for scoped objects. ... *//** Return the current target object behind this scoped object proxy, ... *//** Remove this object from its target scope, for example from ... */import ProxyConfigimport SimpleBeanTargetSource/** Convenient proxy factory bean for scoped objects. ... */new SimpleBeanTargetSource(...)SimpleBeanTargetSource scopedTargetSource, ...;/** The TargetSource that manages scoping. *//** The name of the target bean. *//** The cached singleton proxy. *//** Create a new ScopedProxyFactoryBean instance. *//** Set the name of the bean that is to be scoped. */this.scopedTargetSourceProxyFactory pfScopedObject scopedObjectnew DefaultScopedObject(...)// Add an introduction that implements only the methods on ScopedObject.// Add the AopInfrastructureBean marker to indicate that the scoped proxy// itself is not subject to auto-proxying! Only its target bean is.import AutoProxyUtils/** Utility class for creating a scoped proxy. ... */String TARGET_NAME_PREFIX, ...;int TARGET_NAME_PREFIX_LENGTH, ...;/** Generate a scoped proxy for the supplied target bean, registering the target ... */String originalBeanNameScopedProxyFactoryBean.classsetOriginatingBeanDefinition(...)AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE/** Generate the bean name that is used within the scoped proxy to reference the target bean. ... *//** Get the original bean name for the provided {@linkplain #getTargetBeanName ... */isScopedTarget(...)/** Determine if the {@code beanName} is the name of a bean that references ... */// Create a scoped proxy definition for the original bean name,// "hiding" the target bean in an internal target definition.// ScopedProxyFactoryBean's "proxyTargetClass" default is TRUE, so we don't need to set it explicitly here.// Copy autowire settings from original bean definition.// The target bean should be ignored in favor of the scoped proxy.// Register the target bean as separate bean in the factory.// Return the scoped proxy definition as primary bean definition// (potentially an inner bean)./** Support for AOP-based scoping of target objects, with configurable backend. *//** Abstract BeanFactory-based PointcutAdvisor that allows for any Advice ... */String adviceBeanName, ...;Object adviceMonitor, ...;/** Specify the name of the advice bean that this advisor should refer to. ... */this.adviceBeanName/** Return the name of the advice bean that this advisor refers to, if any. */resetAdviceMonitor(...)this.adviceMonitor/** Specify a particular instance of the target advice directly, ... */// Rely on singleton semantics provided by the factory./** Abstract superclass for expression pointcuts, ... */String location, ...;String expression, ...;/** Set the location for debugging. */this.location/** Return location information about the pointcut expression ... */this.expressiononSetExpression(...)/** Called when a new pointcut expression is set. ... *//** Return this pointcut's expression. */// Fill in location information if possible./** Abstract generic {@link org.springframework.aop.PointcutAdvisor} ... *//** Specify the advice that this advisor should apply. *//** Abstract base class for {@link org.springframework.aop.PointcutAdvisor} ... */PointcutAdvisor otherAdvisorPointcutAdvisor.class/** Abstract base regular expression pointcut bean. JavaBean properties are: ... */...[] patterns, ...;/** Regular expressions to match. */...[] excludedPatterns, ...;/** Regular expressions <strong>not</strong> to match. *//** Convenience method when we have only a single pattern. ... */setPatterns(...)/** Set the regular expressions defining methods to match. ... */this.patternspatterns.lengthinitPatternRepresentation(...)/** Return the regular expressions for method matching. *//** Convenience method when we have only a single exclusion pattern. ... */setExcludedPatterns(...)/** Set the regular expressions defining methods to match for exclusion. ... */this.excludedPatternsexcludedPatterns.lengthinitExcludedPatternRepresentation(...)/** Returns the regular expressions for exclusion matching. *//** Try to match the regular expression against the fully qualified name ... */matchesPattern(...)/** Match the specified candidate against the configured patterns. ... */this.patterns.lengthboolean matchedthis.excludedPatterns.lengthboolean excludedmatchesExclusion(...)/** Subclasses must implement this to initialize regexp pointcuts. ... *//** Does the pattern at the given index match the given String? ... *//** Does the exclusion pattern at the given index match the given String? ... */AbstractRegexpMethodPointcut otherPointcutotherPointcut.patternsotherPointcut.excludedPatternsString patternString excludedPatternnullSafeToString(...)import LinkedHashSetimport MethodIntrospector/** Utility methods for AOP support code. ... *//** Check whether the given object is a JDK dynamic proxy or a CGLIB proxy. ... *//** Check whether the given object is a JDK dynamic proxy. ... *//** Check whether the given object is a CGLIB proxy. ... *//** Determine the target class of the given bean instance which might be an AOP proxy. ... *//** Select an invocable method on the target type: either the given method itself ... */Method methodToUseselectInvocableMethod(...)format(...)/** Determine whether the given method is an "equals" method. ... *//** Determine whether the given method is a "hashCode" method. ... *//** Determine whether the given method is a "toString" method. ... *//** Determine whether the given method is a "finalize" method. ... *//** Given a method, which may come from an interface, and a target class used ... */Class<?> specificTargetClassgetUserClass(...)Method resolvedMethod/** Can the given pointcut apply at all on the given class? ... */MethodMatcher methodMatcherIntroductionAwareMethodMatcher introductionAwareMethodMatcherSet<Class<?>> classesnew LinkedHashSet<Class<?>>(...)getAllDeclaredMethods(...)/** Can the given advisor apply at all on the given class? ... */PointcutAdvisor pca/** Determine the sublist of the {@code candidateAdvisors} list ... */boolean hasIntroductionsAdvisor candidate/** Invoke the given target via reflection, as part of an AOP method invocation. ... */// If we are dealing with method with generic parameters, find the original method.// No need to iterate the methods if we're matching any method anyway...// It doesn't have a pointcut so we assume it applies.// already processed// Use reflection to invoke the method.// Invoked method threw a checked exception.// We must rethrow it. The client won't see the interceptor./** Static utility methods for composing {@link ClassFilter ClassFilters}. ... *//** Match all classes that <i>either</i> (or both) of the given ClassFilters matches. ... */new UnionClassFilter(...)new ClassFilter[]/** Match all classes that <i>either</i> (or all) of the given ClassFilters matches. ... *//** Match all classes that <i>both</i> of the given ClassFilters match. ... */new IntersectionClassFilter(...)/** Match all classes that <i>all</i> of the given ClassFilters match. ... *//** ClassFilter implementation for a union of the given ClassFilters. */...[] filters, ...;this.filtersClassFilter filter(...).filters/** ClassFilter implementation for an intersection of the given ClassFilters. *//** Convenient class for building up pointcuts. ... */ClassFilter classFilter, ...;/** Create a default ComposablePointcut, with {@code ClassFilter.TRUE} ... */this.classFilter/** Create a ComposablePointcut based on the given Pointcut. ... *//** Create a ComposablePointcut for the given ClassFilter, ... *//** Create a ComposablePointcut for the given MethodMatcher, ... *//** Create a ComposablePointcut for the given ClassFilter and MethodMatcher. ... *//** Apply a union with the given ClassFilter. ... *//** Apply an intersection with the given ClassFilter. ... *//** Apply a union with the given MethodMatcher. ... *//** Apply an intersection with the given MethodMatcher. ... *//** Apply a union with the given Pointcut. ... *//** Apply an intersection with the given Pointcut. ... */ComposablePointcut otherPointcutotherPointcut.classFilterotherPointcut.methodMatcher/** Pointcut and method matcher for use in simple <b>cflow</b>-style pointcut. ... */Class<?> clazz, ...;AtomicInteger evaluations, ...;/** Construct a new pointcut that matches all control flows below that class. ... *//** Construct a new pointcut that matches all calls below the given method ... */this.clazz/** Subclasses can override this for greater filtering (and performance). *//** Subclasses can override this if it's possible to filter out some candidate classes. */this.evaluationsStackTraceElement elementgetStackTrace(...)new Throwable(...)getClassName(...)getMethodName(...)/** It's useful to know how many times we've fired, for optimization. */ControlFlowPointcut thatthat.clazzthat.methodNameint code/** Concrete BeanFactory-based PointcutAdvisor that allows for any Advice ... *//** Specify the pointcut targeting the advice. ... */getAdviceBeanName(...)/** Simple {@link org.springframework.aop.IntroductionAdvisor} implementation ... */Set<Class<?>> interfaces, ...;/** Create a DefaultIntroductionAdvisor for the given advice. ... */Class<?>[] introducedInterfacesintroducedInterfaces.length/** Add the specified interface to the list of interfaces to introduce. ... */DefaultIntroductionAdvisor otherAdvisorotherAdvisor.interfaces/** Convenient Pointcut-driven Advisor implementation. ... *//** Create an empty DefaultPointcutAdvisor. ... *//** Create a DefaultPointcutAdvisor that matches all methods. ... *//** Create a DefaultPointcutAdvisor, specifying Pointcut and Advice. ... *//** Convenient implementation of the ... */new WeakHashMap<Object,Object>(...)Map<Object,Object> delegateMap, ...;/** Hold weak references to keys as we don't want to interfere with garbage collection.. */Class<?> defaultImplType, ...;Class<?> interfaceType, ...;Object delegatecreateNewDelegate(...)this.defaultImplTypethis.interfaceTypeimplementInterfacesOnObject(...)suppressInterface(...)IntroductionInterceptor.classDynamicIntroductionAdvice.class/** Subclasses may need to override this if they want to perform custom ... */isMethodOnIntroducedInterface(...)getIntroductionDelegateFor(...)doProceed(...)/** Proceed with the supplied {@link org.aopalliance.intercept.MethodInterceptor}. ... */this.delegateMap// Create a new delegate now (but don't store it in the map).// We do this for two reasons:// 1) to fail early if there is a problem instantiating delegates// 2) to populate the interface map once and once only// Using the following method rather than direct reflection,// we get correct handling of InvocationTargetException// if the introduced method throws an exception.// Massage return value if possible: if the delegate returned itself,// we really want to return the proxy.// If we get here, just pass the invocation on.Object delegate, ...;/** Object that actually implements the interfaces. ... *//** Construct a new DelegatingIntroductionInterceptor, providing ... */init(...)/** Construct a new DelegatingIntroductionInterceptor. ... *//** Both constructors use this init method, as it is impossible to pass ... */this.delegate// We don't want to expose the control interface// Using the following method rather than direct reflection, we// get correct handling of InvocationTargetException/** Convenient abstract superclass for dynamic method matchers, ... *//** Can override to add preconditions for dynamic matching. This implementation ... *//** Convenient superclass when we want to force subclasses to ... *//** Interface to be implemented by pointcuts that use String expressions. ... *//** Return the String expression for this pointcut. *//** Support for implementations of {@link org.springframework.aop.IntroductionInfo}. ... */new ConcurrentHashMap<Method,Boolean>(...)Set<Class<?>> publishedInterfaces, ...;Map<Method,Boolean> rememberedMethods, ...;/** Suppress the specified interface, which may have been autodetected ... */this.publishedInterfaces/** Check whether the specified interfaces is a published introduction interface. ... */Class<?> pubIfc/** Publish all interfaces that the given delegate implements at the proxy level. ... */getAllInterfacesAsSet(...)/** Is this method on an introduced interface? ... */Boolean rememberedResultthis.rememberedMethodsboolean result/** This method is implemented only to restore the logger. ... */// Work it out and cache it.import PatternSyntaxException/** Regular expression pointcut based on the {@code java.util.regex} package. ... */new Pattern[]...[] compiledPatterns, ...;/** Compiled form of the patterns. */...[] compiledExclusionPatterns, ...;/** Compiled form of the exclusion patterns. *//** Initialize {@link Pattern Patterns} from the supplied {@code String[]}. */this.compiledPatternscompilePatterns(...)/** Initialize exclusion {@link Pattern Patterns} from the supplied {@code String[]}. */this.compiledExclusionPatterns/** Returns {@code true} if the {@link Pattern} at index {@code patternIndex} ... *//** Returns {@code true} if the exclusion {@link Pattern} at index {@code patternIndex} ... *//** Compiles the supplied {@code String[]} into an array of ... */Pattern[] destinationsource.length/** Static utility methods for composing {@link MethodMatcher MethodMatchers}. ... *//** Match all methods that <i>either</i> (or both) of the given MethodMatchers matches. ... */new UnionIntroductionAwareMethodMatcher(...)new UnionMethodMatcher(...)new ClassFilterAwareUnionIntroductionAwareMethodMatcher(...)new ClassFilterAwareUnionMethodMatcher(...)/** Match all methods that <i>both</i> of the given MethodMatchers match. ... */new IntersectionIntroductionAwareMethodMatcher(...)new IntersectionMethodMatcher(...)/** Apply the given MethodMatcher to the given Method, supporting an ... *//** MethodMatcher implementation for a union of two given MethodMatchers. */MethodMatcher mm1, ...;MethodMatcher mm2, ...;this.mm1this.mm2matchesClass1(...)matchesClass2(...)UnionMethodMatcher thatthat.mm1that.mm2/** MethodMatcher implementation for a union of two given MethodMatchers ... *//** MethodMatcher implementation for a union of two given MethodMatchers, ... */ClassFilter cf1, ...;ClassFilter cf2, ...;this.cf1this.cf2ClassFilter otherCf1ClassFilter otherCf2ClassFilterAwareUnionMethodMatcher cfacfa.cf1cfa.cf2/** MethodMatcher implementation for an intersection of two given MethodMatchers. */boolean aMatchesboolean bMatchesIntersectionMethodMatcher that/** MethodMatcher implementation for an intersection of two given MethodMatchers ... */// Allow for matching with regular UnionMethodMatcher by providing same hash...// Because a dynamic intersection may be composed of a static and dynamic part,// we must avoid calling the 3-arg matches method on a dynamic matcher, as// it will probably be an unsupported operation./** Pointcut bean for simple method name matches, as an alternative to regexp patterns. ... */List<String> mappedNames, ...;/** Convenience method when we have only a single method name to match. ... */setMappedNames(...)/** Set the method names defining methods to match. ... */this.mappedNames/** Add another eligible method name, in addition to those already named. ... *//** Return if the given method name matches the mapped name. ... */(...).mappedNames/** Convenient class for name-match method pointcuts that hold an Advice, ... */new NameMatchMethodPointcut(...)NameMatchMethodPointcut pointcut, ...;/** Set the {@link ClassFilter} to use for this pointcut. ... */setClassFilter(...)setMappedName(...)addMethodName(...)/* Copyright 2002-2014 the original author or authors. ... *//** Pointcut constants for matching getters and setters, ... */SetterPointcut.INSTANCEGetterPointcut.INSTANCEPointcut SETTERS, ...;/** Pointcut matching all bean property setters, in any class. */Pointcut GETTERS, ...;/** Pointcut matching all bean property getters, in any class. *//** Match all methods that <b>either</b> (or both) of the given pointcuts matches. ... *//** Match all methods that <b>both</b> the given pointcuts match. ... *//** Perform the least expensive check for a pointcut match. ... *//** Pointcut implementation that matches bean property setters. */new SetterPointcut(...)SetterPointcut INSTANCE, ...;/** Pointcut implementation that matches bean property getters. */new GetterPointcut(...)GetterPointcut INSTANCE, ...;// Only check if it gets past first hurdle.// We may need additional runtime (argument) check./** Convenient class for regexp method pointcuts that hold an Advice, ... */new SerializableMonitor(...)AbstractRegexpMethodPointcut pointcut, ...;Object pointcutMonitor, ...;/** Create an empty RegexpMethodPointcutAdvisor. ... *//** Create a RegexpMethodPointcutAdvisor for the given advice. ... */setPattern(...)/** Set the regular expression defining methods to match. ... *//** Initialize the singleton Pointcut held within this Advisor. */this.pointcutMonitorcreatePointcut(...)/** Create the actual pointcut: By default, a {@link JdkRegexpMethodPointcut} ... */new JdkRegexpMethodPointcut(...)/** Empty class used for a serializable monitor object. *//** Simple ClassFilter implementation that passes classes (and optionally subclasses). ... */(...).clazz/** Convenient abstract superclass for static method matchers, which don't care ... */// should never be invoked because isRuntime() returns false/** Convenient superclass when we want to force subclasses to implement the ... *//** Convenient base class for Advisors that are also static pointcuts. ... *//** Create a new StaticMethodMatcherPointcutAdvisor, ... *//** Create a new StaticMethodMatcherPointcutAdvisor for the given advice. ... */import AnnotatedElementUtils/** Simple ClassFilter that looks for a specific Java 5 annotation ... */Class<? extends Annotation> annotationType, ...;boolean checkInherited, ...;/** Create a new AnnotationClassFilter for the given annotation type. ... */this.checkInheritedhasAnnotation(...)isAnnotationPresent(...)AnnotationClassFilter otherCfotherCf.annotationTypeotherCf.checkInherited/** Simple Pointcut that looks for a specific Java 5 annotation ... *//** Create a new AnnotationMatchingPointcut for the given annotation type. ... */new AnnotationClassFilter(...)/** Create a new AnnotationMatchingPointcut for the given annotation types. ... */new AnnotationCandidateClassFilter(...)new AnnotationMethodMatcher(...)AnnotationMatchingPointcut otherPointcut/** Factory method for an AnnotationMatchingPointcut that matches ... */new AnnotationMatchingPointcut(...)/** {@link ClassFilter} that delegates to {@link AnnotationUtils#isCandidateClass} ... */isCandidateClass(...)AnnotationCandidateClassFilter thatthat.annotationType/** Simple MethodMatcher that looks for a specific Java 5 annotation ... */matchesMethod(...)AnnotationMethodMatcher otherMmotherMm.annotationTypeotherMm.checkInherited// Proxy classes never have annotations on their redeclared methods.// The method may be on an interface, so let's check on the target class as well./** Annotation support for AOP pointcuts. *//** Convenience classes for using Spring's AOP API. *//** Base class for {@link org.springframework.aop.TargetSource} implementations ... *//** use serialVersionUID from Spring 1.2.7 for interoperability. *//** Name of the target bean we will create on each invocation. *//** Class of the target. *//** BeanFactory that owns this TargetSource. We need to hold onto this ... *//** Set the name of the target bean in the factory. ... *//** Return the name of the target bean in the factory. *//** Specify the target class explicitly, to avoid any kind of access to the ... *//** Set the owning BeanFactory. We need to save a reference so that we can ... *//** Return the owning BeanFactory. */Object beanInstance/** Copy configuration from the other AbstractBeanFactoryBasedTargetSource object. ... */other.targetBeanNameother.targetClassother.beanFactoryAbstractBeanFactoryBasedTargetSource otherTargetSourceotherTargetSource.beanFactoryotherTargetSource.targetBeanName// Full check within synchronization, entering the BeanFactory interaction algorithm only once...// Determine type of the target bean.// Nothing to do here./** {@link org.springframework.aop.TargetSource} implementation that will ... */Object lazyTarget, ...;/** The lazily initialized target object. *//** Return whether the lazy target object of this TargetSource ... */this.lazyTarget/** This default implementation returns {@code null} if the ... *//** Returns the lazy-initialized target object, ... */createObject(...)/** Subclasses should implement this method to return the lazy initialized object. ... */// nothing to doimport BeanInitializationException/** Abstract base class for pooling {@link org.springframework.aop.TargetSource} ... */int maxSize, ...;/** The maximum size of the pool. *//** Set the maximum size of the pool. ... */this.maxSize/** Return the maximum size of the pool. */createPool(...)new BeanInitializationException(...)/** Create the pool. ... *//** Acquire an object from the pool. ... *//** Return the given object to the pool. ... *//** Return an IntroductionAdvisor that provides a mixin ... */DelegatingIntroductionInterceptor diiPoolingConfig.class/* Copyright 2002-2021 the original author or authors. ... */import NotSerializableExceptionimport ObjectStreamExceptionimport BeanDefinitionStoreException/** Base class for dynamic {@link org.springframework.aop.TargetSource} implementations ... */new BeanDefinitionStoreException(...)/** Subclasses should call this method to create a new prototype instance. ... *//** Subclasses should call this method to destroy an obsolete prototype instance. ... */destroyBean(...)destroy(...)new NotSerializableException(...)/** Replaces this object with a SingletonTargetSource on serialization. ... */String msg// Check whether the target bean is defined as prototype.// Create disconnected SingletonTargetSource/EmptyTargetSource.import ObjectPoolimport PooledObjectimport PooledObjectFactoryimport DefaultPooledObjectimport GenericObjectPoolimport GenericObjectPoolConfig/** {@link org.springframework.aop.TargetSource} implementation that holds ... */GenericObjectPoolConfig<>.DEFAULT_MAX_IDLEGenericObjectPoolConfig<>.DEFAULT_MIN_IDLEGenericObjectPoolConfig<>.DEFAULT_MAX_WAIT_MILLISGenericObjectPoolConfig<>.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLISGenericObjectPoolConfig<>.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLISGenericObjectPoolConfig<>.DEFAULT_BLOCK_WHEN_EXHAUSTEDint maxIdle, ...;int minIdle, ...;long maxWait, ...;long timeBetweenEvictionRunsMillis, ...;long minEvictableIdleTimeMillis, ...;boolean blockWhenExhausted, ...;ObjectPool<> pool, ...;/** The Apache Commons {@code ObjectPool} used to pool target objects. *//** Create a CommonsPoolTargetSource with default settings. ... */GenericObjectPoolConfig<>.DEFAULT_MAX_TOTAL/** Set the maximum number of idle objects in the pool. ... */this.maxIdle/** Return the maximum number of idle objects in the pool. *//** Set the minimum number of idle objects in the pool. ... */this.minIdle/** Return the minimum number of idle objects in the pool. *//** Set the maximum waiting time for fetching an object from the pool. ... */this.maxWait/** Return the maximum waiting time for fetching an object from the pool. *//** Set the time between eviction runs that check idle objects whether ... */this.timeBetweenEvictionRunsMillis/** Return the time between eviction runs that check idle objects. *//** Set the minimum time that an idle object can sit in the pool before ... */this.minEvictableIdleTimeMillis/** Return the minimum time that an idle object can sit in the pool. *//** Set whether the call should bock when the pool is exhausted. */this.blockWhenExhausted/** Specify if the call should block when the pool is exhausted. *//** Creates and holds an ObjectPool instance. ... */this.poolcreateObjectPool(...)/** Subclasses can override this if they want to return a specific Commons pool. ... */GenericObjectPoolConfig<> confignew GenericObjectPoolConfig<>(...)setMaxTotal(...)getMaxSize(...)setMaxIdle(...)getMaxIdle(...)setMinIdle(...)getMinIdle(...)setMaxWaitMillis(...)getMaxWait(...)setTimeBetweenEvictionRunsMillis(...)getTimeBetweenEvictionRunsMillis(...)setMinEvictableIdleTimeMillis(...)getMinEvictableIdleTimeMillis(...)setBlockWhenExhausted(...)isBlockWhenExhausted(...)new GenericObjectPool<>(...)/** Borrows an object from the {@code ObjectPool}. */borrowObject(...)/** Returns the specified object to the underlying {@code ObjectPool}. */returnObject(...)getNumActive(...)getNumIdle(...)/** Closes the underlying {@code ObjectPool} when destroying this object. *///----------------------------------------------------------------------------// Implementation of org.apache.commons.pool2.PooledObjectFactory interfacenew DefaultPooledObject<Object>(...)destroyPrototypeInstance(...)getObject(...)/** Canonical {@code TargetSource} when there is no target ... */new EmptyTargetSource(...)EmptyTargetSource INSTANCE, ...;/** The canonical (Singleton) instance of this {@link EmptyTargetSource}. */// Static factory methods/** Return an EmptyTargetSource for the given target Class. ... */// Instance implementationboolean isStatic, ...;/** Create a new instance of the {@link EmptyTargetSource} class. ... */this.isStatic/** Always returns the specified target Class, or {@code null} if none. *//** Always returns {@code true}. *//** Always returns {@code null}. *//** Nothing to release. *//** Returns the canonical instance on deserialization in case ... */EmptyTargetSource otherTsotherTs.targetClassotherTs.isStaticEmptyTargetSource.class/** {@link org.springframework.aop.TargetSource} implementation that ... *//** The current target object. *//** Create a new HotSwappableTargetSource with the given initial target object. ... *//** Return the type of the current target object. ... *//** Swap the target, returning the old target object. ... *//** Two HotSwappableTargetSources are equal if the current target ... */(...).targetHotSwappableTargetSource.class/** {@link org.springframework.aop.TargetSource} that lazily accesses a ... */postProcessTargetObject(...)/** Subclasses may override this method to perform additional processing on ... *//** Config interface for a pooling target source. ... *//** Return the number of active objects in the pool. ... *//** Return the number of idle objects in the pool. ... *//** Obtain a new prototype instance for every call. ... *//** Destroy the given independent instance. ... *//** Simple {@link org.springframework.aop.TargetSource} implementation, ... *//** Implementation of the {@link org.springframework.aop.TargetSource} interface ... *//** Target cached and invoked using reflection. *//** Create a new SingletonTargetSource for the given target. ... *//** Two invoker interceptors are equal if they have the same target or if the ... */SingletonTargetSource otherTargetSourceotherTargetSource.target/** SingletonTargetSource uses the hash code of the target object. */identityToString(...)/** Alternative to an object pool. This {@link org.springframework.aop.TargetSource} ... */new HashSet<Object>(...)ThreadLocal<Object> targetInThread, ...;/** ThreadLocal holding the target associated with the current ... */Set<Object> targetSet, ...;/** Set of managed targets, enabling us to keep track of the targets we've created. */int invocationCount, ...;int hitCount, ...;/** Implementation of abstract getTarget() method. ... */this.targetInThreadthis.invocationCountcurrentThread(...)this.targetSetthis.hitCount/** Dispose of targets if necessary; clear ThreadLocal. ... *//** Return an introduction advisor mixin that allows the AOP proxy to be ... */ThreadLocalTargetSourceStats.class// Associate target with ThreadLocal.// Clear ThreadLocal, just in case./** Statistics for a ThreadLocal TargetSource. ... *//** Return the number of client invocations. *//** Return the number of hits that were satisfied by a thread-bound object. *//** Return the number of thread-bound objects created. *//** Abstract {@link org.springframework.aop.TargetSource} implementation that ... */Object targetObject, ...;long refreshCheckDelay, ...;long lastRefreshCheck, ...;long lastRefreshTime, ...;long refreshCount, ...;/** Set the delay between refresh checks, in milliseconds. ... */this.refreshCheckDelaythis.targetObject/** Not static. */refreshCheckDelayElapsed(...)requiresRefresh(...)/** No need to release target. */freshTarget(...)this.refreshCountthis.lastRefreshTimecurrentTimeMillis(...)long currentTimeMillisthis.lastRefreshCheck/** Determine whether a refresh is required. ... *//** Obtain a fresh target object. ... */// Going to perform a refresh check - update the timestamp./** Refreshable TargetSource that fetches fresh target beans from a BeanFactory. ... *//** Create a new BeanFactoryRefreshableTargetSource for the given ... *//** Retrieve a fresh target object. */obtainFreshBean(...)/** A template method that subclasses may override to provide a ... *//** Interface to be implemented by dynamic target objects, ... *//** Refresh the underlying target object. *//** Return the number of actual refreshes since startup. *//** Return the last time an actual refresh happened (as timestamp). *//** Additional parameter name discover tests that need Java 5. ... */assertParameterNames(...)import AmbiguousBindingException/** Unit tests for the {@link AspectJAdviceParameterNameDiscoverer} class. ... */assertException(...)AmbiguousBindingException.classMethod[] candidatesMethod candidatenew AssertionError(...)AspectJAdviceParameterNameDiscoverer discovererString[] discoveredNamesString formattedExpectedNamesString formattedActualNamesparameterNames.lengthdiscoveredNames.length// Methods to discover parameter names for// Assumes no overloading of test methods...import UnsupportedPointcutPrimitiveExceptionimport IOtherimport DeepBeanimport static Assertions.assertThatIllegalArgumentExceptionimport static Assertions.assertThatIllegalStateExceptionString MATCH_ALL_METHODS, ...;Method getAge, ...;Method setAge, ...;Method setSomeNumber, ...;TestBean.classint.classNumber.classPointcut pointcutClassFilter classFilterassertMatchesTestBeanClass(...)assertMatchesGetAge(...)testThisOrTarget(...)/** This and target are equivalent. Really instanceof pointcuts. ... */String matchesTestBeanString matchesIOtherAspectJExpressionPointcut testBeanPcAspectJExpressionPointcut iOtherPcOtherIOther.classtestWithinPackage(...)String withinBeansPackageAspectJExpressionPointcut withinBeansPcDeepBean.classAspectJExpressionPointcut pcassertThatIllegalStateException(...)ITestBean.classCallCountingInterceptor interceptornew CallCountingInterceptor(...)TestBean testBeangetAdvisedProxy(...)getCount(...)setSomeNumber(...)assertThatIllegalArgumentException(...)TestBean targetnew TestBean(...)DefaultPointcutAdvisor advisorsetPointcut(...)satisfies(...)UnsupportedPointcutPrimitiveException.classnew Consumer<UnsupportedPointcutPrimitiveException>(...) { ... }PointcutPrimitive.CALLgetUnsupportedPrimitive(...)PointcutExpression exprAspectJExpressionPointcut pointcutint count, ...;// not currently testable in a reliable fashion//assertDoesNotMatchStringClass(classFilter);// Subpackages are matched by **// call to getClassFilter forces resolution// call to getClassFilter forces resolution...// Empty/** Tests for matching of bean() pointcut designator. ... */assertMatch(...)assertMisMatch(...)new AspectJExpressionPointcut(...) { ... }// Spring bean names are less restrictive compared to AspectJ names (methods, types etc.)// MVC Controller-kind// JMX-kind// Wildcards// Or, and, not expressions// And, not expressionsimport StaticPartimport AopContextObject rawAtomicInteger depthITestBean itbsetExposeProxy(...)ITestBean thisProxyMethodSignature msigisNotSameAs(...)getAndIncrement(...)currentProxy(...)SourceLocation slocgetSourceLocation(...)getWithinType(...)UnsupportedOperationException.classgetLine(...)getFileName(...)StaticPart staticPartStaticPart aspectJVersionJpmakeEncSJP(...)getDoctor(...)getStringArray(...)getSpouse(...)setSpouse(...)unreliableFileOperation(...)IOException ex// Will be set by advice during a method call// Ensure that these don't cause problems// Check getting again doesn't cause a problem// Try reentrant call--will go through this advice.// Be sure to increment depth to avoid infinite recursion// Check that toString doesn't cause a problem// Change age, so this will be returned by invocation// Any call will do// makeEncSJP, although meant for computing the enclosing join point,// it serves our purpose here// we don't really care.../** Tests just the annotation binding part of {@link AspectJAdviceParameterNameDiscoverer}; ... */IllegalArgumentException.classimport EmptySpringAnnotationimport Tx/** Java 5 specific {@link AspectJExpressionPointcutTests}. ... */new HashMap<String,Method>(...)Map<String,Method> methodsOnHasGeneric, ...;HasGeneric.classMethod takesGenericListAspectJExpressionPointcut jdbcVarArgsMyTemplate.class...[].classtestMatchAnnotationOnClass(...)AspectJExpressionPointcut springAnnotatedPcAspectJExpressionPointcut springTxAnnotatedPcSpringAnnotated.classHasTransactionalAnnotation.classBeanB.classBeanA.classProxyFactory factorynew BeanA(...)BeanA proxyIBeanA proxyIBeanA.classAspectJExpressionPointcut anySpringMethodAnnotationAspectJExpressionPointcut takesSpringAnnotatedArgument2ProcessesSpringAnnotatedParameters.classint age, ...;// Assumes no overloading// TODO this will currently map, would be nice for optimization//assertTrue(ajexp.matches(HasGeneric.class));//assertFalse(ajexp.matches(TestBean.class));// True because it maybeMatches with potential argument subtypesimport Documentedimport Inheritedimport OverridingClassLoaderTestService targetnew TestServiceImpl(...)LogUserAdvice logAdvicenew LogUserAdvice(...)testAdvice(...)SimpleThrowawayClassLoader loadernew SimpleThrowawayClassLoader(...)TestServiceImpl.classTestService otherloadClass(...)excludeClass(...)TestService.classTestException.classTestService beanreset(...)getCountThrows(...)sayHello(...)/** Create a new SimpleThrowawayClassLoader for the given class loader. ... */ElementType.METHODnew TestException(...)int countBefore, ...;int countThrows, ...;// Test with default class loader first...// Then try again with a different class loader on the target...// Make sure the interface is loaded from the  parent class loaderimport CountingTestBean/** Unit tests for the {@link TypePatternClassFilter} class. ... */TypePatternClassFilter tpcfIOther.classBeanFactory.classDefaultListableBeanFactory.classCountingTestBean.classFloat.classDouble.classTypePatternClassFilter filter1TypePatternClassFilter filter2TypePatternClassFilter filter3isNotEqualTo(...)import FileNotFoundExceptionimport RemoteExceptionimport DeclarePrecedenceimport Disabledimport DefaultLockableimport Lockableimport PerTargetAspectimport TwoAdviceAspectimport OrderComparatorimport Order/** Abstract tests for {@link AspectJAdvisorFactory} implementations. ... *//** To be overridden by concrete test subclasses. ... */AopConfigException.classgetFixture(...)new PerCflowAspect(...)new PerCflowBelowAspect(...)int realAgeTestBean itbnew PerTargetAspect(...)ReflectiveAspectJAdvisorFactory.SyntheticInstantiationAdvisorSyntheticInstantiationAdvisor siaInstantiationModelAwarePointcutAdvisorImpl imapaLazySingletonAspectInstanceFactoryDecorator maaifgetAspectInstanceFactory(...)PerTargetAspect aspect1PerTargetAspect aspect2aspect1.countsetOrder(...)PerTargetAspectWithOrderAnnotation10 aspect1new PerTargetAspectWithOrderAnnotation10(...)PerTargetAspectWithOrderAnnotation5 aspect2new PerTargetAspectWithOrderAnnotation5(...)new PerThisAspect(...)PerTypeWithinAspectInstanceFactory aifnew PerTypeWithinAspectInstanceFactory(...)TestBean itb2getInstantiationCount(...)namedPointcuts(...)new NamedPointcutAspectWithFQN(...)new NamedPointcutAspectWithoutFQN(...)new NamedPointcutAspectFromLibrary(...)new NamedPointcutAspectFromLibraryWithBinding(...)new BindingAspectWithSingleArg(...)ManyValuedArgs targetnew ManyValuedArgs(...)ManyValuedArgs mvaManyValuedArgs.classString aint bint cString dStringBuffer eString expectedResultmungeArgs(...)/** In this case the introduction will be made. */NotLockable notLockableTargetnew NotLockable(...)NotLockable notLockable1NotLockable.classnew MakeLockable(...)Lockable lockableNotLockable notLockable2TargetNotLockable notLockable2Lockable lockable2locked(...)lock(...)setIntValue(...)CannotBeUnlocked.classCannotBeUnlocked targetnew CannotBeUnlocked(...)Lockable proxyLockable.classunlock(...)ArrayList<Object> targetList<?> proxyAnnotatedTarget targetnew AnnotatedTargetImpl(...)new MakeAnnotatedTypeModifiable(...)AnnotatedTarget.class// TODO: Why does this test fail? It hasn't been run before, so it maybe never actually passed...new MakeITestBeanModifiable(...)Modifiable modifiableint oldAgeModifiable.classisModified(...)acceptChanges(...)UnsupportedOperationException expectedExceptionnew ExceptionThrowingAspect(...)// Is it different AspectJ behaviour, at least for checked exceptions?// TODO document this behaviour.RemoteException expectedExceptionnew RemoteException(...)withCause(...)UndeclaredThrowableException.classinterfaces.lengthExposeInvocationInterceptor.INSTANCETwoAdviceAspect twoAdviceAspectnew TwoAdviceAspect(...)InvocationTrackingAspect aspectnew InvocationTrackingAspect(...)Echo echoEcho.classFileNotFoundException.classnew FileNotFoundException(...)MetadataAwareAspectInstanceFactory aspectInstanceFactorynew NoDeclarePrecedenceShouldFail(...)new DeclarePrecedenceShouldSucceed(...)new PerTypeWithinAspect(...)PerTypeWithinAspect.classITestBean fieldThatShouldBeIgnoredBySpringAtAspectJProcessing, ...;Exception ex, ...;this.ex/** Add a DeclareParents field in concrete subclasses, to identify ... */boolean modified, ...;this.modifiedMethod correspondingGettergetGetterFromSetter(...)boolean modifiedObject oldValueprintStackTrace(...)markDirty(...)String getterNamereplaceFirst(...)ModifiableImpl.class/** Adds a declare parents pointcut. ... */MutableModifiable mixin, ...;DefaultLockable.class/** Adds a declare parents pointcut - spr5307 ... */Lockable mixin, ...;/** Demonstrates introductions, AspectJ annotation style. *//** Used as a mixin. ... *//** Used as a target. ... */int intValue, ...;this.intValue// Just to check that this doesn't cause problems with introduction processing// Check that the perclause pointcut is valid// Hit the method in the per clause to instantiate the aspect// Will be ExposeInvocationInterceptor, synthetic instantiation advisor, 2 method advisors// Ensure that we exclude// Required everywhere we use AspectJ proxies// @ArgNames({"age"})	// AMC needs more work here? ignoring pjp arg... ok??// argNames should be supported in Around as it is in Pointcut/* We use the mixin to check and, if necessary, change, ... */// Already changed, don't need to change again//System.out.println("changed");// Find the current raw value, by invoking the corresponding setter//System.out.println("Old value=" + oldValue + "; new=" + newValue);// Don't sweat on exceptions; assume value was modified//System.out.println("cannot get getter for " + jp);// must be write only// Can also obtain the mixin (this) this way//Lockable mixin = (Lockable) jp.getThis();import AspectJAdviceParameterNameDiscovererTestBean tbAspectJProxyFactory proxyFactorynew AspectJProxyFactory(...)ITestBean proxiedTestBeanaddAspect(...)NamedPointcutWithArgs.classTransactionalBean tbnew TransactionalBean(...)ITransactionalBean proxiedTestBeanPointcutWithAnnotationArgument.classdoInTransaction(...)Method methodUsedForParameterTypeDiscoveryString[] pnamespnames.length/** Represents Spring's Transactional annotation without actually introducing the dependency */import AspectJExpressionPointcutTestsimport ExceptionThrowingAspectAspectJAdvisorFactory af, ...;InstantiationModelAwarePointcutAdvisorImpl ajpaAspectJExpressionPointcutTests.MATCH_ALL_METHODSisPerInstance(...)testIllegalInstantiationModel(...)AbstractAspectJAdvisorFactoryTests.PerCflowAspect.classAbstractAspectJAdvisorFactoryTests.PerCflowAspectAbstractAspectJAdvisorFactoryTests.PerCflowBelowAspect.classAbstractAspectJAdvisorFactoryTests.PerCflowBelowAspect/** @since ... */ExceptionThrowingAspect.classPerTargetAspect.classPerThisAspect.classimport PerThisAspectTestBean beanTestBean bean1TestBean bean2AspectJProxyFactory pf1AspectJProxyFactory pf2AspectJProxyFactory pfnew MultiplyReturnValue(...)int multiplethis.agenew MyEnum(...)new MyOtherEnum(...)getArgs(...)int multiple, ...;this.multiple// SPR-13328/** Tests for {@link ReflectiveAspectJAdvisorFactory}. ... */import AopConfigUtilsimport AopNamespaceUtilsimport PassThroughSourceExtractorimport SourceExtractorimport XmlReaderContextimport CollectingReaderEventListenernew CollectingReaderEventListener(...)ParserContext parserContext, ...;CollectingReaderEventListener readerEventListener, ...;BeanDefinitionRegistry registry, ...;SourceExtractor sourceExtractornew PassThroughSourceExtractor(...)XmlBeanDefinitionReader readerthis.registryXmlReaderContext readerContextnew XmlReaderContext(...)this.readerEventListenerthis.parserContextnew ParserContext(...)getBeanDefinitionCount(...)int HIGH_PRECEDENCE_ADVISOR_ORDER, ...;int LOW_PRECEDENCE_ADVISOR_ORDER, ...;int EARLY_ADVICE_DECLARATION_ORDER, ...;int LATE_ADVICE_DECLARATION_ORDER, ...;AspectJPrecedenceComparator comparator, ...;Method anyOldMethod, ...;AspectJExpressionPointcut anyOldPointcut, ...;this.anyOldMethodthis.anyOldPointcutAdvisor advisor1createAspectJBeforeAdvice(...)Advisor advisor2createAspectJAroundAdvice(...)createAspectJAfterAdvice(...)createAspectJAfterReturningAdvice(...)createAspectJAfterThrowingAdvice(...)createSpringAOPBeforeAdvice(...)createSpringAOPAfterAdvice(...)AspectJMethodBeforeAdvice advicecreateAspectJAdvice(...)AspectJAroundAdvice adviceAspectJAfterAdvice adviceAspectJAfterReturningAdvice adviceAspectJAfterThrowingAdvice adviceAspectJPointcutAdvisor advisornew AspectJPointcutAdvisor(...)new AfterReturningAdvice(...) { ... }BeforeAdvice advicenew BeforeAdvice(...) { ... }import ComponentDefinitionimport Resourceimport static ResourceTestUtils.qualifiedResourceAopNamespaceHandlerEventTests.classqualifiedResource(...)Resource CONTEXT, ...;Resource POINTCUT_EVENTS_CONTEXT, ...;Resource POINTCUT_REF_CONTEXT, ...;Resource DIRECT_POINTCUT_EVENTS_CONTEXT, ...;CollectingReaderEventListener eventListener, ...;DefaultListableBeanFactory beanFactory, ...;XmlBeanDefinitionReader reader, ...;this.readersetEventListener(...)this.eventListenerComponentDefinition[] componentDefinitionsgetComponentDefinitions(...)ComponentDefinition[] nestedComponentDefsgetNestedComponents(...)PointcutComponentDefinition pcdcomponentDefinitions.lengthnestedComponentDefs.lengthComponentDefinition componentDefinitiongetBeanDefinitions(...).lengthgetBeanDefinitions(...)AdvisorComponentDefinition acdBeanComponentDefinition adviceDefgetBeanReferences(...).lengthgetBeanReferences(...)AspectComponentDefinition acdBeanDefinition[] beanDefinitionsBeanReference[] beanReferencesSet<String> expectedReferencesComponentDefinition[] nestedComponentDefs2beanDefinitions.lengthbeanReferences.lengthBeanReference beanReferencenestedComponentDefs2.lengthimport BeanDefinitionParsingExceptionBeanDefinitionStoreException.classnew Consumer<BeanDefinitionStoreException>(...) { ... }BeanDefinitionParsingException.class/** Tests that the &lt;aop:config/&gt; element can be used as a top level element. ... */DefaultListableBeanFactory beanFactoryTopLevelAopTagTests.classAdvisedSupport asClass<?>[] completedInterfacesList<?> ifacescompletedInterfaces.lengthsetOpaque(...)List<?> lComparable<>.classproxiedUserInterfaces(...)userInterfaces.lengthnew Class<>[]new InvocationHandler(...) { ... }// Can't assume ordering for others, so use a list/** Benchmarks for introductions. ... */int EXPECTED_COMPARE, ...;int INVOCATIONS, ...;/** Increase this if you want meaningful results! */StopWatch swITestBean proxyCounter counternew SimpleCounterIntroduction(...)prettyPrint(...)List<Object> interceptorssingletonList(...)new MethodInterceptor(...) { ... }ReflectiveMethodInvocation invocationObject rv/** toString on target can cause failure. */new TestBean(...) { ... }Method m// If it hits target, the test will fail with the UnsupportedOpException// in the inner class above./** Test for SPR-4675. A null value returned from around advice is very hard to debug if ... */SimpleFoo targetnew SimpleFoo(...)Foo fooAopInvocationException.classBar targetnew Bar(...)Bar barPrototypeTargetTests.classTestInterceptor interceptorTestBeanImpl.constructionCountdoSomething(...)interceptor.invocationCountint constructionCount, ...;import Accessibleimport JFrameimport RootPaneContainerimport DebugInterceptorimport TimestampIntroductionInterceptorimport TimeStamped/** Also tests AdvisedSupport and ProxyCreatorSupport superclasses. ... */NopInterceptor nopnew CountingBeforeAdvice(...)CountingBeforeAdvice cbaITestBean proxiedNopInterceptor nop2AopConfigException exCountingBeforeAdvice cba1CountingBeforeAdvice cba2replaceAdvisor(...)TimeStamped tstnew TimeStamped(...) { ... }TimeStamped.classTestBeanSubclass rawnew TestBeanSubclass(...)ITestBean tblong tTimestampIntroductionInterceptor tinew TimestampIntroductionInterceptor(...)Class<?>[] oldProxiedInterfacesClass<?>[] newProxiedInterfacesTimeStamped ts// Extend to get new interfacenewProxiedInterfaces.lengtholdProxiedInterfaces.lengthgetTimeStamp(...)absquatulate(...)NopInterceptor diNopInterceptor diUnusedadviceIncluded(...)countAdvicesOfType(...)NopInterceptor.classMyInterceptor.class/** Should see effect immediately on behavior. */ProxyFactory configlong timeint oldCountITestBean itDebugInterceptor debugInterceptornew DebugInterceptor(...)setTime(...)removeAdvice(...)RuntimeException.classProxyFactory pf2Object proxy2setTargetClass(...)JFrame framenew JFrame(...)Object proxy1new A(...)new B(...)List<Object> listProxyFactory pf1isNull(...)// Can use advised and ProxyFactory interchangeably// Removes counting before advisor// Removes Nop1// Check out of bounds// Ok// Use the type cast feature// Replace etc methods on advised should be same as on ProxyFactory// We've already implicitly added this interface.// This call should be ignored without error// All cool//System.out.println("Proxied interfaces are " + StringUtils.arrayToDelimitedString(factory.getProxiedInterfaces(), ","));// Shouldn't fail;// Add to front of interceptor chain// Can remove// Existing reference will fail// Now check non-effect of removing interceptor that isn't there// not invoked againimport ConnectExceptionimport MyThrowsHandlerimport static BDDMockito.givenMyThrowsHandler thnew MyThrowsHandler(...)ThrowsAdviceInterceptor tiObject retMethodInvocation.classwillReturn(...)given(...)getHandlerMethodCount(...)willThrow(...)FileNotFoundException exConnectException exnew ConnectException(...)ConnectException.classThrowable tnew MyThrowsHandler(...) { ... }afterThrowing(...)// should require one handler method at least// Extends RemoteExceptionimport DerivedTestBeanConcurrencyThrottleInterceptorTests.classint NR_OF_THREADS, ...;int NR_OF_ITERATIONS, ...;DerivedTestBean tbnew DerivedTestBean(...)ConcurrencyThrottleInterceptor ctinew ConcurrencyThrottleInterceptor(...)ITestBean serializedProxyConcurrencyThrottleInterceptor serializedCtigetConcurrencyLimit(...)testMultipleThreads(...)Thread[] threadsnew Thread[]new ConcurrencyThread(...)... / ...InterruptedException exnew OutOfMemoryError(...)... % ...join(...)ITestBean proxy, ...;Throwable ex, ...;exceptional(...)Error err// should never happenimport static ArgumentMatchers.anyStringimport static ArgumentMatchers.eqimport static Mockito.timesimport static Mockito.verifysetEnterMessage(...)new CustomizableTraceInterceptor(...)CustomizableTraceInterceptor.PLACEHOLDER_RETURN_VALUECustomizableTraceInterceptor.PLACEHOLDER_EXCEPTIONCustomizableTraceInterceptor.PLACEHOLDER_INVOCATION_TIMEsetExitMessage(...)setExceptionMessage(...)MethodInvocation methodInvocationLog logLog.classCustomizableTraceInterceptor interceptornew StubCustomizableTraceInterceptor(...)verify(...)anyString(...)times(...)IllegalArgumentException exceptioneq(...)CustomizableTraceInterceptor.PLACEHOLDER_ARGUMENT_TYPESCustomizableTraceInterceptor.PLACEHOLDER_ARGUMENTSCustomizableTraceInterceptor.PLACEHOLDER_TARGET_CLASS_NAMECustomizableTraceInterceptor.PLACEHOLDER_METHOD_NAMECustomizableTraceInterceptor.PLACEHOLDER_TARGET_CLASS_SHORT_NAMELog log, ...;this.log// Must not be able to set empty enter message// Must not be able to set enter message with return value placeholder// Must not be able to set enter message with exception placeholder// Must not be able to set enter message with invocation time placeholder// Must not be able to set empty exit message// Must not be able to set exit message with exception placeholder// Must not be able to set empty exception message// Must not be able to set exception message with return value placeholder/** Unit tests for the {@link DebugInterceptor} class. ... */DebugInterceptor interceptornew StubDebugInterceptor(...)checkCallCountTotal(...)new RequiresBeanNameBoundTestBean(...)createAdvisorWithoutIntroduction(...)NamedBean nbcreateAdvisorIntroducingNamedBean(...)// Requires binding/** Non-XML tests are in AbstractAopProxyTests ... */ExposeInvocationInterceptorTests.class// Fires context checksassertions(...)new JamonPerformanceMonitorInterceptor(...)JamonPerformanceMonitorInterceptor interceptor, ...;MethodInvocation mi, ...;getNumRows(...)getReport(...)PerformanceMonitorInterceptor interceptornew PerformanceMonitorInterceptor(...)setPrefix(...)setSuffix(...)/** Unit tests for the {@link SimpleTraceInterceptor} class. ... */SimpleTraceInterceptor interceptornew SimpleTraceInterceptor(...)/** Unit tests for the {@link DefaultScopedObject} class. ... */String GOOD_BEAN_NAME, ...;testBadTargetBeanName(...)ConfigurableBeanFactory factoryConfigurableBeanFactory.classTestBean autowiredTestBean unscopedScopedProxyAutowireTests.classgetBeanNamesForType(...)containsSingleton(...)getChild(...)TestBean scopedTestBean child, ...;this.child/** Unit tests for {@link ScopedProxyUtils}. ... */String parsedOriginalBeanNamegetOriginalBeanName(...)withMessage(...)AbstractRegexpMethodPointcut rpc, ...;getRegexpMethodPointcut(...)noPatternSuppliedTests(...)getPatterns(...).lengthgetPatterns(...)exactMatchTests(...)IOException.classthis.rpcsetExcludedPattern(...)// assumes rpc.setPattern("java.lang.Object.hashCode");// Doesn't match a method from ThrowablePointcut nonew TestPointcut(...)/** Test that when we serialize and deserialize various canonical instances ... */// will return true if we're not proxying interfaces/** Unit tests for {@link ClassFilters}. ... */new RootClassFilter(...)NestedRuntimeException.classClassFilter exceptionFilter, ...;ClassFilter interfaceFilter, ...;ClassFilter hasRootCauseFilter, ...;ClassFilter unionClassFilter intersectionTestBean proxynew StaticMethodMatcher(...) { ... }MethodMatcher GETTER_METHOD_MATCHER, ...;MethodMatcher GET_AGE_METHOD_MATCHER, ...;MethodMatcher ABSQUATULATE_METHOD_MATCHER, ...;MethodMatcher SETTER_METHOD_MATCHER, ...;ComposablePointcut pcClassFilter cfPointcutsTests.TEST_BEAN_ABSQUATULATEPointcutsTests.TEST_BEAN_GET_AGEPointcutsTests.TEST_BEAN_GET_NAMEPointcutsTests.TEST_BEAN_SET_AGEComposablePointcut pc1ComposablePointcut pc2// Matches the getAge() method in any class// Should now match all getter methods// Should now match absquatulate() as well// But it doesn't match everything// Use the Pointcuts matches methodControlFlowPointcut cflownew ControlFlowPointcut(...)One.classnew One(...)nomatch(...)getEvaluations(...)/** Check that we can use a cflow pointcut only in conjunction with ... */Pointcut settersUnderOneControlFlowPointcut.class// Not advised, not under One// Will be advised// Won't be advised// Not advised; under One but not a setter// We saved most evaluationsimport SerializableNopInterceptorimport INestedTestBeanimport NestedTestBeanimport Personimport SerializablePersonTestBean rawlong timestampTimeStamped tspSubTimeStamped.classSubTimeStamped tspDelegatingIntroductionInterceptor iinew Tester(...)foo(...)new TestII(...)new SerializableTimeStamped(...)new DelegatingIntroductionInterceptor(...) { ... }NestedTestBean targetnew NestedTestBean(...)String companyTestBean delegateINestedTestBean proxyITestBean introductionsetCompany(...)getCompany(...)SerializablePerson serializableTargetnew SerializablePerson(...)Person pPerson p1Person.classnew SerializableNopInterceptor(...)// Test when target implements the interface: should get interceptor by preference.new TargetClass(...)long ts, ...;this.tslong t, ...;this.t// Shouldn't accept null target//assertTrue(Arrays.binarySearch(pf.getProxiedInterfaces(), TimeStamped.class) != -1);// Shouldn't proxy framework interfaces// Test removal// Note that we need to construct a new proxy factory,// or suppress the interface on the proxy factory// != t// From introduction interceptor, not targetMethod EXCEPTION_GETMESSAGE, ...;Method ITESTBEAN_SETAGE, ...;Method ITESTBEAN_GETAGE, ...;Method IOTHER_ABSQUATULATE, ...;MethodMatcher defaultMmnew StartsWithMatcher(...)MethodMatcher mm1MethodMatcher mm2new TestDynamicMethodMatcherWhichMatches(...)MethodMatcher intersectionnew TestDynamicMethodMatcherWhichDoesNotMatch(...)MethodMatcher getterMatcherMethodMatcher setterMatcherMethodMatcher unionMethodMatcher firstMethodMatcher second// Knock out dynamic partNameMatchMethodPointcut pc, ...;Person proxied, ...;SerializableNopInterceptor nop, ...;/** Create an empty pointcut, populating instance variables. */Person p2testSets(...)NameMatchMethodPointcut pc1NameMatchMethodPointcut pc2String foo// Can't do exact matching through isMatch// Count is now 2new StaticMethodMatcherPointcut(...) { ... }MyTestBean.classMyTestBeanSubclass.classMethod TEST_BEAN_SET_AGE, ...;Method TEST_BEAN_GET_AGE, ...;Method TEST_BEAN_GET_NAME, ...;Method TEST_BEAN_ABSQUATULATE, ...;Pointcut allTestBeanMethodsPointcut, ...;/** Matches only TestBean class, not subclasses */Pointcut allClassSetterPointcut, ...;// Subclass used for matchingPointcut myTestBeanSetterPointcut, ...;Pointcut myTestBeanGetterPointcut, ...;// Will match MyTestBeanSubclass// Still more specific classPointcut myTestBeanSubclassGetterPointcut, ...;Pointcut allClassGetterPointcut, ...;Pointcut allClassGetAgePointcut, ...;Pointcut allClassGetNamePointcut, ...;/** Should match all setters and getters on any class */Pointcut union/** Tests vertical composition. First pointcut matches all setters. ... *//** Intersection should be MyTestBean getAge() only: ... */Pointcut intersection/** The intersection of these two pointcuts leaves nothing. */// Union with all setters// Still doesn't match superclass setter// Matches subclass of MyTestBean// Now intersection with MyTestBeanSubclass getters should eliminate MyTestBean target// Still matches subclass of MyTestBean// Now union with all TestBean methodsRegexpMethodPointcutAdvisorIntegrationTests.classITestBean advisedTestBean advised// Interceptor behind regexp advisor// Not advised// Only setter fired// This is a CGLIB proxy, so we can proxy it to the target class// This is proxied// Serialize and continue...// Remembers count, but we need to get a new reference to nop.../** Unit tests for {@link RootClassFilter}. ... */ClassFilter filter1, ...;ClassFilter filter2, ...;ClassFilter filter3, ...;Error.classimport Qualifier/** Unit tests for {@link AnnotationMatchingPointcut}. ... */Pointcut pointcut1Qualifier.classPointcut pointcut2Pointcut pointcut3AnnotationClassFilter.classAnnotationMethodMatcher.class// #1 and #3 have equivalent hash codes even though equals() returns false.CommonsPool2TargetSourceProxyTests.classITestBean beanpreInstantiateSingletons(...)import SideEffectBeanint INITIAL_COUNT, ...;/** Initial count value set in bean factory XML */HotSwappableTargetSourceTests.class/** We must simulate container shutdown, which should clear threads. *//** Check it works like a normal invoker */SideEffectBean proxieddoWork(...)SideEffectBean target1SideEffectBean target2HotSwappableTargetSource swapperswap(...)testBasicFunctionality(...)SerializablePerson sp1SerializablePerson sp2HotSwappableTargetSource htsnew HotSwappableTargetSource(...)// Will call pool.close()// TODO should be able to make this assertion: need to fix target handling// in AdvisedSupport//assertEquals(target2, ((Advised) proxied).getTarget());// Swap it back// It shouldn't be corrupted, it should still work// We need to get a reference to the client-side targetsourcenew AbstractLazyCreationTargetSource(...) { ... }new InitCountingBean(...)InitCountingBean.classInitCountingBean proxyInitCountingBean.initCountint initCount, ...;// only increment when creating the actual target - not the proxy//no-opLazyInitTargetSourceTests.classResource SINGLETON_CONTEXT, ...;Resource CUSTOM_TARGET_CONTEXT, ...;Resource FACTORY_BEAN_CONTEXT, ...;Set<?> set1Set<?> set2/** Unit tests relating to the abstract {@link AbstractPrototypeBasedTargetSource} ... */MutablePropertyValues tsPvsnew MutablePropertyValues(...)RootBeanDefinition tsBdTestTargetSource.classRootBeanDefinition bdSerializablePerson.classTestTargetSource cptsTargetSource serializedSingletonTargetSource stssetPropertyValues(...)TestBean thisFieldIsNotSerializable, ...;/** Nonserializable test field to check that subclass ... */PrototypeTargetSourceTests.class/** Test that multiple invocations of the prototype bean will result ... */SideEffectBean singletonSideEffectBean prototypeThreadLocalTargetSourceTests.class/** Check we can use two different ThreadLocalTargetSources ... */SideEffectBean apartment/** Relies on introduction. */ThreadLocalTargetSourceStats statsgetHitCount(...)getObjectCount(...)Runner rnew Runner(...)Thread tnew Thread(...)SideEffectBean mine, ...;this.miner.mine/** Test for SPR-1442. Destroyed target should re-associated with thread and not throw NPE. */ThreadLocalTargetSource source// +1 because creating target for stats call counts// +1 again// + 1 for states call!// Only one thread so only one object can have been bound// Check it didn't affect the other thread's copy// When we use other thread's copy in this thread// it should behave like ours// Bound to two threads// try first time// try second time// Should not throw NPE/** Test what happens when checking for refresh but not refreshing object. */CountingRefreshableTargetSource tsnew CountingRefreshableTargetSource(...)Object aObject bsetRefreshCheckDelay(...)getCallCount(...)/** Test what happens when checking for refresh and refresh occurs. *//** Test what happens when no refresh occurs. */Object cObject dObject eObject fint callCount, ...;boolean requiresRefresh, ...;this.requiresRefreshthis.callCount/** Simple implementation of Lockable interface for use in mixins. ... */boolean locked, ...;this.locked/** Simple interface to use for mixins ... */int invocations, ...;this.invocations/* Copyright 2002-2005 the original author or authors. ... */int totalCalls, ...;/** Simple before advice example that we can use for counting checks. ... */count(...)/** Abstract superclass for counting advices etc. ... */HashMap<String,Integer> map, ...;/** Method name --> count, does not understand overloading */int allCount, ...;merge(...)new BiFunction<Integer,Integer,Integer>(...) { ... }getOrDefault(...)/** A bit simplistic: just wants the same class. ... */// Full method signature/** Not valid, wrong number of arguments *//** Trivial interceptor that can be introduced in a chain to display it. ... */increment(...)(...).count/** Subclass of NopInterceptor that is serializable and ... *//** We must override this field and the related methods as ... */import java.lang.*import java.util.*import java.io.*import java.net.*import groovy.lang.*import groovy.util.*new Boolean(...)boolean decorating, ...;import PropertyChangeEventimport PrivilegedActionExceptionimport Iteratorimport Optionalimport CollectionFactoryimport ResolvableTypeimport ConversionExceptionimport ConverterNotFoundException/** A basic {@link ConfigurablePropertyAccessor} that provides the necessary ... */Integer.MAX_VALUEAbstractNestablePropertyAccessor.class/** We'll create a lot of these objects, so we don't want a new logger every time. */int autoGrowCollectionLimit, ...;Object wrappedObject, ...;String nestedPath, ...;Object rootObject, ...;Map<String,AbstractNestablePropertyAccessor> nestedPropertyAccessors, ...;/** Map with cached nested Accessors: nested path -> Accessor instance. *//** Create a new empty accessor. Wrapped instance needs to be set afterwards. ... */registerDefaultEditors(...)this.typeConverterDelegatenew TypeConverterDelegate(...)/** Create a new accessor for the given object. ... */setWrappedInstance(...)/** Create a new accessor, wrapping a new instance of the specified class. ... */instantiateClass(...)/** Create a new accessor for the given object, ... */getWrappedInstance(...)setExtractOldValueForEditor(...)isExtractOldValueForEditor(...)setAutoGrowNestedPaths(...)isAutoGrowNestedPaths(...)setAutoGrowCollectionLimit(...)getAutoGrowCollectionLimit(...)setConversionService(...)getConversionService(...)/** Specify a limit for array and collection auto-growing. ... */this.autoGrowCollectionLimit/** Return the limit for array and collection auto-growing. *//** Switch the target object, replacing the cached introspection results only ... */this.wrappedObjectunwrapOptional(...)this.nestedPaththis.rootObjectthis.nestedPropertyAccessors/** Return the nested path of the object wrapped by this accessor. *//** Return the root object at the top of the path of this accessor. ... *//** Return the class of the root object at the top of the path of this accessor. ... */getRootInstance(...)AbstractNestablePropertyAccessor nestedPaPropertyTokenHolder tokensgetPropertyNameTokens(...)getFinalPath(...)getPropertyAccessorForPropertyPath(...)NotReadablePropertyException exnew NotWritablePropertyException(...)getRootClass(...)setPropertyValue(...)new PropertyValue(...)pv.resolvedTokensString propertyNamegetOriginalPropertyValue(...).resolvedTokensgetOriginalPropertyValue(...)tokens.keysprocessKeyedProperty(...)processLocalProperty(...)Object propValuegetPropertyHoldingValue(...)PropertyHandler phgetLocalPropertyHandler(...)tokens.actualNameString lastKeytokens.keys.lengthnew InvalidPropertyException(...)Class<?> requiredTypeint arrayIndexparseInt(...)Object convertedValuetokens.canonicalNamenested(...)int lengthClass<?> componentTypeObject newArraygetPropertyValue(...)IndexOutOfBoundsException exgetCollectionType(...)NullPointerException exClass<?> mapKeyTypegetMapKeyType(...)Class<?> mapValueTypegetMapValueType(...)Map<Object,Object> mapTypeDescriptor typeDescriptorvalueOf(...)Object convertedMapKeyObject convertedMapValuePropertyTokenHolder getterTokensnew PropertyTokenHolder(...)getterTokens.canonicalNamegetterTokens.keysint lastKeyIndexlastIndexOf(...)setDefaultValue(...)new NullValueInNestedPathException(...)isWritable(...)isOptional(...)this.suppressNotWritablePropertyExceptioncreateNotWritablePropertyException(...)Object originalValueObject valueToApplypv.conversionNecessaryisConverted(...)getConvertedValue(...)isReadable(...)getException(...)convertForProperty(...)toTypeDescriptor(...)getOriginalPropertyValue(...).conversionNecessaryTypeMismatchException exPropertyChangeEvent propertyChangeEventnew PropertyChangeEvent(...)new TypeMismatchException(...)getPropertyType(...)Throwable causenew MethodInvocationException(...)PropertyChangeEvent pcegetPropertyHandler(...)Object valueClass<?> editorTypeguessPropertyTypeFromEditors(...)InvalidPropertyException exString finalPathnew ConversionNotSupportedException(...)String actualNamenew NotReadablePropertyException(...)StringBuilder indexedPropertyNameString keygrowArrayIfNecessary(...)growCollectionIfNecessary(...)Set<Object> setIterator<Object> ititerator(...)hasNext(...)Object elemnext(...)resolveGeneric(...)asMap(...)getNested(...)getResolvableType(...)/** Return the {@link PropertyHandler} for the specified {@code propertyName}, navigating ... *//** Return a {@link PropertyHandler} for the specified local {@code propertyName}. ... *//** Create a new nested property accessor instance. ... *//** Create a {@link NotWritablePropertyException} for the specified property. */Object defaultValuenewValue(...)Class<?> elementTypeasCollection(...)/** Get the last component of the path. Also works if not nested. ... */getLastNestedPropertySeparatorIndex(...)/** Recursively navigate to return a property accessor for the nested property path. ... */getFirstNestedPropertySeparatorIndex(...)String nestedPropertyString nestedPathgetNestedPropertyAccessor(...)/** Retrieve a Property accessor for the given nested property. ... */String canonicalNamenew HashMap<String,AbstractNestablePropertyAccessor>(...)isPresent(...)newNestedPropertyAccessor(...)copyDefaultEditorsTo(...)copyCustomEditorsTo(...)PropertyValue pvcreateDefaultPropertyValue(...)TypeDescriptor descgetPropertyTypeDescriptor(...)Object arrayCollection<>.classTypeDescriptor elementDescgetElementTypeDescriptor(...)createCollection(...)Map<>.classTypeDescriptor keyDescgetMapKeyTypeDescriptor(...)createMap(...)new IllegalAccessException(...)/** Parse the given property name into the corresponding property name tokens. ... */List<String> keysint searchIndexint keyStartint keyEndgetPropertyNameKeyEnd(...)collectionToDelimitedString(...)toStringArray(...)int unclosedPrefixesPropertyAccessor.PROPERTY_KEY_PREFIX_CHARPropertyAccessor.PROPERTY_KEY_SUFFIX_CHAR/** A handler for a specific property. */Class<?> propertyType, ...;boolean readable, ...;boolean writable, ...;this.propertyTypethis.readablethis.writable/** Holder class used to store property tokens. */this.actualNamethis.canonicalNameString actualName, ...;String canonicalName, ...;...[] keys, ...;// IMPORTANT: Do not pass full property name in here - property editors// must not kick in for map keys but rather only for map values.// Pass full property name and old value in here, since we want full// conversion ability for map values.// Apply indexes and map keys: fetch value for all keys but the last one.// null map value case// Optimization for common ignoreUnknown=true scenario since the// exception would be caught and swallowed higher up anyway...// May happen e.g. with Groovy-generated methods// Maybe an indexed/mapped property...// Check to see if there is a custom editor,// which might give an indication on the desired target type.// Consider as not determinable.// Cannot be evaluated, so can't be readable.// Cannot be evaluated, so can't be writable.// apply indexes and map keys// Apply index to Iterator in case of a Set.// Handle nested properties recursively.// Get value of bean property.// Lookup cached sub-PropertyAccessor, create new one if not found.// Inherit all type-specific PropertyEditors.// TODO - only handles 2-dimensional arrays// The property name contains opening prefix(es)...// No unclosed prefix(es) in the property name (left) ->// this is the suffix we are looking for.// This suffix does not close the initial prefix but rather// just one that occurred within the property name./** Abstract implementation of the {@link PropertyAccessor} interface. ... */boolean extractOldValueForEditor, ...;boolean autoGrowNestedPaths, ...;boolean suppressNotWritablePropertyException, ...;this.extractOldValueForEditorthis.autoGrowNestedPathsList<PropertyAccessException> propertyAccessExceptionsList<PropertyValue> propertyValuesgetPropertyValueList(...)NotWritablePropertyException exNullValueInNestedPathException exPropertyAccessException exnew ArrayList<PropertyAccessException>(...)PropertyAccessException[] paeArraynew PropertyAccessException[]new PropertyBatchUpdateException(...)// Redefined with public visibility./** Actually get the value of a property. ... *//** Actually set a property value. ... */// setPropertyValue may throw any BeansException, which won't be caught// here, if there is a critical failure such as no matching field.// We can attempt to deal only with less serious exceptions.// Otherwise, just ignore it and continue...// If we encountered individual exceptions, throw the composite exception.import BeanInfoimport IntrospectionException/** Strategy interface for creating {@link BeanInfo} instances for Spring beans. ... *//** Return the bean info for the given class, if supported. ... *//** Exception thrown when instantiation of a bean failed. ... */Class<?> beanClass, ...;Constructor<?> constructor, ...;Method constructingMethod, ...;/** Create a new BeanInstantiationException. ... */this.beanClassthis.constructorthis.constructingMethod/** Return the offending bean class (never {@code null}). ... *//** Return the offending constructor, if known. ... *//** Return the delegate for bean construction purposes, if known. ... *//** Holder for a key-value style attribute that is part of a bean definition. ... */Object value, ...;Object source, ...;/** Create a new AttributeValue instance. ... */this.value/** Return the name of the attribute. *//** Return the value of the attribute. *//** Set the configuration source {@code Object} for this metadata element. ... */this.sourceBeanMetadataAttribute otherMaotherMa.nameotherMa.valueotherMa.sourceimport AttributeAccessorSupport/** Extension of {@link org.springframework.core.AttributeAccessorSupport}, ... *//** Add the given BeanMetadataAttribute to this accessor's set of attributes. ... *//** Look up the given BeanMetadataAttribute in this accessor's set of attributes. ... */new BeanMetadataAttribute(...)BeanMetadataAttribute attributeremoveAttribute(...)/** Interface to be implemented by bean metadata elements ... *//** Return the configuration source {@code Object} for this metadata element ... */import ConstructorPropertiesimport PropertyDescriptorimport URIimport URLimport Temporalimport Dateimport Localeimport JvmClassMappingKtimport KFunctionimport KParameterimport KClassesimport KCallablesJvmimport ReflectJvmMappingimport ConcurrentReferenceHashMap/** Static convenience methods for JavaBeans: for instantiating beans, ... */BeanUtils.classnew ConcurrentReferenceHashMap<K,V>(...)Map<Class<?>,Object> valuesnew HashMap<Class<?>,Object>(...)boolean.classbyte.classshort.classlong.classunmodifiableMap(...)Set<Class<?>> unknownEditorTypes, ...;Map<Class<?>,Object> DEFAULT_TYPE_VALUES, ...;/** Convenience method to instantiate a class using its no-arg constructor. ... */new BeanInstantiationException(...)/** Instantiate a class using its 'primary' constructor (for Kotlin classes, ... */Constructor<T> ctorfindPrimaryConstructor(...)LinkageError err/** Instantiate a class using its no-arg constructor and return the new instance ... *//** Convenience method to instantiate a class using the given constructor. ... */isKotlinReflectPresent(...)Object[] argsWithDefaultValues... <= ...parameterTypes.lengthClass<?> parameterType/** Return a resolvable constructor for the provided class, either a primary constructor ... */Constructor<?>[] ctorsgetConstructors(...)ctors.length/** Return the primary constructor of the provided class. For Kotlin classes, this ... *//** Find a method with the given method name and the given parameter types, ... */findDeclaredMethod(...)getDeclaredMethod(...)/** Find a method with the given method name and minimal parameters (best case: none), ... */findMethodWithMinimalParameters(...)findDeclaredMethodWithMinimalParameters(...)/** Find a method with the given method name and minimal parameters (best case: none) ... */int numMethodsFoundWithCurrentMinimumArgsint numParamsisBridge(...)/** Parse a method signature in the form {@code methodName[([arg_list])]}, ... */int startParenint endParenString methodNameString[] parameterTypeNamesparameterTypeNames.lengthString parameterTypeNamefindMethod(...)/** Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class. ... */getPropertyDescriptors(...)/** Retrieve the JavaBeans {@code PropertyDescriptors} for the given property. ... */getPropertyDescriptor(...)/** Find a JavaBeans {@code PropertyDescriptor} for the given method, ... */findPropertyForMethod(...)PropertyDescriptor[] pdsPropertyDescriptor pdgetReadMethod(...)getWriteMethod(...)/** Find a JavaBeans PropertyEditor following the 'Editor' suffix convention ... */ClassLoader clString targetTypeNameString editorNamegetSystemClassLoader(...)Class<?> editorClassPropertyEditor.class/** Determine the bean property type for the given property from the ... *//** Obtain a new MethodParameter object for the write method of the ... */getWriteMethodParameter(...)Method writeMethod/** Determine required parameter names for the given constructor, ... */ConstructorProperties cpConstructorProperties.classString[] paramNames/** Check if the given type represents a "simple" property: a simple value ... */isSimpleValueType(...)/** Check if the given type represents a "simple" value type: a primitive or ... */isPrimitiveOrWrapper(...)Enum<>.classCharSequence.classDate.classTemporal.classURI.classURL.classLocale.classClass<>.class/** Copy the property values of the given source bean into the target bean. ... */copyProperties(...)/** Copy the property values of the given source bean into the given target bean, ... *//** Copy the property values of the given source bean into the given target bean. ... */Class<?> actualEditablePropertyDescriptor[] targetPdsList<String> ignoreListPropertyDescriptor targetPdPropertyDescriptor sourcePdMethod readMethodResolvableType sourceResolvableTypeforMethodReturnType(...)ResolvableType targetResolvableTypeforMethodParameter(...)boolean isAssignablehasUnresolvableGenerics(...)setAccessible(...)new FatalBeanException(...)/** Inner class to avoid a hard dependency on Kotlin at runtime. *//** Retrieve the Java constructor corresponding to the Kotlin primary constructor, if any. ... */KFunction<T> primaryCtorgetPrimaryConstructor(...)getKotlinClass(...)Constructor<T> constructorgetJavaConstructor(...)UnsupportedOperationException ex/** Instantiate a Kotlin class using the provided constructor. ... */KFunction<T> kotlinConstructorgetKotlinFunction(...)List<KParameter> parametersgetParameters(...)Map<KParameter,Object> argParameterscallBy(...)// Prefer regular method over bridge...// Additional candidate with same length// e.g. AccessControlException on Google App Engine// Misbehaving ClassLoader returned null instead of ClassNotFoundException// - fall back to unknown editor type registration below// Ignore - fall back to unknown editor type registration below// Ignore generic types in assignable check if either ResolvableType has unresolvable generics./** The central interface of Spring's low-level JavaBeans infrastructure. ... *//** Return the limit for array and collection auto-growing. ... *//** Return the bean instance wrapped by this object. *//** Return the type of the wrapped bean instance. *//** Obtain the PropertyDescriptors for the wrapped object ... *//** Obtain the property descriptor for a specific property ... */import AccessControlContextimport AccessControllerimport PrivilegedActionimport PrivilegedExceptionActionimport Property/** Default {@link BeanWrapper} implementation that should be sufficient ... */CachedIntrospectionResults cachedIntrospectionResults, ...;/** Cached introspections results for this object, to prevent encountering ... */AccessControlContext acc, ...;/** The security context used for invoking the property methods. *//** Create a new empty BeanWrapperImpl. Wrapped instance needs to be set afterwards. ... *//** Create a new BeanWrapperImpl for the given object. ... *//** Create a new BeanWrapperImpl, wrapping a new instance of the specified class. ... *//** Create a new BeanWrapperImpl for the given object, ... */setSecurityContext(...)parent.acc/** Set a bean instance to hold, without any unwrapping of {@link java.util.Optional}. ... */setIntrospectionClass(...)getWrappedClass(...)/** Set the class to introspect. ... */this.cachedIntrospectionResultsgetBeanClass(...)/** Obtain a lazily initialized CachedIntrospectionResults instance ... *//** Set the security context used during the invocation of the wrapped instance methods. ... */this.acc/** Return the security context used during the invocation of the wrapped instance methods. ... *//** Convert the given value for the specified property to the latter's type. ... */CachedIntrospectionResults cachedIntrospectionResultsgetCachedIntrospectionResults(...)TypeDescriptor tdgetTypeDescriptor(...)getNestedPath(...)addTypeDescriptor(...)property(...)GenericTypeAwarePropertyDescriptor gpdnew Property(...)new BeanPropertyHandler(...)new BeanWrapperImpl(...)PropertyMatches matchesforProperty(...)buildErrorMessage(...)getPossibleMatches(...)BeanWrapperImpl nestedBwPropertyDescriptor pd, ...;this.pdgetSecurityManager(...)doPrivileged(...)new PrivilegedAction<Object>(...) { ... }new PrivilegedExceptionAction<Object>(...) { ... }PrivilegedActionException paegetWriteMethodForActualAccess(...)PrivilegedActionException ex/** Abstract superclass for all exceptions thrown in the beans package ... *//** Create a new BeansException with the specified message. ... *//** Create a new BeansException with the specified message ... */import Introspectorimport LinkedHashMapimport ConcurrentMapimport SpringPropertiesimport SpringFactoriesLoader/** Internal class that caches JavaBeans {@link java.beans.PropertyDescriptor} ... */new PropertyDescriptor[]getFlag(...)loadFactories(...)BeanInfoFactory.classCachedIntrospectionResults.classnew ConcurrentHashMap<Class<?>,CachedIntrospectionResults>(...)new ConcurrentReferenceHashMap<Class<?>,CachedIntrospectionResults>(...)String IGNORE_BEANINFO_PROPERTY_NAME, ...;/** System property that instructs Spring to use the {@link Introspector#IGNORE_ALL_BEANINFO} ... */...[] EMPTY_PROPERTY_DESCRIPTOR_ARRAY, ...;boolean shouldIntrospectorIgnoreBeaninfoClasses, ...;List<BeanInfoFactory> beanInfoFactories, ...;/** Stores the BeanInfoFactory instances. */Set<ClassLoader> acceptedClassLoaders, ...;/** Set of ClassLoaders that this CachedIntrospectionResults class will always ... */ConcurrentMap<Class<?>,CachedIntrospectionResults> strongClassCache, ...;/** Map keyed by Class containing CachedIntrospectionResults, strongly held. ... */ConcurrentMap<Class<?>,CachedIntrospectionResults> softClassCache, ...;/** Map keyed by Class containing CachedIntrospectionResults, softly held. ... *//** Accept the given ClassLoader as cache-safe, even if its classes would ... *//** Clear the introspection cache for the given ClassLoader, removing the ... */new Predicate<ClassLoader>(...) { ... }isUnderneathClassLoader(...)keySet(...)new Predicate<Class<?>>(...) { ... }/** Create CachedIntrospectionResults for the given bean class. ... */CachedIntrospectionResults resultsConcurrentMap<Class<?>,CachedIntrospectionResults> classCacheToUseCachedIntrospectionResults existingputIfAbsent(...)new CachedIntrospectionResults(...)isCacheSafe(...)isClassLoaderAccepted(...)/** Check whether this CachedIntrospectionResults class is configured ... */ClassLoader acceptedLoader/** Check whether the given ClassLoader is underneath the given parent, ... */ClassLoader classLoaderToCheckgetParent(...)/** Retrieve a {@link BeanInfo} descriptor for the given target class. ... */BeanInfoFactory beanInfoFactoryBeanInfo beanInfogetBeanInfo(...)Introspector.IGNORE_ALL_BEANINFOBeanInfo beanInfo, ...;/** The BeanInfo object for the introspected bean class. */Map<String,PropertyDescriptor> propertyDescriptors, ...;/** PropertyDescriptor objects keyed by property name String. */ConcurrentMap<PropertyDescriptor,TypeDescriptor> typeDescriptorCache, ...;/** TypeDescriptor objects keyed by PropertyDescriptor. *//** Create a new CachedIntrospectionResults instance for the given class. ... */Set<String> readMethodNamesthis.beanInfothis.propertyDescriptorsnew LinkedHashMap<String,PropertyDescriptor>(...)getPropertyEditorClass(...)buildGenericTypeAwarePropertyDescriptor(...)introspectInterfaces(...)introspectPlainAccessors(...)this.typeDescriptorCachenew ConcurrentReferenceHashMap<PropertyDescriptor,TypeDescriptor>(...)IntrospectionException exisJavaLanguageInterface(...)PropertyDescriptor existingPdisPlainAccessor(...)new GenericTypeAwarePropertyDescriptor(...)getBeanDescriptor(...)capitalize(...)TypeDescriptor existing// This call is slow so we do it once.// Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those// Explicitly check implemented interfaces for setter/getter methods as well,// in particular for Java 8 default methods...// Check for record-style accessors without prefix: e.g. "lastName()"// - accessor method directly referring to instance field of same name// - same convention for component accessors of Java 15 record classes// GenericTypeAwarePropertyDescriptor leniently resolves a set* write method// against a declared read method, so we prefer read method descriptors here.// Accessor method referring to instance field of same name?// Same lenient fallback checking as in Property.../** Interface that encapsulates configuration methods for a PropertyAccessor. ... *//** Specify a Spring 3.0 ConversionService to use for converting ... *//** Return the associated ConversionService, if any. *//** Set whether to extract the old property value when applying a ... *//** Return whether to extract the old property value when applying a ... *//** Set whether this instance should attempt to "auto-grow" a ... *//** Return whether "auto-growing" of nested paths has been activated. *//** Exception thrown when no suitable editor or converter can be found for a bean property. ... *//** Create a new ConversionNotSupportedException. ... *//** {@link ConfigurablePropertyAccessor} implementation that directly accesses ... */new HashMap<String,FieldPropertyHandler>(...)Map<String,FieldPropertyHandler> fieldMap, ...;/** Create a new DirectFieldAccessor for the given object. ... *//** Create a new DirectFieldAccessor for the given object, ... */FieldPropertyHandler propertyHandlerthis.fieldMapfindField(...)new FieldPropertyHandler(...)new DirectFieldAccessor(...)forField(...)Field field, ...;this.fieldimport Imageimport BeanDescriptorimport EventSetDescriptorimport IndexedPropertyDescriptorimport MethodDescriptorimport TreeSet/** Decorator for a standard {@link BeanInfo} object, e.g. as created by ... */new TreeSet<PropertyDescriptor>(...)new PropertyDescriptorComparator(...)ExtendedBeanInfo.classBeanInfo delegate, ...;Set<PropertyDescriptor> propertyDescriptors, ...;/** Wrap the given {@link BeanInfo} instance; copy all its existing property descriptors ... */MethodDescriptor[] methodDescriptorsgetMethodDescriptors(...)new SimpleIndexedPropertyDescriptor(...)new SimplePropertyDescriptor(...)findCandidateWriteMethods(...)handleCandidateWriteMethod(...)List<Method> matchesMethodDescriptor methodDescriptorisCandidateWriteMethod(...)new Comparator<Method>(...) { ... }int nParamspropertyNameFor(...)Class<?> propertyTypefindExistingPropertyDescriptor(...)setWriteMethod(...)setIndexedWriteMethod(...)Class<?> candidateTypeString candidateNameIndexedPropertyDescriptor ipdgetIndexedPropertyType(...)decapitalize(...)/** Return the set of {@link PropertyDescriptor PropertyDescriptors} from the wrapped ... */getAdditionalBeanInfo(...)getDefaultEventIndex(...)getDefaultPropertyIndex(...)getEventSetDescriptors(...)getIcon(...)/** A simple {@link PropertyDescriptor}. */Method readMethod, ...;Method writeMethod, ...;Class<?> propertyEditorClass, ...;copyNonMethodProperties(...)this.readMethodthis.writeMethodfindPropertyType(...)this.propertyEditorClass/** A simple {@link IndexedPropertyDescriptor}. */Method indexedReadMethod, ...;Method indexedWriteMethod, ...;Class<?> indexedPropertyType, ...;getIndexedReadMethod(...)getIndexedWriteMethod(...)this.indexedReadMethodthis.indexedWriteMethodthis.indexedPropertyTypefindIndexedPropertyType(...)/* See java.beans.IndexedPropertyDescriptor#equals */IndexedPropertyDescriptor otherPd/** Sorts PropertyDescriptor instances alpha-numerically to emulate the behavior of ... */String leftString rightbyte[] leftBytesgetBytes(...)byte[] rightBytes// Probably simply a method that wasn't meant to follow the JavaBeans pattern...// We're only trying to find candidates, can easily ignore extra ones here...// Sort non-void returning write methods to guard against the ill effects of// non-deterministic sorting of methods returned from Class#getDeclaredMethods// under JDK 7. See https://bugs.java.com/view_bug.do?bug_id=7023180// Ignore, as does PropertyDescriptor#getPropertyType// Ignore, as does IndexedPropertyDescriptor#getPropertyType// Ignore, as does IndexedPropertyDescriptor#getIndexedPropertyType/** {@link BeanInfoFactory} implementation that evaluates whether bean classes have ... *//** Return an {@link ExtendedBeanInfo} for the given bean class, if applicable. */supports(...)new ExtendedBeanInfo(...)/** Return whether the given bean class declares or inherits any non-void ... *//** Thrown on an unrecoverable problem encountered in the ... *//** Create a new FatalBeanException with the specified message. ... *//** Create a new FatalBeanException with the specified message ... */import GenericTypeResolver/** Extension of the standard JavaBeans {@link PropertyDescriptor} class, ... */Set<Method> ambiguousWriteMethods, ...;MethodParameter writeMethodParameter, ...;Method readMethodToUseMethod writeMethodToUsegetMethodIfAvailable(...)Set<Method> ambiguousCandidatesnew HashSet<Method>(...)this.ambiguousWriteMethodsthis.writeMethodParameterwithContainingClass(...)resolveReturnType(...)getParameterType(...)GenericTypeAwarePropertyDescriptor.classGenericTypeAwarePropertyDescriptor otherPd// Fallback: Original JavaBeans introspection might not have found matching setter// method due to lack of bridge method resolution, in case of the getter using a// covariant return type whereas the setter is defined for the concrete property type.// Write method not matched against read method: potentially ambiguous through// several overloaded variants, in which case an arbitrary winner has been chosen// by the JDK's JavaBeans Introspector.../** Exception thrown when referring to an invalid bean property. ... */String propertyName, ...;/** Create a new InvalidPropertyException. ... */this.propertyName/** Return the offending bean class. *//** Return the name of the offending property. *//** Interface representing an object whose value set can be merged with ... *//** Is merging enabled for this particular instance? *//** Merge the current value set with that of the supplied object. ... *//** Thrown when a bean property getter or setter method throws an exception, ... */String ERROR_CODE, ...;/** Error code that a method invocation error will be registered with. *//** Create a new MethodInvocationException. ... */getPropertyName(...)import Spliteratorimport Spliteratorsimport Stream/** The default implementation of the {@link PropertyValues} interface. ... */List<PropertyValue> propertyValueList, ...;Set<String> processedProperties, ...;boolean converted, ...;/** Creates a new empty MutablePropertyValues object. ... */this.propertyValueListnew ArrayList<PropertyValue>(...)/** Deep copy constructor. Guarantees PropertyValue references ... */PropertyValue[] pvspvs.length/** Construct a new MutablePropertyValues object from a Map. ... */forEach(...)new BiConsumer<?,?>(...) { ... }/** Construct a new MutablePropertyValues object using the given List of ... *//** Return the underlying List of PropertyValue objects in its raw form. ... *//** Return the number of PropertyValue entries in the list. *//** Copy all given PropertyValues into this object. Guarantees PropertyValue ... *//** Add all property values from the given Map. ... *//** Add a PropertyValue object, replacing any existing one for the ... */PropertyValue currentPvmergeIfRequired(...)setPropertyValueAt(...)/** Overloaded version of {@code addPropertyValue} that takes ... *//** Modify a PropertyValue object held in this object. ... *//** Merges the value of the supplied 'new' {@link PropertyValue} with that of ... */Mergeable mergeableisMergeEnabled(...)Object merged/** Remove the given PropertyValue, if contained. ... *//** Overloaded version of {@code removePropertyValue} that takes a property name. ... */unmodifiableList(...)spliterator(...)new PropertyValue[]/** Get the raw property value, if any. ... */MutablePropertyValues changesPropertyValue newPvPropertyValue pvOldthis.processedProperties/** Register the specified property as "processed" in the sense ... *//** Clear the "processed" registration of the given property, if any. ... *//** Mark this holder as containing converted values only ... */this.converted/** Return whether this holder contains converted values only ({@code true}), ... */(...).propertyValueListarrayToDelimitedString(...)// We can optimize this because it's all new:// There is no replacement of existing property values.// for each property value in the new set// if there wasn't an old one, add it/** Exception thrown on an attempt to get the value of a property ... *//** Create a new NotReadablePropertyException. ... *//** Exception thrown on an attempt to set the value of a property that ... */...[] possibleMatches, ...;/** Create a new NotWritablePropertyException. ... */this.possibleMatches/** Return suggestions for actual bean property names that closely match ... *//** Exception thrown when navigation of a valid nested property ... *//** Create a new NullValueInNestedPathException. ... *//** Superclass for exceptions related to a property access, ... */PropertyChangeEvent propertyChangeEvent, ...;/** Create a new PropertyAccessException. ... */this.propertyChangeEvent/** Create a new PropertyAccessException without PropertyChangeEvent. ... *//** Return the PropertyChangeEvent that resulted in the problem. ... *//** Return the name of the affected property, if available. *//** Return the affected value that was about to be set, if any. */getNewValue(...)/** Return a corresponding error code for this type of exception. *//** Common interface for classes that can access named properties ... */String NESTED_PROPERTY_SEPARATOR, ...;/** Path separator for nested properties. ... */char NESTED_PROPERTY_SEPARATOR_CHAR, ...;String PROPERTY_KEY_PREFIX, ...;/** Marker that indicates the start of a property key for an ... */char PROPERTY_KEY_PREFIX_CHAR, ...;String PROPERTY_KEY_SUFFIX, ...;/** Marker that indicates the end of a property key for an ... */char PROPERTY_KEY_SUFFIX_CHAR, ...;/** Determine whether the specified property is readable. ... *//** Determine whether the specified property is writable. ... *//** Determine the property type for the specified property, ... *//** Return a type descriptor for the specified property: ... *//** Get the current value of the specified property. ... *//** Set the specified value as current property value. ... *//** Perform a batch update from a Map. ... *//** The preferred way to perform a batch update. ... *//** Perform a batch update with more control over behavior. ... *//** Perform a batch update with full control over behavior. ... *//** Simple factory facade for obtaining {@link PropertyAccessor} instances, ... *//** Obtain a BeanWrapper for the given target object, ... *//** Obtain a PropertyAccessor for the given target object, ... *//** Utility methods for classes that perform bean property access ... *//** Return the actual property name for the given property path. ... */int separatorIndexPropertyAccessor.PROPERTY_KEY_SUFFIX/** Check whether the given property path indicates an indexed or nested property. ... */char chPropertyAccessor.NESTED_PROPERTY_SEPARATOR_CHAR/** Determine the first nested property separator in the ... */getNestedPropertySeparatorIndex(...)/** Determine the first (or last) nested property separator in the ... */boolean inKey/** Determine whether the given registered path matches the given property path, ... *//** Determine the canonical name for the given property path. ... */PropertyAccessor.PROPERTY_KEY_PREFIXdelete(...)/** Determine the canonical names for the given property paths. ... */String[] resultpropertyNames.lengthcanonicalPropertyName(...)import PrintStreamimport PrintWriterimport StringJoiner/** Combined exception, composed of individual PropertyAccessException instances. ... */...[] propertyAccessExceptions, ...;/** List of PropertyAccessException objects. *//** Create a new PropertyBatchUpdateException. ... */this.propertyAccessExceptions/** If this returns 0, no errors were encountered during binding. */this.propertyAccessExceptions.length/** Return an array of the propertyAccessExceptions stored in this object. ... *//** Return the exception for this field, or {@code null} if there isn't any. */PropertyAccessException paeStringJoiner stringJoinernew StringJoiner(...)PropertyAccessException exceptiongetExceptionCount(...)import Enumeration/** Common delegate methods for Spring's internal {@link PropertyDescriptor} implementations. ... *//** See {@link java.beans.FeatureDescriptor}. */Enumeration<String> keysattributeNames(...)setExpert(...)isExpert(...)setHidden(...)isHidden(...)setPreferred(...)isPreferred(...)setShortDescription(...)getShortDescription(...)setDisplayName(...)getDisplayName(...)hasMoreElements(...)nextElement(...)setPropertyEditorClass(...)setBound(...)isBound(...)setConstrained(...)isConstrained(...)/** See {@link java.beans.PropertyDescriptor#findPropertyType}. */new IntrospectionException(...)Class<?>[] paramsparams.length/** See {@link java.beans.IndexedPropertyDescriptor#findIndexedPropertyType}. */Class<?> indexedPropertyTypeInteger.TYPE/** Compare the given {@code PropertyDescriptors} and return {@code true} if ... */// Copy all attributes (emulating behavior of private FeatureDescriptor#addTable)// See java.beans.PropertyDescriptor#PropertyDescriptor(PropertyDescriptor)// Write method's property type potentially more specific// Proceed with read method's property type/** Interface for strategies that register custom ... *//** Register custom {@link java.beans.PropertyEditor PropertyEditors} with ... *//** Encapsulates methods for registering JavaBeans {@link PropertyEditor PropertyEditors}. ... *//** Register the given custom property editor for all properties of the given type. ... *//** Register the given custom property editor for the given type and ... *//** Find a custom property editor for the given type and property. ... */import InputStreamimport Readerimport BigDecimalimport BigIntegerimport Charsetimport Pathimport ZoneIdimport Currencyimport Propertiesimport SortedMapimport SortedSetimport TimeZoneimport UUIDimport InputSourceimport ByteArrayPropertyEditorimport CharArrayPropertyEditorimport CharacterEditorimport CharsetEditorimport ClassArrayEditorimport ClassEditorimport CurrencyEditorimport CustomBooleanEditorimport CustomCollectionEditorimport CustomMapEditorimport CustomNumberEditorimport FileEditorimport InputSourceEditorimport InputStreamEditorimport LocaleEditorimport PathEditorimport PatternEditorimport PropertiesEditorimport ReaderEditorimport StringArrayPropertyEditorimport TimeZoneEditorimport URIEditorimport URLEditorimport UUIDEditorimport ZoneIdEditorimport ResourceArrayPropertyEditor/** Base implementation of the {@link PropertyEditorRegistry} interface. ... */boolean shouldIgnoreXml, ...;/** Boolean flag controlled by a {@code spring.xml.ignore} system property that instructs Spring to ... */boolean defaultEditorsActive, ...;boolean configValueEditorsActive, ...;Map<Class<?>,PropertyEditor> defaultEditors, ...;Map<Class<?>,PropertyEditor> overriddenDefaultEditors, ...;Map<Class<?>,PropertyEditor> customEditors, ...;Map<String,CustomEditorHolder> customEditorsForPath, ...;Map<Class<?>,PropertyEditor> customEditorCache, ...;/** Activate the default editors for this registry instance, ... */// Management of default editorsthis.defaultEditorsActive/** Activate config value editors which are only intended for configuration purposes, ... */this.configValueEditorsActive/** Override the default editor for the specified type with the given property editor. ... */this.overriddenDefaultEditorsnew HashMap<Class<?>,PropertyEditor>(...)/** Retrieve the default editor for the given property type, if any. ... */this.defaultEditorscreateDefaultEditors(...)/** Actually register the default editors for this registry instance. */Charset.classnew CharsetEditor(...)new ClassEditor(...)new ClassArrayEditor(...)Currency.classnew CurrencyEditor(...)File.classnew FileEditor(...)InputStream.classnew InputStreamEditor(...)InputSource.classnew InputSourceEditor(...)new LocaleEditor(...)Path.classnew PathEditor(...)Pattern.classnew PatternEditor(...)Properties.classnew PropertiesEditor(...)Reader.classnew ReaderEditor(...)new ResourceArrayPropertyEditor(...)TimeZone.classnew TimeZoneEditor(...)new URIEditor(...)new URLEditor(...)UUID.classnew UUIDEditor(...)ZoneId.classnew ZoneIdEditor(...)new CustomCollectionEditor(...)Set<>.classSortedSet<>.classSortedMap<>.classnew CustomMapEditor(...)new ByteArrayPropertyEditor(...)new CharArrayPropertyEditor(...)char.classnew CharacterEditor(...)Character.classnew CustomBooleanEditor(...)Boolean.classnew CustomNumberEditor(...)Byte.classShort.classInteger.classLong.classfloat.classdouble.classBigDecimal.classBigInteger.classStringArrayPropertyEditor saenew StringArrayPropertyEditor(...)/** Copy the default editors registered in this instance to the given target registry. ... */target.defaultEditorsActivetarget.configValueEditorsActivetarget.defaultEditorstarget.overriddenDefaultEditors// Management of custom editorsregisterCustomEditor(...)this.customEditorsForPathnew LinkedHashMap<String,CustomEditorHolder>(...)new CustomEditorHolder(...)this.customEditorsnew LinkedHashMap<Class<?>,PropertyEditor>(...)this.customEditorCacheClass<?> requiredTypeToUsegetCustomEditor(...)List<String> strippedPathsaddStrippedPropertyPaths(...)Iterator<String> itString strippedPath/** Determine whether this registry contains a custom editor ... */Entry<String,CustomEditorHolder> entryMap<>.Entry<String,CustomEditorHolder>entrySet(...)matchesProperty(...)getKey(...)getPropertyEditor(...)/** Determine the property type for the given property path. ... *//** Get custom editor that has been registered for the given property. ... */CustomEditorHolder holder/** Get custom editor for the given type. If no direct match found, ... */Iterator<Class<?>> itClass<?> key/** Guess the property type of the specified property from the registered ... */CustomEditorHolder editorHolderString strippedNamegetRegisteredType(...)/** Copy the custom editors registered in this instance to the given target registry. ... */String actualPropertyNamenew BiConsumer<Class<?>,PropertyEditor>(...) { ... }new BiConsumer<String,CustomEditorHolder>(...) { ... }String editorNestedPropertyString editorNestedPath/** Add property paths with all variations of stripped keys and/or indexes. ... */int startIndexString suffix/** Holder for a registered custom editor with property name. ... */PropertyEditor propertyEditor, ...;Class<?> registeredType, ...;this.propertyEditorthis.registeredType// Simple editors, without parameterization capabilities.// The JDK does not contain a default editor for any of these target types.// Default instances of collection editors.// Can be overridden by registering custom instances of those as custom editors.// Default editors for primitive arrays.// The JDK does not contain a default editor for char!// Spring's CustomBooleanEditor accepts more flag values than the JDK's default editor.// The JDK does not contain default editors for number wrapper types!// Override JDK primitive number editors with our own CustomNumberEditor.// Only register config value editors if explicitly requested.// Check property-specific editor first.// No property-specific editor -> check type-specific editor.// Check directly registered editor for type.// Check cached editor for type, registered for superclass or interface.// Find editor for superclass or interface.// Cache editor for search type, to avoid the overhead// of repeated assignable-from checks.// Strip the first key.// Search for further keys to strip, with the first key stripped.// Search for further keys to strip, with the first key not stripped.// Special case: If no required type specified, which usually only happens for// Collection elements, or required type is not assignable to registered type,// which usually only happens for generic properties of type Object -// then return PropertyEditor if not registered for Collection or array type.// (If not registered for Collection or array, it is assumed to be intended// for elements.)/** Helper class for calculating property matches, according to a configurable ... */int DEFAULT_MAX_DISTANCE, ...;/** Default maximum property distance: 2. *//** Create PropertyMatches for the given bean property. ... */new BeanPropertyMatches(...)/** Create PropertyMatches for the given field property. ... */new FieldPropertyMatches(...)// Instance state/** Create a new PropertyMatches instance for the given property and possible matches. *//** Return the name of the requested property. *//** Return the calculated possible matches. *//** Build an error message for the given invalid property name, ... */// Implementation support for subclassesthis.possibleMatches.length/** Calculate the distance between the given two Strings ... */int[][] dnew int[][]char c1int costchar c2min(...)// Concrete subclassescalculateMatches(...)/** Generate possible property alternatives for the given property and class. ... */List<String> candidatesString possibleAlternativecalculateStringDistance(...)StringBuilder msgappendHintMessage(...)doWithFields(...)new FieldCallback(...) { ... }/** Object to hold information and value for an individual bean property. ... */boolean optional, ...;Object convertedValue, ...;Boolean conversionNecessary, ...;/** Package-visible field that indicates whether conversion is necessary. */Object resolvedTokens, ...;/** Package-visible field for caching the resolved property path tokens. *//** Create a new PropertyValue instance. ... *//** Copy constructor. ... */this.optionaloriginal.convertedthis.convertedValueoriginal.convertedValuethis.conversionNecessaryoriginal.conversionNecessarythis.resolvedTokensoriginal.resolvedTokenscopyAttributesFrom(...)/** Constructor that exposes a new value for an original value holder. ... *//** Return the name of the property. *//** Return the value of the property. ... *//** Return the original PropertyValue instance for this value holder. ... */PropertyValue original/** Set whether this is an optional value, that is, to be ignored ... *//** Return whether this is an optional value, that is, to be ignored ... *//** Return whether this holder contains a converted value already ({@code true}), ... *//** Set the converted value of this property value, ... *//** Return the converted value of this property value, ... */PropertyValue otherPvotherPv.nameotherPv.valueimport StreamSupport/** Holder containing one or more {@link PropertyValue} objects, ... *//** Return an {@link Iterator} over the property values. ... *//** Return a {@link Spliterator} over the property values. ... *//** Return a sequential {@link Stream} containing the property values. ... *//** Return an array of the PropertyValue objects held in this object. *//** Return the property value with the given name, if any. ... *//** Return the changes since the previous PropertyValues. ... *//** Is there a property value (or other processing entry) for this property? ... *//** Does this holder not contain any PropertyValue objects at all? */import PropertyEditorSupport/** {@link java.beans.PropertyEditor Editor} for a {@link PropertyValues} object. ... */PropertiesEditor propertiesEditor, ...;Properties propsthis.propertiesEditorsetAsText(...)/** Simple implementation of the {@link TypeConverter} interface that does not operate on ... *//** Interface that defines type conversion methods. Typically (but not necessarily) ... *//** Convert the value to the required type (if necessary from a String). ... */import ConversionFailedExceptionimport NumberUtils/** Internal helper class for converting property values to target types. ... */TypeConverterDelegate.classPropertyEditorRegistrySupport propertyEditorRegistry, ...;/** Create a new TypeConverterDelegate for the given editor registry. ... *//** Create a new TypeConverterDelegate for the given editor registry and bean instance. ... */this.propertyEditorRegistry/** Convert the value to the required type for the specified property. ... *//** Convert the value to the required type (if necessary from a String), ... */ConversionFailedException conversionAttemptExConversionService conversionServiceboolean standardConversionTypeDescriptor sourceTypeDescConversionFailedException exTypeDescriptor elementTypeDescfindDefaultEditor(...)doConvertValue(...)convertToTypedArray(...)convertToTypedCollection(...)convertToTypedMap(...)String trimmedValueisEnum(...)Constructor<T> strCtorgetConstructor(...)attemptToConvertStringToEnum(...)convertNumberToTargetClass(...)Optional<>.classempty(...)getDescriptiveType(...)getQualifiedName(...)String enumTypeString fieldNameClass<?> enumValueTypeField enumFieldgetField(...)/** Find a default editor for the given type. ... */findEditorByConvention(...)Object newConvertedValueString newTextValuedoConvertTextValue(...)/** Convert the given text value using the given property editor. ... */Collection<?> collIterator<?> itbuildIndexedPropertyName(...)int arrayLengthhasCustomEditorForElement(...)boolean approximableisApproximableCollectionType(...)boolean originalAllowedTypeDescriptor elementTypeCollection<Object> convertedCopycanCreateCopy(...)createApproximateCollection(...)Object elementString indexedPropertyNameObject convertedElementisApproximableMapType(...)TypeDescriptor keyTypeTypeDescriptor valueTypegetMapValueTypeDescriptor(...)Map<Object,Object> convertedCopycreateApproximateMap(...)Map<>.Entry<?,?>Entry<?,?> entryObject keyString keyedPropertyNamebuildKeyedPropertyName(...)Object convertedKeyhasConstructor(...)// Custom editor for this type?// No custom editor but custom ConversionService specified?// fallback to default conversion logic below// Value not of required type?// Try to apply some standard type conversion rules if appropriate.// Array required -> apply appropriate conversion of elements.// Convert elements to target type, if determined.// Convert keys and values to respective target type, if determined.// We can stringify any primitive value...// proceed with field lookup// It's an empty enum identifier: reset the enum value to null.// convertedValue == null// Original exception from former ConversionService call above...// ConversionService not tried before, probably custom editor found// but editor couldn't produce the required type...// Definitely doesn't match: throw IllegalArgumentException/IllegalStateException// target type is declared as raw enum, treat the trimmed value as <enum.fqn>.FIELD_NAME// Try field lookup as fallback: for JDK 1.5 enum or custom enum// with values defined as static fields. Resulting value still needs// to be checked, hence we don't return it right away.// No custom editor -> check BeanWrapperImpl's default editors.// No BeanWrapper default editor -> check standard JavaBean editor.// Not a String -> use PropertyEditor's setValue.// With standard PropertyEditors, this will return the very same object;// we just want to allow special PropertyEditors to override setValue// for type conversion from non-String values to the required type.// Reset PropertyEditor: It already did a proper conversion.// Don't use it again for a setAsText call.// Swallow and proceed.// Convert String array to a comma-separated String.// Only applies if no PropertyEditor converted the String array before.// The CSV String will be passed into a PropertyEditor's setAsText method, if any.// Use PropertyEditor's setAsText in case of a String value.// Convert Collection elements to array elements.// Convert array elements, if necessary.// A plain value: convert it to an array with a single component./** Base implementation of the {@link TypeConverter} interface, using a package-private delegate. ... */TypeConverterDelegate typeConverterDelegate, ...;/** Exception thrown on a type mismatch when trying to set a bean property. ... *//** Error code that a type mismatch error will be registered with. */Class<?> requiredType, ...;/** Create a new {@code TypeMismatchException}. ... */this.requiredType/** Create a new {@code TypeMismatchException} without a {@code PropertyChangeEvent}. ... *//** Initialize this exception's property name for exposure through {@link #getPropertyName()}, ... *//** Return the offending value (may be {@code null}). *//** Return the required target type, if any. */import BeanWrapperimport PropertyAccessorFactoryimport StringValueResolver/** General utility methods for working with annotations in JavaBeans style. ... *//** Copy the properties of the supplied {@link Annotation} to the supplied target bean. ... */copyPropertiesToBean(...)Set<String> excludedemptySet(...)excludedProperties.lengthMethod[] annotationPropertiesBeanWrapper bwforBeanPropertyAccess(...)Method annotationPropertyisWritableProperty(...)invokeMethod(...)resolveStringValue(...)/** Support package for beans-style handling of Java 5 annotations. *//** A marker superinterface indicating that a bean is eligible to be notified by the ... *//** Callback that allows a bean to be aware of the bean ... *//** Callback that supplies the bean {@link ClassLoader class loader} to ... */import FatalBeanException/** Exception thrown when a BeanFactory encounters an error when ... */String resourceDescription, ...;List<Throwable> relatedCauses, ...;/** Create a new BeanCreationException. ... */this.resourceDescriptioninitCause(...)this.relatedCauses/** Return the description of the resource that the bean ... *//** Return the name of the bean requested, if any. *//** Add a related cause to this bean creation exception, ... */new ArrayList<Throwable>(...)/** Return the related causes, if any. ... */new Throwable[]Throwable relatedCause/** Exception thrown in case of a bean being requested despite ... *//** Create a new BeanCreationNotAllowedException. ... *//** Exception thrown in case of a reference to a bean that's currently in creation. ... *//** Create a new BeanCurrentlyInCreationException, ... *//** Create a new BeanCurrentlyInCreationException. ... *//** Exception thrown when a BeanFactory encounters an invalid bean definition: ... *//** Create a new BeanDefinitionStoreException. ... *//** Return the description of the resource that the bean definition came from, if available. *//** Return the name of the bean, if available. *//** Exception that indicates an expression evaluation attempt having failed. ... *//** Create a new BeanExpressionException with the specified message. ... *//** Create a new BeanExpressionException with the specified message ... *//** The root interface for accessing a Spring bean container. ... */String FACTORY_BEAN_PREFIX, ...;/** Used to dereference a {@link FactoryBean} instance and distinguish it from ... *//** Return an instance, which may be shared or independent, of the specified bean. ... *//** Return the bean instance that uniquely matches the given object type, if any. ... *//** Return a provider for the specified bean, allowing for lazy on-demand retrieval ... *//** Does this bean factory contain a bean definition or externally registered singleton ... *//** Is this bean a shared singleton? That is, will {@link #getBean} always ... *//** Is this bean a prototype? That is, will {@link #getBean} always return ... *//** Check whether the bean with the given name matches the specified type. ... *//** Determine the type of the bean with the given name. More specifically, ... *//** Return the aliases for the given bean name, if any. ... *//** Interface to be implemented by beans that wish to be aware of their ... *//** Callback that supplies the owning factory to a bean instance. ... *//** Convenience methods operating on bean factories, in particular ... */new ConcurrentHashMap<String,String>(...)String GENERATED_BEAN_NAME_SEPARATOR, ...;/** Separator for generated bean names. If a class name or parent name is not ... */Map<String,String> transformedBeanNameCache, ...;/** Cache from name with factory bean prefix to stripped name without dereference. ... *//** Return whether the given name is a factory dereference ... *//** Return the actual bean name, stripping out the factory dereference ... */new Function<String,String>(...) { ... }/** Return whether the given name is a bean name which has been generated ... *//** Extract the "raw" bean name from the given (potentially generated) bean name, ... *//** Count all beans in any hierarchy in which this factory participates. ... */// Retrieval of bean namesbeanNamesIncludingAncestors(...).lengthbeanNamesIncludingAncestors(...)/** Return all bean names in the factory, including ancestor factories. ... *//** Get all bean names for the given type, including those defined in ancestor ... */HierarchicalBeanFactory hbfgetParentBeanFactory(...)String[] parentResultmergeNamesWithParent(...)/** Get all bean names whose {@code Class} has the supplied {@link Annotation} ... */getBeanNamesForAnnotation(...)beanNamesForAnnotationIncludingAncestors(...)/** Return all beans of the given type or subtypes, also picking up beans defined in ... */// Retrieval of bean instancesMap<String,T> resultnew LinkedHashMap<String,T>(...)putAll(...)getBeansOfType(...)Map<String,T> parentResultbeansOfTypeIncludingAncestors(...)new BiConsumer<String,T>(...) { ... }containsLocalBean(...)/** Return a single bean of the given type or subtypes, also picking up beans ... */Map<String,T> beansOfTypeuniqueBean(...)/** Return a single bean of the given type or subtypes, not looking in ancestor ... *//** Merge the given bean names result with the given parent result. ... */List<String> mergedresult.lengthparentResult.length/** Extract a unique bean for the given type from the given Map of matching beans. ... */new NoUniqueBeanDefinitionException(...)new NoSuchBeanDefinitionException(...)/** Exception that a bean implementation is suggested to throw if its own ... *//** Create a new BeanInitializationException with the specified message. ... *//** Create a new BeanInitializationException with the specified message ... *//** Exception thrown when a bean instance has been requested for ... *//** Create a new BeanIsAbstractException. ... *//** Exception thrown when a bean is not a factory, but a user tries to get ... *//** Create a new BeanIsNotAFactoryException. ... *//** Interface to be implemented by beans that want to be aware of their ... *//** Set the name of the bean in the bean factory that created this bean. ... *//** Thrown when a bean doesn't match the expected type. ... *//** The name of the instance that was of the wrong type. *//** The required type. */Class<?> actualType, ...;/** The offending type. *//** Create a new BeanNotOfRequiredTypeException. ... */this.actualType/** Return the name of the instance that was of the wrong type. *//** Return the expected type for the bean. *//** Return the actual type of the instance found. *//** Exception thrown when the BeanFactory cannot load the specified class ... */String beanClassName, ...;/** Create a new CannotLoadBeanClassException. ... */this.beanClassName/** Return the name of the bean requested. *//** Return the name of the class we were trying to load. *//** Interface to be implemented by beans that want to release resources on destruction. ... *//** Invoked by the containing {@code BeanFactory} on destruction of a bean. ... *//** Interface to be implemented by objects used within a {@link BeanFactory} which ... */String OBJECT_TYPE_ATTRIBUTE, ...;/** The name of an attribute that can be ... *//** Return an instance (possibly shared or independent) of the object ... *//** Return the type of object that this FactoryBean creates, ... *//** Is the object managed by this factory a singleton? That is, ... *//** Exception to be thrown from a FactoryBean's {@code getObject()} method ... *//** Create a new FactoryBeanNotInitializedException with the default message. *//** Create a new FactoryBeanNotInitializedException with the given message. ... *//** Sub-interface implemented by bean factories that can be part ... *//** Return the parent bean factory, or {@code null} if there is none. *//** Return whether the local bean factory contains a bean of the given name, ... *//** Interface to be implemented by beans that need to react once all their properties ... *//** Invoked by the containing {@code BeanFactory} after it has set all bean properties ... */import AnnotatedElementimport Member/** A simple descriptor for an injection point, pointing to a method/constructor ... */MethodParameter methodParameter, ...;...[] fieldAnnotations, ...;/** Create an injection point descriptor for a method or constructor parameter. ... */this.methodParameter/** Create an injection point descriptor for a field. ... */original.methodParameteroriginal.fieldthis.fieldAnnotationsoriginal.fieldAnnotations/** Just available for serialization purposes in subclasses. *//** Return the wrapped MethodParameter, if any. ... *//** Return the wrapped Field, if any. ... *//** Return the wrapped MethodParameter, assuming it is present. ... *//** Obtain the annotations associated with the wrapped field or method/constructor parameter. */Annotation[] fieldAnnotationsgetAnnotations(...)getParameterAnnotations(...)obtainMethodParameter(...)/** Retrieve a field/parameter annotation of the given type, if any. ... */getParameterAnnotation(...)/** Return the type declared by the underlying field or method/constructor parameter, ... *//** Returns the wrapped member, containing the injection point. ... */getMember(...)/** Return the wrapped annotated element. ... */getAnnotatedElement(...)InjectionPoint otherPointotherPoint.fieldotherPoint.methodParameter/** Extension of the {@link BeanFactory} interface to be implemented by bean factories ... *//** Check if this bean factory contains a bean definition with the given name. ... *//** Return the number of beans defined in the factory. ... *//** Return the names of all beans defined in this factory. ... *//** Return the names of beans matching the given type (including subclasses), ... *//** Return the bean instances that match the given object type (including ... *//** Find all names of beans which are annotated with the supplied {@link Annotation} ... *//** Find all beans which are annotated with the supplied {@link Annotation} type, ... *//** Find an {@link Annotation} of {@code annotationType} on the specified bean, ... *//** Counterpart of {@link BeanNameAware}. Returns the bean name of an object. ... *//** Return the name of this bean in a Spring bean factory, if known. *//** Exception thrown when a {@code BeanFactory} is asked for a bean instance for which it ... */ResolvableType resolvableType, ...;/** Create a new {@code NoSuchBeanDefinitionException}. ... */this.resolvableType/** Return the name of the missing bean, if it was a lookup <em>by name</em> that failed. *//** Return the required type of the missing bean, if it was a lookup <em>by type</em> ... *//** Return the required {@link ResolvableType} of the missing bean, if it was a lookup ... *//** Return the number of beans found when only one matching bean was expected. ... *//** Exception thrown when a {@code BeanFactory} is asked for a bean instance for which ... */int numberOfBeansFound, ...;Collection<String> beanNamesFound, ...;/** Create a new {@code NoUniqueBeanDefinitionException}. ... */this.numberOfBeansFoundthis.beanNamesFoundcollectionToCommaDelimitedString(...)/** Return the names of all beans found when only one matching bean was expected. ... *//** Defines a factory which can return an Object instance ... *//** Return an instance (possibly shared or independent) ... */import Consumer/** A variant of {@link ObjectFactory} designed specifically for injection points, ... */T dependencygetIfAvailable(...)/** Consume an instance (possibly shared or independent) of the object ... */getIfUnique(...)/** Return an {@link Iterator} over all matching object instances, ... *//** Return a sequential {@link Stream} over all matching object instances, ... *//** Extension of the {@link FactoryBean} interface. Implementations may ... *//** Is the object managed by this factory a prototype? That is, ... *//** Does this FactoryBean expect eager initialization, that is, ... *//** Callback interface triggered at the end of the singleton pre-instantiation phase ... *//** Invoked right at the end of the singleton pre-instantiation phase, ... *//** Exception thrown when a bean depends on other beans or simple properties ... */InjectionPoint injectionPoint, ...;/** Create a new UnsatisfiedDependencyException. ... */this.injectionPoint/** Return the injection point (field or method/constructor parameter), if known. ... */import AnnotationMetadataimport MethodMetadata/** Extended {@link org.springframework.beans.factory.config.BeanDefinition} ... *//** Obtain the annotation metadata (as well as basic class metadata) ... *//** Obtain metadata for this bean definition's factory method, if any. ... */import StandardAnnotationMetadata/** Extension of the {@link org.springframework.beans.factory.support.GenericBeanDefinition} ... */AnnotationMetadata metadata, ...;MethodMetadata factoryMethodMetadata, ...;/** Create a new AnnotatedGenericBeanDefinition for the given bean class. ... */introspect(...)/** Create a new AnnotatedGenericBeanDefinition for the given annotation metadata, ... */getIntrospectedClass(...)this.factoryMethodMetadataimport BeanWiringInfoimport BeanWiringInfoResolver/** {@link org.springframework.beans.factory.wiring.BeanWiringInfoResolver} that ... */Configurable annotationConfigurable.classbuildWiringInfo(...)/** Build the {@link BeanWiringInfo} for the given {@link Configurable} annotation. ... */Autowire.NOautowire(...)new BeanWiringInfo(...)dependencyCheck(...)getDefaultBeanName(...)/** Determine the default bean name for the specified bean instance. ... */// Autowiring by name or by type// Explicitly specified bean name for bean definition to take property values from// Default bean name for bean definition to take property values from/** Enumeration determining autowiring status: that is, whether a bean should ... */new Autowire(...)AutowireCapableBeanFactory.AUTOWIRE_NOAutowireCapableBeanFactory.AUTOWIRE_BY_NAMEAutowireCapableBeanFactory.AUTOWIRE_BY_TYPEAutowire NO, ...;/** Constant that indicates no autowiring at all. */Autowire BY_NAME, ...;/** Constant that indicates autowiring bean properties by name. */Autowire BY_TYPE, ...;/** Constant that indicates autowiring bean properties by type. */int value, ...;/** Return whether this represents an actual autowiring value. ... *//* Copyright 2002-2009 the original author or authors. ... *//** Marks a constructor, field, setter method, or config method as to be autowired by ... */ElementType.CONSTRUCTORElementType.ANNOTATION_TYPE/** Declares whether the annotated dependency is required. ... */import InjectionPointimport UnsatisfiedDependencyExceptionimport DependencyDescriptorimport LookupOverrideimport MergedBeanDefinitionPostProcessorimport AnnotationAttributesimport MergedAnnotationimport MergedAnnotations/** {@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor} ... */new LinkedHashSet<Class<? extends Annotation>>(...)new ConcurrentHashMap<Class<?>,Constructor<?>[]>(...)new ConcurrentHashMap<String,InjectionMetadata>(...)Set<Class<? extends Annotation>> autowiredAnnotationTypes, ...;String requiredParameterName, ...;boolean requiredParameterValue, ...;Set<String> lookupMethodsChecked, ...;Map<Class<?>,Constructor<?>[]> candidateConstructorsCache, ...;Map<String,InjectionMetadata> injectionMetadataCache, ...;/** Create a new {@code AutowiredAnnotationBeanPostProcessor} for Spring's ... */this.autowiredAnnotationTypesAutowired.classValue.classAutowiredAnnotationBeanPostProcessor.class/** Set the 'autowired' annotation type, to be used on constructors, fields, ... *//** Set the 'autowired' annotation types, to be used on constructors, fields, ... *//** Set the name of an attribute of the annotation that specifies whether it is required. ... */this.requiredParameterName/** Set the boolean value that marks a dependency as required. ... */this.requiredParameterValueInjectionMetadata metadatafindAutowiringMetadata(...)checkConfigMembers(...)this.lookupMethodsCheckedthis.injectionMetadataCacheConstructor<?>[] candidateConstructorsthis.candidateConstructorsCacheLookup.classdoWithLocalMethods(...)Lookup lookupLookupOverride overridenew LookupOverride(...)RootBeanDefinition mbdaddOverride(...)getMethodOverrides(...)new BeanCreationException(...)Constructor<?>[] rawCandidatesList<Constructor<?>> candidatesnew ArrayList<Constructor<?>>(...)rawCandidates.lengthConstructor<?> requiredConstructorConstructor<?> defaultConstructorConstructor<?> primaryConstructorint nonSyntheticConstructorsgetDeclaredConstructors(...)Constructor<?> candidateMergedAnnotation<?> annfindAutowiredAnnotation(...)isSynthetic(...)Class<?> userClassConstructor<?> superCtorboolean requireddetermineRequiredStatus(...)new Constructor<?>[]candidateConstructors.lengthinject(...)postProcessProperties(...)/** 'Native' processing method for direct calls with an arbitrary target instance, ... */String cacheKeyneedsRefresh(...)buildAutowiringMetadata(...)List<InjectedElement> elementsnew ArrayList<InjectedElement>(...)InjectionMetadata.EMPTYInjectionMetadata.InjectedElementList<InjectedElement> currElementsdoWithLocalFields(...)new AutowiredFieldElement(...)Method bridgedMethodisVisibilityBridgeMethodPair(...)new AutowiredMethodElement(...)forElements(...)MergedAnnotations annotationsfrom(...)Class<? extends Annotation> typeMergedAnnotation<?> annotation/** Determine if the annotated field or method requires its dependency. ... */new Function<MergedAnnotation<?>,AnnotationAttributes>(...) { ... }new AnnotationAttributes(...)getBoolean(...)/** Obtain all beans of the given type as autowire candidates. ... *//** Register the specified bean as dependent on the autowired beans. */String autowiredBeanNameregisterDependentBean(...)/** Resolve the specified cached method argument or field value. */DependencyDescriptor descriptorresolveDependency(...)/** Class representing injection information about an annotated field. */boolean required, ...;boolean cached, ...;Object cachedFieldValue, ...;this.requiredthis.memberthis.cachedresolvedCachedArgument(...)this.cachedFieldValueDependencyDescriptor descnew DependencyDescriptor(...)Set<String> autowiredBeanNamesnew LinkedHashSet<String>(...)TypeConverter typeConvertersetContainingClass(...)BeansException exnew UnsatisfiedDependencyException(...)new InjectionPoint(...)Object cachedFieldValueregisterDependentBeans(...)new ShortcutDependencyDescriptor(...)/** Class representing injection information about an annotated method. */...[] cachedMethodArguments, ...;Object[] argumentscheckPropertySkipping(...)resolveCachedArguments(...)int argumentCountDependencyDescriptor[] descriptorsnew DependencyDescriptor[]Set<String> autowiredBeansMethodParameter methodParamDependencyDescriptor currDescObject argDependencyDescriptor[] cachedMethodArgumentsthis.cachedMethodArgumentsObject[] cachedMethodArgumentscachedMethodArguments.length/** DependencyDescriptor variant with a pre-resolved target bean name. */String shortcut, ...;this.shortcut// JSR-330 API not available - simply skip.// Let's check for lookup methods here...// Quick check on the concurrent map first, with minimal locking.// Fully synchronized resolution now...// Simply proceed, no equivalent superclass constructor found...// Add default constructor to list of optional constructors, as fallback.// Fall back to class name as cache key, for backwards compatibility with custom callers.// The following (AnnotationAttributes) cast is required on JDK 9+.// Shortcut for avoiding synchronization...import Predicateimport AutowireCandidateQualifier/** Convenience methods performing bean lookups related to Spring-specific annotations, ... *//** Retrieve all bean of type {@code T} from the given {@code BeanFactory} declaring a ... */String[] candidateBeans/** Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a ... *//** Obtain a bean of type {@code T} from the given {@code BeanFactory} declaring a qualifier ... */String matchingBean/** Check whether the named bean declares a qualifier of the given name. ... */test(...)AbstractBeanDefinition abdAutowireCandidateQualifier candidategetQualifier(...)AutowireCandidateQualifier.VALUE_KEYMethod factoryMethodgetResolvedFactoryMethod(...)Qualifier targetAnnotation// Full qualifier matching supported.// Fallback: target bean at least found by bean name.// Fallback: target bean at least found by bean name - probably a manually registered singleton.// Try quick bean name or alias match first...// Explicit qualifier metadata on bean definition? (typically in XML definition)// Corresponding qualifier on factory method? (typically in configuration class)// Corresponding qualifier on bean implementation class? (for custom user types)// Ignore - can't compare qualifiers for a manually registered singleton object/** Marks a class as being eligible for Spring-driven configuration. ... *//** The name of the bean definition that serves as the configuration template. *//** Are dependencies to be injected via autowiring? *//** Is dependency checking to be performed for configured objects? *//** Are dependencies to be injected prior to the construction of an object? */import BeanFactoryPostProcessor/** A {@link org.springframework.beans.factory.config.BeanFactoryPostProcessor} ... */Set<?> customQualifierTypes, ...;// default: same as non-OrderedClassLoader beanClassLoader, ...;this.beanClassLoader/** Register custom qualifier annotation types to be considered ... */this.customQualifierTypesDefaultListableBeanFactory dlbfQualifierAnnotationAutowireCandidateResolver resolvergetAutowireCandidateResolver(...)setAutowireCandidateResolver(...)new QualifierAnnotationAutowireCandidateResolver(...)Class<? extends Annotation> customTyperesolveClassName(...)addQualifierType(...)import DestructionAwareBeanPostProcessornew LifecycleMetadata(...) { ... }InitDestroyAnnotationBeanPostProcessor.LifecycleElementnew ConcurrentHashMap<Class<?>,LifecycleMetadata>(...)LifecycleMetadata emptyLifecycleMetadata, ...;Class<? extends Annotation> initAnnotationType, ...;Class<? extends Annotation> destroyAnnotationType, ...;Map<Class<?>,LifecycleMetadata> lifecycleMetadataCache, ...;/** Specify the init annotation to check for, indicating initialization ... */this.initAnnotationType/** Specify the destroy annotation to check for, indicating destruction ... */this.destroyAnnotationTypeLifecycleMetadata metadatafindLifecycleMetadata(...)invokeInitMethods(...)invokeDestroyMethods(...)hasDestroyMethods(...)this.lifecycleMetadataCachebuildLifecycleMetadata(...)List<LifecycleElement> initMethodsnew ArrayList<LifecycleElement>(...)List<LifecycleElement> destroyMethodsthis.emptyLifecycleMetadataList<LifecycleElement> currInitMethodsList<LifecycleElement> currDestroyMethodsLifecycleElement elementnew LifecycleElement(...)new LifecycleMetadata(...)this.logger/** Class representing information about annotated init and destroy methods. */Collection<LifecycleElement> initMethods, ...;Collection<LifecycleElement> destroyMethods, ...;Set<LifecycleElement> checkedInitMethods, ...;Set<LifecycleElement> checkedDestroyMethods, ...;this.initMethodsthis.destroyMethodsSet<LifecycleElement> checkedInitMethodsnew LinkedHashSet<LifecycleElement>(...)Set<LifecycleElement> checkedDestroyMethodsString methodIdentifiergetIdentifier(...)isExternallyManagedInitMethod(...)registerExternallyManagedInitMethod(...)isExternallyManagedDestroyMethod(...)registerExternallyManagedDestroyMethod(...)this.checkedInitMethodsthis.checkedDestroyMethodsCollection<LifecycleElement> checkedInitMethodsCollection<LifecycleElement> initMethodsToIterateCollection<LifecycleElement> checkedDestroyMethodsCollection<LifecycleElement> destroyMethodsToUseString identifier, ...;this.identifierLifecycleElement otherElementotherElement.identifier// Happens after deserialization, during destruction.../** Internal class for managing injection metadata. ... */new InjectionMetadata(...) { ... }InjectionMetadata EMPTY, ...;/** An empty {@code InjectionMetadata} instance with no-op callbacks. ... */Collection<InjectedElement> injectedElements, ...;Set<InjectedElement> checkedElements, ...;/** Create a new {@code InjectionMetadata instance}. ... */this.injectedElements/** Determine whether this metadata instance needs to be refreshed. ... */Set<InjectedElement> checkedElementsnew LinkedHashSet<InjectedElement>(...)InjectedElement elementMember memberisExternallyManagedConfigMember(...)registerExternallyManagedConfigMember(...)this.checkedElementsCollection<InjectedElement> checkedElementsCollection<InjectedElement> elementsToIterate/** Clear property skipping for the contained elements. ... */clearPropertySkipping(...)/** Return an {@code InjectionMetadata} instance, possibly for empty elements. ... */new InjectionMetadata(...)/** Check whether the given injection metadata needs to be refreshed. ... *//** A single injected element. */Member member, ...;boolean isField, ...;Boolean skip, ...;this.isFieldClass<?> fieldTypeClass<?> paramType/** Either this or {@link #getResourceToInject} needs to be overridden. */getResourceToInject(...)/** Check whether this injector's property needs to be skipped due to ... */Boolean skipthis.skipregisterProcessedProperty(...)/** Clear property skipping for this element. ... */clearProcessedProperty(...)/** Either this or {@link #inject} needs to be overridden. */InjectedElement otherElementotherElement.member// Explicit value provided as part of the bean definition./** An annotation that indicates 'lookup' methods, to be overridden by the container ... *//** This annotation attribute may suggest a target bean name to look up. ... */import Executableimport Parameterimport SynthesizingMethodParameter/** Public delegate for resolving autowirable parameters on externally managed ... */new AnnotatedElement(...) { ... }new Annotation[]AnnotatedElement EMPTY_ANNOTATED_ELEMENT, ...;/** Determine if the supplied {@link Parameter} can <em>potentially</em> be ... */AnnotatedElement annotatedParametergetEffectiveAnnotatedParameter(...)/** Resolve the dependency for the supplied {@link Parameter} from the ... */Autowired autowiredfindMergedAnnotation(...)required(...)MethodParameter methodParameterforExecutable(...)getDeclaringExecutable(...)/** Due to a bug in {@code javac} on JDK versions prior to JDK 9, looking up ... */Executable executableisInnerClass(...)getParameterAnnotations(...).length// Bug in javac in JDK <9: annotation array excludes enclosing instance parameter// for inner classes, so access it with the actual parameter index lowered by 1/** This annotation may be used on a field or parameter as a qualifier for ... *//* Copyright 2002-2011 the original author or authors. ... */import AutowireCandidateResolverimport GenericTypeAwareAutowireCandidateResolver/** {@link AutowireCandidateResolver} implementation that matches bean definition qualifiers ... */Set<Class<? extends Annotation>> qualifierTypes, ...;Class<? extends Annotation> valueAnnotationType, ...;/** Create a new QualifierAnnotationAutowireCandidateResolver ... */this.qualifierTypesQualifierAnnotationAutowireCandidateResolver.class/** Register the given type to be used as a qualifier when autowiring. ... *//** Set the 'value' annotation type, to be used on fields, method parameters ... */this.valueAnnotationType/** Determine whether the provided bean definition is an autowire candidate. ... */checkQualifiers(...)getMethodParameter(...)getMethodAnnotations(...)/** Match the given qualifier annotations against the candidate bean definition. */SimpleTypeConverter typeConverterAnnotation annotationboolean checkMetaboolean fallbackToMetaisQualifier(...)checkQualifier(...)boolean foundMetaAnnotation metaAnnClass<? extends Annotation> metaType/** Checks whether the given annotation type is a recognized qualifier type. */Class<? extends Annotation> qualifierType/** Match the given qualifier annotation against the candidate bean definition. */AutowireCandidateQualifier qualifierMap<String,Object> attributesgetAnnotationAttributes(...)Annotation targetAnnotationgetQualifiedElementAnnotation(...)getFactoryMethodAnnotation(...)RootBeanDefinition dbdgetResolvedDecoratedDefinition(...)hasBeanClass(...)Entry<String,Object> entryMap<>.Entry<String,Object>Object expectedValueObject actualValuematchesName(...)getDefaultValue(...)AnnotatedElement qualifiedElementgetQualifiedElement(...)Method resolvedFactoryMethod/** Determine whether the given dependency declares an autowired annotation, ... */isRequired(...)/** Determine whether the given dependency declares a qualifier annotation. ... */Annotation ann/** Determine whether the given dependency declares a value annotation. ... */findValue(...)/** Determine a suggested value from any of the given candidate annotations. */annotationsToSearch.lengthAnnotationAttributes attrgetMergedAnnotationAttributes(...)forAnnotations(...)extractValue(...)/** Extract the value attribute from the given annotation. ... */AnnotationUtils.VALUE// Only accept fallback match if @Qualifier annotation has a value...// Otherwise it is just a marker for a custom qualifier annotation.// First, check annotation on qualified element, if any// Then, check annotation on factory method, if applicable// Look for matching annotation on the target class// Not the usual case - simply forget about the type check...// If no attributes, the qualifier must be present// Check qualifier first// Fall back on bean definition attribute// Fall back on bean name (or alias) match// Fall back on default, but only if the qualifier is present// qualifier annotations have to be local/** Marks a method (typically a JavaBean setter method) as being 'required': that is, ... */Required.classRequiredAnnotationBeanPostProcessor.classString SKIP_REQUIRED_CHECK_ATTRIBUTE, ...;Class<? extends Annotation> requiredAnnotationType, ...;Set<String> validatedBeanNames, ...;/** Cache for validated bean names, skipping re-validation for the same bean. *//** Set the 'required' annotation type, to be used on bean property ... */this.requiredAnnotationType/** Return the 'required' annotation type. */this.validatedBeanNamesList<String> invalidPropertiesisRequiredProperty(...)buildExceptionMessage(...)/** Check whether the given bean definition is not subject to the annotation-based ... */getFactoryBeanName(...)/** Is the supplied property required to have a value (that is, to be dependency-injected)? ... */Method settergetRequiredAnnotationType(...)/** Build an exception message for the given list of invalid properties. ... *//** Annotation used at the field or method/constructor parameter level ... *//** The actual value expression such as <code>#{systemProperties.myProp}</code> ... *//** Support package for annotation-driven bean configuration. *//** Simple template superclass for {@link FactoryBean} implementations that ... */boolean initialized, ...;T singletonInstance, ...;T earlySingletonInstance, ...;/** Set if a singleton should be created, or a new object on each request ... *//** Return the BeanFactory that this bean runs in. *//** Obtain a bean type converter from the BeanFactory that this bean ... *//** Eagerly create the singleton instance, if necessary. */this.initializedcreateInstance(...)this.earlySingletonInstance/** Expose the singleton instance or create a new prototype instance. ... */getEarlySingletonInstance(...)/** Determine an 'early singleton' instance, exposed in case of a ... */getEarlySingletonInterfaces(...)new EarlySingletonInvocationHandler(...)/** Expose the singleton instance (for access through the 'early singleton' proxy). ... *//** Destroy the singleton instance, if any. ... */destroyInstance(...)/** This abstract method declaration mirrors the method in the FactoryBean ... *//** Template method that subclasses must override to construct ... *//** Return an array of interfaces that a singleton object exposed by this ... *//** Callback for destroying a singleton instance. Subclasses may ... *//** Reflective InvocationHandler for lazy access to the actual singleton object. */identityHashCode(...)// Only consider equal when proxies are identical.// Use hashCode of reference proxy./** Extension of the {@link org.springframework.beans.factory.BeanFactory} ... */int AUTOWIRE_NO, ...;/** Constant that indicates no externally defined autowiring. Note that ... */int AUTOWIRE_BY_NAME, ...;/** Constant that indicates autowiring bean properties by name ... */int AUTOWIRE_BY_TYPE, ...;/** Constant that indicates autowiring bean properties by type ... */int AUTOWIRE_CONSTRUCTOR, ...;/** Constant that indicates autowiring the greediest constructor that ... */int AUTOWIRE_AUTODETECT, ...;/** Constant that indicates determining an appropriate autowire strategy ... */String ORIGINAL_INSTANCE_SUFFIX, ...;/** Suffix for the "original instance" convention when initializing an existing ... *//** Fully create a new bean instance of the given class. ... *///-------------------------------------------------------------------------// Typical methods for creating and populating external bean instances/** Populate the given bean instance through applying after-instantiation callbacks ... *//** Configure the given raw bean: autowiring bean properties, applying ... *//** Fully create a new bean instance of the given class with the specified ... */// Specialized methods for fine-grained control over the bean lifecycle/** Instantiate a new bean instance of the given class with the specified autowire ... *//** Autowire the bean properties of the given bean instance by name or type. ... *//** Apply the property values of the bean definition with the given name to ... *//** Initialize the given raw bean, applying factory callbacks ... *//** Apply {@link BeanPostProcessor BeanPostProcessors} to the given existing bean ... *//** Destroy the given bean instance (typically coming from {@link #createBean}), ... *//** Resolve the bean instance that uniquely matches the given object type, if any, ... */// Delegate methods for resolving injection points/** Resolve a bean instance for the given bean name, providing a dependency descriptor ... *//** Resolve the specified dependency against the beans defined in this factory. ... *//** Simple marker class for an individually autowired property value, to be added ... */new AutowiredPropertyMarker(...)Object INSTANCE, ...;/** The canonical instance for the autowired marker value. */AutowiredPropertyMarker.classimport BeanMetadataElementimport AttributeAccessor/** A BeanDefinition describes a bean instance, which has property values, ... */ConfigurableBeanFactory.SCOPE_SINGLETONConfigurableBeanFactory.SCOPE_PROTOTYPEString SCOPE_SINGLETON, ...;/** Scope identifier for the standard singleton scope: {@value}. ... */String SCOPE_PROTOTYPE, ...;/** Scope identifier for the standard prototype scope: {@value}. ... */int ROLE_APPLICATION, ...;/** Role hint indicating that a {@code BeanDefinition} is a major part ... */int ROLE_SUPPORT, ...;/** Role hint indicating that a {@code BeanDefinition} is a supporting ... */int ROLE_INFRASTRUCTURE, ...;/** Role hint indicating that a {@code BeanDefinition} is providing an ... *//** Set the name of the parent definition of this bean definition, if any. */// Modifiable attributes/** Return the name of the parent definition of this bean definition, if any. *//** Specify the bean class name of this bean definition. ... *//** Return the current bean class name of this bean definition. ... *//** Override the target scope of this bean, specifying a new scope name. ... *//** Return the name of the current target scope for this bean, ... *//** Set whether this bean should be lazily initialized. ... *//** Return whether this bean should be lazily initialized, i.e. not ... *//** Set the names of the beans that this bean depends on being initialized. ... *//** Return the bean names that this bean depends on. *//** Set whether this bean is a candidate for getting autowired into some other bean. ... *//** Return whether this bean is a candidate for getting autowired into some other bean. *//** Set whether this bean is a primary autowire candidate. ... *//** Return whether this bean is a primary autowire candidate. *//** Specify the factory bean to use, if any. ... *//** Return the factory bean name, if any. *//** Specify a factory method, if any. This method will be invoked with ... *//** Return a factory method, if any. *//** Return the constructor argument values for this bean. ... *//** Return if there are constructor argument values defined for this bean. ... *//** Return the property values to be applied to a new instance of the bean. ... *//** Return if there are property values defined for this bean. ... *//** Set the name of the initializer method. ... *//** Return the name of the initializer method. ... *//** Set the name of the destroy method. ... *//** Return the name of the destroy method. ... *//** Set the role hint for this {@code BeanDefinition}. The role hint ... *//** Get the role hint for this {@code BeanDefinition}. The role hint ... *//** Set a human-readable description of this bean definition. ... *//** Return a human-readable description of this bean definition. *//** Return a resolvable type for this bean definition, ... */// Read-only attributes/** Return whether this a <b>Singleton</b>, with a single, shared instance ... *//** Return whether this a <b>Prototype</b>, with an independent instance ... *//** Return whether this bean is "abstract", that is, not meant to be instantiated. *//** Return a description of the resource that this bean definition ... *//** Return the originating BeanDefinition, or {@code null} if none. ... *//** Callback for customizing a given bean definition. ... *//** Customize the given bean definition. *//** Holder for a BeanDefinition with name and aliases. ... */BeanDefinition beanDefinition, ...;...[] aliases, ...;/** Create a new BeanDefinitionHolder. ... */this.beanDefinitionthis.aliases/** Copy constructor: Create a new BeanDefinitionHolder with the ... *//** Return the wrapped BeanDefinition. *//** Return the primary name of the bean, as specified for the bean definition. *//** Return the alias names for the bean, as specified directly for the bean definition. ... *//** Expose the bean definition's source object. ... *//** Determine whether the given candidate name matches the bean name ... */transformedBeanName(...)/** Return a friendly, short description for the bean, stating name and aliases. ... *//** Return a long description for the bean, including name and aliases ... *//** This implementation returns the long description. Can be overridden ... */getLongDescription(...)BeanDefinitionHolder otherHolderotherHolder.beanDefinitionotherHolder.beanNameotherHolder.aliasesimport PropertyValue/** Visitor class for traversing {@link BeanDefinition} objects, in particular ... */StringValueResolver valueResolver, ...;/** Create a new BeanDefinitionVisitor, applying the specified ... */this.valueResolver/** Create a new BeanDefinitionVisitor for subclassing. ... *//** Traverse the given BeanDefinition object and the MutablePropertyValues ... */visitParentName(...)visitBeanClassName(...)visitFactoryBeanName(...)visitFactoryMethodName(...)visitScope(...)hasPropertyValues(...)visitPropertyValues(...)hasConstructorArgumentValues(...)ConstructorArgumentValues casvisitIndexedArgumentValues(...)getIndexedArgumentValues(...)visitGenericArgumentValues(...)getGenericArgumentValues(...)String parentNamegetParentName(...)String resolvedNamesetParentName(...)String factoryBeanNamesetFactoryBeanName(...)String factoryMethodNamegetFactoryMethodName(...)String scopeString resolvedScopePropertyValue[] pvArrayObject newValresolveValue(...)ConstructorArgumentValues.ValueHolderValueHolder valueHoldervisitBeanDefinition(...)RuntimeBeanReference refString newBeanNameRuntimeBeanNameReference refvisitArray(...)visitList(...)visitSet(...)visitMap(...)TypedStringValue typedStringValueString stringValueString visitedStringarrayVal.lengthSet<> newContentnew LinkedHashSet<>(...)boolean entriesModifiedint elemHashint newValHashMap<> newContentnew LinkedHashMap<>(...)Entry<> entryMap<>.Entry<>int keyHashObject newKeyint newKeyHash/** Resolve the given String value, for example parsing placeholders. ... */String resolvedValue// Return original String if not modified./** Context object for evaluating an expression within a bean definition. ... */Scope scope, ...;this.scoperesolveContextualObject(...)BeanExpressionContext otherContextotherContext.beanFactoryotherContext.scope/** Strategy interface for resolving a value through evaluating it ... *//** Evaluate the given value as an expression, if applicable; ... *//** Factory hook that allows for custom modification of an application context's ... *//** Modify the application context's internal bean factory after its standard ... *//** Factory hook that allows for custom modification of new bean instances &mdash; ... *//** Apply this {@code BeanPostProcessor} to the given new bean instance <i>before</i> any bean ... *//** Apply this {@code BeanPostProcessor} to the given new bean instance <i>after</i> any bean ... *//** Interface that exposes a reference to a bean name in an abstract fashion. ... *//** Return the target bean name that this reference points to (never {@code null}). */import PropertyEditorRegistrarimport PropertyEditorRegistryimport HierarchicalBeanFactoryimport ApplicationStartup/** Configuration interface to be implemented by most bean factories. Provides ... *//** Set the parent of this bean factory. ... *//** Set the class loader to use for loading bean classes. ... *//** Return this factory's class loader for loading bean classes ... *//** Specify a temporary ClassLoader to use for type matching purposes. ... *//** Return the temporary ClassLoader to use for type matching purposes, ... *//** Set whether to cache bean metadata such as given bean definitions ... *//** Return whether to cache bean metadata such as given bean definitions ... *//** Specify the resolution strategy for expressions in bean definition values. ... *//** Return the resolution strategy for expressions in bean definition values. ... *//** Return the associated ConversionService, if any. ... *//** Add a PropertyEditorRegistrar to be applied to all bean creation processes. ... *//** Register the given custom property editor for all properties of the ... *//** Initialize the given PropertyEditorRegistry with the custom editors ... *//** Set a custom type converter that this BeanFactory should use for converting ... *//** Obtain a type converter as used by this BeanFactory. This may be a fresh ... *//** Add a String resolver for embedded values such as annotation attributes. ... *//** Determine whether an embedded value resolver has been registered with this ... *//** Resolve the given embedded value, e.g. an annotation attribute. ... *//** Add a new BeanPostProcessor that will get applied to beans created ... *//** Return the current number of registered BeanPostProcessors, if any. *//** Register the given scope, backed by the given Scope implementation. ... *//** Return the names of all currently registered scopes. ... *//** Return the Scope implementation for the given scope name, if any. ... *//** Set the {@code ApplicationStartup} for this bean factory. ... *//** Return the {@code ApplicationStartup} for this bean factory. ... *//** Provides a security access control context relevant to this factory. ... *//** Copy all relevant configuration from the given other factory. ... *//** Given a bean name, create an alias. We typically use this method to ... *//** Resolve all alias target names and aliases registered in this ... *//** Return a merged BeanDefinition for the given bean name, ... *//** Determine whether the bean with the given name is a FactoryBean. ... *//** Explicitly control the current in-creation status of the specified bean. ... *//** Determine whether the specified bean is currently in creation. ... *//** Register a dependent bean for the given bean, ... *//** Return the names of all beans which depend on the specified bean, if any. ... *//** Return the names of all beans that the specified bean depends on, if any. ... *//** Destroy the given bean instance (usually a prototype instance ... *//** Destroy the specified scoped bean in the current target scope, if any. ... *//** Destroy all singleton beans in this factory, including inner beans that have ... *//** Configuration interface to be implemented by most listable bean factories. ... *//** Ignore the given dependency type for autowiring: ... *//** Ignore the given dependency interface for autowiring. ... *//** Register a special dependency type with corresponding autowired value. ... *//** Determine whether the specified bean qualifies as an autowire candidate, ... *//** Return the registered BeanDefinition for the specified bean, allowing access ... *//** Return a unified view over all bean names managed by this factory. ... *//** Clear the merged bean definition cache, removing entries for beans ... *//** Freeze all bean definitions, signalling that the registered bean definitions ... *//** Return whether this factory's bean definitions are frozen, ... *//** Ensure that all non-lazy-init singletons are instantiated, also considering ... */import Mergeable/** Holder for constructor argument values, typically as part of a bean definition. ... */new LinkedHashMap<Integer,ValueHolder>(...)new ArrayList<ValueHolder>(...)Map<Integer,ValueHolder> indexedArgumentValues, ...;List<ValueHolder> genericArgumentValues, ...;/** Create a new empty ConstructorArgumentValues object. *//** Deep copy constructor. ... */addArgumentValues(...)/** Copy all given argument values into this object, using separate holder ... */other.indexedArgumentValuesnew BiConsumer<Integer,ValueHolder>(...) { ... }addOrMergeIndexedArgumentValue(...)filter(...)other.genericArgumentValuesnew Predicate<ValueHolder>(...) { ... }this.genericArgumentValuesnew Consumer<ValueHolder>(...) { ... }addOrMergeGenericArgumentValue(...)/** Add an argument value for the given index in the constructor argument list. ... */new ValueHolder(...)/** Add an argument value for the given index in the constructor argument list, ... */ValueHolder currentValuethis.indexedArgumentValues/** Check whether an argument value has been registered for the given index. ... *//** Get argument value for the given index in the constructor argument list. ... */getIndexedArgumentValue(...)matchesTypeName(...)/** Return the map of indexed argument values. ... *//** Add a generic argument value to be matched by type. ... *//** Add a generic argument value to be matched by type or name (if available). ... *//** Add a generic argument value, merging the new value (typically a collection) ... */Iterator<ValueHolder> it/** Look for a generic argument value that matches the given type. ... */getGenericArgumentValue(...)/** Look for the next generic argument value that matches the given type, ... *//** Return the list of generic argument values. ... *//** Look for an argument value that either corresponds to the given index ... */getArgumentValue(...)/** Return the number of argument values held in this instance, ... *//** Return if this holder does not contain any argument values, ... *//** Clear this holder, removing all argument values. */ConstructorArgumentValues thatIterator<ValueHolder> it1Iterator<ValueHolder> it2that.genericArgumentValuesthat.indexedArgumentValuesValueHolder vh1ValueHolder vh2contentEquals(...)Entry<Integer,ValueHolder> entryMap<>.Entry<Integer,ValueHolder>contentHashCode(...)... ^ .../** Holder for a constructor argument value, with an optional type ... */String type, ...;/** Create a new ValueHolder for the given value. ... *//** Create a new ValueHolder for the given value and type. ... */this.type/** Create a new ValueHolder for the given value, type and name. ... *//** Set the value for the constructor argument. *//** Return the value for the constructor argument. *//** Set the type of the constructor argument. *//** Return the type of the constructor argument. *//** Set the name of the constructor argument. *//** Return the name of the constructor argument. *//** Set the converted value of the constructor argument, ... *//** Return the converted value of the constructor argument, ... *//** Determine whether the content of this ValueHolder is equal ... */other.valueother.type/** Determine whether the hash code of the content of this ValueHolder. ... *//** Create a copy of this ValueHolder: that is, an independent ... */ValueHolder copy/** {@link BeanFactoryPostProcessor} implementation that allows for convenient ... */...[] propertyEditorRegistrars, ...;Map<Class<?>,Class<? extends PropertyEditor>> customEditors, ...;/** Specify the {@link PropertyEditorRegistrar PropertyEditorRegistrars} ... */this.propertyEditorRegistrars/** Specify the custom editors to register via a {@link Map}, using the ... */PropertyEditorRegistrar propertyEditorRegistraraddPropertyEditorRegistrar(...)new BiConsumer<Class<?>,Class<? extends PropertyEditor>>(...) { ... }/** Simple {@link BeanFactoryPostProcessor} implementation that registers ... */Map<String,Object> scopes, ...;/** Specify the custom scopes that are to be registered. ... */this.scopes/** Add the given scope to this configurer's map of scopes. ... */new LinkedHashMap<String,Object>(...)new BiConsumer<String,Object>(...) { ... }registerScope(...)Class<?> scopeClassimport ParameterizedTypeimport KProperty/** Descriptor for a specific dependency that is about to be injected. ... */int parameterIndex, ...;String fieldName, ...;boolean eager, ...;int nestingLevel, ...;Class<?> containingClass, ...;TypeDescriptor typeDescriptor, ...;/** Create a new descriptor for a method or constructor parameter. ... */getExecutable(...)this.parameterIndexgetParameterIndex(...)this.containingClassgetContainingClass(...)this.eager/** Create a new descriptor for a field. ... */this.fieldNameoriginal.declaringClassoriginal.methodNameoriginal.parameterTypesoriginal.parameterIndexoriginal.fieldNameoriginal.containingClassoriginal.requiredoriginal.eagerthis.nestingLeveloriginal.nestingLevel/** Return whether this dependency is required. ... */hasNullableAnnotation(...)isNullable(...)/** Check whether the underlying field is annotated with any variant of a ... *//** Return whether this dependency is 'eager' in the sense of ... *//** Resolve the specified not-unique scenario: by default, ... *//** Resolve a shortcut for this dependency against the given factory, for example ... *//** Resolve the specified bean name, as a candidate result of the matching ... *//** Increase this descriptor's nesting level. *//** Optionally set the concrete class that contains this dependency. ... *//** Build a {@link ResolvableType} object for the wrapped parameter/field. ... */ResolvableType resolvableType/** Build a {@link TypeDescriptor} object for the wrapped parameter/field. ... */this.typeDescriptorgetDependencyType(...)/** Return whether a fallback match is allowed. ... *//** Return a variant of this descriptor that is intended for a fallback match. ... */new DependencyDescriptor(...) { ... }/** Initialize parameter name discovery for the underlying method parameter, if any. ... */initParameterNameDiscovery(...)/** Determine the name of the wrapped parameter/field. ... */getParameterName(...)/** Determine the declared (non-generic) type of the wrapped parameter/field. ... */Type typegetGenericType(...)Type[] argsgetActualTypeArguments(...)Type arggetRawType(...)getNestedParameterType(...)DependencyDescriptor otherDescotherDesc.requiredotherDesc.eagerotherDesc.nestingLevelotherDesc.containingClass/** Check whether the specified {@link Field} represents a nullable Kotlin type or not. */KProperty<?> propertygetKotlinProperty(...)isMarkedNullable(...)// Restore reflective handles (which are unfortunately not serializable)/** Bean factory post processor that logs a warning for {@link Deprecated @Deprecated} beans. ... *//** Set the name of the logger to use. ... */getBeanDefinitionNames(...)String nameToLookupisFactoryBean(...)Deprecated.classlogDeprecatedBean(...)/** Logs a warning for a bean annotated with {@link Deprecated @Deprecated}. ... */StringBuilder builderString resourceDescriptiongetResourceDescription(...)/** Actually write to the underlying log. ... *//** Determine whether the {@link #logger} field is enabled. ... *//** Subinterface of {@link BeanPostProcessor} that adds a before-destruction callback. ... *//** Apply this BeanPostProcessor to the given bean instance before its ... *//** Determine whether the given bean instance requires destruction by this ... *//** {@link StringValueResolver} adapter for resolving placeholders and ... */BeanExpressionContext exprContext, ...;BeanExpressionResolver exprResolver, ...;this.exprContextnew BeanExpressionContext(...)this.exprResolvergetBeanExpressionResolver(...)String valueresolveEmbeddedValue(...)Object evaluatedevaluate(...)/** {@link FactoryBean} which retrieves a static or non-static field value. ... */String targetField, ...;String staticField, ...;Field fieldObject, ...;// the field we will retrieve/** Set the target class on which the field is defined. ... *//** Return the target class on which the field is defined. *//** Set the target object on which the field is defined. ... *//** Return the target object on which the field is defined. *//** Set the name of the field to be retrieved. ... */this.targetFieldtrimAllWhitespace(...)/** Return the name of the field to be retrieved. *//** Set a fully qualified static field name to retrieve, ... */this.staticField/** The bean name of this FieldRetrievingFactoryBean will be interpreted ... */originalBeanName(...)int lastDotIndexthis.fieldObject// If no other property specified, consider bean name as static field expression.// Try to parse static field into class and field.// Either targetClass or targetObject specified.// Try to get the exact method first.// instance field// class field/** Subinterface of {@link BeanPostProcessor} that adds a before-instantiation callback, ... *//** Apply this BeanPostProcessor <i>before the target bean gets instantiated</i>. ... *//** Perform operations after the bean has been instantiated, via a constructor or factory method, ... *//** Post-process the given property values before the factory applies them ... *//** Adapter that implements all methods on {@link SmartInstantiationAwareBeanPostProcessor} ... *//** Simple factory for shared List instances. Allows for central setup ... */List<?> sourceList, ...;Class<? extends List<>> targetListClass, ...;/** Set the source List, typically populated via XML "list" elements. */this.sourceList/** Set the class to use for the target List. Can be populated with a fully ... */this.targetListClassList<Object> resultClass<?> valueTypeTypeConverter convertergetBeanTypeConverter(...)/** Simple factory for shared Map instances. Allows for central setup ... */Map<?,?> sourceMap, ...;Class<? extends Map<>> targetMapClass, ...;/** Set the source Map, typically populated via XML "map" elements. */this.sourceMap/** Set the class to use for the target Map. Can be populated with a fully ... */this.targetMapClassMap<Object,Object> resultClass<?> keyTypenewLinkedHashMap(...)ResolvableType mapTypeimport ArgumentConvertingMethodInvoker/** Simple method invoker bean: just invoking a target method, not expecting a result ... *//** Obtain the TypeConverter from the BeanFactory that this bean runs in, ... */getDefaultTypeConverter(...)prepare(...)invokeWithTargetException(...)/** Perform the invocation and convert InvocationTargetException ... *//** {@link FactoryBean} which returns a value which is the result of a static or instance ... */Object singletonObject, ...;/** Method call result in the singleton case. *//** Set if a singleton should be created, or a new object on each ... */this.singletonObject/** Returns the same value each time if the singleton property is set ... */isPrepared(...)getPreparedMethod(...)// Singleton: return shared object.// Prototype: new object on each call.// Not fully initialized yet -> return null to indicate "not known yet"./** A simple holder for a given bean name plus bean instance. ... */T beanInstance, ...;/** Create a new holder for the given bean name plus instance. ... */this.beanInstance/** Return the name of the bean. *//** Return the corresponding bean instance. */import ObjectFactory/** A {@link org.springframework.beans.factory.FactoryBean} implementation that ... *//** Set the name of the target bean. ... */afterPropertiesSet(...)ObjectFactory<>.classnew TargetBeanObjectFactory(...)/** Independent inner class - for serialization purposes. *//** Abstract base class for property resource configurers that resolve placeholders ... */String DEFAULT_PLACEHOLDER_PREFIX, ...;/** Default placeholder prefix: {@value}. */String DEFAULT_PLACEHOLDER_SUFFIX, ...;/** Default placeholder suffix: {@value}. */String DEFAULT_VALUE_SEPARATOR, ...;/** Default value separator: {@value}. */String placeholderPrefix, ...;/** Defaults to {@value #DEFAULT_PLACEHOLDER_PREFIX}. */String placeholderSuffix, ...;/** Defaults to {@value #DEFAULT_PLACEHOLDER_SUFFIX}. */String valueSeparator, ...;/** Defaults to {@value #DEFAULT_VALUE_SEPARATOR}. */boolean trimValues, ...;String nullValue, ...;boolean ignoreUnresolvablePlaceholders, ...;/** Set the prefix that a placeholder string starts with. ... */this.placeholderPrefix/** Set the suffix that a placeholder string ends with. ... */this.placeholderSuffix/** Specify the separating character between the placeholder variable ... */this.valueSeparator/** Specify whether to trim resolved values before applying them, ... */this.trimValues/** Set a value that should be treated as {@code null} when resolved ... */this.nullValue/** Set whether to ignore unresolvable placeholders. ... */this.ignoreUnresolvablePlaceholders/** Only necessary to check that we're not parsing our own bean definition, ... */BeanDefinitionVisitor visitornew BeanDefinitionVisitor(...)String curNameresolveAliases(...)addEmbeddedValueResolver(...)// Check that we're not parsing our own bean definition,// to avoid failing on unresolvable placeholders in properties file locations.// New in Spring 2.5: resolve placeholders in alias target names and aliases as well.// New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.import BackingStoreExceptionimport Preferences/** Subclass of PropertyPlaceholderConfigurer that supports JDK 1.4's ... */systemRoot(...)userRoot(...)String systemTreePath, ...;String userTreePath, ...;Preferences systemPrefs, ...;Preferences userPrefs, ...;/** Set the path in the system preferences tree to use for resolving ... */this.systemTreePaththis.userTreePath/** This implementation eagerly fetches the Preferences instances ... */this.systemPrefsnode(...)this.userPrefs/** This implementation tries to resolve placeholders as keys first ... */String pathint endOfPathresolvePlaceholder(...)/** Resolve the given path and key against the given Preferences. ... */nodeExists(...)BackingStoreException ex// Do not create the node if it does not exist...import PropertiesLoaderSupport/** Allows for making a properties file from a classpath location available ... */Properties singletonInstance, ...;/** Set whether a shared 'singleton' Properties instance should be ... */createProperties(...)/** Template method that subclasses may override to construct the object ... */mergeProperties(...)/** Property resource configurer that overrides bean property values in an application ... */String DEFAULT_BEAN_NAME_SEPARATOR, ...;/** The default bean name separator. */String beanNameSeparator, ...;boolean ignoreInvalidKeys, ...;Set<String> beanNames, ...;/** Contains names of beans that have overrides. *//** Set the separator to expect between bean name and property path. ... */this.beanNameSeparator/** Set whether to ignore invalid keys. Default is "false". ... */this.ignoreInvalidKeysEnumeration<?> namespropertyNames(...)processKey(...)/** Process the given key as 'beanName.property' entry. */String beanPropertyapplyPropertyValue(...)/** Apply the given property value to the corresponding bean. */BeanDefinition bdToUsegetOriginatingBeanDefinition(...)setOptional(...)/** Were there overrides for this bean? ... *//** {@link FactoryBean} that evaluates a property path on a given target object. ... */PropertyPathFactoryBean.classBeanWrapper targetBeanWrapper, ...;String propertyPath, ...;Class<?> resultType, ...;/** Specify a target object to apply the property path to. ... */this.targetBeanWrapper/** Specify the name of a target bean to apply the property path to. ... *//** Specify the property path to apply to the target. ... */this.propertyPath/** Specify the type of the result from evaluating the property path. ... */this.resultType/** The bean name of this PropertyPathFactoryBean will be interpreted ... */int dotIndexBeanWrapper target/** While this FactoryBean will often be used for singleton targets, ... */// No other properties specified: check bean name.// either targetObject or targetBeanName specified// Eagerly fetch singleton target bean, and determine result type.// Fetch prototype target bean...import AbstractEnvironmentimport PropertyPlaceholderHelperimport PlaceholderResolver/** {@link PlaceholderConfigurerSupport} subclass that resolves ${...} placeholders against ... */AbstractEnvironment.IGNORE_GETENV_PROPERTY_NAMEint SYSTEM_PROPERTIES_MODE_NEVER, ...;/** Never check system properties. */int SYSTEM_PROPERTIES_MODE_FALLBACK, ...;/** Check system properties if not resolvable in the specified properties. ... */int SYSTEM_PROPERTIES_MODE_OVERRIDE, ...;/** Check system properties first, before trying the specified properties. ... */Constants constants, ...;int systemPropertiesMode, ...;boolean searchSystemEnvironment, ...;/** Set the system property mode by the name of the corresponding constant, ... */this.systemPropertiesModeintValue(...)asNumber(...)/** Set how to check system properties: as fallback, as override, or never. ... *//** Set whether to search for a matching system environment variable ... */this.searchSystemEnvironment/** Resolve the given placeholder using the given properties, performing ... */String propValresolveSystemProperty(...)/** Resolve the given placeholder using the given properties. ... *//** Resolve the given key as JVM system property, and optionally also as ... */getenv(...)/** Visit each bean definition in the given bean factory and attempt to replace ${...} property ... */StringValueResolver valueResolvernew PlaceholderResolvingStringValueResolver(...)doProcessProperties(...)PropertyPlaceholderHelper helper, ...;PlaceholderResolver resolver, ...;this.helpernew PropertyPlaceholderHelper(...)this.resolvernew PropertyPlaceholderConfigurerResolver(...)String resolvedProperties props, ...;this.propsPropertyPlaceholderConfigurer.this/** Allows for configuration of individual bean property values from a property resource, ... *//** Set the order value of this object for sorting purposes. ... *//** {@linkplain #mergeProperties Merge}, {@linkplain #convertProperties convert} and ... */Properties mergedPropsconvertProperties(...)processProperties(...)/** Convert the given merged properties, converting property values ... */Enumeration<?> propertyNamesString propertyValueString convertedValueconvertProperty(...)/** Convert the given property from the properties source to the value ... */convertPropertyValue(...)/** Convert the given property value from the properties source to the value ... *//** Apply the given Properties to the given BeanFactory. ... */// Convert the merged properties, if necessary.// Let the subclass process the properties.import ProviderProvider<>.classnew TargetBeanProvider(...)/** Immutable placeholder class used for a property value object when it's a ... *//** Create a new RuntimeBeanNameReference to the given bean name. ... */RuntimeBeanNameReference thatthat.beanName/** Immutable placeholder class used for a property value object when it's ... */Class<?> beanType, ...;boolean toParent, ...;/** Create a new RuntimeBeanReference to the given bean name. ... *//** Create a new RuntimeBeanReference to the given bean name, ... */this.beanTypethis.toParent/** Create a new RuntimeBeanReference to a bean of the given type. ... *//** Create a new RuntimeBeanReference to a bean of the given type, ... *//** Return the requested bean name, or the fully-qualified type name ... *//** Return the requested bean type if resolution by type is demanded. ... *//** Return whether this is an explicit reference to a bean in the parent factory. */RuntimeBeanReference thatthat.beanTypethat.toParent/** Strategy interface used by a {@link ConfigurableBeanFactory}, ... *//** Return the object with the given name from the underlying scope, ... *//** Remove the object with the given {@code name} from the underlying scope. ... *//** Register a callback to be executed on destruction of the specified ... *//** Resolve the contextual object for the given key, if any. ... *//** Return the <em>conversation ID</em> for the current underlying scope, if any. ... *//** A {@link FactoryBean} implementation that takes an interface which must have one or more ... */Class<?> serviceLocatorInterface, ...;Constructor<Exception> serviceLocatorExceptionConstructor, ...;Properties serviceMappings, ...;/** Set the service locator interface to use, which must have one or more methods with ... */this.serviceLocatorInterface/** Set the exception class that the service locator should throw if service ... */this.serviceLocatorExceptionConstructordetermineServiceLocatorExceptionConstructor(...)/** Set mappings between service ids (passed into the service locator) ... */this.serviceMappingsnew ServiceLocatorInvocationHandler(...)/** Determine the constructor to use for the given service locator exception ... */NoSuchMethodException ex2NoSuchMethodException ex3/** Create a service locator exception for the given cause. ... */Object[] args/** Invocation handler that delegates service locator calls to the bean factory. */invokeServiceLocatorMethod(...)Class<?> serviceLocatorMethodReturnTypegetServiceLocatorMethodReturnType(...)tryGetBeanName(...)createServiceLocatorException(...)/** Check whether a service id was passed in. */Method interfaceMethodClass<?> serviceLocatorReturnType// Create service locator proxy.// Use hashCode of service locator proxy.// Service locator for a specific bean name// Service locator for a bean type// Look for explicit serviceId-to-beanName mappings.// Check whether the method is a valid service locator./** Simple factory for shared Set instances. Allows for central setup ... */Set<?> sourceSet, ...;Class<? extends Set<>> targetSetClass, ...;/** Set the source Set, typically populated via XML "set" elements. */this.sourceSet/** Set the class to use for the target Set. Can be populated with a fully ... */this.targetSetClassSet<Object> resultnew LinkedHashSet<Object>(...)/** Interface that defines a registry for shared bean instances. ... *//** Register the given existing object as singleton in the bean registry, ... *//** Return the (raw) singleton object registered under the given name. ... *//** Check if this registry contains a singleton instance with the given name. ... *//** Return the names of singleton beans registered in this registry. ... *//** Return the number of singleton beans registered in this registry. ... *//** Return the singleton mutex used by this registry (for external collaborators). ... *//** Extension of the {@link InstantiationAwareBeanPostProcessor} interface, ... *//** Predict the type of the bean to be eventually returned from this ... *//** Determine the candidate constructors to use for the given bean. ... *//** Obtain a reference for early access to the specified bean, ... *//** Holder for a typed String value. Can be added to bean definitions ... */String value, ...;Object targetType, ...;String specifiedTypeName, ...;boolean dynamic, ...;/** Create a new {@link TypedStringValue} for the given String value. ... *//** Create a new {@link TypedStringValue} for the given String value ... */setTargetType(...)setTargetTypeName(...)/** Set the String value. ... *//** Return the String value. *//** Set the type to convert to. ... */this.targetType/** Return the type to convert to. */Object targetTypeValue/** Specify the type to convert to. *//** Return whether this typed String value carries a target type . *//** Determine the type to convert to, resolving it from a specified class name ... */String typeNamegetTargetTypeName(...)Class<?> resolvedClass/** Set the type name as actually specified for this particular value, if any. */this.specifiedTypeName/** Return the type name as actually specified for this particular value, if any. *//** Mark this value as dynamic, i.e. as containing an expression ... */this.dynamic/** Return whether this value has been marked as dynamic. */TypedStringValue otherValueotherValue.valueotherValue.targetType/** Factory for a {@code Map} that reads from a YAML source, preserving the ... */Map<String,Object> map, ...;this.mapMap<String,Object> resultprocess(...)new MatchCallback(...) { ... }Object existing// Inner cast required by Eclipse IDE.import Collectorsimport DumperOptionsimport LoaderOptionsimport Yamlimport UnicodeReaderimport Representer/** Base class for YAML factories. ... */ResolutionMethod.OVERRIDEnew Resource[]ResolutionMethod resolutionMethod, ...;...[] resources, ...;List<DocumentMatcher> documentMatchers, ...;boolean matchDefault, ...;Set<String> supportedTypes, ...;/** A map of document matchers allowing callers to selectively use only ... */this.documentMatchers/** Flag indicating that a document for which all the ... */this.matchDefault/** Method to use for resolving resources. Each resource will be converted to a Map, ... */this.resolutionMethod/** Set locations of YAML {@link Resource resources} to be loaded. ... */this.resources/** Set the supported types that can be loaded from YAML documents. ... */this.supportedTypesnoNullElements(...)collect(...)map(...)collectingAndThen(...)new Function<Class<?>,String>(...) { ... }toSet(...)new Function<Set<String>,Set<String>>(...) { ... }unmodifiableSet(...)/** Provide an opportunity for subclasses to process the Yaml parsed from the supplied ... */Yaml yamlcreateYaml(...)Resource resourceboolean foundResolutionMethod.FIRST_FOUND/** Create the {@link Yaml} instance to use. ... */LoaderOptions loaderOptionsnew LoaderOptions(...)setAllowDuplicateKeys(...)new Yaml(...)new FilteringConstructor(...)new Representer(...)new DumperOptions(...)Reader readernew UnicodeReader(...)getInputStream(...)Object objectloadAll(...)handleProcessError(...)ResolutionMethod.OVERRIDE_AND_IGNOREnew BiConsumer<Object,Object>(...) { ... }Properties propertiescreateStringAdaptingProperties(...)MatchStatus resultMatchStatus.ABSTAINgetFlattenedMap(...)DocumentMatcher matcherMatchStatus matchgetMostSpecific(...)MatchStatus.FOUND/** Return a flattened version of the given map, recursively following any nested Map ... */buildFlattenedMap(...)Map<String,Object> mapCollection<Object> collectionsingletonMap(...)/** Callback interface used to process the YAML parsing results. *//** Process the given representation of the parsing results. ... *//** Strategy interface used to test if properties match. *//** Test if the given properties match. ... *//** Status returned from {@link DocumentMatcher#matches(java.util.Properties)}. */new MatchStatus(...)MatchStatus FOUND, ...;/** A match was found. */MatchStatus NOT_FOUND, ...;/** No match was found. */MatchStatus ABSTAIN, ...;/** The matcher should not be considered. *//** Compare two {@link MatchStatus} items, returning the most specific status. */ordinal(...)/** Method to use for resolving resources. */new ResolutionMethod(...)ResolutionMethod OVERRIDE, ...;/** Replace values from earlier in the list. */ResolutionMethod OVERRIDE_AND_IGNORE, ...;/** Replace values from earlier in the list, ignoring any failures. */ResolutionMethod FIRST_FOUND, ...;/** Take the first resource in the list that exists and use just that. *//** {@link Constructor} that supports filtering of unsupported types. ... */YamlProcessor.this.supportedTypesYamlProcessor.thisgetClassForName(...)// YAML can have numbers as keys// A document can be a text literal// It has to be a map key in this case// Need a compound key/** Factory for {@link java.util.Properties} that reads from a YAML source, ... */Properties properties, ...;this.propertiesProperties result/** SPI interfaces and configuration-related convenience classes for bean factories. */import Bindingimport Closureimport GStringimport GroovyObjectimport GroovyObjectSupportimport GroovyShellimport GroovySystemimport MetaClassimport DefaultGroovyMethodsimport InvokerHelperimport Locationimport Problemimport AbstractBeanDefinitionReaderimport ManagedMapimport BeanDefinitionParserDelegateimport NamespaceHandlerimport DescriptiveResourceimport EncodedResource/** A Groovy-based reader for Spring bean definitions: like a Groovy builder, ... */new HashMap<String,String>(...)new HashMap<String,DeferredProperty>(...)getMetaClass(...)getMetaClassRegistry(...)XmlBeanDefinitionReader standardXmlBeanDefinitionReader, ...;/** Standard {@code XmlBeanDefinitionReader} created with default ... */XmlBeanDefinitionReader groovyDslXmlBeanDefinitionReader, ...;/** Groovy DSL {@code XmlBeanDefinitionReader} for loading bean definitions ... */Map<String,String> namespaces, ...;Map<String,DeferredProperty> deferredProperties, ...;MetaClass metaClass, ...;Binding binding, ...;GroovyBeanDefinitionWrapper currentBeanDefinition, ...;/** Create a new {@code GroovyBeanDefinitionReader} for the given ... */this.standardXmlBeanDefinitionReaderthis.groovyDslXmlBeanDefinitionReadersetValidating(...)/** Create a new {@code GroovyBeanDefinitionReader} based on the given ... */this.metaClass/** Set the binding, i.e. the Groovy variables available in the scope ... */this.binding/** Return a specified binding for Groovy variables, if any. *//** Load bean definitions from the specified Groovy script or XML file. ... */// TRADITIONAL BEAN DEFINITION READER METHODSnew EncodedResource(...)String filenamegetFilename(...)getResource(...)Closure<Object> beansnew Closure<Object>(...) { ... }invokeBeanDefiningClosure(...)Binding bindingnew Binding(...) { ... }applyPropertyToBeanDefinition(...)setVariable(...)int countBeforeendsWithIgnoreCase(...)GroovyShell shellnew GroovyShell(...)getReader(...)new BeanDefinitionParsingException(...)new Problem(...)new Location(...)/** Defines a set of beans for the given block or closure. ... */// METHODS FOR CONSUMPTION IN A GROOVY CLOSURE/** Define an inner bean definition. ... */GenericBeanDefinition beanDefinitionGroovyBeanDefinitionWrapper currentthis.currentBeanDefinitionClosure<?> callableCollection<Object> constructorArgsObject lastArgresolveConstructorArguments(...)new GroovyBeanDefinitionWrapper(...)/** Define a Spring XML namespace definition to use. ... */Entry<String,String> entryMap<>.Entry<String,String>String namespaceString uriNamespaceHandler namespaceHandlergetNamespaceHandlerResolver(...)new DescriptiveResource(...)this.namespaces/** Import Spring bean definitions from either XML or Groovy sources into the ... *//** This method overrides method invocation to create beans for each method name that ... */// INTERNAL HANDLING OF GROOVY CLOSURES AND PROPERTIESMetaClass mcbeans(...)String refNameboolean parentRefGroovyDynamicElementReader readercreateDynamicElementReader(...)invokeBeanDefiningMethod(...)respondsTo(...)this.deferredPropertiesnew DeferredProperty(...)DeferredProperty dpdp.valuemanageListIfNecessary(...)manageMapIfNecessary(...)apply(...)/** When a method argument is only a closure it is a set of bean definitions. ... */setDelegate(...)finalizeDeferredProperties(...)/** This method is called when a bean definition node is called. ... */boolean hasClosureArgumentGroovyBeanDefinitionWrapper beanDefinitionList<Object> constructorArgsMap<?,?> namedArgsString propNameEntry<?,?> factoryBeanEntryint constructorArgsTestint endOfConstructArgssetAbstract(...)setResolveStrategy(...)Closure<>.DELEGATE_FIRSTGroovyBeanDefinitionWrapper.classObject[] constructorArgscopyOfRange(...)/** Checks whether there are any {@link RuntimeBeanReference RuntimeBeanReferences} ... */boolean containsRuntimeRefsMap<Object,Object> managedMapnew ManagedMap<Object,Object>(...)List<Object> managedListnew ManagedList<Object>(...)/** This method overrides property setting in the scope of the {@code GroovyBeanDefinitionReader} ... */addDeferredProperty(...)addProperty(...)/** This method overrides property retrieval in the scope of the ... */hasVariable(...)getVariable(...)new GroovyRuntimeBeanReference(...)createReaderContext(...)BeanDefinitionParserDelegate delegatenew BeanDefinitionParserDelegate(...)boolean decoratingnew GroovyDynamicElementReader(...) { ... }this.decorating/** This class is used to defer the adding of a property to a bean definition ... */GroovyBeanDefinitionWrapper beanDefinition, ...;/** A RuntimeBeanReference that takes care of adding new properties to runtime references. */new GroovyPropertyValue(...)/** Wraps a bean definition property and ensures that any RuntimeBeanReference ... */Object propertyValue, ...;this.propertyValueupdateDeferredProperties(...)// Check for XML files and redirect them to the "standard" XmlBeanDefinitionReader// abstract bean definition// named constructor arguments// factory method syntax// First arg is the map containing factoryBean : factoryMethod// If we have a closure body, that will be the last argument.// In between are the constructor args// If we have more than this number of args, we have constructor args// factory-method requires args// This is to deal with the case where the property setter is the last// statement in a closure (hence the return value)import BeanWrapperImpl/** Internal wrapper for a Spring BeanDefinition, allowing for Groovy-style ... */String PARENT, ...;String AUTOWIRE, ...;String CONSTRUCTOR_ARGS, ...;String FACTORY_BEAN, ...;String FACTORY_METHOD, ...;String INIT_METHOD, ...;String DESTROY_METHOD, ...;String SINGLETON, ...;List<String> dynamicProperties, ...;Collection<?> constructorArgs, ...;AbstractBeanDefinition definition, ...;BeanWrapper definitionWrapper, ...;String parentName, ...;this.definitioncreateBeanDefinition(...)AbstractBeanDefinition bdnew ConstructorArgumentValues(...)Object constructorArgsetConstructorArgumentValues(...)this.parentNamethis.definitionWrapperisReadableProperty(...)setParent(...)setAutowireMode(...)AbstractBeanDefinition.AUTOWIRE_BY_NAMEAbstractBeanDefinition.AUTOWIRE_BY_TYPEAbstractBeanDefinition.AUTOWIRE_CONSTRUCTORList<?> argssetInitMethodName(...)setDestroyMethodName(...)// constructorArgs// factoryBean// factoryMethod// initMethod// destroyMethod// singleton property/** The core package implementing Spring's lightweight Inversion of Control (IoC) container. ... *//** Base implementation of {@link ComponentDefinition} that provides a basic implementation of ... *//** Delegates to {@link #getName}. *//** Returns an empty array. *//** Delegates to {@link #getDescription}. */getDescription(...)/** Representation of an alias that has been registered during the parsing process. ... */String alias, ...;/** Create a new AliasDefinition. ... */this.alias/** Return the canonical name of the bean. *//** Return the alias registered for the bean. *//** ComponentDefinition based on a standard BeanDefinition, exposing the given bean ... */...[] innerBeanDefinitions, ...;/** Create a new BeanComponentDefinition for the given bean. ... */List<BeanDefinition> innerBeansList<BeanReference> referencesPropertyValues propertyValuesPropertyValue propertyValuethis.innerBeanDefinitions/** This implementation returns this ComponentDefinition's description. ... *//** This implementations expects the other object to be of type BeanComponentDefinition ... *//** Exception thrown when a bean definition reader encounters an error ... *//** Create a new BeanDefinitionParsingException. ... */getRootCause(...)/** {@link ParseState} entry representing a bean definition. ... */String beanDefinitionName, ...;/** Create a new {@code BeanEntry} instance. ... */this.beanDefinitionName/** Interface that describes the logical view of a set of {@link BeanDefinition BeanDefinitions} ... *//** Get the user-visible name of this {@code ComponentDefinition}. ... *//** Return a friendly description of the described component. ... *//** Return the {@link BeanDefinition BeanDefinitions} that were registered ... *//** Return the {@link BeanDefinition BeanDefinitions} that represent all relevant ... *//** Return the set of {@link BeanReference BeanReferences} that are considered ... *//** {@link ComponentDefinition} implementation that holds one or more nested ... */new ArrayList<ComponentDefinition>(...)List<ComponentDefinition> nestedComponents, ...;/** Create a new CompositeComponentDefinition. ... *//** Add the given component as nested element of this composite component. ... */this.nestedComponents/** Return the nested components that this composite component holds. ... */new ComponentDefinition[]/** {@link ParseState} entry representing a (possibly indexed) ... */int index, ...;/** Creates a new instance of the {@link ConstructorArgumentEntry} class ... */this.index/** Marker interface for a defaults definition, ... *//** Empty implementation of the {@link ReaderEventListener} interface, ... */// no-op/** Simple {@link ProblemReporter} implementation that exhibits fail-fast ... *//** Set the {@link Log logger} that is to be used to report warnings. ... *//** Throws a {@link BeanDefinitionParsingException} detailing the error ... *//** Writes the supplied {@link Problem} to the {@link Log} at {@code WARN} level. ... *//** Representation of an import that has been processed during the parsing process. ... */String importedResource, ...;...[] actualResources, ...;/** Create a new ImportDefinition. ... */this.importedResourcethis.actualResources/** Return the location of the imported resource. *//** Class that models an arbitrary location in a {@link Resource resource}. ... */Resource resource, ...;/** Create a new instance of the {@link Location} class. ... */this.resource/** Get the resource with which this location is associated. *//** Get the actual location within the associated {@link #getResource() resource} ... *//** Simple implementation of {@link SourceExtractor} that returns {@code null} ... *//** This implementation simply returns {@code null} for any input. */import ArrayDeque/** Simple {@link ArrayDeque}-based structure for tracking the logical position during ... */ArrayDeque<Entry> state, ...;/** Internal {@link ArrayDeque} storage. *//** Create a new {@code ParseState} with an empty {@link ArrayDeque}. */this.statenew ArrayDeque<Entry>(...)/** Create a new {@code ParseState} whose {@link ArrayDeque} is a clone ... */other.state/** Add a new {@link Entry} to the {@link ArrayDeque}. *//** Remove an {@link Entry} from the {@link ArrayDeque}. *//** Return the {@link Entry} currently at the top of the {@link ArrayDeque} or ... */peek(...)/** Create a new instance of {@link ParseState} which is an independent snapshot ... *//** Returns a tree-style representation of the current {@code ParseState}. */Entry entry/** Marker interface for entries into the {@link ParseState}. *//** Simple {@link SourceExtractor} implementation that just passes ... *//** Simply returns the supplied {@code sourceCandidate} as-is. ... *//** Represents a problem with a bean definition configuration. ... */Location location, ...;Throwable rootCause, ...;/** Create a new instance of the {@link Problem} class. ... */this.rootCause/** Get the message detailing the problem. *//** Get the location within a bean configuration source that triggered the error. *//** Get the description of the bean configuration source that triggered the error, ... *//** Get the {@link ParseState} at the time of the error (may be {@code null}). *//** Get the underlying exception that caused the error (may be {@code null}). */getParseState(...)/** SPI interface allowing tools and other external processes to handle errors ... *//** Called when a fatal error is encountered during the parsing process. ... *//** Called when an error is encountered during the parsing process. ... *//** Called when a warning is raised during the parsing process. ... *//** {@link ParseState} entry representing a JavaBean property. ... *//** Create a new {@code PropertyEntry} instance. ... *//** {@link ParseState} entry representing an autowire candidate qualifier. ... */String typeName, ...;/** Create a new {@code QualifierEntry} instance. ... */this.typeName/** Context that gets passed along a bean definition reading process, ... */ProblemReporter problemReporter, ...;ReaderEventListener eventListener, ...;SourceExtractor sourceExtractor, ...;/** Construct a new {@code ReaderContext}. ... */this.problemReporterthis.sourceExtractor/** Raise a fatal error. */// Errors and warningsLocation location/** Raise a regular error. *//** Raise a non-critical warning. */warning(...)/** Fire a defaults-registered event. */// Explicit parse eventsdefaultsRegistered(...)/** Fire a component-registered event. */componentRegistered(...)/** Fire an alias-registered event. */aliasRegistered(...)new AliasDefinition(...)/** Fire an import-processed event. */importProcessed(...)new ImportDefinition(...)/** Return the source extractor in use. */// Source extraction/** Call the source extractor for the given source object. ... */import EventListener/** Interface that receives callbacks for component, alias and import ... *//** Notification that the given defaults has been registered. ... *//** Notification that the given component has been registered. ... *//** Notification that the given alias has been registered. ... *//** Notification that the given import has been processed. ... *//** Simple strategy allowing tools to control how source metadata is attached ... *//** Extract the source metadata from the candidate object supplied ... *//** Support infrastructure for bean definition parsing. */import ServiceLoaderimport AbstractFactoryBean/** Abstract base class for FactoryBeans operating on the ... */Class<?> serviceType, ...;/** Specify the desired service type (typically the service's public API). */this.serviceType/** Return the desired service type. *//** Delegates to {@link #getObjectToExpose(java.util.ServiceLoader)}. ... */getServiceType(...)getObjectToExpose(...)/** Determine the actual object to expose for the given ServiceLoader. ... *//** {@link org.springframework.beans.factory.FactoryBean} that exposes the ... *//** {@link org.springframework.beans.factory.FactoryBean} that exposes <i>all</i> ... */Object loaderObjectServiceLoader<>.class/** Support package for the Java 6 ServiceLoader facility. */import PropertyAccessorUtilsimport AutowiredPropertyMarkerimport InstantiationAwareBeanPostProcessorimport MethodCallback/** Abstract bean factory superclass that implements default bean creation, ... */new HashSet<Class<?>>(...)new ConcurrentHashMap<String,BeanWrapper>(...)new ConcurrentHashMap<Class<?>,Method[]>(...)new ConcurrentHashMap<Class<?>,PropertyDescriptor[]>(...)InstantiationStrategy instantiationStrategy, ...;/** Strategy for creating bean instances. *//** Resolver strategy for method parameter names. */boolean allowCircularReferences, ...;/** Whether to automatically try to resolve circular references between beans. */boolean allowRawInjectionDespiteWrapping, ...;/** Whether to resort to injecting a raw bean instance in case of circular reference, ... */Set<Class<?>> ignoredDependencyTypes, ...;/** Dependency types to ignore on dependency check and autowire, as Set of ... */Set<Class<?>> ignoredDependencyInterfaces, ...;/** Dependency interfaces to ignore on dependency check and autowire, as Set of ... */NamedThreadLocal<String> currentlyCreatedBean, ...;/** The name of the currently created bean, for implicit dependency registration ... */ConcurrentMap<String,BeanWrapper> factoryBeanInstanceCache, ...;/** Cache of unfinished FactoryBean instances: FactoryBean name to BeanWrapper. */ConcurrentMap<Class<?>,Method[]> factoryMethodCandidateCache, ...;/** Cache of candidate factory methods per factory class. */ConcurrentMap<Class<?>,PropertyDescriptor[]> filteredPropertyDescriptorsCache, ...;/** Cache of filtered PropertyDescriptors: bean Class to PropertyDescriptor array. *//** Create a new AbstractAutowireCapableBeanFactory. */ignoreDependencyInterface(...)BeanNameAware.classBeanFactoryAware.classBeanClassLoaderAware.classthis.instantiationStrategynew SimpleInstantiationStrategy(...)new CglibSubclassingInstantiationStrategy(...)/** Create a new AbstractAutowireCapableBeanFactory with the given parent. ... */setParentBeanFactory(...)/** Set the instantiation strategy to use for creating bean instances. ... *//** Return the instantiation strategy to use for creating bean instances. *//** Set the ParameterNameDiscoverer to use for resolving method parameter ... *//** Return the ParameterNameDiscoverer to use for resolving method parameter ... *//** Set whether to allow circular references between beans - and automatically ... */this.allowCircularReferences/** Set whether to allow the raw injection of a bean instance into some other ... */this.allowRawInjectionDespiteWrappingthis.ignoredDependencyTypesthis.ignoredDependencyInterfacesAbstractAutowireCapableBeanFactory otherAutowireFactoryotherAutowireFactory.instantiationStrategyotherAutowireFactory.allowCircularReferencesotherAutowireFactory.ignoredDependencyTypesotherAutowireFactory.ignoredDependencyInterfacesbd.allowCachingcreateBean(...)initBeanWrapper(...)populateBean(...)BeanDefinition mbdmarkBeanAsCreated(...)RootBeanDefinition rbdcloneBeanDefinition(...)initializeBean(...)getResolvedAutowireMode(...)autowireConstructor(...)getAccessControlContext(...)instantiate(...)getInstantiationStrategy(...)applyPropertyValues(...)BeanPostProcessor processorpostProcessBeforeInitialization(...)postProcessAfterInitialization(...)new DisposableBeanAdapter(...)getBeanPostProcessorCache(...).destructionAwaregetBeanPostProcessorCache(...)InjectionPoint previousInjectionPointsetCurrentInjectionPoint(...)/** Central method of this class: creates a bean instance, ... */// Implementation of relevant AbstractBeanFactory template methodsRootBeanDefinition mbdToUseresolveBeanClass(...)prepareMethodOverrides(...)BeanDefinitionValidationException exresolveBeforeInstantiation(...)doCreateBean(...)/** Actually create the specified bean. Pre-creation processing has already happened ... */BeanWrapper instanceWrapperboolean earlySingletonExposureisSingletonCurrentlyInCreation(...)Object exposedObjectthis.factoryBeanInstanceCachecreateBeanInstance(...)NullBean.classmbd.resolvedTargetTypembd.postProcessingLockmbd.postProcessedapplyMergedBeanDefinitionPostProcessors(...)addSingletonFactory(...)new ObjectFactory<Object>(...) { ... }getEarlyBeanReference(...)Object earlySingletonReferencegetSingleton(...)hasDependentBean(...)String[] dependentBeansgetDependentBeans(...)Set<String> actualDependentBeansdependentBeans.lengthString dependentBeanremoveSingletonIfCreatedForTypeCheckOnly(...)new BeanCurrentlyInCreationException(...)registerDisposableBeanIfNecessary(...)determineTargetType(...)hasInstantiationAwareBeanPostProcessors(...)boolean matchingOnlyFactoryBeantypesToMatch.lengthSmartInstantiationAwareBeanPostProcessor bpgetBeanPostProcessorCache(...).smartInstantiationAwareClass<?> predictedpredictBeanType(...)/** Determine the target type for the given bean definition. ... */getTargetType(...)getTypeForFactoryMethod(...)getTempClassLoader(...)/** Determine the target type for the given bean definition which is based on ... */ResolvableType cachedReturnTypembd.factoryMethodReturnTypeClass<?> commonTypeMethod uniqueCandidatembd.factoryMethodToIntrospectClass<?> factoryClassint minNrOfArgsgetArgumentCount(...)this.factoryMethodCandidateCachenew Function<Class<?>,Method[]>(...) { ... }getUniqueDeclaredMethods(...)isFactoryMethod(...)getTypeParameters(...).lengthgetTypeParameters(...)ParameterNameDiscoverer pndgetParameterNameDiscoverer(...)Set<ValueHolder> usedValueHoldersnew HashSet<ValueHolder>(...)resolveReturnTypeForFactoryMethod(...)determineCommonAncestor(...)/** This implementation attempts to query the FactoryBean's generic parameter metadata ... */ResolvableType resultgetTypeForFactoryBeanFromAttributes(...)ResolvableType beanTypeResolvableType.NONEgetInstanceSupplier(...)getFactoryBeanGeneric(...)mbd.targetTypeBeanDefinition factoryBeanDefinitionClass<?> factoryBeanClassRootBeanDefinition fbmbdgetTypeForFactoryBeanFromMethod(...)isBeanEligibleForMetadataCaching(...)FactoryBean<?> factoryBeangetSingletonFactoryBeanForTypeCheck(...)getNonSingletonFactoryBeanForTypeCheck(...)getTypeForFactoryBean(...)getGeneric(...)/** Introspect the factory method signatures on the given bean class, ... */FactoryBeanMethodTypeFinder findernew FactoryBeanMethodTypeFinder(...)getResult(...)/** Obtain a "shortcut" singleton FactoryBean instance to use for a ... */// Implementation methodsFactoryBean<?> fbgetFactoryBean(...)beforeSingletonCreation(...)UnsatisfiedDependencyException exonSuppressedException(...)afterSingletonCreation(...)/** Obtain a "shortcut" non-singleton FactoryBean instance to use for a ... */isPrototypeCurrentlyInCreation(...)beforePrototypeCreation(...)afterPrototypeCreation(...)/** Apply MergedBeanDefinitionPostProcessors to the specified bean definition, ... */MergedBeanDefinitionPostProcessor processorgetBeanPostProcessorCache(...).mergedDefinitionpostProcessMergedBeanDefinition(...)/** Apply before-instantiation post-processors, resolving whether there is a ... */mbd.beforeInstantiationResolvedapplyBeanPostProcessorsBeforeInstantiation(...)applyBeanPostProcessorsAfterInitialization(...)/** Apply InstantiationAwareBeanPostProcessors to the specified bean definition ... */InstantiationAwareBeanPostProcessor bpgetBeanPostProcessorCache(...).instantiationAwarepostProcessBeforeInstantiation(...)/** Create a new instance for the specified bean, using an appropriate instantiation strategy: ... */Supplier<?> instanceSupplierboolean resolvedboolean autowireNecessarydetermineConstructorsFromBeanPostProcessors(...)isNonPublicAccessAllowed(...)obtainFromSupplier(...)instantiateUsingFactoryMethod(...)mbd.constructorArgumentLockmbd.resolvedConstructorOrFactoryMethodmbd.constructorArgumentsResolvedinstantiateBean(...)getPreferredConstructors(...)/** Obtain a bean instance from the given supplier. ... */String outerBeanthis.currentlyCreatedBeannew NullBean(...)/** Overridden in order to implicitly register the currently created bean as ... */String currentlyCreatedBeangetObjectForBeanInstance(...)/** Determine candidate constructors to use for the given bean, checking all registered ... */determineCandidateConstructors(...)/** Instantiate the given bean using its default constructor. ... *//** Instantiate the bean using a named factory method. The method may be static, if the ... */new ConstructorResolver(...)/** "autowire constructor" (with constructor arguments by type) behavior. ... *//** Populate the bean instance in the given BeanWrapper with the property values ... */PropertyValues pvsint resolvedAutowireModeboolean hasInstAwareBppsboolean needsDepCheckgetDependencyCheck(...)AbstractBeanDefinition.DEPENDENCY_CHECK_NONEPropertyDescriptor[] filteredPdspostProcessAfterInstantiation(...)MutablePropertyValues newPvsautowireByName(...)autowireByType(...)PropertyValues pvsToUsefilterPropertyDescriptorsForDependencyCheck(...)mbd.allowCachingpostProcessPropertyValues(...)checkDependencies(...)/** Fill in any missing property values with references to ... */String[] propertyNamesunsatisfiedNonSimpleProperties(...)/** Abstract method defining "autowire by type" (bean properties by type) behavior. ... */getCustomTypeConverter(...)boolean eagernew AutowireByTypeDependencyDescriptor(...)Object autowiredArgument/** Return an array of non-simple bean properties that are unsatisfied. ... */Set<String> resultnew TreeSet<String>(...)isExcludedFromDependencyCheck(...)isSimpleProperty(...)/** Extract a filtered set of PropertyDescriptors from the given BeanWrapper, ... */PropertyDescriptor[] filteredthis.filteredPropertyDescriptorsCachePropertyDescriptor[] existingList<PropertyDescriptor> pdsnew ArrayList<PropertyDescriptor>(...)new Predicate<PropertyDescriptor>(...) { ... }/** Determine whether the given bean property is excluded from dependency checks. ... */isSetterDefinedInInterface(...)/** Perform a dependency check that all properties exposed have been set, ... */int dependencyCheckboolean isSimpleboolean unsatisfiedAbstractBeanDefinition.DEPENDENCY_CHECK_ALLAbstractBeanDefinition.DEPENDENCY_CHECK_SIMPLEAbstractBeanDefinition.DEPENDENCY_CHECK_OBJECTS/** Apply the given property values, resolving any runtime references ... */MutablePropertyValues mpvsList<PropertyValue> originalBeanDefinitionValueResolver valueResolvernew BeanDefinitionValueResolver(...)List<PropertyValue> deepCopyboolean resolveNecessaryObject resolvedValueresolveValueIfNecessary(...)boolean convertibleisNestedOrIndexedProperty(...)AutowiredPropertyMarker.INSTANCEsetConvertedValue(...)isDynamic(...)setConverted(...)/** Convert the given value for the specified target property. *//** Initialize the given bean instance, applying factory callbacks ... */Object wrappedBeaninvokeAwareMethods(...)applyBeanPostProcessorsBeforeInitialization(...)setBeanName(...)ClassLoader bclsetBeanClassLoader(...)AbstractAutowireCapableBeanFactory.this/** Give a bean a chance to react now all its properties are set, ... */boolean isInitializingBeanString initMethodNamegetInitMethodName(...)invokeCustomInitMethod(...)/** Invoke the specified custom init method on the given bean. ... */Method initMethodMethod methodToInvokegetInterfaceMethodIfPossible(...)isEnforceInitMethod(...)new BeanDefinitionValidationException(...)/** Applies the {@code postProcessAfterInitialization} callback of all ... *//** Overridden to clear FactoryBean instance cache as well. */removeSingleton(...)clearSingletonCache(...)/** Expose the logger to collaborating delegates. ... *//** Special DependencyDescriptor variant for Spring's good old autowire="byType" mode. ... *//** {@link MethodCallback} used to find {@link FactoryBean} type information. */String factoryMethodName, ...;ResolvableType result, ...;this.factoryMethodNameisFactoryBeanMethod(...)ResolvableType returnTypeResolvableType candidatethis.resultClass<?> resolvedResultClass<?> commonAncestorClass<?> resolvedboolean foundResult// Use prototype bean definition, to avoid registering bean as dependent bean.// Use non-singleton bean definition, to avoid registering bean as dependent bean.// Make sure bean class is actually resolved at this point, and// clone the bean definition in case of a dynamically resolved Class// which cannot be stored in the shared merged bean definition.// Prepare method overrides.// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.// A previously detected exception with proper bean creation context already,// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.// Instantiate the bean.// Allow post-processors to modify the merged bean definition.// Eagerly cache singletons to be able to resolve circular references// even when triggered by lifecycle interfaces like BeanFactoryAware.// Initialize the bean instance.// Register bean as disposable.// Apply SmartInstantiationAwareBeanPostProcessors to predict the// eventual type after a before-instantiation shortcut.// Check declared factory method return type on factory class.// Check declared factory method return type on bean class.// If all factory methods have the same return type, return that type.// Can't clearly figure out exact method due to type converting / autowiring!// Declared type variables to inspect?// Fully resolve parameter names and argument values.// Ambiguous return types found: return null to indicate "not determinable".// Common return type found: all factory methods return same type. For a non-parameterized// unique candidate, cache the full type declaration context of the target factory method.// Check if the bean definition itself has defined the type with an attribute// For instance supplied beans try the target type and bean class// Consider factory methods// Scan the factory bean methods// Try to obtain the FactoryBean's object type from its factory method// declaration without instantiating the containing bean at all.// If not resolvable above and the referenced factory bean doesn't exist yet,// exit here - we don't want to force the creation of another bean just to// obtain a FactoryBean's object type...// If we're allowed, we can create the factory bean and call getObjectType() early// Try to obtain the FactoryBean's object type from this early stage of the instance.// No type found for shortcut FactoryBean instance:// fall back to full creation of the FactoryBean instance.// No early bean instantiation possible: determine FactoryBean's type from// static factory method signature or from class inheritance hierarchy...// CGLIB subclass methods hide generic parameters; look at the original user class.// Mark this bean as currently in creation, even if just partially.// Don't swallow, probably misconfiguration...// Instantiation failure, maybe too early...// Finished partial creation of this bean.// Make sure bean class is actually resolved at this point.// Shortcut when re-creating the same bean...// Candidate constructors for autowiring?// Preferred constructors for default construction?// No special handling: simply use no-arg constructor.// for postProcessPropertyValues// Skip property population phase for null instance.// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the// state of the bean before properties are set. This can be used, for example,// to support styles of field injection.// Add property values based on autowire by name if applicable.// Add property values based on autowire by type if applicable.// Don't try autowiring by type for type Object: never makes sense,// even if it technically is a unsatisfied, non-simple property.// Do not allow eager init for type matching in case of a prioritized post-processor.// Shortcut: use the pre-converted values as-is.// Create a deep copy, resolving any references for values.// Possibly store converted value in merged bean definition,// in order to avoid re-conversion for every created bean instance.// Set our (possibly massaged) deep copy.// Ignore non-existent default lifecycle methods.import BeanMetadataAttributeAccessor/** Base class for concrete, full-fledged {@link BeanDefinition} classes, ... */new LinkedHashMap<String,AutowireCandidateQualifier>(...)new MethodOverrides(...)BeanDefinition.ROLE_APPLICATIONAutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTORAutowireCapableBeanFactory.AUTOWIRE_AUTODETECTString SCOPE_DEFAULT, ...;/** Constant for the default scope name: {@code ""}, equivalent to singleton ... *//** Constant that indicates no external autowiring at all. ... *//** Constant that indicates autowiring bean properties by name. ... *//** Constant that indicates autowiring bean properties by type. ... *//** Constant that indicates autowiring a constructor. ... */int DEPENDENCY_CHECK_NONE, ...;/** Constant that indicates no dependency check at all. ... */int DEPENDENCY_CHECK_OBJECTS, ...;/** Constant that indicates dependency checking for object references. ... */int DEPENDENCY_CHECK_SIMPLE, ...;/** Constant that indicates dependency checking for "simple" properties. ... */int DEPENDENCY_CHECK_ALL, ...;/** Constant that indicates dependency checking for all properties ... */String INFER_METHOD, ...;/** Constant that indicates the container should attempt to infer the ... */Object beanClass, ...;String scope, ...;boolean abstractFlag, ...;Boolean lazyInit, ...;int autowireMode, ...;int dependencyCheck, ...;...[] dependsOn, ...;boolean autowireCandidate, ...;boolean primary, ...;Map<String,AutowireCandidateQualifier> qualifiers, ...;Supplier<?> instanceSupplier, ...;boolean nonPublicAccessAllowed, ...;boolean lenientConstructorResolution, ...;String factoryBeanName, ...;ConstructorArgumentValues constructorArgumentValues, ...;MutablePropertyValues propertyValues, ...;MethodOverrides methodOverrides, ...;String initMethodName, ...;String destroyMethodName, ...;boolean enforceInitMethod, ...;boolean enforceDestroyMethod, ...;boolean synthetic, ...;int role, ...;/** Create a new AbstractBeanDefinition with default settings. *//** Create a new AbstractBeanDefinition with the given ... */this.constructorArgumentValuesthis.propertyValues/** Create a new AbstractBeanDefinition as a deep copy of the given ... */AbstractBeanDefinition originalAbdBoolean lazyInitgetLazyInit(...)hasMethodOverrides(...)setMethodOverrides(...)getAutowireMode(...)setDependencyCheck(...)setDependsOn(...)getDependsOn(...)setInstanceSupplier(...)setNonPublicAccessAllowed(...)setLenientConstructorResolution(...)isLenientConstructorResolution(...)setEnforceInitMethod(...)getDestroyMethodName(...)setEnforceDestroyMethod(...)isEnforceDestroyMethod(...)setResource(...)setResourceDescription(...)/** Override settings in this bean definition (presumably a copied parent ... */AbstractBeanDefinition otherAbdaddPropertyValues(...)addOverrides(...)/** Apply the provided default values to this bean. ... *//** Specify the bean class name of this bean definition. *//** Return the current bean class name of this bean definition. */Object beanClassObject/** Specify the class for this bean. ... *//** Return the specified class of the bean definition (assuming it is resolved already). ... *//** Return whether this definition specifies a bean class. ... *//** Determine the class of the wrapped bean, resolving it from a ... *//** Return a resolvable type for this bean definition. ... *//** Set the name of the target scope for the bean. ... *//** Return the name of the target scope for the bean. *//** Return whether this a <b>Singleton</b>, with a single shared instance ... *//** Set if this bean is "abstract", i.e. not meant to be instantiated itself but ... */this.abstractFlag/** Return whether this bean is "abstract", i.e. not meant to be instantiated ... */this.lazyInitbooleanValue(...)/** Set the autowire mode. This determines whether any automagical detection ... */this.autowireMode/** Return the autowire mode as specified in the bean definition. *//** Return the resolved autowire code, ... */Constructor<?>[] constructorsConstructor<?> constructor/** Set the dependency check code. ... */this.dependencyCheck/** Return the dependency check code. */this.dependsOnthis.autowireCandidate/** Register a qualifier to be used for autowire candidate resolution, ... */this.qualifiersgetTypeName(...)/** Return whether this bean has the specified qualifier. *//** Return the qualifier mapped to the provided type name. *//** Return all registered qualifiers. ... */new LinkedHashSet<AutowireCandidateQualifier>(...)/** Copy the qualifiers from the supplied AbstractBeanDefinition to this bean definition. ... */source.qualifiers/** Specify a callback for creating an instance of the bean, ... */this.instanceSupplier/** Return a callback for creating an instance of the bean, if any. ... *//** Specify whether to allow access to non-public constructors and methods, ... */this.nonPublicAccessAllowed/** Return whether to allow access to non-public constructors and methods. *//** Specify whether to resolve constructors in lenient mode ({@code true}, ... */this.lenientConstructorResolution/** Return whether to resolve constructors in lenient mode or in strict mode. */this.factoryBeanName/** Specify constructor argument values for this bean. *//** Return constructor argument values for this bean (never {@code null}). *//** Return if there are constructor argument values defined for this bean. *//** Specify property values for this bean, if any. *//** Return property values for this bean (never {@code null}). *//** Return if there are property values values defined for this bean. ... *//** Specify method overrides for the bean, if any. */this.methodOverrides/** Return information about methods to be overridden by the IoC ... *//** Return if there are method overrides defined for this bean. ... */this.initMethodName/** Return the name of the initializer method. *//** Specify whether or not the configured initializer method is the default. ... */this.enforceInitMethod/** Indicate whether the configured initializer method is the default. ... */this.destroyMethodName/** Return the name of the destroy method. *//** Specify whether or not the configured destroy method is the default. ... */this.enforceDestroyMethod/** Indicate whether the configured destroy method is the default. ... *//** Set whether this bean definition is 'synthetic', that is, not defined ... */this.synthetic/** Return whether this bean definition is 'synthetic', that is, ... *//** Set the role hint for this {@code BeanDefinition}. */this.role/** Return the role hint for this {@code BeanDefinition}. *//** Set a human-readable description of this bean definition. *//** Set the resource that this bean definition came from ... *//** Return the resource that this bean definition came from. *//** Set a description of the resource that this bean definition ... *//** Set the originating (e.g. decorated) BeanDefinition, if any. */new BeanDefinitionResource(...)/** Validate this bean definition. ... *//** Validate and prepare the method overrides defined for this bean. ... */getOverrides(...)new Consumer<MethodOverride>(...) { ... }prepareMethodOverride(...)/** Validate and prepare the given method override. ... */getMethodCountForName(...)setOverloaded(...)/** Public declaration of Object's {@code clone()} method. ... *//** Clone this bean definition. ... */AbstractBeanDefinition thatthat.scopethat.abstractFlagthat.lazyInitthat.autowireModethat.dependencyCheckthat.dependsOnthat.autowireCandidatethat.qualifiersthat.primarythat.nonPublicAccessAllowedthat.lenientConstructorResolutionthat.constructorArgumentValuesthat.propertyValuesthat.methodOverridesthat.factoryBeanNamethat.factoryMethodNamethat.initMethodNamethat.enforceInitMethodthat.destroyMethodNamethat.enforceDestroyMethodthat.syntheticthat.role// Work out whether to apply setter autowiring or constructor autowiring.// If it has a no-arg constructor it's deemed to be setter autowiring,// otherwise we'll try constructor autowiring.// Check that lookup methods exist and determine their overloaded status.// Mark override as not overloaded, to avoid the overhead of arg type checking.import Environmentimport EnvironmentCapableimport StandardEnvironmentimport ResourceLoaderimport PathMatchingResourcePatternResolverimport ResourcePatternResolver/** Abstract base class for bean definition readers which implement ... */DefaultBeanNameGenerator.INSTANCEResourceLoader resourceLoader, ...;BeanNameGenerator beanNameGenerator, ...;/** Create a new AbstractBeanDefinitionReader for the given bean factory. ... */this.resourceLoadernew PathMatchingResourcePatternResolver(...)/** Set the ResourceLoader to use for resource locations. ... *//** Set the ClassLoader to use for bean classes. ... *//** Set the Environment to use when reading bean definitions. Most often used ... *//** Set the BeanNameGenerator to use for anonymous beans ... */this.beanNameGenerator/** Load bean definitions from the specified resource location. ... */ResourceLoader resourceLoadergetResourceLoader(...)Resource[] resourcesgetResources(...)String location// Determine ResourceLoader to use.// Inherit Environment if possible// Resource pattern matching available.// Can only load single resources by absolute URL.import CopyOnWriteArrayListimport UnaryOperatorimport PropertyEditorRegistrySupportimport TypeMismatchExceptionimport BeanIsAbstractExceptionimport BeanIsNotAFactoryExceptionimport BeanNotOfRequiredTypeExceptionimport CannotLoadBeanClassExceptionimport SmartFactoryBeanimport BeanExpressionContextimport BeanExpressionResolverimport Scopeimport DecoratingClassLoaderimport LogMessageimport StartupStep/** Abstract base class for {@link org.springframework.beans.factory.BeanFactory} ... */new LinkedHashSet<PropertyEditorRegistrar>(...)new HashMap<Class<?>,Class<? extends PropertyEditor>>(...)new CopyOnWriteArrayList<StringValueResolver>(...)new BeanPostProcessorCacheAwareList(...)new LinkedHashMap<String,Scope>(...)new ConcurrentHashMap<String,RootBeanDefinition>(...)ApplicationStartup.DEFAULTBeanFactory parentBeanFactory, ...;/** Parent bean factory, for bean inheritance support. *//** ClassLoader to resolve bean class names with, if necessary. */ClassLoader tempClassLoader, ...;/** ClassLoader to temporarily resolve bean class names with, if necessary. */boolean cacheBeanMetadata, ...;/** Whether to cache bean metadata or rather reobtain it for every access. */BeanExpressionResolver beanExpressionResolver, ...;/** Resolution strategy for expressions in bean definition values. *//** Spring ConversionService to use instead of PropertyEditors. */Set<PropertyEditorRegistrar> propertyEditorRegistrars, ...;/** Custom PropertyEditorRegistrars to apply to the beans of this factory. *//** Custom PropertyEditors to apply to the beans of this factory. */TypeConverter typeConverter, ...;/** A custom TypeConverter to use, overriding the default PropertyEditor mechanism. */List<StringValueResolver> embeddedValueResolvers, ...;/** String resolvers to apply e.g. to annotation attribute values. */List<BeanPostProcessor> beanPostProcessors, ...;/** BeanPostProcessors to apply. */BeanPostProcessorCache beanPostProcessorCache, ...;/** Cache of pre-filtered post-processors. */Map<String,Scope> scopes, ...;/** Map from scope identifier String to corresponding Scope. */SecurityContextProvider securityContextProvider, ...;/** Security context used when running with a SecurityManager. */Map<String,RootBeanDefinition> mergedBeanDefinitions, ...;/** Map from bean name to merged RootBeanDefinition. */Set<String> alreadyCreated, ...;/** Names of beans that have already been created at least once. */ThreadLocal<Object> prototypesCurrentlyInCreation, ...;/** Names of beans that are currently in creation. */ApplicationStartup applicationStartup, ...;/** Application startup metrics. * *//** Create a new AbstractBeanFactory. *//** Create a new AbstractBeanFactory with the given parent. ... */this.parentBeanFactory// Implementation of BeanFactory interfacedoGetBean(...)Object sharedInstanceBeanFactory parentBeanFactoryStartupStep beanCreationtag(...)this.applicationStartupgetMergedLocalBeanDefinition(...)String[] dependsOncheckMergedBeanDefinition(...)String depisDependent(...)destroySingleton(...)Object prototypeInstanceString scopeNameScope scopeObject scopedInstancenew ScopeNotActiveException(...)cleanupAfterBeanCreationFailure(...)end(...)adaptBeanInstance(...)Object convertedBeannew BeanNotOfRequiredTypeException(...)isFactoryDereference(...)new PrivilegedAction<Boolean>(...) { ... }/** Internal extended variant of {@link #isTypeMatch(String, ResolvableType)} ... */boolean isFactoryDereferenceBeanDefinitionHolder dbdgetDecoratedDefinition(...)Class<?> classToMatchClass<?>[] typesToMatchClass<?> predictedTypehasGenerics(...)RootBeanDefinition tbdResolvableType definedTypeforRawClass(...)List<String> aliasesboolean factoryPrefixString fullBeanNameString[] retrievedAliasesString retrievedAlias// Implementation of HierarchicalBeanFactory interface// Implementation of ConfigurableBeanFactory interfacethis.tempClassLoaderthis.cacheBeanMetadatathis.beanExpressionResolver/** Return the set of PropertyEditorRegistrars. */registerCustomEditors(...)/** Return the map of custom editors, with Classes as keys and PropertyEditor classes as values. */this.typeConverter/** Return the custom TypeConverter to use, if any. ... */TypeConverter customConverterthis.embeddedValueResolversStringValueResolver resolverthis.beanPostProcessors/** Add new BeanPostProcessors that will get applied to beans created ... */removeAll(...)/** Return the list of BeanPostProcessors that will get applied ... *//** Return the internal cache of pre-filtered post-processors, ... */BeanPostProcessorCache bpCachethis.beanPostProcessorCachenew BeanPostProcessorCache(...)BeanPostProcessor bpbpCache.instantiationAwarebpCache.smartInstantiationAwarebpCache.destructionAwarebpCache.mergedDefinition/** Return whether this factory holds a InstantiationAwareBeanPostProcessor ... *//** Return whether this factory holds a DestructionAwareBeanPostProcessor ... */Scope previous/** Set the security context provider for this bean factory. If a security manager ... */this.securityContextProvider/** Delegate the creation of the access control context to the ... */getContext(...)setCacheBeanMetadata(...)isCacheBeanMetadata(...)setBeanExpressionResolver(...)AbstractBeanFactory otherAbstractFactoryotherAbstractFactory.propertyEditorRegistrarsotherAbstractFactory.customEditorsotherAbstractFactory.typeConverterotherAbstractFactory.beanPostProcessorsotherAbstractFactory.scopesotherAbstractFactory.securityContextProviderString[] otherScopeNamesgetRegisteredScopeNames(...)getRegisteredScope(...)/** Return a 'merged' BeanDefinition for the given bean name, ... *//** Return whether the specified prototype bean is currently in creation ... */Object curValthis.prototypesCurrentlyInCreation/** Callback before prototype creation. ... */Set<String> beanNameSet/** Callback after prototype creation. ... *//** Return the bean name, stripping out the factory dereference prefix if necessary, ... */canonicalName(...)/** Determine the original bean name, resolving locally defined aliases to canonical names. ... *//** Initialize the given BeanWrapper with the custom editors registered ... */useConfigValueEditors(...)PropertyEditorRegistrar registrar/** Return a merged RootBeanDefinition, traversing the parent bean definition ... */this.mergedBeanDefinitionsmbd.stale/** Return a RootBeanDefinition for the given top-level bean, by merging with ... *//** Return a RootBeanDefinition for the given bean, by merging with the ... */RootBeanDefinition previousBeanDefinition pbdString parentBeanNameBeanFactory parentoverrideFrom(...)copyRelevantMergedBeanDefinitionCaches(...)ResolvableType targetTypeResolvableType previousTargetTypeprevious.targetTypembd.isFactoryBeanprevious.isFactoryBeanprevious.resolvedTargetTypeprevious.factoryMethodReturnTypeprevious.factoryMethodToIntrospect/** Check the given merged bean definition, ... */new BeanIsAbstractException(...)/** Remove the merged bean definition for the specified bean, ... */bd.stalenew BiConsumer<String,RootBeanDefinition>(...) { ... }/** Resolve the bean class for the specified bean definition, ... */new PrivilegedExceptionAction<Class<?>>(...) { ... }doResolveBeanClass(...)new CannotLoadBeanClassException(...)ClassLoader beanClassLoaderClassLoader dynamicLoaderboolean freshResolveClassLoader tempClassLoaderDecoratingClassLoader dclClass<?> typeToMatchevaluateBeanDefinitionString(...)/** Evaluate the given String as contained in a bean definition, ... *//** Predict the eventual bean type (of the processed bean instance) for the ... *//** Check whether the given bean is defined as a {@link FactoryBean}. ... */Boolean result/** Determine the bean type for the given FactoryBean definition, as far as possible. ... */Class<?> objectTypeBeanCurrentlyInCreationException.class/** Determine the bean type for a FactoryBean by inspecting its attributes for a ... */Object attributeFactoryBean<>.OBJECT_TYPE_ATTRIBUTE/** Mark the specified bean as already created (or about to be created). ... */this.alreadyCreatedclearMergedBeanDefinition(...)/** Perform appropriate cleanup of cached metadata after bean creation failed. ... *//** Determine whether the specified bean is eligible for having ... *//** Remove the singleton instance (if any) for the given bean name, ... *//** Check whether this factory's bean creation phase already started, ... *//** Get the object for the given bean instance, either the bean ... */new BeanIsNotAFactoryException(...)getCachedObjectForFactoryBean(...)FactoryBean<?> factoryboolean syntheticgetObjectFromFactoryBean(...)/** Determine whether the given bean name is already in use within this factory, ... */isAlias(...)/** Determine whether the given bean requires destruction on shutdown. ... */hasDestroyMethod(...)hasDestructionAwareBeanPostProcessors(...)hasApplicableProcessors(...)/** Add the given bean to the list of disposable beans in this factory, ... */AccessControlContext accrequiresDestruction(...)registerDisposableBean(...)registerDestructionCallback(...)// Abstract methods to be implemented by subclasses/** Return the bean definition for the given bean name. ... *//** Create a bean instance for the given merged bean definition (and arguments). ... *//** CopyOnWriteArrayList which resets the beanPostProcessorCache field on modification. ... */BeanPostProcessor resultboolean successretainAll(...)replaceAll(...)/** Internal cache of pre-filtered post-processors. ... */new ArrayList<InstantiationAwareBeanPostProcessor>(...)new ArrayList<SmartInstantiationAwareBeanPostProcessor>(...)new ArrayList<DestructionAwareBeanPostProcessor>(...)new ArrayList<MergedBeanDefinitionPostProcessor>(...)List<InstantiationAwareBeanPostProcessor> instantiationAware, ...;List<SmartInstantiationAwareBeanPostProcessor> smartInstantiationAware, ...;List<DestructionAwareBeanPostProcessor> destructionAware, ...;List<MergedBeanDefinitionPostProcessor> mergedDefinition, ...;// Eagerly check singleton cache for manually registered singletons.// Fail if we're already creating this bean instance:// We're assumably within a circular reference.// Check if bean definition exists in this factory.// Not found -> check parent.// Delegation to parent with explicit args.// No args -> delegate to standard getBean method.// Guarantee initialization of beans that the current bean depends on.// Create bean instance.// Explicitly remove instance from singleton cache: It might have been put there// eagerly by the creation process, to allow for circular reference resolution.// Also remove any beans that received a temporary reference to the bean.// It's a prototype -> create a new instance.// Check if required type matches the type of the actual bean instance.// No singleton instance found -> check bean definition.// No bean definition found in this factory -> delegate to parent.// In case of FactoryBean, return singleton status of created object if not a dereference.// Singleton or scoped - not a prototype.// However, FactoryBean may still produce a prototype object...// Check manually registered singletons.// Direct match for exposed instance?// Generics potentially only match on the target class, not on the proxy...// Check raw class match as well, making sure it's exposed on the proxy.// null instance registered// Retrieve corresponding bean definition.// Setup the types that we want to match against// Attempt to predict the bean type// We're looking for a regular reference but we're a factory bean that has// a decorated bean definition. The target bean should be the same type// as FactoryBean would ultimately return.// We should only attempt if the user explicitly set lazy-init to true// and we know the merged bean definition is for a factory bean.// If we couldn't use the target type, try regular prediction.// Attempt to get the actual ResolvableType for the bean.// If it's a FactoryBean, we want to look at what it creates, not the factory class.// Special case: A SmartInstantiationAwareBeanPostProcessor returned a non-FactoryBean// type but we nevertheless are being asked to dereference a FactoryBean...// Let's check the original bean class and proceed with it if it is a FactoryBean.// We don't have an exact type but if bean definition target type or the factory// method return type matches the predicted type then we can use that.// If we have a bean type use it so that generics are considered// If we don't have a bean type, fallback to the predicted type// Check decorated bean definition, if any: We assume it'll be easier// to determine the decorated bean's type than the proxy's type.// Check bean class whether we're dealing with a FactoryBean.// If it's a FactoryBean, we want to look at what it creates, not at the factory class.// Build default TypeConverter, registering custom editors.// Remove from old position, if any// Add to end of list// Efficiently check whether bean definition exists in this factory.// Resolve merged bean definition locally.// Check with full lock now in order to enforce the same merged instance.// Use copy of given root bean definition.// Child bean definition: needs to be merged with parent.// Deep copy with overridden values.// Set default singleton scope, if not configured before.// A bean contained in a non-singleton bean cannot be a singleton itself.// Let's correct this on the fly here, since this might be the result of// parent-child merging for the outer bean, in which case the original inner bean// definition will not have inherited the merged outer bean's singleton status.// Cache the merged bean definition for the time being// (it might still get re-merged later on in order to pick up metadata changes)// When just doing type checks (i.e. not creating an actual instance yet),// use the specified temporary class loader (e.g. in a weaving scenario).// A dynamically resolved expression, supported as of 4.2...// When resolving against a temporary class loader, exit early in order// to avoid storing the resolved Class in the bean definition.// Resolve regularly, caching the result in the BeanDefinition...// Let the bean definition get re-merged now that we're actually creating// the bean... just in case some of its metadata changed in the meantime.// Don't let calling code try to dereference the factory if the bean isn't a factory.// Now we have the bean instance, which may be a normal bean or a FactoryBean.// If it's a FactoryBean, we use it to create a bean instance, unless the// caller actually wants a reference to the factory.// Return bean instance from factory.// Caches object obtained from FactoryBean if it is a singleton.// Register a DisposableBean implementation that performs all destruction// work for the given bean: DestructionAwareBeanPostProcessors,// DisposableBean interface, custom destroy method.// A bean with a custom scope.../** Qualifier for resolving autowire candidates. A bean definition that ... */String VALUE_KEY, ...;/** The name of the key used to store the value. *//** Construct a qualifier to match against an annotation of the ... *//** Retrieve the type name. This value will be the same as the ... *//** Strategy interface for determining whether a specific bean definition ... *//** Determine whether the given bean definition qualifies as an ... *//** Determine whether the given descriptor is effectively required. ... *//** Determine whether the given descriptor declares a qualifier beyond the type ... *//** Determine whether a default value is suggested for the given dependency. ... *//** Build a proxy for lazy resolution of the actual dependency target, ... *//** Return a clone of this resolver instance if necessary, retaining its local ... */import TypeVariable/** Utility class that contains various methods useful for the implementation of ... */new Comparator<Executable>(...) { ... }Comparator<Executable> EXECUTABLE_COMPARATOR, ...;/** Sort the given constructors, preferring public constructors and "greedy" ones with ... *//** Sort the given factory methods, preferring public methods and "greedy" ones ... */Method wmClass<?> superclass/** Return whether the setter method of the given bean property is defined ... *//** Resolve the given autowiring value against the given required type, ... */ObjectFactory<?> factorynew ObjectFactoryDelegatingInvocationHandler(...)/** Determine the target type for the generic return type of the given ... */TypeVariable<Method>[] declaredTypeVariablesType genericReturnTypeType[] methodParameterTypesboolean locallyDeclaredTypeVariableMatchesReturnTypemethodParameterTypes.lengthTypeVariable<Method> currentTypeVariableType methodParameterTypeTypedStringValue typedValuehasTargetType(...)resolveTargetType(...)ParameterizedType parameterizedTypeType[] actualTypeArgumentsType typeArg/** Reflective {@link InvocationHandler} for lazy access to the current target object. */ObjectFactory<?> objectFactory, ...;this.objectFactory// Not a CGLIB method so it's OK.// It was declared by CGLIB, but we might still want to autowire it// if it was actually declared by the superclass.// Ensure that the type variable (e.g., T) is declared directly on the method// itself (e.g., via <T>), not on the enclosing class or interface.// Only consider argument type if it is a simple value...// Consider adding logic to determine the class of the typeArg, if possible.// For now, just fall back...// Fall back...// Use hashCode of proxy.import BeanDefinitionCustomizer/** Programmatic means of constructing ... *//** Create a new {@code BeanDefinitionBuilder} used to construct a {@link GenericBeanDefinition}. */new BeanDefinitionBuilder(...)/** Create a new {@code BeanDefinitionBuilder} used to construct a {@link GenericBeanDefinition}. ... */builder.beanDefinition/** Create a new {@code BeanDefinitionBuilder} used to construct a {@link RootBeanDefinition}. ... *//** Create a new {@code BeanDefinitionBuilder} used to construct a {@link ChildBeanDefinition}. ... */new ChildBeanDefinition(...)AbstractBeanDefinition beanDefinition, ...;/** The {@code BeanDefinition} instance we are creating. */int constructorArgIndex, ...;/** Our current position with respect to constructor args. *//** Enforce the use of factory methods. *//** Return the current BeanDefinition object in its raw (unvalidated) form. ... *//** Validate and return the created BeanDefinition object. *//** Set the name of the parent definition of this bean definition. *//** Set the name of a static factory method to use for this definition, ... *//** Set the name of a non-static factory method to use for this definition, ... *//** Add an indexed constructor arg value. The current index is tracked internally ... */this.constructorArgIndex/** Add a reference to a named bean as a constructor arg. ... *//** Add the supplied property value under the given property name. *//** Add a reference to the specified bean name under the property specified. ... *//** Add an autowired marker for the specified property on the specified bean. ... *//** Set the init method for this definition. *//** Set the destroy method for this definition. *//** Set the scope of this definition. ... *//** Set whether or not this definition is abstract. *//** Set whether beans for this definition should be lazily initialized or not. *//** Set the autowire mode for this definition. *//** Set the dependency check mode for this definition. *//** Append the specified bean name to the list of beans that this definition ... */String[] addedaddObjectToArray(...)/** Set the role of this definition. *//** Apply the given customizers to the underlying bean definition. ... */BeanDefinitionCustomizer customizercustomize(...)/** A simple holder for {@code BeanDefinition} property defaults. ... */AbstractBeanDefinition.AUTOWIRE_NO/** Set whether beans should be lazily initialized by default. ... *//** Return whether beans should be lazily initialized by default, i.e. not ... *//** Return the default autowire mode. *//** Return the default dependency check code. *//** Set the name of the default initializer method. ... *//** Return the name of the default initializer method. *//** Set the name of the default destroy method. ... *//** Return the name of the default destroy method. */import NonNull/** Subclass of {@link BeanDefinitionStoreException} indicating an invalid override ... */BeanDefinition existingDefinition, ...;/** Create a new BeanDefinitionOverrideException for the given new and existing definition. ... */this.existingDefinition/** Return the description of the resource that the bean definition came from. *//** Return the newly registered bean definition. ... *//** Return the existing bean definition for the same name. ... *//** Simple interface for bean definition readers. ... *//** Return the bean factory to register the bean definitions with. ... *//** Return the resource loader to use for resource locations. ... *//** Return the class loader to use for bean classes. ... *//** Return the BeanNameGenerator to use for anonymous beans ... *//** Load bean definitions from the specified resource. ... *//** Load bean definitions from the specified resources. ... *//** Load bean definitions from the specified resource locations. ... *//** Utility methods that are useful for bean definition reader implementations. ... */BeanFactoryUtils.GENERATED_BEAN_NAME_SEPARATOR/** Create a new GenericBeanDefinition for the given parent name and class name, ... */GenericBeanDefinition bd/** Generate a bean name for the given top-level bean definition, ... */generateBeanName(...)/** Generate a bean name for the given bean definition, unique within the ... */String generatedBeanNamegetIdentityHexString(...)uniqueBeanName(...)/** Turn the given bean name into a unique bean name for the given bean factory, ... */int counter/** Register the given bean definition with the given bean factory. ... *//** Register the given bean definition with a generated name, ... */String generatedName// Inner bean: generate identity hashcode suffix.// Top-level bean: use plain class name with unique suffix if necessary.// Increase counter until the id is unique.// Register bean definition under primary name.// Register aliases for bean name, if any.import AliasRegistry/** Interface for registries that hold bean definitions, for example RootBeanDefinition ... *//** Register a new bean definition with this registry. ... *//** Remove the BeanDefinition for the given name. ... *//** Return the BeanDefinition for the given bean name. ... *//** Check if this registry contains a bean definition with the given name. ... *//** Return the names of all beans defined in this registry. ... *//** Return the number of beans defined in the registry. ... *//** Determine whether the given bean name is already in use within this registry, ... *//** Extension to the standard {@link BeanFactoryPostProcessor} SPI, allowing for ... *//** Modify the application context's internal bean definition registry after its ... *//* Copyright 2002-2010 the original author or authors. ... */import AbstractResource/** Descriptive {@link org.springframework.core.io.Resource} wrapper for ... *//** Create a new BeanDefinitionResource. ... *//** Return the wrapped BeanDefinition object. *//** This implementation compares the underlying BeanDefinition. */(...).beanDefinition/** This implementation returns the hash code of the underlying BeanDefinition. *//** Exception thrown when the validation of a bean definition failed. ... *//** Create a new BeanDefinitionValidationException with the specified message. ... *//** Create a new BeanDefinitionValidationException with the specified message ... */import NamedBeanHolder/** Helper class for use in bean factory implementations, ... */AbstractAutowireCapableBeanFactory beanFactory, ...;/** Create a BeanDefinitionValueResolver for the given BeanFactory and BeanDefinition. ... *//** Given a PropertyValue, return a value, resolving any references to other ... */resolveReference(...)doEvaluate(...)BeanDefinitionHolder bdHolderresolveInnerBean(...)String innerBeanNameManagedArray arrayarray.resolvedElementTypeString elementTypeNamegetElementTypeName(...)resolveManagedArray(...)resolveManagedList(...)resolveManagedSet(...)resolveManagedMap(...)Properties originalProperties copynew Properties(...)Object valueObjectClass<?> resolvedTargetType/** Evaluate the given value as an expression, if necessary. ... */setDynamic(...)String[] valuesboolean actuallyResolvedObject[] resolvedValuesvalues.lengthString originalValue/** Evaluate the given String value as an expression, if necessary. ... *//** Resolve the target type in the given TypedStringValue. ... *//** Resolve a reference to another bean in the factory. */getBeanType(...)isToParent(...)NamedBeanHolder<?> namedBeanresolveNamedBean(...)getBeanInstance(...)/** Resolve an inner bean definition. ... */String actualInnerBeanNameObject innerBeanadaptInnerBeanName(...)registerContainedBean(...)String dependsOnBean/** Checks the given bean name whether it is unique. If not already unique, ... */isBeanNameInUse(...)/** For each element in the managed array, resolve reference if necessary. */Object resolvednew KeyedArgName(...)/** For each element in the managed list, resolve reference if necessary. */List<Object> resolved/** For each element in the managed set, resolve reference if necessary. */Set<Object> resolvedObject m/** For each element in the managed map, resolve reference if necessary. */Map<Object,Object> resolvedObject resolvedKey/** Holder class used for delayed toString building. */Object argName, ...;Object key, ...;this.argNamethis.keyBeanWrapper.PROPERTY_KEY_SUFFIXBeanWrapper.PROPERTY_KEY_PREFIX// We must check each value to see whether it requires a runtime reference// to another bean to be resolved.// Resolve BeanDefinitionHolder: contains BeanDefinition with name and aliases.// Resolve plain BeanDefinition, without contained name: use dummy name.// May need to resolve contained runtime references.// Improve the message by showing the context.// Convert value to target type here.// Check given bean name whether it is unique. If not already unique,// add counter - increasing the counter until the name is unique.// Guarantee initialization of beans that the inner bean depends on.// Actually create the inner bean instance now.../** Strategy interface for generating bean names for bean definitions. ... *//** Generate a bean name for the given bean definition. ... */import BeanInstantiationException/** Default object instantiation strategy for use in BeanFactories. ... */int PASSTHROUGH, ...;/** Index in the CGLIB callback array for passthrough behavior, ... */int LOOKUP_OVERRIDE, ...;/** Index in the CGLIB callback array for a method that should ... */int METHOD_REPLACER, ...;instantiateWithMethodInjection(...)new CglibSubclassCreator(...)/** An inner class created for historical reasons to avoid external CGLIB dependency ... */NoOp.classLookupOverrideMethodInterceptor.classReplaceOverrideMethodInterceptor.class...[] CALLBACK_TYPES, ...;RootBeanDefinition beanDefinition, ...;BeanFactory owner, ...;this.owner/** Create a new instance of a dynamically generated subclass implementing the ... */Class<?> subclasscreateEnhancedSubclass(...)Factory factoryConstructor<?> enhancedSubclassConstructorNoOp.INSTANCEnew LookupOverrideMethodInterceptor(...)new ReplaceOverrideMethodInterceptor(...)/** Create an enhanced subclass of the bean class for the provided bean ... */new MethodOverrideCallbackFilter(...)/** Class providing hashCode and equals methods required by CGLIB to ... *//** CGLIB callback for filtering method interception behavior. */MethodOverrideCallbackFilter.classMethodOverride methodOverridegetOverride(...)/** CGLIB MethodInterceptor to override methods, replacing them with an ... */LookupOverride lo/** CGLIB MethodInterceptor to override methods, replacing them with a call ... */ReplaceOverride roMethodReplacer mrgetMethodReplacerBeanName(...)MethodReplacer.classreimplement(...)// Must generate CGLIB subclass...// SPR-10785: set callbacks directly on the instance instead of in the// enhanced class (via the Enhancer) in order to avoid memory leaks.// Cast is safe, as CallbackFilter filters are used selectively.// if no-arg, don't insist on args at all// Detect package-protected NullBean instance through equals(null) check// TODO could cache if a singleton for minor performance optimization/** Bean definition for beans which inherit settings from their parent. ... *//** Create a new ChildBeanDefinition for the given parent, to be ... *//** Create a new ChildBeanDefinition for the given parent. ... *//** Create a new ChildBeanDefinition for the given parent, ... *//** Create a new ChildBeanDefinition as deep copy of the given ... */ChildBeanDefinition thatthat.parentNameimport Dequeimport ValueHolderimport MethodInvoker/** Delegate for resolving constructors and factory methods. ... */new NamedThreadLocal<InjectionPoint>(...)...[] EMPTY_ARGS, ...;Object autowiredArgumentMarker, ...;/** Marker for autowired arguments in a cached argument array, to be replaced ... */NamedThreadLocal<InjectionPoint> currentInjectionPoint, ...;/** Create a new ConstructorResolver for the given factory and instantiation strategy. ... */getLogger(...)BeanWrapperImpl bwConstructor<?> constructorToUseArgumentsHolder argsHolderToUseObject[] argsToResolvembd.resolvedConstructorArgumentsmbd.preparedConstructorArgumentsresolvePreparedArguments(...)Constructor<?>[] candidatesboolean autowiringConstructorArgumentValues resolvedValuesint minTypeDiffWeightSet<Constructor<?>> ambiguousConstructorsDeque<UnsatisfiedDependencyException> causescandidates.lengthConstructor<?> uniqueCandidatesetBeanInstance(...)explicitArgs.lengthConstructorArgumentValues cargssortConstructors(...)int parameterCountArgumentsHolder argsHolderint typeDiffWeightgetTypeDifferenceWeight(...)getAssignabilityWeight(...)argsToUse.lengthcreateArgumentArray(...)getUserDeclaredConstructor(...)new ArrayDeque<UnsatisfiedDependencyException>(...)new ArgumentsHolder(...)argsHolder.argumentsnew LinkedHashSet<Constructor<?>>(...)removeLast(...)Exception causestoreCache(...)InstantiationStrategy strategy/** Resolve the factory method in the specified bean definition, if possible. ... */getCandidateMethods(...)isParamMismatch(...)int uniqueCandidateParameterCountint candidateParameterCount/** Retrieve all candidate methods for the given class, considering ... */new PrivilegedAction<Method[]>(...) { ... }Object factoryBeanMethod factoryMethodToUsenew ImplicitlyAppearedSingletonException(...)List<Method> candidatesSet<Method> ambiguousFactoryMethodsmbd.isFactoryMethodUniqueMethod[] rawCandidatesAutowireUtils.EXECUTABLE_COMPARATORnew LinkedHashSet<Method>(...)List<String> argTypesString argDescSet<ValueHolder> valueHoldersnew LinkedHashSet<ValueHolder>(...)ValueHolder valueString argType/** Resolve the constructor arguments for this bean into the resolvedValues object. ... */ValueHolder resolvedValueHolder/** Create an array of arguments to invoke a constructor or factory method, ... */ArgumentsHolder argsint paramIndexString paramNameargs.preparedArgumentsObject sourceHoldernullSafeClassName(...)Object sourceValueargs.resolveNecessaryargs.argumentsargs.rawArgumentsresolveAutowiredArgument(...)/** Resolve the prepared arguments stored in the given bean definition. */Object[] resolvedArgsargsToResolve.lengthint argIndexObject argValueClass<?> declaringClass/** Template method for resolving the specified argument which is supposed to be autowired. */InjectionPoint.classInjectionPoint injectionPointInjectionPoint old/** Private inner class for holding argument combinations. */...[] rawArguments, ...;...[] preparedArguments, ...;boolean resolveNecessary, ...;this.rawArgumentsthis.preparedArgumentsint rawTypeDiffWeightthis.resolveNecessary/** Delegate for checking Java 6's {@link ConstructorProperties} annotation. */// Found a cached constructor...// Take specified constructors, if any.// Need to resolve the constructor.// Already found greedy constructor that can be satisfied ->// do not look any further, there are only less greedy constructors left.// Swallow and try next constructor.// Explicit arguments given -> arguments length must match exactly.// Choose this constructor if it represents the closest match.// It's a static factory method on the bean class.// Found a cached factory method...// Need to determine the factory method...// Try all methods with this name to see if they match the given arguments.// explicitly skip immutable singletonList// We don't have arguments passed in programmatically, so we need to resolve the// arguments specified in the constructor arguments held in the bean definition.// Resolved constructor arguments: type conversion and/or autowiring necessary.// Swallow and try next overloaded factory method.// Choose this factory method if it represents the closest match.// Find out about ambiguity: In case of the same type difference weight// for methods with the same number of parameters, collect such candidates// and eventually raise an ambiguity exception.// However, only perform that check in non-lenient constructor resolution mode,// and explicitly ignore overridden methods (with the same parameter signature).// Try to find matching constructor argument value, either indexed or generic.// If we couldn't find a direct match and are not supposed to autowire,// let's try the next generic, untyped argument value as fallback:// it could match after type conversion (for example, String -> int).// We found a potential match - let's give it a try.// Do not consider the same value definition multiple times!// No explicit match found: we're either supposed to autowire or// have to fail creating an argument array for the given constructor.// No equivalent constructor on user class (superclass)...// Let's proceed with the given constructor as we usually would.// Single constructor or factory method -> let's return an empty array/collection// for e.g. a vararg or a non-null List/Set/Map parameter.// If valid arguments found, determine type difference weight.// Try type difference weight on both the converted arguments and// the raw arguments. If the raw weight is better, use it.// Decrease raw weight by 1024 to prefer it over equal converted weight./** Default implementation of the {@link BeanNameGenerator} interface, delegating to ... */new DefaultBeanNameGenerator(...)DefaultBeanNameGenerator INSTANCE, ...;/** A convenient constant for a default {@code DefaultBeanNameGenerator} instance, ... */import Referenceimport WeakReferenceimport IdentityHashMapimport ObjectProviderimport SmartInitializingSingletonimport SearchStrategyimport CompositeIterator/** Spring's default implementation of the {@link ConfigurableListableBeanFactory} ... */SimpleAutowireCandidateResolver.INSTANCEnew ConcurrentHashMap<String,BeanDefinition>(...)new ConcurrentHashMap<String,BeanDefinitionHolder>(...)new ConcurrentHashMap<Class<?>,String[]>(...)new ConcurrentHashMap<String,Reference<DefaultListableBeanFactory>>(...)Class<?> javaxInjectProviderClass, ...;Map<String,Reference<DefaultListableBeanFactory>> serializableFactories, ...;/** Map from serialized id to factory instance. */String serializationId, ...;/** Optional id for this factory, for serialization purposes. */boolean allowBeanDefinitionOverriding, ...;/** Whether to allow re-registration of a different definition with the same name. */boolean allowEagerClassLoading, ...;/** Whether to allow eager class loading even for lazy-init beans. */Comparator<Object> dependencyComparator, ...;/** Optional OrderComparator for dependency Lists and arrays. */AutowireCandidateResolver autowireCandidateResolver, ...;/** Resolver to use for checking if a bean definition is an autowire candidate. */Map<Class<?>,Object> resolvableDependencies, ...;/** Map from dependency type to corresponding autowired value. */Map<String,BeanDefinition> beanDefinitionMap, ...;/** Map of bean definition objects, keyed by bean name. */Map<String,BeanDefinitionHolder> mergedBeanDefinitionHolders, ...;/** Map from bean name to merged BeanDefinitionHolder. */Map<Class<?>,String[]> allBeanNamesByType, ...;/** Map of singleton and non-singleton bean names, keyed by dependency type. */Map<Class<?>,String[]> singletonBeanNamesByType, ...;/** Map of singleton-only bean names, keyed by dependency type. */List<String> beanDefinitionNames, ...;/** List of bean definition names, in registration order. */Set<String> manualSingletonNames, ...;/** List of names of manually registered singletons, in registration order. */...[] frozenBeanDefinitionNames, ...;/** Cached array of bean definition names in case of frozen configuration. */boolean configurationFrozen, ...;/** Whether bean definition metadata may be cached for all beans. *//** Create a new DefaultListableBeanFactory. *//** Create a new DefaultListableBeanFactory with the given parent. ... *//** Specify an id for serialization purposes, allowing this BeanFactory to be ... */new WeakReference<DefaultListableBeanFactory>(...)this.serializationId/** Return an id for serialization purposes, if specified, allowing this BeanFactory ... *//** Set whether it should be allowed to override bean definitions by registering ... */this.allowBeanDefinitionOverriding/** Return whether it should be allowed to override bean definitions by registering ... *//** Set whether the factory is allowed to eagerly load bean classes ... */this.allowEagerClassLoading/** Return whether the factory is allowed to eagerly load bean classes ... *//** Set a {@link java.util.Comparator} for dependency Lists and arrays. ... */this.dependencyComparator/** Return the dependency comparator for this BeanFactory (may be {@code null}. ... *//** Set a custom autowire candidate resolver for this BeanFactory to use ... */this.autowireCandidateResolver/** Return the autowire candidate resolver for this BeanFactory (never {@code null}). */DefaultListableBeanFactory otherListableFactoryotherListableFactory.allowBeanDefinitionOverridingotherListableFactory.allowEagerClassLoadingotherListableFactory.dependencyComparatorcloneIfNecessary(...)this.resolvableDependenciesotherListableFactory.resolvableDependencies// Implementation of remaining BeanFactory methodsresolveBean(...)getBeanProvider(...)// Implementation of ListableBeanFactory interfacethis.beanDefinitionMapString[] frozenNamesthis.frozenBeanDefinitionNamesthis.beanDefinitionNamesnew BeanObjectProvider<T>(...) { ... }T resolvedScopeNotActiveException exgetBeanNamesForTypedStream(...)new Function<String,T>(...) { ... }new Predicate<T>(...) { ... }Map<String,T> matchingBeansStream<T> streamsorted(...)adaptOrderComparator(...)NamedBeanHolder<T> namedBeanObjectProvider<T> parentProviderdoGetBeanNamesForType(...)Map<Class<?>,String[]> cachethis.allBeanNamesByTypethis.singletonBeanNamesByTypeString[] resolvedBeanNamesisConfigurationFrozen(...)List<String> resultisAllowEagerClassLoading(...)requiresEagerInitForType(...)boolean matchFoundboolean allowFactoryBeanInitboolean isNonLazyDecoratedFatalBeanException exLogMessage messagethis.manualSingletonNames/** Check whether the specified bean would need to be eagerly initialized ... */String exBeanNamefindAnnotationOnBean(...)orElse(...)synthesize(...)findMergedAnnotationOnBean(...)new Predicate<MergedAnnotation<A>>(...) { ... }MergedAnnotation<A> annotationSearchStrategy.TYPE_HIERARCHYmissing(...)// Implementation of ConfigurableListableBeanFactory interface/** Determine whether the specified bean definition qualifies as an autowire candidate, ... */String bdNamethis.mergedBeanDefinitionHoldersnew Function<String,BeanDefinitionHolder>(...) { ... }resolveFactoryMethodIfPossible(...)CompositeIterator<String> iteratornew CompositeIterator<String>(...)clearMetadataCache(...)clearByTypeCache(...)this.configurationFrozen/** Considers all beans as eligible for metadata caching ... */List<String> beanNamesboolean isEagerInitisEagerInit(...)Object singletonInstanceStartupStep smartInitializegetApplicationStartup(...)SmartInitializingSingleton smartSingletonafterSingletonsInstantiated(...)// Implementation of BeanDefinitionRegistry interfaceBeanDefinition existingDefinitionisAllowBeanDefinitionOverriding(...)new BeanDefinitionOverrideException(...)hasBeanCreationStarted(...)List<String> updatedDefinitionsremoveManualSingletonName(...)resetBeanDefinition(...)/** Reset all bean definition caches for the given bean, ... *//** Only allows alias overriding if bean definition overriding is allowed. *//** Also checks for an alias overriding a bean definition of the same name. */checkForAliasCircle(...)registerSingleton(...)updateManualSingletonNames(...)new Consumer<Set<String>>(...) { ... }new Predicate<Set<String>>(...) { ... }/** Update the factory's internal set of manual singleton names. ... */Set<String> updatedSingletons/** Remove any assumptions about by-type mappings. */// Dependency resolution functionalityString[] candidateNamescandidateNames.lengthList<String> autowireCandidatesMap<String,Object> candidatesdeterminePrimaryCandidate(...)toClass(...)determineHighestPriorityCandidate(...)new NamedBeanHolder<T>(...)createOptionalDependency(...)ObjectProvider<>.classnew DependencyObjectProvider(...)createDependencyProvider(...)new Jsr330Factory(...)getLazyResolutionProxyIfNecessary(...)doResolveDependency(...)Object shortcutresolveShortcut(...)getSuggestedValue(...)Object multipleBeansresolveMultipleBeans(...)Map<String,Object> matchingBeansfindAutowireCandidates(...)Object instanceCandidateString strValraiseNoMatchingBeanFound(...)determineAutowireCandidate(...)indicatesMultipleBeans(...)resolveNotUnique(...)resolveCandidate(...)Stream<Object> streamnew Function<String,Object>(...) { ... }new Predicate<Object>(...) { ... }isOrdered(...)Class<?> resolvedArrayTypenew MultiElementDescriptor(...)Comparator<Object> comparatoradaptDependencyComparator(...)getDependencyComparator(...)withSourceProvider(...)createFactoryAwareOrderSourceProvider(...)Comparator<Object> dependencyComparatorOrderComparator comparatorOrderComparator.INSTANCEOrderComparator.OrderSourceProviderIdentityHashMap<Object,String> instancesToBeanNamesnew IdentityHashMap<Object,String>(...)new BiConsumer<String,?>(...) { ... }new FactoryAwareOrderSourceProvider(...)/** Find bean instances that match the required type. ... */isEager(...)Entry<Class<?>,Object> classObjectEntryMap<>.Entry<Class<?>,Object>Class<?> autowiringTypeObject autowiringValueresolveAutowiringValue(...)String candidateisSelfReference(...)addCandidateEntry(...)boolean multipleDependencyDescriptor fallbackDescriptorforFallbackMatch(...)hasQualifier(...)/** Add an entry to the candidate map: a bean instance if available or just the resolved ... *//** Determine the autowire candidate in the given set of beans. ... */String primaryCandidateString priorityCandidatematchesBeanName(...)containsValue(...)getDependencyName(...)/** Determine the primary candidate in the given set of beans. ... */String primaryBeanNameString candidateBeanNameboolean candidateLocalboolean primaryLocal/** Determine the candidate with the highest priority in the given set of beans. ... */String highestPriorityBeanNameInteger highestPriorityInteger candidatePrioritygetPriority(...)/** Return whether the bean definition for the given bean name has been ... */String transformedBeanName/** Return the priority assigned for the given bean instance by ... *//** Determine whether the given candidate name matches the bean name or the aliases ... *//** Determine whether the given beanName/candidateName pair indicates a self reference, ... *//** Raise a NoSuchBeanDefinitionException or BeanNotOfRequiredTypeException ... */checkBeanNotOfRequiredType(...)/** Raise a BeanNotOfRequiredTypeException for an unresolvable dependency, if applicable, ... *//** Create an {@link Optional} wrapper for the specified dependency. */DependencyDescriptor descriptorToUsenew NestedDependencyDescriptor(...) { ... }ofNullable(...)new SerializedBeanFactoryReference(...)/** Minimal id reference to the factory. ... */Reference<?> refDefaultListableBeanFactory dummyFactorydummyFactory.serializationId/** A dependency descriptor marker for nested elements. */increaseNestingLevel(...)/** A dependency descriptor for a multi-element declaration with nested elements. *//** A dependency descriptor marker for stream access to multiple elements. */boolean ordered, ...;this.ordered/** Serializable ObjectFactory/ObjectProvider for lazy resolution of a dependency. */DependencyDescriptor descriptor, ...;this.descriptornew NestedDependencyDescriptor(...)Object dependencyresolveStream(...)new StreamDependencyDescriptor(...)/** Separate inner class for avoiding a hard dependency on the {@code javax.inject} API. ... */new Jsr330Provider(...)/** An {@link org.springframework.core.OrderComparator.OrderSourceProvider} implementation ... */Map<Object,String> instancesToBeanNames, ...;this.instancesToBeanNamesList<Object> sources// JSR-330 API not available - Provider interface simply not supported then.// A clone of the AutowireCandidateResolver since it is potentially BeanFactoryAware// Make resolvable dependencies (e.g. ResourceLoader) available here as well// Ignore resolved bean in non-active scope// Ignore resolved bean in non-active scope, even on scoped proxy invocation// Check all bean definitions.// Only consider bean as eligible if the bean name is not defined as alias for some other bean.// Only check bean definition if it is complete.// In case of FactoryBean, try to match FactoryBean instance itself next.// Probably a placeholder: let's ignore it for type matching purposes.// Register exception, in case the bean was accidentally unresolvable.// Bean definition got removed while we were iterating -> ignore.// Check manually registered singletons too.// In case of FactoryBean, match object created by FactoryBean.// Match found for this bean: do not match FactoryBean itself anymore.// In case of FactoryBean, try to match FactoryBean itself next.// Match raw bean instance (might be raw FactoryBean).// Shouldn't happen - probably a result of circular reference resolution...// Ignore: indicates a circular reference when autowiring constructors.// We want to find matches other than the currently created bean itself.// Check raw bean class, e.g. in case of a proxy.// Check annotations declared on factory method, if any.// If no DefaultListableBeanFactory, can't pass the resolver along.// Iterate over a copy to allow for init methods which in turn register new bean definitions.// While this may not be part of the regular factory bootstrap, it does otherwise work fine.// Trigger initialization of all non-lazy singleton beans...// Trigger post-initialization callback for all applicable beans...// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE// Cannot modify startup-time collection elements anymore (for stable iteration)// Still in startup registration phase// Remove the merged bean definition for the given bean, if already created.// Remove corresponding bean from singleton cache, if any. Shouldn't usually// be necessary, rather just meant for overriding a context's default beans// (e.g. the default StaticMessageSource in a StaticApplicationContext).// Notify all post-processors that the specified bean definition has been reset.// Reset all bean definitions that have the given bean as parent (recursively).// Ensure bd is non-null due to potential concurrent modification of beanDefinitionMap.// A custom TypeConverter which does not support TypeDescriptor resolution...// In case of an optional Collection/Map, silently ignore a non-unique case:// possibly it was meant to be an empty collection of multiple regular beans// (before 4.3 in particular when we didn't even look for collection beans).// We have exactly one match.// Consider fallback matches if the first pass failed to find anything...// Consider self references as a final pass...// but in the case of a dependency collection, not the very same bean itself.// Fallback// Probably a proxy interfering with target type match -> throw meaningful exception.// Lenient fallback: dummy factory in case of original factory not found...import BeanCreationNotAllowedExceptionimport SingletonBeanRegistryimport SimpleAliasRegistry/** Generic registry for shared bean instances, implementing the ... */new ConcurrentHashMap<String,Object>(...)new HashMap<String,ObjectFactory<?>>(...)new ConcurrentHashMap<String,Set<String>>(...)int SUPPRESSED_EXCEPTIONS_LIMIT, ...;/** Maximum number of suppressed exceptions to preserve. */Map<String,Object> singletonObjects, ...;/** Cache of singleton objects: bean name to bean instance. */Map<String,ObjectFactory<?>> singletonFactories, ...;/** Cache of singleton factories: bean name to ObjectFactory. */Map<String,Object> earlySingletonObjects, ...;/** Cache of early singleton objects: bean name to bean instance. */Set<String> registeredSingletons, ...;/** Set of registered singletons, containing the bean names in registration order. */Set<String> singletonsCurrentlyInCreation, ...;Set<String> inCreationCheckExclusions, ...;/** Names of beans currently excluded from in creation checks. */Set<Exception> suppressedExceptions, ...;/** Collection of suppressed Exceptions, available for associating related causes. */boolean singletonsCurrentlyInDestruction, ...;/** Flag that indicates whether we're currently within destroySingletons. */Map<String,Object> disposableBeans, ...;/** Disposable bean instances: bean name to disposable instance. */Map<String,Set<String>> containedBeanMap, ...;/** Map between containing bean names: bean name to Set of bean names that the bean contains. */Map<String,Set<String>> dependentBeanMap, ...;/** Map between dependent bean names: bean name to Set of dependent bean names. */Map<String,Set<String>> dependenciesForBeanMap, ...;/** Map between depending bean names: bean name to Set of bean names for the bean's dependencies. */this.singletonObjectsObject oldObjectaddSingleton(...)/** Add the given singleton object to the singleton cache of this factory. ... */this.singletonFactoriesthis.earlySingletonObjectsthis.registeredSingletons/** Add the given singleton factory for building the specified singleton ... */Object singletonObjectObjectFactory<?> singletonFactory/** Return the (raw) singleton object registered under the given name, ... */boolean newSingletonboolean recordSuppressedExceptionsthis.suppressedExceptionsthis.singletonsCurrentlyInDestructionnew BeanCreationNotAllowedException(...)new LinkedHashSet<Exception>(...)Exception suppressedExceptionaddRelatedCause(...)/** Register an exception that happened to get suppressed during the creation of a ... *//** Remove the bean with the given name from the singleton cache of this factory, ... */this.inCreationCheckExclusionsisActuallyInCreation(...)/** Return whether the specified singleton bean is currently in creation ... */this.singletonsCurrentlyInCreation/** Callback before singleton creation. ... *//** Callback after singleton creation. ... *//** Add the given bean to the list of disposable beans in this registry. ... */this.disposableBeans/** Register a containment relationship between two beans, ... */this.containedBeanMapSet<String> containedBeansnew Function<String,Set<String>>(...) { ... }this.dependentBeanMapSet<String> dependentBeansthis.dependenciesForBeanMapSet<String> dependenciesForBean/** Determine whether the specified dependent bean has been registered as ... */String transitiveDependency/** Determine whether a dependent bean has been registered for the given name. ... */String[] disposableBeanNamesdisposableBeanNames.length/** Clear all cached singleton instances in this registry. ... *//** Destroy the given bean. Delegates to {@code destroyBean} ... */DisposableBean disposableBean/** Destroy the given bean. Must destroy beans that depend on the given ... */Set<String> dependenciesString dependentBeanNameString containedBeanNameIterator<Entry<String,Set<String>>> itMap<>.Entry<String,Set<String>>Entry<String,Set<String>> entrySet<String> dependenciesToClean/** Exposes the singleton mutex to subclasses and external collaborators. ... */// Quick check for existing instance without full singleton lock// Consistent creation of early reference within full singleton lock// Has the singleton object implicitly appeared in the meantime ->// if yes, proceed with it since the exception indicates that state.// Remove a registered singleton of the given name, if any.// Destroy the corresponding DisposableBean instance.// Trigger destruction of dependent beans first...// Within full synchronization in order to guarantee a disconnected Set// Actually destroy the bean now...// Trigger destruction of contained beans...// Remove destroyed bean from other beans' dependencies.// Remove destroyed bean's prepared dependency information./** Adapter that implements the {@link DisposableBean} and {@link Runnable} ... */DisposableBeanAdapter.classString CLOSE_METHOD_NAME, ...;String SHUTDOWN_METHOD_NAME, ...;Object bean, ...;boolean invokeDisposableBean, ...;Method destroyMethod, ...;List<DestructionAwareBeanPostProcessor> beanPostProcessors, ...;/** Create a new DisposableBeanAdapter for the given bean. ... */String destroyMethodNameinferDestroyMethodIfNecessary(...)this.beanthis.invokeDisposableBeanMethod destroyMethoddetermineDestroyMethod(...)this.destroyMethodfilterPostProcessors(...)/** Create a new DisposableBeanAdapter for the given bean. *//** If the current value of the given beanDefinition's "destroyMethodName" property is ... */AbstractBeanDefinition.INFER_METHOD/** Search for all DestructionAwareBeanPostProcessors in the List. ... */List<DestructionAwareBeanPostProcessor> filteredPostProcessorsDestructionAwareBeanPostProcessor processorpostProcessBeforeDestruction(...)invokeCustomDestroyMethod(...)new PrivilegedAction<Method>(...) { ... }findDestroyMethod(...)/** Invoke the specified custom destroy method on the given bean. ... */int paramCountPrivilegedActionException pax/** Serializes a copy of the state of this class, ... */List<DestructionAwareBeanPostProcessor> serializablePostProcessorsDestructionAwareBeanPostProcessor postProcessor/** Check whether the given bean has any kind of destroy method to call. ... *//** Check whether the given bean has destruction-aware post-processors applying to it. ... */// Only perform destroy method inference or Closeable detection// in case of the bean not explicitly implementing DisposableBean// no candidate destroy method found/** Support base class for singleton registries which need to handle ... */Map<String,Object> factoryBeanObjectCache, ...;/** Cache of singleton objects created by FactoryBeans: FactoryBean name to object. *//** Determine the type for the given FactoryBean. ... */new PrivilegedAction<Class<?>>(...) { ... }/** Obtain an object to expose from the given FactoryBean, if available ... */this.factoryBeanObjectCache/** Obtain an object to expose from the given FactoryBean. ... */Object alreadyTheredoGetObjectFromFactoryBean(...)postProcessObjectFromFactoryBean(...)FactoryBeanNotInitializedException ex/** Post-process the given object that has been obtained from the FactoryBean. ... *//** Get a FactoryBean for the given bean if possible. ... *//** Overridden to clear the FactoryBean object cache as well. *//** Return the security context for this bean factory. If a security manager ... */// Thrown from the FactoryBean's getObjectType implementation.// Only post-process and store if not put there already during getObject() call above// (e.g. because of circular reference processing triggered by custom getBean calls)// Temporarily return non-post-processed object, not storing it yet..// Do not accept a null value for a FactoryBean that's not fully// initialized yet: Many FactoryBeans just return null then./** GenericBeanDefinition is a one-stop shop for standard bean definition purposes. ... *//** Create a new GenericBeanDefinition, to be configured through its bean ... *//** Create a new GenericBeanDefinition as deep copy of the given ... */GenericBeanDefinition that/** Basic {@link AutowireCandidateResolver} that performs a full generic type ... */checkGenericTypeMatch(...)/** Match the given dependency type with its generic type information against the given ... */ResolvableType dependencyTypeboolean cacheTyperbd.targetTypegetReturnTypeForFactoryMethod(...)dbd.targetTypefallbackMatchAllowed(...)BeanDefinitionHolder decDefConfigurableListableBeanFactory clbfBeanDefinition dbdrbd.factoryMethodReturnType/** This implementation clones all instance fields through standard ... */// If explicitly false, do not proceed with any other checks...// No generic type -> we know it's a Class type-match, so no need to check again.// First, check factory method return type, if applicable// Regular case: straight bean instance, with BeanFactory available.// Fallback: no BeanFactory set, or no type resolvable through it// -> best-effort match against the target class if applicable.// Fallback matches allow unresolvable generics, e.g. plain HashMap to Map<String,String>;// and pragmatically also java.util.Properties to any Map (since despite formally being a// Map<Object,Object>, java.util.Properties is usually perceived as a Map<String,String>).// Full check for complex generic type match...// Should typically be set for any kind of factory method, since the BeanFactory// pre-resolves them before reaching out to the AutowireCandidateResolver...// Only use factory method metadata if the return type is actually expressive enough// for our dependency. Otherwise, the returned instance type may have matched instead// in case of a singleton instance having been registered with the container already./** Internal exception to be propagated from {@link ConstructorResolver}, ... *//** Interface responsible for creating instances corresponding to a root bean definition. ... *//** Return an instance of the bean with the given name in this factory. ... *//** Return an instance of the bean with the given name in this factory, ... *//** Represents an override of a method that looks up an object in the same IoC context. ... *//** Construct a new LookupOverride. ... *//** Return the name of the bean that should be returned by this method. *//** Match the specified method by {@link Method} reference or method name. ... */isOverloaded(...)LookupOverride thatthat.method/** Tag collection class used to hold managed array elements, which may ... */Class<?> resolvedElementType, ...;/** Resolved element type for runtime creation of the target array. *//** Create a new managed array placeholder. ... */setElementTypeName(...)/** Tag collection class used to hold managed List elements, which may ... */String elementTypeName, ...;boolean mergeEnabled, ...;/** Set the default element type name (class name) to be used for this list. */this.elementTypeName/** Return the default element type name (class name) to be used for this list. *//** Set whether merging should be enabled for this collection, ... */this.mergeEnabledList<E> mergednew ManagedList(...)/** Tag collection class used to hold managed Map values, which may ... */String keyTypeName, ...;String valueTypeName, ...;/** Set the default key type name (class name) to be used for this map. */this.keyTypeName/** Return the default key type name (class name) to be used for this map. *//** Set the default value type name (class name) to be used for this map. */this.valueTypeName/** Return the default value type name (class name) to be used for this map. */Map<K,V> mergednew ManagedMap(...)/** Tag class which represents a Spring-managed {@link Properties} instance ... */Properties mergednew ManagedProperties(...)/** Tag collection class used to hold managed Set values, which may ... *//** Set the default element type name (class name) to be used for this set. *//** Return the default element type name (class name) to be used for this set. */Set<E> mergednew ManagedSet(...)/** Post-processor callback interface for <i>merged</i> bean definitions at runtime. ... *//** Post-process the given merged bean definition for the specified bean. ... *//** A notification that the bean definition for the specified name has been reset, ... *//** Object representing the override of a method on a managed object by the IoC ... */boolean overloaded, ...;/** Construct a new override for the given method. ... *//** Return the name of the method to be overridden. *//** Set whether the overridden method is <em>overloaded</em> (i.e., whether argument ... */this.overloaded/** Return whether the overridden method is <em>overloaded</em> (i.e., whether argument ... *//** Subclasses must override this to indicate whether they <em>match</em> the ... */MethodOverride thatthat.sourceimport CopyOnWriteArraySet/** Set of method overrides, determining which, if any, methods on a ... */new CopyOnWriteArraySet<MethodOverride>(...)Set<MethodOverride> overrides, ...;/** Create new MethodOverrides. *//** Deep copy constructor. *//** Copy all given method overrides into this object. */this.overridesother.overrides/** Add the given method override. *//** Return all method overrides contained by this object. ... *//** Return whether the set of method overrides is empty. *//** Return the override for the given method, if any. ... */MethodOverride matchMethodOverride candidateMethodOverrides thatthat.overrides/** Interface to be implemented by classes that can reimplement any method ... *//** Reimplement the given method. ... *//** Internal representation of a null bean instance, e.g. for a {@code null} value ... */import InputStreamReaderimport ResourceBundleimport PropertyAccessorimport ResourcePropertiesPersisterimport PropertiesPersister/** Bean definition reader for a simple properties format. ... */ResourcePropertiesPersister.INSTANCEString TRUE_VALUE, ...;/** Value of a T/F attribute that represents true. ... *//** Separator between bean name and property name. ... */String CLASS_KEY, ...;/** Special key to distinguish {@code owner.(class)=com.myapp.MyClass}. */String PARENT_KEY, ...;/** Special key to distinguish {@code owner.(parent)=parentBeanName}. */String SCOPE_KEY, ...;/** Special key to distinguish {@code owner.(scope)=prototype}. ... */String SINGLETON_KEY, ...;/** Special key to distinguish {@code owner.(singleton)=false}. ... */String ABSTRACT_KEY, ...;/** Special key to distinguish {@code owner.(abstract)=true} ... */String LAZY_INIT_KEY, ...;/** Special key to distinguish {@code owner.(lazy-init)=true} ... */String REF_SUFFIX, ...;/** Property suffix for references to other beans in the current ... */String REF_PREFIX, ...;/** Prefix before values referencing other beans. */String CONSTRUCTOR_ARG_PREFIX, ...;/** Prefix used to denote a constructor argument definition. */String defaultParentBean, ...;PropertiesPersister propertiesPersister, ...;/** Create new PropertiesBeanDefinitionReader for the given bean factory. ... *//** Set the default parent bean for this bean factory. ... */this.defaultParentBean/** Return the default parent bean for this bean factory. *//** Set the PropertiesPersister to use for parsing properties files. ... */this.propertiesPersister/** Return the PropertiesPersister to use for parsing properties files. *//** Load bean definitions from the specified properties file, ... *//** Load bean definitions from the specified properties file. ... */registerBeanDefinitions(...)InputStream isgetEncoding(...)getPropertiesPersister(...)new InputStreamReader(...)/** Register bean definitions contained in a resource bundle, ... *//** Register bean definitions contained in a ResourceBundle. ... */getKeys(...)/** Register bean definitions contained in a Map, using all property keys (i.e. not ... *//** Register bean definitions contained in a Map. ... */int beanCountString keyStringString nameAndPropertyint sepIdxint propKeyIdx/** Get all property values, given a prefix (which will be stripped) ... */String parentboolean isAbstractboolean lazyInitString prefixWithSepString propertyString valreadValue(...)String ref/** Reads the value of the entry. Correctly interprets bean references for ... */String targetName// Simply create a map and call overloaded method.// Key is of form: prefix<name>.property// Find dot before property name, ignoring dots in property keys.// If we haven't already registered it...// Ignore it: It wasn't a valid bean name and property,// although it did start with the required prefix.// Spring 2.0 style// Spring 1.2 style// This isn't a real property, but a reference to another prototype// Extract property name: property is of form dog(ref)// It doesn't matter if the referenced bean hasn't yet been registered:// this will ensure that the reference is resolved at runtime.// It's a normal bean property.// Just use default parent if we're not dealing with the parent itself,// and if there's no class name specified. The latter has to happen for// backwards compatibility reasons.// If it starts with a reference prefix...// Expand the reference.// Escaped prefix -> use plain value./** Extension of MethodOverride that represents an arbitrary ... */String methodReplacerBeanName, ...;List<String> typeIdentifiers, ...;/** Construct a new ReplaceOverride. ... */this.methodReplacerBeanName/** Return the name of the bean implementing MethodReplacer. *//** Add a fragment of a class string, like "Exception" ... */this.typeIdentifiersString identifierReplaceOverride thatthat.methodReplacerBeanNamethat.typeIdentifiers// Not overloaded: don't worry about arg type matching...// If we get here, we need to insist on precise argument matching.../** A root bean definition represents the merged bean definition that backs ... */BeanDefinitionHolder decoratedDefinition, ...;AnnotatedElement qualifiedElement, ...;boolean stale, ...;/** Determines if the definition needs to be re-merged. */boolean allowCaching, ...;boolean isFactoryMethodUnique, ...;ResolvableType targetType, ...;Class<?> resolvedTargetType, ...;/** Package-visible field for caching the determined Class of a given bean definition. */Boolean isFactoryBean, ...;/** Package-visible field for caching if the bean is a factory bean. */ResolvableType factoryMethodReturnType, ...;/** Package-visible field for caching the return type of a generically typed factory method. */Method factoryMethodToIntrospect, ...;/** Package-visible field for caching a unique factory method candidate for introspection. */Object constructorArgumentLock, ...;/** Common lock for the four constructor fields below. */Executable resolvedConstructorOrFactoryMethod, ...;/** Package-visible field for caching the resolved constructor or factory method. */boolean constructorArgumentsResolved, ...;/** Package-visible field that marks the constructor arguments as resolved. */...[] resolvedConstructorArguments, ...;/** Package-visible field for caching fully resolved constructor arguments. */...[] preparedConstructorArguments, ...;/** Package-visible field for caching partly prepared constructor arguments. */Object postProcessingLock, ...;/** Common lock for the two post-processing fields below. */boolean postProcessed, ...;/** Package-visible field that indicates MergedBeanDefinitionPostProcessor having been applied. */Boolean beforeInstantiationResolved, ...;/** Package-visible field that indicates a before-instantiation post-processor having kicked in. */Set<Member> externallyManagedConfigMembers, ...;Set<String> externallyManagedInitMethods, ...;Set<String> externallyManagedDestroyMethods, ...;/** Create a new RootBeanDefinition, to be configured through its bean ... *//** Create a new RootBeanDefinition for a singleton. ... *//** Create a new RootBeanDefinition for a singleton bean, constructing each instance ... *//** Create a new RootBeanDefinition for a scoped bean, constructing each instance ... *//** Create a new RootBeanDefinition for a singleton, ... *//** Create a new RootBeanDefinition as deep copy of the given ... */this.decoratedDefinitionoriginal.decoratedDefinitionthis.qualifiedElementoriginal.qualifiedElementthis.allowCachingoriginal.allowCachingthis.isFactoryMethodUniqueoriginal.isFactoryMethodUniqueoriginal.targetTypethis.factoryMethodToIntrospectoriginal.factoryMethodToIntrospect/** Register a target definition that is being decorated by this bean definition. *//** Return the target definition that is being decorated by this bean definition, if any. *//** Specify the {@link AnnotatedElement} defining qualifiers, ... *//** Return the {@link AnnotatedElement} defining qualifiers, if any. ... *//** Specify a generics-containing target type of this bean definition, if known in advance. ... *//** Specify the target type of this bean definition, if known in advance. ... *//** Return the target type of this bean definition, if known ... */this.resolvedTargetType/** Return a {@link ResolvableType} for this bean definition, ... */this.factoryMethodReturnType/** Determine preferred constructors to use for default construction, if any. ... *//** Specify a factory method name that refers to a non-overloaded method. *//** Specify a factory method name that refers to an overloaded method. ... *//** Check whether the given candidate qualifies as a factory method. *//** Set a resolved Java Method for the factory method on this bean definition. ... *//** Return the resolved factory method as a Java Method object, if available. ... */this.postProcessingLockthis.externallyManagedConfigMembersnew HashSet<Member>(...)this.externallyManagedInitMethodsthis.externallyManagedDestroyMethods/** A subclass of {@link BeanCreationException} which indicates that the target scope ... *//** Create a new ScopeNotActiveException. ... *//** Provider of the security context of the code running inside the bean factory. ... *//** Provides a security access control context relevant to a bean factory. ... *//** {@link AutowireCandidateResolver} implementation to use when no annotation ... */new SimpleAutowireCandidateResolver(...)SimpleAutowireCandidateResolver INSTANCE, ...;/** Shared instance of {@code SimpleAutowireCandidateResolver}. ... *//** This implementation returns {@code this} as-is. ... *//** Simple implementation of the {@link BeanDefinitionRegistry} interface. ... *//** Simple object instantiation strategy for use in a BeanFactory. ... */new ThreadLocal<Method>(...)ThreadLocal<Method> currentlyInvokedFactoryMethod, ...;/** Return the factory method currently being invoked or {@code null} if none. ... */bd.constructorArgumentLockbd.resolvedConstructorOrFactoryMethodnew PrivilegedExceptionAction<Constructor<?>>(...) { ... }/** Subclasses can override this method, which is implemented to throw ... */Method priorInvokedFactoryMethod// Don't override the class with CGLIB if no overrides.// Must generate CGLIB subclass.// use own privileged to change accessibility (when security is on)/** Simple {@link SecurityContextProvider} implementation. ... *//** Construct a new {@code SimpleSecurityContextProvider} instance. ... *//** Static {@link org.springframework.beans.factory.BeanFactory} implementation ... */Map<String,Object> beans, ...;/** Map from bean name to bean instance. *//** Create a regular {@code StaticListableBeanFactory}, to be populated ... */this.beans/** Create a {@code StaticListableBeanFactory} wrapping the given {@code Map}. ... *//** Add a new singleton bean. ... */new ObjectProvider<T>(...) { ... }boolean isFactoryTypeList<String> matchesMap<String,T> matchesList<String> resultsMap<String,Object> results// Don't let calling code try to dereference the// bean factory if the bean isn't a factory// In case of FactoryBean, return singleton status of created object.// In case of FactoryBean, return prototype status of created object.// Is bean a FactoryBean?// Match object created by FactoryBean.// If type to match is FactoryBean, return FactoryBean itself.// Else, return bean instance./** Classes supporting the {@code org.springframework.beans.factory} package. ... *//** Convenient base class for bean configurers that can perform Dependency Injection ... */BeanWiringInfoResolver beanWiringInfoResolver, ...;/** Set the {@link BeanWiringInfoResolver} to use. ... */this.beanWiringInfoResolver/** Set the {@link BeanFactory} in which this aspect must configure beans. */createDefaultBeanWiringInfoResolver(...)/** Create the default BeanWiringInfoResolver to be used if none was ... */new ClassNameBeanWiringInfoResolver(...)/** Check that a {@link BeanFactory} has been set. *//** Release references to the {@link BeanFactory} and ... *//** Configure the bean instance. ... */BeanWiringInfoResolver bwiResolverBeanWiringInfo bwiresolveWiringInfo(...)ConfigurableListableBeanFactory beanFactoryindicatesAutowiring(...)isDefaultBeanName(...)autowireBeanProperties(...)configureBean(...)// Skip the bean if no wiring info given.// Perform autowiring (also applying standard factory / post-processor callbacks).// Perform explicit wiring based on the specified bean definition./** Holder for bean wiring metadata information about a particular class. Used in ... */boolean isDefaultBeanName, ...;boolean dependencyCheck, ...;/** Create a default BeanWiringInfo that suggests plain initialization of ... *//** Create a new BeanWiringInfo that points to the given bean name. ... */this.isDefaultBeanName/** Create a new BeanWiringInfo that indicates autowiring. ... *//** Return whether this BeanWiringInfo indicates autowiring. *//** Return the specific bean name that this BeanWiringInfo points to, if any. *//** Return whether the specific bean name is a suggested default bean name, ... *//** Return one of the constants {@link #AUTOWIRE_BY_NAME} / ... *//** Return whether to perform a dependency check for object references ... *//** Strategy interface to be implemented by objects than can resolve bean name ... *//** Resolve the BeanWiringInfo for the given bean instance. ... *//** Simple default implementation of the {@link BeanWiringInfoResolver} interface, ... *//** Mechanism to determine bean wiring metadata from a bean instance. ... *//** Abstract {@link BeanDefinitionParser} implementation providing ... */String ID_ATTRIBUTE, ...;/** Constant for the "id" attribute. */String NAME_ATTRIBUTE, ...;/** Constant for the "name" attribute. */parseInternal(...)isNested(...)resolveId(...)shouldParseNameAsAliases(...)trimArrayElements(...)shouldFireEvents(...)BeanComponentDefinition componentDefinitionpostProcessComponentDefinition(...)BeanDefinitionStoreException ex/** Resolve the ID for the supplied {@link BeanDefinition}. ... */shouldGenerateId(...)shouldGenerateIdAsFallback(...)/** Register the supplied {@link BeanDefinitionHolder bean} with the supplied ... *//** Central template method to actually parse the supplied {@link Element} ... *//** Should an ID be generated instead of read from the passed in {@link Element}? ... *//** Should an ID be generated instead if the passed in {@link Element} does not ... *//** Determine whether the element's "name" attribute should get parsed as ... *//** Determine whether this parser is supposed to fire a ... *//** Hook method called after the primary parsing of a ... */import Attrimport NamedNodeMap/** Convenient base class for when there exists a one-to-one mapping ... *//** Parse the supplied {@link Element} and populate the supplied ... */NamedNodeMap attributesgetAttributes(...)Attr attributeisEligibleAttribute(...)extractPropertyName(...)postProcess(...)/** Determine whether the given attribute is eligible for being ... */String fullName/** Extract a JavaBean property name from the supplied attribute name. ... */attributeNameToPropertyName(...)/** Hook method that derived classes can implement to inspect/change a ... *//** Base class for those {@link BeanDefinitionParser} implementations that ... *//** Creates a {@link BeanDefinitionBuilder} instance for the ... */genericBeanDefinition(...)BeanDefinition containingBdgetContainingBeanDefinition(...)getRawBeanDefinition(...)isDefaultLazyInit(...)doParse(...)/** Determine the name for the parent of the currently parsed bean, ... *//** Determine the bean class corresponding to the supplied {@link Element}. ... *//** Determine the bean class name corresponding to the supplied {@link Element}. ... */// Inner bean definition must receive same scope as containing bean.// Default-lazy-init applies to custom bean definitions as well./** Interface used by the {@link DefaultBeanDefinitionDocumentReader} ... *//** Parse the specified {@link Node} (either an element or an attribute) and decorate ... */import Document/** SPI for parsing an XML document that contains Spring bean definitions. ... *//** Read bean definitions from the given DOM document and ... *//** Interface used by the {@link DefaultBeanDefinitionDocumentReader} to handle custom, ... *//** Parse the specified {@link Element} and register the resulting ... */import BeanMetadataAttributeimport BeanEntryimport ConstructorArgumentEntryimport PropertyEntryimport QualifierEntryimport BeanDefinitionDefaultsimport ManagedArrayimport ManagedPropertiesimport ManagedSetimport MethodOverridesimport ReplaceOverride/** Stateful delegate class used to parse XML bean definitions. ... */new DocumentDefaultsDefinition(...)String BEANS_NAMESPACE_URI, ...;String MULTI_VALUE_ATTRIBUTE_DELIMITERS, ...;String FALSE_VALUE, ...;String DEFAULT_VALUE, ...;String DESCRIPTION_ELEMENT, ...;String AUTOWIRE_NO_VALUE, ...;String AUTOWIRE_BY_NAME_VALUE, ...;String AUTOWIRE_BY_TYPE_VALUE, ...;String AUTOWIRE_CONSTRUCTOR_VALUE, ...;String AUTOWIRE_AUTODETECT_VALUE, ...;String BEAN_ELEMENT, ...;String META_ELEMENT, ...;String PARENT_ATTRIBUTE, ...;String CLASS_ATTRIBUTE, ...;String ABSTRACT_ATTRIBUTE, ...;String SCOPE_ATTRIBUTE, ...;String SINGLETON_ATTRIBUTE, ...;String LAZY_INIT_ATTRIBUTE, ...;String AUTOWIRE_ATTRIBUTE, ...;String AUTOWIRE_CANDIDATE_ATTRIBUTE, ...;String PRIMARY_ATTRIBUTE, ...;String DEPENDS_ON_ATTRIBUTE, ...;String INIT_METHOD_ATTRIBUTE, ...;String DESTROY_METHOD_ATTRIBUTE, ...;String FACTORY_METHOD_ATTRIBUTE, ...;String FACTORY_BEAN_ATTRIBUTE, ...;String CONSTRUCTOR_ARG_ELEMENT, ...;String INDEX_ATTRIBUTE, ...;String TYPE_ATTRIBUTE, ...;String VALUE_TYPE_ATTRIBUTE, ...;String KEY_TYPE_ATTRIBUTE, ...;String PROPERTY_ELEMENT, ...;String REF_ATTRIBUTE, ...;String VALUE_ATTRIBUTE, ...;String LOOKUP_METHOD_ELEMENT, ...;String REPLACED_METHOD_ELEMENT, ...;String REPLACER_ATTRIBUTE, ...;String ARG_TYPE_ELEMENT, ...;String ARG_TYPE_MATCH_ATTRIBUTE, ...;String REF_ELEMENT, ...;String IDREF_ELEMENT, ...;String BEAN_REF_ATTRIBUTE, ...;String PARENT_REF_ATTRIBUTE, ...;String VALUE_ELEMENT, ...;String NULL_ELEMENT, ...;String ARRAY_ELEMENT, ...;String LIST_ELEMENT, ...;String SET_ELEMENT, ...;String MAP_ELEMENT, ...;String ENTRY_ELEMENT, ...;String KEY_ELEMENT, ...;String KEY_ATTRIBUTE, ...;String KEY_REF_ATTRIBUTE, ...;String VALUE_REF_ATTRIBUTE, ...;String PROPS_ELEMENT, ...;String PROP_ELEMENT, ...;String MERGE_ATTRIBUTE, ...;String QUALIFIER_ELEMENT, ...;String QUALIFIER_ATTRIBUTE_ELEMENT, ...;String DEFAULT_LAZY_INIT_ATTRIBUTE, ...;String DEFAULT_MERGE_ATTRIBUTE, ...;String DEFAULT_AUTOWIRE_ATTRIBUTE, ...;String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE, ...;String DEFAULT_INIT_METHOD_ATTRIBUTE, ...;String DEFAULT_DESTROY_METHOD_ATTRIBUTE, ...;XmlReaderContext readerContext, ...;DocumentDefaultsDefinition defaults, ...;Set<String> usedNames, ...;/** Stores all used bean names so we can enforce uniqueness on a per ... *//** Create a new BeanDefinitionParserDelegate associated with the supplied ... */this.readerContext/** Get the {@link XmlReaderContext} associated with this helper instance. *//** Invoke the {@link org.springframework.beans.factory.parsing.SourceExtractor} ... *//** Report an error with the given message for the given source element. *//** Initialize the default settings assuming a {@code null} parent delegate. */initDefaults(...)/** Initialize the default lazy-init, autowire, dependency check settings, ... */populateDefaults(...)this.defaultsparent.defaultsfireDefaultsRegistered(...)/** Populate the given DocumentDefaultsDefinition instance with the default lazy-init, ... */String lazyInitString mergeString autowireisDefaultValue(...)getMerge(...)setMerge(...)getAutowire(...)setAutowire(...)setAutowireCandidates(...)getAutowireCandidates(...)setInitMethod(...)getInitMethod(...)setDestroyMethod(...)getDestroyMethod(...)/** Return the defaults definition object. *//** Return the default settings for bean definitions as indicated within ... */BeanDefinitionDefaults bddnew BeanDefinitionDefaults(...)equalsIgnoreCase(...)/** Return any patterns provided in the 'default-autowire-candidates' ... */String candidatePattern/** Parses the supplied {@code <bean>} element. May return {@code null} ... */parseBeanDefinitionElement(...)String nameAttrAbstractBeanDefinition beanDefinitionString[] nameArrcheckNameUniqueness(...)String[] aliasesArray/** Validate that the specified bean name and aliases have not been used already ... */String foundNamethis.usedNamesfindFirstMatch(...)/** Parse the bean definition itself, without regard to name or aliases. May return ... */new BeanEntry(...)parseBeanDefinitionAttributes(...)setDescription(...)getChildElementValueByTagName(...)parseMetaElements(...)parseLookupOverrideSubElements(...)parseReplacedMethodSubElements(...)parseConstructorArgElements(...)parsePropertyElements(...)parseQualifierElements(...)NoClassDefFoundError err/** Apply the attributes of the given bean element to the given bean * definition. ... */String autowireCandidateString dependsOnString[] patterns/** Create a bean definition for the given class name and parent name. ... *//** Parse the meta elements underneath the given element, if any. */NodeList nlisCandidateElement(...)nodeNameEquals(...)Element metaElementaddMetadataAttribute(...)/** Parse the given autowire attribute value into ... */String attrint autowireAbstractBeanDefinition.AUTOWIRE_AUTODETECT/** Parse constructor-arg sub-elements of the given bean element. */parseConstructorArgElement(...)/** Parse property sub-elements of the given bean element. */parsePropertyElement(...)/** Parse qualifier sub-elements of the given bean element. */parseQualifierElement(...)/** Parse lookup-override sub-elements of the given bean element. */String beanRef/** Parse replaced-method sub-elements of the given bean element. */Element replacedMethodEleString callbackReplaceOverride replaceOverridenew ReplaceOverride(...)List<Element> argTypeElesElement argTypeElegetTextValue(...)addTypeIdentifier(...)/** Parse a constructor-arg element. */String indexAttrString typeAttrparsePropertyValue(...)new ConstructorArgumentEntry(...)hasIndexedArgumentValue(...)NumberFormatException ex/** Parse a property element. */new PropertyEntry(...)/** Parse a qualifier element. */new QualifierEntry(...)new AutowireCandidateQualifier(...)Element attributeEleString attributeValueaddQualifier(...)/** Get the value of a property element. May be a list etc. ... */Element subElementboolean hasRefAttributeboolean hasValueAttributeparsePropertySubElement(...)/** Parse a value, ref or collection sub-element of a property or ... */isDefaultNamespace(...)parseNestedCustomElement(...)BeanDefinitionHolder nestedBddecorateBeanDefinitionIfRequired(...)boolean toParentparseIdRefElement(...)parseValueElement(...)TypedStringValue nullHolderparseArrayElement(...)parseListElement(...)parseSetElement(...)parseMapElement(...)parsePropsElement(...)getNodeName(...)/** Return a typed String value Object for the given 'idref' element. *//** Return a typed String value Object for the given value element. */String specifiedTypeNamebuildTypedStringValue(...)setSpecifiedTypeName(...)/** Build a typed String value Object for the given raw value. ... *//** Parse an array element. */String elementTypeManagedArray targetnew ManagedArray(...)setMergeEnabled(...)parseMergeAttribute(...)parseCollectionElements(...)/** Parse a list element. */String defaultElementTypeManagedList<Object> target/** Parse a set element. */ManagedSet<Object> targetnew ManagedSet<Object>(...)/** Parse a map element. */String defaultKeyTypeString defaultValueTypeList<Element> entryElesManagedMap<Object,Object> mapsetKeyTypeName(...)setValueTypeName(...)Element entryEleNodeList entrySubNodesElement keyEleElement valueEleboolean hasKeyAttributeboolean hasKeyRefAttributeboolean hasValueRefAttributeboolean hasValueTypeAttributeElement candidateElebuildTypedStringValueForMap(...)parseKeyElement(...)String valueType/** Parse a key sub-element of a map element. *//** Parse a props element. */ManagedProperties propsList<Element> propElesElement propEleTypedStringValue keyHolder/** Parse the merge attribute of a collection element, if any. *//** Parse a custom element (outside of the default namespace). ... */parseCustomElement(...)String namespaceUrigetNamespaceURI(...)NamespaceHandler handlerparse(...)/** Decorate the given bean definition through a namespace handler, if applicable. ... */BeanDefinitionHolder finalDefinitionNodeList childrendecorateIfRequired(...)getNodeType(...)Node.ELEMENT_NODE/** Decorate the given bean definition through a namespace handler, ... */BeanDefinitionHolder decorateddecorate(...)BeanDefinition innerDefinitionBeanDefinitionReaderUtils.GENERATED_BEAN_NAME_SEPARATOR/** Get the namespace URI for the supplied node. ... *//** Get the local name for the supplied {@link Node}. ... *//** Determine whether the name of the supplied node is equal to the supplied name. ... *//** Determine whether the given URI indicates the default namespace. *//** Determine whether the given node indicates the default namespace. */getParentNode(...)// Potentially inherited from outer <beans> sections, otherwise falling back to false.// Potentially inherited from outer <beans> sections, otherwise falling back to 'no'.// Register an alias for the plain bean class name, if still possible,// if the generator returned the class name plus a suffix.// This is expected for Spring 1.2/2.0 backwards compatibility.// Take default from containing bean in case of an inner bean definition.// Else leave default value.// Look for arg-type match elements.// Should only have one child element: ref, value, list, etc.// Child element is what we're looking for.// Neither child element nor "ref" or "value" attribute found.// A generic reference to any name of any bean.// A reference to the id of another bean in a parent context.// It's a distinguished null value. Let's wrap it in a TypedStringValue// object in order to preserve the source location.// It's a literal value.// Should only have one value child element: ref, value, list, etc.// Optionally, there might be a key child element.// the element is a <description> -> ignore it// Extract key from attribute or sub-element.// Extract value from attribute or sub-element.// Add final key and value to the Map.// Trim the text value to avoid unwanted whitespace// caused by typical XML formatting.// Decorate based on custom attributes first.// Decorate based on custom nested elements.// A custom namespace, not to be handled by Spring - maybe "xml:...".import EntityResolver/** {@link EntityResolver} implementation for the Spring beans DTD, ... */BeansDtdResolver.classString DTD_EXTENSION, ...;String DTD_NAME, ...;int lastPathSeparatorint dtdNameStartString dtdFileInputSource sourcenew InputSource(...)setPublicId(...)setSystemId(...)// Fall back to the parser's default behavior.import URISyntaxExceptionimport ResourcePatternUtilsimport ResourceUtils/** Default implementation of the {@link BeanDefinitionDocumentReader} interface that ... */BeanDefinitionParserDelegate.BEAN_ELEMENTString NESTED_BEANS_ELEMENT, ...;String ALIAS_ELEMENT, ...;String ALIAS_ATTRIBUTE, ...;String IMPORT_ELEMENT, ...;String RESOURCE_ATTRIBUTE, ...;String PROFILE_ATTRIBUTE, ...;BeanDefinitionParserDelegate delegate, ...;/** This implementation parses bean definitions according to the "spring-beans" XSD ... */doRegisterBeanDefinitions(...)getDocumentElement(...)/** Return the descriptor for the XML resource that this parser works on. *//** Register each bean definition within the given root {@code <beans/>} element. */BeanDefinitionParserDelegate parentcreateDelegate(...)String profileSpecString[] specifiedProfilesBeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERSacceptsProfiles(...)preProcessXml(...)parseBeanDefinitions(...)postProcessXml(...)/** Parse the elements at the root level in the document: ... */parseDefaultElement(...)importBeanDefinitionResource(...)processAliasRegistration(...)processBeanDefinition(...)/** Parse an "import" element and load the bean definitions ... */Set<Resource> actualResourcesnew LinkedHashSet<Resource>(...)boolean absoluteLocationResource[] actResArrayresolveRequiredPlaceholders(...)isUrl(...)isAbsolute(...)toURI(...)URISyntaxException exint importCountResource relativeResourcecreateRelative(...)exists(...)String baseLocationgetURL(...)applyRelativePath(...)fireImportProcessed(...)/** Process the given alias element, registering the alias with the registry. */boolean validfireAliasRegistered(...)/** Process the given bean element, parsing the bean definition ... *//** Allow the XML to be extensible by processing any custom element types first, ... *//** Allow the XML to be extensible by processing any custom element types last, ... */// for Environment.acceptsProfiles(String...)// Any nested <beans> elements will cause recursion in this method. In// order to propagate and preserve <beans> default-* attributes correctly,// keep track of the current (parent) delegate, which may be null. Create// the new (child) delegate with a reference to the parent for fallback purposes,// then ultimately reset this.delegate back to its original (parent) reference.// this behavior emulates a stack of delegates without actually necessitating one.// We cannot use Profiles.of(...) since profile expressions are not supported// in XML config. See SPR-12458 for details.// recurse// Resolve system properties: e.g. "${user.dir}"// Discover whether the location is an absolute or relative URI// cannot convert to an URI, considering the location relative// unless it is the well-known Spring prefix "classpath*:"// Absolute or relative?// No URL -> considering resource location as relative to the current file.// Register the final decorated instance.// Send registration event.import DocumentBuilderimport DocumentBuilderFactoryimport ParserConfigurationExceptionimport ErrorHandlerimport XmlValidationModeDetector/** Spring's default {@link DocumentLoader} implementation. ... */DefaultDocumentLoader.classString SCHEMA_LANGUAGE_ATTRIBUTE, ...;/** JAXP attribute used to configure the schema language for validation. */String XSD_SCHEMA_LANGUAGE, ...;/** JAXP attribute value indicating the XSD schema language. *//** Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured ... */DocumentBuilderFactory factorycreateDocumentBuilderFactory(...)DocumentBuilder buildercreateDocumentBuilder(...)/** Create the {@link DocumentBuilderFactory} instance. ... */setNamespaceAware(...)XmlValidationModeDetector.VALIDATION_NONEXmlValidationModeDetector.VALIDATION_XSDParserConfigurationException pcexnew ParserConfigurationException(...)/** Create a JAXP DocumentBuilder that this bean definition reader ... */DocumentBuilder docBuildernewDocumentBuilder(...)setEntityResolver(...)setErrorHandler(...)// Enforce namespace aware for XSD...import PropertiesLoaderUtils/** Default implementation of the {@link NamespaceHandlerResolver} interface. ... */String DEFAULT_HANDLER_MAPPINGS_LOCATION, ...;/** The location to look for the mapping files. Can be present in multiple JAR files. */ClassLoader classLoader, ...;/** ClassLoader to use for NamespaceHandler classes. */String handlerMappingsLocation, ...;/** Resource location to search for. */Map<String,Object> handlerMappings, ...;/** Stores the mappings from namespace URI to NamespaceHandler class name / instance. *//** Create a new {@code DefaultNamespaceHandlerResolver} using the ... */this.classLoaderthis.handlerMappingsLocation/** Locate the {@link NamespaceHandler} for the supplied namespace URI ... */Map<String,Object> handlerMappingsgetHandlerMappings(...)Object handlerOrClassNameClass<?> handlerClassNamespaceHandler.class/** Load the specified NamespaceHandler mappings lazily. */this.handlerMappingsProperties mappingsloadAllProperties(...)mergePropertiesIntoMap(...)import SAXException/** {@link EntityResolver} implementation that delegates to a {@link BeansDtdResolver} ... */String DTD_SUFFIX, ...;/** Suffix for DTD files. */String XSD_SUFFIX, ...;/** Suffix for schema definition files. */EntityResolver dtdResolver, ...;EntityResolver schemaResolver, ...;/** Create a new DelegatingEntityResolver that delegates to ... */this.dtdResolvernew BeansDtdResolver(...)this.schemaResolvernew PluggableSchemaResolver(...)resolveEntity(...)import DefaultsDefinition/** Simple JavaBean that holds the defaults specified at the {@code <beans>} ... */String lazyInit, ...;String merge, ...;String autowire, ...;String autowireCandidates, ...;String initMethod, ...;String destroyMethod, ...;/** Set the default lazy-init flag for the document that's currently parsed. *//** Return the default lazy-init flag for the document that's currently parsed. *//** Set the default merge setting for the document that's currently parsed. */this.merge/** Return the default merge setting for the document that's currently parsed. *//** Set the default autowire setting for the document that's currently parsed. */this.autowire/** Return the default autowire setting for the document that's currently parsed. *//** Set the default autowire-candidate pattern for the document that's currently parsed. ... */this.autowireCandidates/** Return the default autowire-candidate pattern for the document that's currently parsed. ... *//** Set the default init-method setting for the document that's currently parsed. */this.initMethod/** Return the default init-method setting for the document that's currently parsed. *//** Set the default destroy-method setting for the document that's currently parsed. *//** Return the default destroy-method setting for the document that's currently parsed. *//** Strategy interface for loading an XML {@link Document}. ... *//** Load a {@link Document document} from the supplied {@link InputSource source}. ... *//** Base interface used by the {@link DefaultBeanDefinitionDocumentReader} ... *//** Invoked by the {@link DefaultBeanDefinitionDocumentReader} after ... *//** Parse the specified {@link Element} and register any resulting ... *//** Parse the specified {@link Node} and decorate the supplied ... *//** Used by the {@link org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader} to ... *//** Resolve the namespace URI and return the located {@link NamespaceHandler} ... *//** Support class for implementing custom {@link NamespaceHandler NamespaceHandlers}. ... */new HashMap<String,BeanDefinitionParser>(...)new HashMap<String,BeanDefinitionDecorator>(...)Map<String,BeanDefinitionParser> parsers, ...;/** Stores the {@link BeanDefinitionParser} implementations keyed by the ... */Map<String,BeanDefinitionDecorator> decorators, ...;/** Stores the {@link BeanDefinitionDecorator} implementations keyed by the ... */Map<String,BeanDefinitionDecorator> attributeDecorators, ...;/** Stores the {@link BeanDefinitionDecorator} implementations keyed by the local ... *//** Parses the supplied {@link Element} by delegating to the {@link BeanDefinitionParser} that is ... */BeanDefinitionParser parserfindParserForElement(...)/** Locates the {@link BeanDefinitionParser} from the register implementations using ... */this.parsers/** Decorates the supplied {@link Node} by delegating to the {@link BeanDefinitionDecorator} that ... */BeanDefinitionDecorator decoratorfindDecoratorForNode(...)this.decoratorsthis.attributeDecorators/** Subclasses can call this to register the supplied {@link BeanDefinitionParser} to ... *//** Subclasses can call this to register the supplied {@link BeanDefinitionDecorator} to ... *//** Context that gets passed along a bean definition parsing process, ... */new ArrayDeque<CompositeComponentDefinition>(...)BeanDefinition containingBeanDefinition, ...;Deque<CompositeComponentDefinition> containingComponents, ...;this.containingBeanDefinitionBeanDefinitionParserDelegate.TRUE_VALUEgetDefaults(...)this.containingComponentspopContainingComponent(...)CompositeComponentDefinition containingComponentgetContainingComponent(...)addNestedComponent(...)/** {@link EntityResolver} implementation that attempts to resolve schema URLs into ... */PluggableSchemaResolver.classString DEFAULT_SCHEMA_MAPPINGS_LOCATION, ...;/** The location of the file that defines schema mappings. ... */String schemaMappingsLocation, ...;Map<String,String> schemaMappings, ...;/** Stores the mapping of schema URL -> local schema path. *//** Loads the schema URL -> schema file location mappings using the default ... */this.schemaMappingsLocation/** Loads the schema URL -> schema file location mappings using the given ... */String resourceLocationgetSchemaMappings(...)/** Load the specified schema mappings lazily. */Map<String,String> schemaMappingsthis.schemaMappings// Retrieve canonical http schema mapping even for https declarationimport URLDecoder/** {@code EntityResolver} implementation that tries to resolve entity references ... */ResourceEntityResolver.class/** Create a ResourceEntityResolver for the specified ResourceLoader ... */String resourcePathString decodedSystemIddecode(...)String givenUrlnew URL(...)String systemRootUrltoURL(...)new File(...)String urlopenStream(...)// Try relative to resource base if currently in system root.// Typically a MalformedURLException or AccessControlException.// No URL (or no resolvable URL) -> try relative to resource base.// External dtd/xsd lookup via https even for canonical http declaration/** Simple {@code NamespaceHandler} implementation that maps custom ... */String DELIMITER_PREFIX, ...;Attr attrString argNameString argValueConstructorArgumentValues cvsboolean refString argcontainsArgWithName(...)checkName(...)ValueHolder holder// handle -ref arguments// handle "escaped"/"_" arguments// fast default check// assume an index otherwise// no escaping -> ctr name/** Simple {@code NamespaceHandler} implementation that maps custom attributes ... */import FieldRetrievingFactoryBeanimport ListFactoryBeanimport MapFactoryBeanimport PropertiesFactoryBeanimport PropertyPathFactoryBeanimport SetFactoryBean/** {@link NamespaceHandler} for the {@code util} namespace. ... */new ConstantBeanDefinitionParser(...)new PropertyPathBeanDefinitionParser(...)new ListBeanDefinitionParser(...)new SetBeanDefinitionParser(...)new MapBeanDefinitionParser(...)new PropertiesBeanDefinitionParser(...)FieldRetrievingFactoryBean.classString propertyPathListFactoryBean.classList<Object> parsedListString listClassSetFactoryBean.classSet<Object> parsedSetString setClassMapFactoryBean.classMap<Object,Object> parsedMapString mapClassPropertiesFactoryBean.classProperties parsedPropsString[] locationsresolvePlaceholders(...)import SAXParseExceptionimport EmptyReaderEventListenerimport FailFastProblemReporterimport NullSourceExtractorimport ProblemReporterimport ReaderEventListenerimport SimpleSaxErrorHandler/** Bean definition reader for XML bean definitions. ... */DefaultBeanDefinitionDocumentReader.classnew FailFastProblemReporter(...)new EmptyReaderEventListener(...)new NullSourceExtractor(...)new DefaultDocumentLoader(...)new SimpleSaxErrorHandler(...)new XmlValidationModeDetector(...)new NamedThreadLocal<Set<EncodedResource>>(...) { ... }new HashSet<EncodedResource>(...)XmlValidationModeDetector.VALIDATION_AUTOXmlValidationModeDetector.VALIDATION_DTDXmlBeanDefinitionReader.classint VALIDATION_NONE, ...;/** Indicates that the validation should be disabled. */int VALIDATION_AUTO, ...;/** Indicates that the validation mode should be detected automatically. */int VALIDATION_DTD, ...;/** Indicates that DTD validation should be used. */int VALIDATION_XSD, ...;/** Indicates that XSD validation should be used. *//** Constants instance for this class. */int validationMode, ...;boolean namespaceAware, ...;Class<? extends BeanDefinitionDocumentReader> documentReaderClass, ...;NamespaceHandlerResolver namespaceHandlerResolver, ...;DocumentLoader documentLoader, ...;EntityResolver entityResolver, ...;ErrorHandler errorHandler, ...;XmlValidationModeDetector validationModeDetector, ...;ThreadLocal<Set<EncodedResource>> resourcesCurrentlyBeingLoaded, ...;/** Create new XmlBeanDefinitionReader for the given bean factory. ... *//** Set whether to use XML validation. Default is {@code true}. ... */this.validationModethis.namespaceAware/** Set the validation mode to use by name. Defaults to {@link #VALIDATION_AUTO}. ... */setValidationMode(...)/** Set the validation mode to use. Defaults to {@link #VALIDATION_AUTO}. ... *//** Return the validation mode to use. *//** Set whether or not the XML parser should be XML namespace aware. ... *//** Return whether or not the XML parser should be XML namespace aware. *//** Specify which {@link org.springframework.beans.factory.parsing.ProblemReporter} to use. ... *//** Specify which {@link ReaderEventListener} to use. ... *//** Specify the {@link SourceExtractor} to use. ... *//** Specify the {@link NamespaceHandlerResolver} to use. ... */this.namespaceHandlerResolver/** Specify the {@link DocumentLoader} to use. ... */this.documentLoader/** Set a SAX entity resolver to be used for parsing. ... */this.entityResolver/** Return the EntityResolver to use, building a default resolver ... */new ResourceEntityResolver(...)new DelegatingEntityResolver(...)/** Set an implementation of the {@code org.xml.sax.ErrorHandler} ... */this.errorHandler/** Specify the {@link BeanDefinitionDocumentReader} implementation to use, ... */this.documentReaderClass/** Load bean definitions from the specified XML file. ... */Set<EncodedResource> currentResourcesthis.resourcesCurrentlyBeingLoadedInputStream inputStreamInputSource inputSourcesetEncoding(...)doLoadBeanDefinitions(...)/** Actually load bean definitions from the specified XML file. ... */Document docdoLoadDocument(...)SAXParseException exnew XmlBeanDefinitionStoreException(...)getLineNumber(...)SAXException exParserConfigurationException ex/** Actually load the specified document using the configured DocumentLoader. ... */loadDocument(...)getEntityResolver(...)getValidationModeForResource(...)isNamespaceAware(...)/** Determine the validation mode for the specified {@link Resource}. ... */int validationModeToUsegetValidationMode(...)int detectedModedetectValidationMode(...)/** Detect which kind of validation to perform on the XML file identified ... */isOpen(...)this.validationModeDetector/** Register the bean definitions contained in the given DOM document. ... */BeanDefinitionDocumentReader documentReadercreateBeanDefinitionDocumentReader(...)/** Create the {@link BeanDefinitionDocumentReader} to use for actually ... *//** Create the {@link XmlReaderContext} to pass over to the document reader. *//** Lazily create a default NamespaceHandlerResolver, if not set before. ... */createDefaultNamespaceHandlerResolver(...)/** Create the default implementation of {@link NamespaceHandlerResolver} used if none is specified. ... */new DefaultNamespaceHandlerResolver(...)// Determine default EntityResolver to use.// Hmm, we didn't get a clear indication... Let's assume XSD,// since apparently no DTD declaration has been found up until// detection stopped (before finding the document's root tag)./** XML-specific BeanDefinitionStoreException subclass that wraps a ... *//** Create a new XmlBeanDefinitionStoreException. ... *//** Return the line number in the XML resource that failed. ... *//** Convenience extension of {@link DefaultListableBeanFactory} that reads bean definitions ... *//** Create a new XmlBeanFactory with the given resource, ... *//** Create a new XmlBeanFactory with the given input stream, ... */import StringReaderimport ReaderContext/** Extension of {@link org.springframework.beans.factory.parsing.ReaderContext}, ... *//** Construct a new {@code XmlReaderContext}. ... *//** Return the XML bean definition reader in use. *//** Return the bean definition registry to use. ... *//** Return the resource loader to use, if any. ... *//** Return the bean class loader to use, if any. ... *//** Return the environment to use. ... *//** Return the namespace resolver. ... *//** Call the bean name generator for the given bean definition. ... */// Convenience methods to delegate togetBeanNameGenerator(...)/** Call the bean name generator for the given bean definition ... *//** Read an XML document from the given String. ... */InputSource isnew StringReader(...)/** Contains an abstract XML-based {@code BeanFactory} implementation, ... *//** This package contains interfaces and classes for manipulating Java beans. ... *//** Editor for byte arrays. Strings will simply be converted to ... */byte[] valuenew String(...)/** Editor for char arrays. Strings will simply be converted to ... */toCharArray(...)char[] value/** Editor for a {@link Character}, to populate a property ... */String UNICODE_PREFIX, ...;/** The prefix that identifies a string as being a Unicode character sequence. */int UNICODE_LENGTH, ...;/** The length of a Unicode character sequence. */boolean allowEmpty, ...;/** Create a new CharacterEditor instance. ... */this.allowEmptyisUnicodeCharacterSequence(...)setAsUnicode(...)// Treat empty String as null value./** Editor for {@code java.nio.charset.Charset}, translating charset ... */Charset valuename(...)/** Property editor for an array of {@link Class Classes}, to enable ... *//** Create a default {@code ClassEditor}, using the thread ... *//** Create a default {@code ClassArrayEditor}, using the given ... */String[] classNamesClass<?>[] classesclassNames.lengthStringJoiner sjClass<?> klass/** Property editor for {@link Class java.lang.Class}, to enable the direct ... *//** Create a default ClassEditor, using the thread context ClassLoader. *//** Create a default ClassEditor, using the given ClassLoader. ... *//** Editor for {@code java.util.Currency}, translating currency codes into Currency ... */Currency valuegetCurrencyCode(...)/** Property editor for Boolean/boolean properties. ... */String VALUE_TRUE, ...;/** Value of {@code "true"}. */String VALUE_FALSE, ...;/** Value of {@code "false"}. */String VALUE_ON, ...;/** Value of {@code "on"}. */String VALUE_OFF, ...;/** Value of {@code "off"}. */String VALUE_YES, ...;/** Value of {@code "yes"}. */String VALUE_NO, ...;/** Value of {@code "no"}. */String VALUE_1, ...;/** Value of {@code "1"}. */String VALUE_0, ...;/** Value of {@code "0"}. */String trueString, ...;String falseString, ...;/** Create a new CustomBooleanEditor instance, with "true"/"on"/"yes" ... *//** Create a new CustomBooleanEditor instance, ... */this.trueStringthis.falseStringString input/** Property editor for Collections, converting any source Collection ... */Class<? extends Collection<>> collectionType, ...;boolean nullAsEmptyCollection, ...;/** Create a new CustomCollectionEditor for the given target type, ... *//** Create a new CustomCollectionEditor for the given target type. ... */this.collectionTypethis.nullAsEmptyCollection/** Convert the given text value to a Collection with a single element. *//** Convert the given value to a Collection of the target type. */alwaysCreateNewCollection(...)Collection<?> sourceCollection<Object> targetconvertElement(...)/** Create a Collection of the given type, with the given ... */new TreeSet<Object>(...)/** Return whether to always create a new Collection, ... *//** Hook to convert each encountered Collection/array element. ... *//** This implementation returns {@code null} to indicate that ... */// Use the source value as-is, as it matches the target type.// Convert Collection elements.// Convert array elements to Collection elements.// A plain value: convert it to a Collection with a single element.import DateFormatimport ParseException/** Property editor for {@code java.util.Date}, ... */DateFormat dateFormat, ...;int exactDateLength, ...;/** Create a new CustomDateEditor instance, using the given DateFormat ... */this.dateFormatthis.exactDateLength/** Parse the Date from the given text, using the specified DateFormat. */ParseException ex/** Format the Date as String, using the specified DateFormat. */Date valueimport TreeMap/** Property editor for Maps, converting any source Map ... */Class<? extends Map<>> mapType, ...;boolean nullAsEmptyMap, ...;/** Create a new CustomMapEditor for the given target type, ... *//** Create a new CustomMapEditor for the given target type. ... */this.mapTypethis.nullAsEmptyMap/** Convert the given text value to a Map with a single element. *//** Convert the given value to a Map of the target type. */alwaysCreateNewMap(...)Map<?,?> sourceMap<Object,Object> targetconvertKey(...)convertValue(...)/** Create a Map of the given type, with the given ... */new TreeMap<Object,Object>(...)new LinkedHashMap<Object,Object>(...)/** Return whether to always create a new Map, ... *//** Hook to convert each encountered Map key. ... *//** Hook to convert each encountered Map value. ... */// Convert Map elements.import NumberFormat/** Property editor for any Number subclass such as Short, Integer, Long, ... */Class<? extends Number> numberClass, ...;NumberFormat numberFormat, ...;/** Create a new CustomNumberEditor instance, using the default ... *//** Create a new CustomNumberEditor instance, using the given NumberFormat ... */this.numberClassthis.numberFormat/** Parse the Number from the given text, using the specified NumberFormat. */parseNumber(...)/** Coerce a Number value into the required target class, if necessary. *//** Format the Number as String, using the specified NumberFormat. */// Use given NumberFormat for parsing text.// Use default valueOf methods for parsing text.// Use NumberFormat for rendering value.// Use toString method for rendering value.import ResourceEditor/** Editor for {@code java.io.File}, to directly populate a File property ... */ResourceEditor resourceEditor, ...;/** Create a new FileEditor, using a default ResourceEditor underneath. */this.resourceEditornew ResourceEditor(...)/** Create a new FileEditor, using the given ResourceEditor underneath. ... */File fileFile value// Check whether we got an absolute file path without "file:" prefix.// For backwards compatibility, we'll consider those as straight file path.// Proceed with standard resource location parsing.// If it's a URL or a path pointing to an existing resource, use it as-is.// Set a relative File reference and hope for the best./** Editor for {@code org.xml.sax.InputSource}, converting from a ... *//** Create a new InputSourceEditor, ... */InputSource valuegetSystemId(...)/** One-way PropertyEditor which can convert from a text String to a ... *//** Create a new InputStreamEditor, using the default ResourceEditor underneath. *//** Create a new InputStreamEditor, using the given ResourceEditor underneath. ... *//** Editor for {@code java.util.Locale}, to directly populate a Locale property. ... */parseLocaleString(...)import FileSystemNotFoundExceptionimport Paths/** Editor for {@code java.nio.file.Path}, to directly populate a Path ... *//** Create a new PathEditor, using the default ResourceEditor underneath. *//** Create a new PathEditor, using the given ResourceEditor underneath. ... */boolean nioPathCandidateResourceLoader.CLASSPATH_URL_PREFIXURI urinew URI(...)getScheme(...)normalize(...)toPath(...)Path value// Let's try NIO file system providers via Paths.get(URI)// Not a valid URI (let's try as Spring resource location),// or a URI scheme not registered for NIO (let's try URL// protocol handlers via Spring's resource mechanism)./** Editor for {@code java.util.regex.Pattern}, to directly populate a Pattern property. ... */int flags, ...;/** Create a new PatternEditor with default settings. */this.flags/** Create a new PatternEditor with the given settings. ... */Pattern valuepattern(...)import ByteArrayInputStreamimport StandardCharsets/** Custom {@link java.beans.PropertyEditor} for {@link Properties} objects. ... *//** Convert {@link String} into {@link Properties}, considering it as ... */new ByteArrayInputStream(...)StandardCharsets.ISO_8859_1/** Take {@link Properties} as-is; convert {@link Map} into {@code Properties}. */// Must use the ISO-8859-1 encoding because Properties.load(stream) expects it.// Should never happen./** Create a new ReaderEditor, using the default ResourceEditor underneath. *//** Create a new ReaderEditor, using the given ResourceEditor underneath. ... *//** {@link java.beans.PropertyEditor} implementation for standard JDK ... */String BASE_NAME_SEPARATOR, ...;/** The separator used to distinguish between the base name and the locale ... */int separatorgetBundle(...)String baseNameString localeStringLocale locale// The name potentially contains locale information/** Custom {@link java.beans.PropertyEditor} for String arrays. ... */String DEFAULT_SEPARATOR, ...;/** Default separator for splitting a String: a comma (","). */String separator, ...;String charsToDelete, ...;boolean emptyArrayAsNull, ...;/** Create a new {@code StringArrayPropertyEditor} with the default separator ... *//** Create a new {@code StringArrayPropertyEditor} with the given separator. ... */this.separatorthis.charsToDeletethis.emptyArrayAsNullString[] arraydelimitedListToStringArray(...)array.lengthtoObjectArray(...)/** Property editor that trims Strings. ... */boolean emptyAsNull, ...;/** Create a new StringTrimmerEditor. ... */this.emptyAsNulldeleteAny(...)/** Editor for {@code java.util.TimeZone}, translating timezone IDs into ... */parseTimeZoneString(...)TimeZone valuegetID(...)/** Editor for {@code java.net.URI}, to directly populate a URI property ... */boolean encode, ...;/** Create a new, encoding URIEditor, converting "classpath:" locations into ... *//** Create a new URIEditor, converting "classpath:" locations into ... */this.encode/** Create a new URIEditor, using the given ClassLoader to resolve ... */ResourceUtils.CLASSPATH_URL_PREFIXClassPathResource resourcegetURI(...)createURI(...)/** Create a URI instance for the given user-specified String value. ... */int colonIndexint fragmentIndexString schemeString sspString fragmentURI value// not encoding or the value contains no scheme - fallback to default/** Editor for {@code java.net.URL}, to directly populate a URL property ... *//** Create a new URLEditor, using a default ResourceEditor underneath. *//** Create a new URLEditor, using the given ResourceEditor underneath. ... */URL valuetoExternalForm(...)/** Editor for {@code java.util.UUID}, translating UUID ... */fromString(...)UUID value/** Editor for {@code java.time.ZoneId}, translating zone ID Strings into {@code ZoneId} ... */ZoneId valuegetId(...)/** Properties editors used to convert from String values to object ... *//** Subclass of {@link MethodInvoker} that tries to convert the given ... */boolean useDefaultConverter, ...;/** Set a TypeConverter to use for argument type conversion. ... */this.useDefaultConverter/** Return the TypeConverter used for argument type conversion. ... *//** Obtain the default TypeConverter for this method invoker. ... *//** This implementation looks for a method with matching parameter types. ... */Method matchingMethodfindMatchingMethod(...)doFindMatchingMethod(...)/** Actually find a method with matching parameter type, i.e. where each ... */String targetMethodgetTargetMethod(...)int argCountObject[] argumentsToUseObject[] convertedArguments// Second pass: look for method where arguments can be converted to parameter types.// Interpret argument array as individual method arguments.// Interpret argument array as single method argument of array type.// Check if the inspected method has the correct number of parameters.// Verify that the supplied argument is assignable to the method parameter.// Ignore -> simply doesn't match./** Mutable implementation of the {@link SortDefinition} interface. ... */String property, ...;boolean ignoreCase, ...;boolean ascending, ...;boolean toggleAscendingOnProperty, ...;/** Create an empty MutableSortDefinition, ... *//** Copy constructor: create a new MutableSortDefinition ... */this.propertythis.ignoreCaseisIgnoreCase(...)this.ascendingisAscending(...)/** Create a MutableSortDefinition for the given settings. ... *//** Create a new MutableSortDefinition. ... */this.toggleAscendingOnProperty/** Set the property to compare. ... */isToggleAscendingOnProperty(...)/** Set whether upper and lower case in String values should be ignored. *//** Set whether to sort ascending (true) or descending (false). *//** Set whether to toggle the ascending flag if the same property gets set again ... *//** Return whether to toggle the ascending flag if the same property gets set again ... */SortDefinition otherSd// Implicit toggling of ascending?/** PagedListHolder is a simple state holder for handling lists of objects, ... */int DEFAULT_PAGE_SIZE, ...;/** The default page size. */int DEFAULT_MAX_LINKED_PAGES, ...;/** The default maximum number of page links. */List<E> source, ...;Date refreshDate, ...;SortDefinition sort, ...;SortDefinition sortUsed, ...;int pageSize, ...;int page, ...;boolean newPageSet, ...;int maxLinkedPages, ...;/** Create a new holder instance. ... */new ArrayList<E>(...)/** Create a new holder instance with the given source list, starting with ... */new MutableSortDefinition(...)/** Create a new holder instance with the given source list. ... */setSort(...)/** Set the source list for this holder. */this.refreshDatenew Date(...)this.sortUsed/** Return the source list for this holder. *//** Return the last time the list has been fetched from the source provider. *//** Set the sort definition for this holder. ... */this.sort/** Return the sort definition for this holder. *//** Set the current page size. ... */this.pageSizethis.newPageSetthis.page/** Return the current page size. *//** Set the current page number. ... *//** Return the current page number. ... */getPageCount(...)/** Set the maximum number of page links to a few pages around the current one. */this.maxLinkedPages/** Return the maximum number of page links to a few pages around the current one. *//** Return the number of pages for the current source list. */float nrOfPagesgetPageSize(...)getNrOfElements(...)/** Return if the current page is the first one. */getPage(...)/** Return if the current page is the last one. *//** Switch to previous page. ... */isFirstPage(...)/** Switch to next page. ... */isLastPage(...)/** Return the total number of elements in the source list. *//** Return the element index of the first element on the current page. ... *//** Return the element index of the last element on the current page. ... *//** Return a sub-list representing the current page. */subList(...)getFirstElementOnPage(...)getLastElementOnPage(...)/** Return the first page to which create a link around the current page. */max(...)getMaxLinkedPages(...)/** Return the last page to which create a link around the current page. */getFirstLinkedPage(...)/** Resort the list if necessary, i.e. if the current {@code sort} instance ... */SortDefinition sortgetSort(...)copySortDefinition(...)doSort(...)setPage(...)/** Create a deep copy of the given sort definition, ... *//** Actually perform sorting of the given source list, according to ... *//** PropertyComparator performs a comparison of two beans, ... */SortDefinition sortDefinition, ...;BeanWrapperImpl beanWrapper, ...;/** Create a new PropertyComparator for the given SortDefinition. ... */this.sortDefinition/** Create a PropertyComparator for the given settings. ... *//** Return the SortDefinition that this comparator uses. */Object v1Object v2/** Get the SortDefinition's property value for the given object. ... */this.beanWrapper/** Sort the given List according to the given sort definition. ... */new PropertyComparator<?>(...)/** Sort the given source according to the given sort definition. ... */new PropertyComparator<T>(...)// Put an object with null property at the end of the sort result.// If a nested property cannot be read, simply return null// (similar to JSTL EL). If the property doesn't exist in the// first place, let the exception through.import PropertyResolverimport ContextResource/** PropertyEditorRegistrar implementation that populates a given ... */PropertyResolver propertyResolver, ...;/** Create a new ResourceEditorRegistrar for the given {@link ResourceLoader} ... */this.propertyResolver/** Populate the given {@code registry} with the following resource editors: ... */ResourceEditor baseEditordoRegisterEditor(...)ContextResource.class/** Override default editor, if possible (since that's what we really mean to do here); ... */overrideDefaultEditor(...)/** Definition for sorting bean instances by a property. ... *//** Return the name of the bean property to compare. ... *//** Return whether upper and lower case in String values should be ignored. *//** Return whether to sort ascending (true) or descending (false). *//** Classes supporting the org.springframework.beans package, ... */import Autowireimport StringTrimmerEditorimport DerivedFromProtectedBaseBeanimport BooleanTestBeanimport IndexedTestBeanimport NumberTestBeanimport GenericConversionServiceimport static Assertions.within/** Shared tests for property accessors. ... */createAccessor(...)AbstractPropertyAccessor accessornew Simple(...)new NoRead(...)/** Shouldn't throw an exception: should just return false */IndexedTestBean targetnew IndexedTestBean(...)Simple targetPerson targetcreatePerson(...)ITestBean targetITestBean kerryInteger KAInteger RAITestBean spousesSpousetarget.addressNullValueInNestedPathException.classnew Consumer<NullValueInNestedPathException>(...) { ... }Foo targetnew Foo(...)target.listOfMapsNotReadablePropertyException.classnew Consumer<NotReadablePropertyException>(...) { ... }Simple.classtarget.nametarget.address.citynew Employee(...)AbstractPropertyAccessor kerryAccessorString doctorCompanyString lawyerCompanygetLawyer(...)target.address.country.nametarget.address.countryITestBean childnew DifferentTestBean(...)Map<String,String> maptarget.listnew GenericConversionService(...) { ... }new ConversionFailedException(...)int ageString newNameString newTouchygetTouchy(...)Object bwAgeMutablePropertyValues valuesnew PropertyEditorSupport(...) { ... }BooleanTestBean targetnew BooleanTestBean(...)getBool2(...)NumberTestBean targetnew NumberTestBean(...)new Short(...)getShort2(...)new Integer(...)getInt2(...)new Long(...)getLong2(...)new BigInteger(...)getBigInteger(...)new Float(...)getFloat2(...)new Double(...)getDouble2(...)new BigDecimal(...)getBigDecimal(...)NumberPropertyBean targetnew NumberPropertyBean(...)String byteValueByte.MAX_VALUEString shortValueShort.MAX_VALUEString intValueString longValueLong.MAX_VALUEString floatValueFloat.MAX_VALUEString doubleValueDouble.MAX_VALUEgetMyPrimitiveByte(...)byteValue(...)getMyByte(...)getMyPrimitiveShort(...)shortValue(...)getMyShort(...)getMyPrimitiveInt(...)getMyInteger(...)getMyPrimitiveLong(...)longValue(...)getMyLong(...)isCloseTo(...)within(...)getMyPrimitiveFloat(...)floatValue(...)getMyFloat(...)getMyPrimitiveDouble(...)doubleValue(...)getMyDouble(...)EnumTester targetnew EnumTester(...)Autowire.BY_NAMEAutowire.BY_TYPETypeMismatchException.classEnumConsumer targetnew EnumConsumer(...)TestEnum.classTestEnum.TEST_VALUEgetEnumValue(...)WildcardEnumConsumer targetnew WildcardEnumConsumer(...)PropsTester targetnew PropsTester(...)String psString freedomValtarget.propertiesString peaceValSet<String> settarget.stringArraytarget.stringArray.lengthStringArrayBean targetnew StringArrayBean(...)getArray(...).lengthgetArray(...)List<Integer> resultnew ArrayList<Integer>(...)target.intArray.lengthtarget.intArraynew Integer[]PrimitiveArrayBean targetnew PrimitiveArrayBean(...)int[] inputSkipReaderStub<> targetnew SkipReaderStub<>(...)List<String> valuesObject[] resulttarget.itemsArrayToObject targetnew ArrayToObject(...)Object[] arrayCollection<String> collSortedSet<String> sortedSetgetCollection(...)getSet(...)getSortedSet(...)getList(...)List<String> setList<String> sortedSetSet<String> listcontainsAll(...)Collection<Integer> collnew HashSet<Integer>(...)List<Integer> setList<Integer> sortedSetSet<Integer> listnew StringTrimmerEditor(...)SortedMap<?,?> sortedMapgetMap(...)getSortedMap(...)new TreeMap<String,String>(...)Map<String,String> sortedMapMutablePropertyValues goodValuesMutablePropertyValues badValuesPropertyBatchUpdateException.classnew Consumer<PropertyBatchUpdateException>(...) { ... }getPropertyAccessException(...)Map<Integer,String> inputMapnew HashMap<Integer,String>(...)Map<Object,Object> inputMapnew HashMap<Object,Object>(...)new ReadOnlyMap<Object,Object>(...)Map<> inputMapnew HashMap<>(...)ReadOnlyMap<> readOnlyMapnew ReadOnlyMap<>(...)isAccessed(...)NotWritablePropertyException.classnew Consumer<NotWritablePropertyException>(...) { ... }PropertyValue valueDerivedFromProtectedBaseBean targetnew DerivedFromProtectedBaseBean(...)getSomeProperty(...)TestBean tb0TestBean tb1TestBean tb2TestBean tb3TestBean tb6TestBean tb7TestBean tb4TestBean tb5TestBean tb8Spr10115Bean targetnew Spr10115Bean(...)Spr10115Bean.prop1Spr13837Bean targetnew Spr13837Bean(...)target.somethingnew Person(...)new Address(...)Integer integer, ...;this.integerAddress address, ...;this.addressString city, ...;Country country, ...;this.citythis.countrynew Country(...)List<> list, ...;List<Map<>> listOfMaps, ...;this.listthis.listOfMapsAutowire autowire, ...;...[] stringArray, ...;...[] intArray, ...;this.stringArraythis.intArray...[] array, ...;this.arrayString company, ...;this.companybyte myPrimitiveByte, ...;Byte myByte, ...;short myPrimitiveShort, ...;Short myShort, ...;int myPrimitiveInt, ...;Integer myInteger, ...;long myPrimitiveLong, ...;Long myLong, ...;float myPrimitiveFloat, ...;Float myFloat, ...;double myPrimitiveDouble, ...;Double myDouble, ...;this.myPrimitiveBytethis.myBytethis.myPrimitiveShortthis.myShortthis.myPrimitiveIntthis.myIntegerthis.myPrimitiveLongthis.myLongthis.myPrimitiveFloatthis.myFloatthis.myPrimitiveDoublethis.myDoubleEnum<TestEnum> enumValue, ...;this.enumValueEnum<?> enumValue, ...;new TestEnum(...)TestEnum TEST_VALUE, ...;Object object, ...;this.object...[] items, ...;this.itemsString prop1, ...;Integer something, ...;this.somethingboolean accessed, ...;Map<>.Entry<K,V>this.accessed// Not touched// Check its unchanged// we need to change it back// now test with non-string// Note format...// list cannot be properly parameterized as it breaks other tests// must work with raw map in this test// Don't ignore: should fail// class to test naming of beans in an error message/** Must contain: forname=Tony surname=Blair age=50 */PropertyValue[] psMap<String,String> mgetPropertyValues(...).lengthps.lengthimport DayOfWeekimport LocalDateTimeimport ParameterizedTestimport ValueSourceimport CustomDateEditorDayOfWeek.classLocalDateTime.classboolean[].classBoolean[].classLocalDateTime[].classDate[].classint[].class/** Unit tests for {@link BeanUtils}. ... */FatalBeanException.classCustomDateEditor.classConstructor<BeanWithNullableTypes> ctorBeanWithNullableTypes.classBeanWithNullableTypes beangetCounter(...)isFlag(...)Constructor<BeanWithPrimitiveTypes> ctorBeanWithPrimitiveTypes.classBeanWithPrimitiveTypes beanBeanInstantiationException.classConstructor<PrivateBeanWithPrivateConstructor> ctorPrivateBeanWithPrivateConstructor.classPropertyDescriptor[] actualPropertyDescriptor[] descriptorsactual.lengthdescriptors.lengthContainerBean.classPropertyDescriptor descriptorContainedBean.classResourceEditor.classsetTouchy(...)DerivedTestBean tb2IntegerListHolder1 integerListHolder1new IntegerListHolder1(...)IntegerListHolder2 integerListHolder2new IntegerListHolder2(...)containsOnly(...)IntegerListHolder1 integerListHolderLongListHolder longListHoldernew LongListHolder(...)Order originalnew Order(...)OrderSummary proxyproxyOrder(...)Order targetOrderSummary.classgetLineItems(...)NameAndSpecialProperty sourcenew NameAndSpecialProperty(...)InvalidProperty sourcenew InvalidProperty(...)InvalidProperty targetsetFlag1(...)setFlag2(...)getFlag1(...)getFlag2(...)Method desiredMethodMethodSignatureBean.classassertSignatureEquals(...)PropertyDescriptor[] descrsBean.classPropertyDescriptor keyDescrPropertyDescriptor propertyDescriptorList<Integer> list, ...;new ArrayList<Long>(...)List<Long> list, ...;int specialProperty, ...;this.specialPropertyboolean flag1, ...;boolean flag2, ...;this.flag1this.flag2...[] containedBeans, ...;this.containedBeansString key, ...;Integer counter, ...;Boolean flag, ...;this.counterthis.flagint counter, ...;boolean flag, ...;List<String> lineItems, ...;this.lineItemsnew OrderInvocationHandler(...)Order order, ...;Order.class// gh-22531// gh-26531// Create a Proxy that loses the generic type information for the getLineItems() method.// Ensure that our custom Proxy works as expected.// Copy from proxy to target.// "touchy" should not be copied: it's not defined in ITestBean// "spouse", "touchy", "age" should not be copied// test resolve with no args// resolve with single arg// resolve with two args// Ignore args since OrderSummary doesn't declare any methods with arguments,// and we're not supporting equals(Object), etc.new Bean(...)Bean bean, ...;BeanWrapperImpl wrapper, ...;getProp(...)assertNotNull(...)...[...].lengthgetMultiArray(...)withRootCauseInstanceOf(...)IndexOutOfBoundsException.classInvalidPropertyException.classgetMultiList(...)String prop, ...;Bean nested, ...;NestedNoDefaultConstructor nestedNoConstructor, ...;...[] multiArray, ...;List<Bean> list, ...;List<List<Bean>> multiList, ...;List<> listNotParameterized, ...;Map<String,Bean> map, ...;this.propthis.nestedthis.multiArraythis.multiListthis.nestedNoConstructorthis.listNotParameterizedimport CustomEnumimport GenericBeanGenericBean<?> gbnew GenericBean<Object>(...)CustomEnum.VALUE_1getCustomEnum(...)getCustomEnumArray(...).lengthgetCustomEnumArray(...)CustomEnum.VALUE_2getCustomEnumSet(...)getStandardEnumSet(...)Map<String,Integer> mapnew LinkedHashMap<String,Integer>(...)getStandardEnumMap(...)NonPublicEnumHolder holdernew NonPublicEnumHolder(...)NonPublicEnum.VALUE_1getNonPublicEnum(...)new NonPublicEnum(...)NonPublicEnum VALUE_1, ...;NonPublicEnum VALUE_2, ...;NonPublicEnum nonPublicEnum, ...;this.nonPublicEnumimport MalformedURLExceptionimport GenericIntegerBeanimport GenericSetOfIntegerBeanimport UrlResourceSet<String> inputgetIntegerSet(...)getNumberSet(...)Set<TestBean> inputnew HashSet<TestBean>(...)List<String> inputnew UrlResource(...)getResourceList(...)setResourceList(...)new ArrayList<Resource>(...)Map<String,String> inputgetShortMap(...)setShortMap(...)new HashMap<Short,Integer>(...)getLongMap(...)setLongMap(...)new HashMap<Long,Integer>(...)Map<String,Collection<?>> inputnew HashMap<String,Collection<?>>(...)HashSet<Integer> value1ArrayList<Boolean> value2new ArrayList<Boolean>(...)getCollectionMap(...)setCollectionMap(...)new HashMap<Number,Collection<? extends Object>>(...)Properties inputGenericBean<String> gbnew GenericBean<String>(...)List<List<Integer>> listnew ArrayList<List<Integer>>(...)setListOfLists(...)getListOfLists(...)ArrayList<String[]> listnew ArrayList<String[]>(...)setListOfArrays(...)getListOfArrays(...)List<Map<Integer,Long>> listnew ArrayList<Map<Integer,Long>>(...)new HashMap<Integer,Long>(...)setListOfMaps(...)getListOfMaps(...)Map<String,Map<Integer,Long>> mapnew HashMap<String,Map<Integer,Long>>(...)setMapOfMaps(...)getMapOfMaps(...)Map<Integer,List<Integer>> mapnew HashMap<Integer,List<Integer>>(...)setMapOfLists(...)getMapOfLists(...)NestedGenericCollectionBean gbnew NestedGenericCollectionBean(...)Object objgetMapOfInteger(...)Map<String,List<String>> mapnew HashMap<String,List<String>>(...)getMapOfListOfInteger(...)List<Map<String,String>> listnew ArrayList<Map<String,String>>(...)getListOfMapOfInteger(...)Map<String,List<List<String>>> mapnew HashMap<String,List<List<String>>>(...)getMapOfListOfListOfInteger(...)Map<List<String>,List<String>> inputMapnew HashMap<List<String>,List<String>>(...)List<String> inputKeyList<String> inputValueComplexMapHolder holdernew ComplexMapHolder(...)getGenericMap(...)Map<Set<String>,Set<String>> inputMapnew HashMap<Set<String>,Set<String>>(...)Set<String> inputKeySet<String> inputValuegetGenericIndexedMap(...)getDerivedIndexedMap(...)GenericIntegerBean gbnew GenericIntegerBean(...)getGenericProperty(...)getGenericListProperty(...)GenericSetOfIntegerBean gbnew GenericSetOfIntegerBean(...)getVersion(...)Promotion beannew Promotion(...)Map<String,Object> dataHolder<Map<String,Object>> contextnew Holder<Map<String,Object>>(...)D data, ...;this.dataMap<String,Integer> mapOfInteger, ...;Map<String,List<Integer>> mapOfListOfInteger, ...;List<Map<String,Integer>> listOfMapOfInteger, ...;Map<String,List<List<Integer>>> mapOfListOfListOfInteger, ...;this.mapOfIntegerthis.mapOfListOfIntegerthis.listOfMapOfIntegerthis.mapOfListOfListOfIntegernew HashMap<Integer,List<Long>>(...)new DerivedMap(...)Map<List<Integer>,List<Long>> genericMap, ...;Map<Integer,List<Long>> genericIndexedMap, ...;DerivedMap derivedIndexedMap, ...;this.genericMapthis.genericIndexedMapthis.derivedIndexedMapdouble version, ...;this.versionLong id, ...;/** Specific {@link BeanWrapperImpl} tests. ... */GetterBean targetnew GetterBean(...)BeanWrapper accessorgetAliasedName(...)String invalidTouchygetPropertyChangeEvent(...)TypedReadOnlyMap mapnew TypedReadOnlyMap(...)TypedReadOnlyMapClient targetnew TypedReadOnlyMapClient(...)IntelliBean targetnew IntelliBean(...)getPossibleMatches(...).lengthPropertyTypeMismatch targetnew PropertyTypeMismatch(...)target.valueGetterWithOptional targetnew GetterWithOptional(...)TestBean value, ...;// This will call the getter// Test validly set property matches// Can't be shared; there is no such thing as a read-only field// Can't be shared: no type mismatch with a fieldClassLoader childnew OverridingClassLoader(...)Class<?> tbClassCachedIntrospectionResults.strongClassCacheacceptClassLoader(...)clearClassLoader(...)ArrayList<>.classC.classBeanInfo info// given a class with a non-void returning setter methodPropertyDescriptor candidate// CachedIntrospectionResults should delegate to ExtendedBeanInfo// resulting in a property descriptor including the non-standard setFoo method// No write method found for non-void returning 'setFoo' method.// Check to see if CachedIntrospectionResults is delegating to ExtendedBeanInfo as expectedimport ByteArrayOutputStreamsynchronizedSet(...)new HashSet<TestRun>(...)Set<TestRun> set, ...;performSet(...)TestRun runnew TestRun(...)setDaemon(...)wait(...)InterruptedException eProperties pgetProperties(...)ByteArrayOutputStream buffernew ByteArrayOutputStream(...)toByteArray(...)BeanWrapperImpl wrapperIterator<?> irandom(...)store(...)IOException eConcurrentBeanWrapperTests test, ...;this.testThrowable etest.extest.setnotifyAll(...)// ByteArrayOutputStream does not throw// any IOException/** Specific {@link DirectFieldAccessor} tests. ... */StringBuilder name, ...;DirectFieldAccessor dfaStringBuilder.class/** Unit tests for {@link ExtendedBeanInfoTests}. ... */new ExtendedBeanInfoFactory(...)ExtendedBeanInfoFactory factory, ...;BeanInfo biExtendedBeanInfo ebihasReadMethodForProperty(...)hasWriteMethodForProperty(...)BeanInfo ebihasIndexedWriteMethodForProperty(...)ExtendedBeanInfo biParent.classChild.classgetPropertyDescriptors(...).lengthC csetBar(...)setFoo(...)new C(...)This instance, ...;String foo, ...;this.foothis.instanceint bar, ...;this.bargetFoo(...)getBar(...)/** {@link ExtendedBeanInfo} should behave exactly like {@link BeanInfo} ... */hasIndexedReadMethodForProperty(...)// indexed read method// indexed write method// read method// write method// non-standard indexed write method// non-standard write method// baseline with standard write method// VOID-RETURNING, NON-INDEXED write method// variant with non-standard write method// NON-VOID-RETURNING, NON-INDEXED write method/** Prior to SPR-10111 (a follow-up fix for SPR-9702), this method would throw an ... *//** Ensures that an empty string is not passed into a PropertyDescriptor constructor. This ... *//** Corners the bug revealed by SPR-8522, in which an (apparently) indexed write method ... */ExtendedTestBean.class/** {@link BeanInfo#getPropertyDescriptors()} returns alphanumerically sorted. ... */ExtendedBeanInfo.PropertyDescriptorComparatorPropertyDescriptorComparator cnew PropertyDescriptor(...)LawLibrary.classB.classA.classboolean hasReadMethodboolean hasWriteMethodboolean hasIndexedReadMethodboolean hasIndexedWriteMethodWithStaticWriteMethod.classWindow.class// always passes// failed prior to fix for SPR-9414// failed prior to fix for SPR-9453// interesting! standard Inspector picks up non-void return types on indexed write methods by default// again as above, standard Inspector picks up non-void return types on indexed write methods by default// does not throw// does not throw after the changes introduced in SPR-8806// java.beans.Introspector returns the "wrong" declaring class for overridden read// methods, which in turn violates expectations in {@link ExtendedBeanInfo} regarding// method equality. Spring's {@link ClassUtils#getMostSpecificMethod(Method, Class)}// helps out here, and is now put into use in ExtendedBeanInfo as well.// Baseline:// ExtendedBeanInfo needs to behave exactly like BeanInfo...// SPR-12434/** Tests for {@link MutablePropertyValues}. ... */MutablePropertyValues deepCopydoTestTony(...)PropertyValue addedPvPropertyValue changedPvMutablePropertyValues pvs2PropertyValues changeschangesSince(...)PropertyValue fnMutablePropertyValues pvs3Iterator<PropertyValue> itnew Predicate<PropertyValue>(...) { ... }// add new/** Unit tests for {@link PropertyAccessorUtils}. ... */String[] originalString[] canonicalcanonicalPropertyNames(...)/** Tests for {@link PropertyMatches}. ... */SampleBeanProperties.classSampleFieldProperties.classint counter1, ...;int counter2, ...;int counter3, ...;this.counter1this.counter2this.counter3Object pdExtendedBeanInfo.SimplePropertyDescriptorExtendedBeanInfo.SimpleIndexedPropertyDescriptorObject pd1Object pd2Method wm1Object pd3Method rm1Object pd4Object pd5Object pd6Object pd7new IndexedPropertyDescriptor(...)import StaticListableBeanFactoryimport AnnotatedBeanimport TestAnnotationimport DummyFactoryimport AliasForBeanFactoryUtilsTests.classResource ROOT_CONTEXT, ...;Resource MIDDLE_CONTEXT, ...;Resource LEAF_CONTEXT, ...;Resource DEPENDENT_BEANS_CONTEXT, ...;DefaultListableBeanFactory listableBeanFactory, ...;DefaultListableBeanFactory dependentBeansFactory, ...;DefaultListableBeanFactory grandParentDefaultListableBeanFactory parentDefaultListableBeanFactory childthis.dependentBeansFactorythis.listableBeanFactoryStaticListableBeanFactory lbfnew StaticListableBeanFactory(...)addBean(...)countBeansIncludingAncestors(...)/** Check that override doesn't count as two separate beans. */List<String> namesIndexedTestBean.classgetBeanNamesForType(...).lengthMap<String,?> beansTestBean t1TestBean t2DummyFactory t3new DummyFactory(...)DummyFactory t4setSingleton(...)DummyFactory.classObject test3Object testboolean condition2Object testFactory1Override.classTestAnnotation.classgetBeanNamesForAnnotation(...).lengthAnnotatedBean annotatedBeannew AnnotatedBean(...)String[] depsnew ControllerAdviceClass(...)new RestControllerAdviceClass(...)testFindAnnotationOnBean(...)assertControllerAdvice(...)ControllerAdvice controllerAdviceControllerAdvice.classbasePackage(...)DummyFactory fb1DummyFactory fb2TestBeanSmartFactoryBean sfb1new TestBeanSmartFactoryBean(...)TestBeanSmartFactoryBean sfb2TestBeanSmartFactoryBean sfb3TestBeanSmartFactoryBean sfb4SmartFactoryBean<>.classTestBean testBean, ...;boolean prototype, ...;this.prototypethis.testBean// Interesting hierarchical factory to test counts.// Leaf count// Count minus duplicate// Distinguish from default ListableBeanFactory behavior// includes 2 TestBeans from FactoryBeans (DummyFactory definitions)// t3 and t4 are found here as of Spring 2.0, since they are pre-registered// singleton instances, while testFactory1 and testFactory are *not* found// because they are FactoryBean definitions that haven't been initialized yet.// gh-25520// We don't really care if the actual instance is a singleton or prototype// for the tests that use this factory.import Principalimport Objectsimport IntStreamimport Priorityimport Subjectimport NotWritablePropertyExceptionimport AbstractBeanFactoryimport BeanDefinitionOverrideExceptionimport ChildBeanDefinitionimport ConstructorDependenciesBeanimport DependenciesBeanimport TestPrincipalimport static ArgumentMatchers.anyimport static ArgumentMatchers.isNullimport static Mockito.never/** Tests properties population and autowire behavior. ... */DefaultListableBeanFactory lbf, ...;clearInstantiationRecord(...)KnowsIfInstantiated.classwasInstantiated(...)wasPrototypeCreated(...)SuppressWarnings.classforClassWithGenerics(...)getAliases(...).lengthTestBeanFactory.classTestBeanFactory.initializedRootBeanDefinition factoryBdListableBeanFactory lbfgetBeanDefinitionNames(...).lengthsingleTestBean(...)String PREFIXTestBean kerryITestBean spousegetSomeMap(...)BeansException.classTestBean selfNestedTestBean.classhasSize(...)new Consumer<BeanCreationException>(...) { ... }NotWritablePropertyException causeTestBean kerry1TestBean kerry2String EXPECTED_NAMEint EXPECTED_AGERootBeanDefinition parentDefinitionChildBeanDefinition childDefinitionDefaultListableBeanFactory factoryTestBean childBeanDefinition mergedBeanDefinition1BeanDefinition mergedBeanDefinition2DerivedTestBean.classfreezeConfiguration(...)BeanDefinition oldDefBeanDefinition newDefsetAllowBeanDefinitionOverriding(...)BeanDefinitionOverrideException.classnew Consumer<BeanDefinitionOverrideException>(...) { ... }getExistingDefinition(...)RootBeanDefinition bd1RootBeanDefinition bd2removeBeanDefinition(...)removeAlias(...)int MAXrange(...)new IntConsumer(...) { ... }registerTestBean(...)parallel(...)removeTestBean(...)TestBean kTestBean rnew PropertyEditorRegistrar(...) { ... }NumberFormat nfLocale.GERMANGenericConversionService conversionServiceaddConverter(...)new Converter<String,Float>(...) { ... }new CustomTypeConverter(...)TestBean testMap<?,?> beansOfTypeIterator<String> beanNamesgetBeanNamesIterator(...)DependenciesBean.classDependenciesBean testRootBeanDefinition.DEPENDENCY_CHECK_OBJECTSRootBeanDefinition.AUTOWIRE_BY_TYPEArrayBean.classArrayBean abgetResourceArray(...)RootBeanDefinition.AUTOWIRE_CONSTRUCTORgetIntegerArray(...)BeanExpressionResolver beanExpressionResolverBeanExpressionResolver.classany(...)BeanExpressionContext.classObject registeredNoDependencies.classDependenciesBean kerryTestBean rodConstructorDependency.classConstructorDependency kerryUnsatisfiedDependencyException.classUnsatisfiedConstructorDependency.classConstructorDependenciesBean beanConstructorDependenciesBean.classObject spousegetSpouse1(...)beanOfType(...)DependenciesBean beanTestBean spouseRootBeanDefinition bd3DefaultListableBeanFactory lbfNoSuchBeanDefinitionException.classNoUniqueBeanDefinitionException.classNullTestBeanFactoryBean<>.classNullTestBeanFactoryBean<> factoryBeanByTypeNullTestBeanFactoryBean<> bd1FactoryBeanNullTestBeanFactoryBean<> bd2FactoryBeanHighPriorityTestBean.classLowPriorityTestBean.classsetDependencyComparator(...)RootBeanDefinition bd4TestBeanRecipient.classgetBean(...).testBeanRootBeanDefinition na1TestBean actualObjectProvider<ConstructorDependency> providercreateConstructorDependencyBeanDefinition(...)ConstructorDependency beanbean.beanNamebean.spouseAgeConstructorDependency instancenew Consumer<ConstructorDependency>(...) { ... }ConstructorDependency actualactual.beanNameObjectProvider<> deserializedsetSerializationId(...)ConstructorDependencyFactoryBean.class/** Verifies that a dependency on a {@link FactoryBean} can be autowired ... */LazyInitFactory.classLazyInitFactory factoryBeanFactoryBeanDependentBean beanFactoryBeanDependentBean.classLazyInitFactory bd1FactoryBeanLazyInitFactory bd2FactoryBeanFactoryBeanThatShouldntBeCalled<>.classRunnable.classCallable<>.classRepositoryFactoryInformation<>.class/** Verifies that a dependency on a {@link FactoryBean} can <strong>not</strong> ... */withCauseExactlyInstanceOf(...)DependenciesBean existingBeannew DependenciesBean(...)applyBeanPropertyValues(...)wasDestroyed(...)RootBeanDefinition.AUTOWIRE_BY_NAMETestBean otherBeanConstructorDependencyBean.classConstructorDependencyWithClassResolution.classAbstractBeanFactory.classLazyInitFactory factoryfactory.initializedEagerInitFactory factoryEagerInitFactory.classRootBeanDefinition stringDefString val1String val2BeanWithDisposableBean.classaddBeanPostProcessor(...)new BeanPostProcessor(...) { ... }BeanWithDisposableBean.closedBeanWithCloseable.classBeanWithCloseable.closedBeanWithDestroyMethod.classBeanWithDestroyMethod.closeCountRootBeanDefinition innerBdfindTypeOfPrototypeFactoryMethodOnBeanInstance(...)/** @param ... */String expectedNameFromPropertiesString expectedNameFromArgsRootBeanDefinition instanceFactoryDefinitionBeanWithFactoryMethod.classRootBeanDefinition factoryMethodDefinitionWithPropertiesRootBeanDefinition factoryMethodDefinitionGenericRootBeanDefinition factoryMethodDefinitionWithArgsConstructorArgumentValues cvalsList<String> tbNamesTestBean secondString theChildScopeRootBeanDefinition parentAbstractBeanDefinition childchildBeanDefinition(...)AbstractBeanDefinition defString theParentScopeBeanDefinition defdoTestFieldSettingWithInstantiationAwarePostProcessor(...)int ageSetByPropertyValueString nameSetOnFieldnew InstantiationAwareBeanPostProcessor(...) { ... }Field fTestSecuredBean.classSubject subjectnew Subject(...)TestSecuredBean beandoAsPrivileged(...)new PrivilegedAction<>(...) { ... }getPrincipals(...)new TestPrincipal(...)getUserName(...)StringValueResolver r1StringValueResolver.classStringValueResolver r2StringValueResolver r3never(...)NonPublicEnumHolder.classnew PropertiesBeanDefinitionReader(...)TestBean spouse, ...;int spouseAge, ...;this.spousethis.spouseAgeConstructorDependency thatthat.spouseAgethat.spousehash(...)boolean closed, ...;int closeCount, ...;BeanWithDestroyMethod inner, ...;this.inner...[] integerArray, ...;...[] resourceArray, ...;this.integerArraythis.resourceArray/** Bean with a dependency on a {@link FactoryBean}. */FactoryBean<?> factoryBean, ...;this.factoryBeanString userName, ...;getSubject(...)setNameFromPrincipal(...)Iterator<Principal> itPrincipal pthis.userNameboolean instantiated, ...;// Reset static state// expected// gh-23542// Register the bean definitions before invoking preInstantiateSingletons()// to simulate realistic usage of an ApplicationContext; otherwise, the bean// factory thinks it's an "empty" factory which causes this test to fail in// an unrealistic manner.// This test is considered successful if the following does not result in an exception.// Depends on age, name and spouse (TestBean)// conflicting priority// na1 was filtered/** Written with the intention of reproducing SPR-7318. ... */Object fooFactoryFooFactoryBean.classFooFactoryBean fooFactoryFoo.classFactoryBeanTests.classResource RETURNS_NULL_CONTEXT, ...;Resource WITH_AUTOWIRING_CONTEXT, ...;Resource ABSTRACT_CONTEXT, ...;Resource CIRCULAR_CONTEXT, ...;BeanFactoryPostProcessor ppcAlpha alphaBeta betaGamma gammaGamma gamma2postProcessBeanFactory(...)getBeta(...)getGamma(...)getBeansWithAnnotation(...)AbstractFactoryBean.classCountingPostProcessor counternew CountingPostProcessor(...)BeanImpl1 impl1BeanImpl1.classgetImpl2(...)getImpl1(...)Beta beta, ...;this.betaGamma gamma, ...;this.gammaClass<T> type, ...;String instanceName, ...;T instance, ...;this.instanceNamenew HashMap<String,AtomicInteger>(...)Map<String,AtomicInteger> count, ...;AtomicInteger cBeanImpl2 impl2, ...;this.impl2BeanImpl1 impl1, ...;this.impl1/** SPR-5475 exposed the fact that the error message displayed when incorrectly ... */assertExceptionMessageForMisconfiguredFactoryMethod(...)setFactoryMethod(...)// calling a factory method that accepts arguments without any arguments emits an exception unlike cases// where a no-arg factory method is called with arguments. Adding this test just to document the differencenew AnnotationBeanWiringInfoResolver(...)AnnotationBeanWiringInfoResolver resolverBeanWiringInfo infonew Soap(...)new WirelessSoap(...)WirelessSoap.classnew NamedWirelessSoap(...)import Functionimport MockitoAutowiredAnnotationBeanPostProcessor bpp, ...;registerResolvableDependency(...)new AutowiredAnnotationBeanPostProcessor(...)ResourceInjectionBean.classResourceInjectionBean beangetTestBean(...)getTestBean2(...)TypedExtendedResourceInjectionBean.classNestedTestBean ntbTypedExtendedResourceInjectionBean beanString[] depBeansgetDependenciesForBean(...)getTestBean3(...)getTestBean4(...)getNestedTestBean(...)depBeans.lengthbean.destroyedgetDependenciesForBean(...).lengthRootBeanDefinition annotatedBdOverriddenExtendedResourceInjectionBean.classOverriddenExtendedResourceInjectionBean beanbean.baseInjectedbean.subInjectedDefaultMethodResourceInjectionBean.classDefaultMethodResourceInjectionBean beannew RequiredAnnotationBeanPostProcessor(...)IndexedTestBean itbNestedTestBean ntb1NestedTestBean ntb2OptionalResourceInjectionBean beanOptionalResourceInjectionBean.classgetIndexedTestBean(...)getNestedTestBeans(...).lengthgetNestedTestBeans(...)bean.nestedTestBeansField.lengthbean.nestedTestBeansFieldOptionalCollectionResourceInjectionBean.classOptionalCollectionResourceInjectionBean beanbean.nestedTestBeansSetterOrderedNestedTestBean ntb1new OrderedNestedTestBean(...)OrderedNestedTestBean ntb2FixedOrder2NestedTestBean ntb1new FixedOrder2NestedTestBean(...)FixedOrder1NestedTestBean ntb2new FixedOrder1NestedTestBean(...)ConstructorResourceInjectionBean.classConstructorResourceInjectionBean beanNullNestedTestBeanFactoryBean.classRootBeanDefinition tbNullFactoryMethods.classRootBeanDefinition ntbConstructorsResourceInjectionBean beanConstructorsResourceInjectionBean.classConstructorWithoutFallbackBean.classmethodParameterDeclaredOn(...)ConstructorsCollectionResourceInjectionBean beanMap<String,NestedTestBean> mapConstructorsCollectionResourceInjectionBean.classSingleConstructorVarargBean beanSingleConstructorVarargBean.classSingleConstructorRequiredCollectionBean beanSingleConstructorRequiredCollectionBean.classSingleConstructorOptionalCollectionBean beanSingleConstructorOptionalCollectionBean.classMapConstructorInjectionBean.classRootBeanDefinition tb2MapConstructorInjectionBean beangetTestBeanMap(...)MapFieldInjectionBean.classMapFieldInjectionBean beanMapMethodInjectionBean.classMapMethodInjectionBean beanRootBeanDefinition rbd2MyTestBeanMap tbmnew MyTestBeanMap(...)RootBeanDefinition tbmCollectionFactoryMethods.classsetUniqueFactoryMethodName(...)CustomMapConstructorInjectionBean.classCustomCollectionFactoryMethods.classCustomMapConstructorInjectionBean beanQualifiedMapConstructorInjectionBean.classQualifiedMapConstructorInjectionBean beanHashMap<>.classSetConstructorInjectionBean.classMyTestBeanSet tbsnew MyTestBeanSet(...)SetConstructorInjectionBean beangetTestBeanSet(...)RootBeanDefinition tbsCustomSetConstructorInjectionBean.classCustomSetConstructorInjectionBean beanSelfInjectionBean beanSelfInjectionBean.classbean.referencebean.referenceCollectionSelfInjectionBean bean2SelfInjectionCollectionBean beanSelfInjectionCollectionBean.classSelfInjectionCollectionBean bean2bean2.referenceCollectionObjectFactoryFieldInjectionBean beanObjectFactoryFieldInjectionBean.classObjectFactoryConstructorInjectionBean beanObjectFactoryConstructorInjectionBean.classRootBeanDefinition annotatedBeanDefinitionObjectFactoryFieldInjectionBean anotherBeanObjectFactoryQualifierInjectionBean beanObjectFactoryQualifierInjectionBean.classsetQualifiedElement(...)ObjectProviderInjectionBean beanList<?> testBeansiterateTestBeans(...)ObjectProviderInjectionBean.classgetOptionalTestBean(...)getOptionalTestBeanWithDefault(...)consumeOptionalTestBean(...)getUniqueTestBean(...)getUniqueTestBeanWithDefault(...)consumeUniqueTestBean(...)forEachTestBeans(...)streamTestBeans(...)sortedTestBeans(...)RootBeanDefinition tb1CustomAnnotationRequiredFieldResourceInjectionBean beansetAutowiredAnnotationType(...)MyAutowired.classsetRequiredParameterName(...)setRequiredParameterValue(...)CustomAnnotationRequiredFieldResourceInjectionBean.classfieldDeclaredOn(...)CustomAnnotationRequiredMethodResourceInjectionBean beanCustomAnnotationRequiredMethodResourceInjectionBean.classCustomAnnotationOptionalFieldResourceInjectionBean beanCustomAnnotationOptionalFieldResourceInjectionBean.classCustomAnnotationOptionalMethodResourceInjectionBean beanCustomAnnotationOptionalMethodResourceInjectionBean.class/** Verifies that a dependency on a {@link FactoryBean} can be autowired via ... */StringFactoryBean factoryBeannew StringFactoryBean(...)RepositoryFieldInjectionBean.classString svInteger ivStringRepository srnew StringRepository(...)IntegerRepository irnew IntegerRepository(...)RepositoryFieldInjectionBean beanbean.stringbean.integerbean.stringArray.lengthbean.stringArraybean.integerArray.lengthbean.integerArraybean.stringListbean.integerListbean.stringMapbean.integerMapbean.stringRepositorybean.integerRepositorybean.stringRepositoryArray.lengthbean.stringRepositoryArraybean.integerRepositoryArray.lengthbean.integerRepositoryArraybean.stringRepositoryListbean.integerRepositoryListbean.stringRepositoryMapbean.integerRepositoryMapRepositoryFieldInjectionBeanWithSubstitutedVariables.classRepositoryFieldInjectionBeanWithSubstitutedVariables beanRepositoryFieldInjectionBeanWithQualifiers.classRepositoryFieldInjectionBeanWithQualifiers beanMocksControl.classRepository<?> srRepository<>.classRepository<?> irRepositoryFieldInjectionBeanWithSimpleMatch.classRepositoryFieldInjectionBeanWithSimpleMatch beanRepository<?> repobean.repositorybean.repositoryArray.lengthbean.repositoryArraybean.repositoryListbean.repositoryMapRepositoryFactoryBeanInjectionBean.classRepositoryFactoryBeanInjectionBean beanRepositoryFactoryBean<?> repoFactoryBeanRepositoryFactoryBean<>.classbean.repositoryFactoryBeannew RepositoryFactoryBean<Object>(...)Mockito.classRepositoryMethodInjectionBean.classRepositoryMethodInjectionBean beanRepositoryMethodInjectionBeanWithSubstitutedVariables.classRepositoryMethodInjectionBeanWithSubstitutedVariables beanRepositoryConstructorInjectionBean.classRepositoryConstructorInjectionBean beanGenericRepository<> grnew GenericRepository<>(...)SimpleRepository ngrnew SimpleRepository(...)new GenericRepositorySubclass(...)new SimpleRepositorySubclass(...)GenericInterface1Impl<>.classGenericInterface1Impl<> bean1GenericInterface2Impl bean2GenericInterface2Impl.classbean1.gi2ReallyGenericInterface2Impl.classPlainGenericInterface2Impl.classGenericInterface1<>.classGenericInterface2<>.classGenericInterface2Bean<>.classMultiGenericFieldInjection.classStockServiceImpl serviceStockServiceImpl.classStockMovementDaoImpl<>.classStockMovementImpl<>.classStockMovementInstructionImpl<>.classservice.stockMovementDaoMyCallable.classSecondCallable.classFooBar.classProvidedArgumentBean.classAnnotatedDefaultConstructorBean.classSelfInjectingFactoryBean beanSelfInjectingFactoryBean.classbean.testBeandeclaredOn(...)new Function<InjectionPoint,Class<?>>(...) { ... }new Consumer<E>(...) { ... }getInjectionPoint(...)Repository<?> integerRepositoryQualifierProvider, ...;TestBean testBean2, ...;this.testBean2ITestBean testBean3, ...;T nestedTestBean, ...;ITestBean testBean4, ...;boolean baseInjected, ...;setTestBean2(...)this.testBean4this.nestedTestBeanthis.baseInjectedthis.testBean3boolean destroyed, ...;this.destroyedboolean subInjected, ...;this.subInjectedmarkSubInjected(...)IndexedTestBean indexedTestBean, ...;...[] nestedTestBeans, ...;...[] nestedTestBeansField, ...;this.indexedTestBeanthis.nestedTestBeansList<NestedTestBean> nestedTestBeans, ...;List<NestedTestBean> nestedTestBeansSetter, ...;List<NestedTestBean> nestedTestBeansField, ...;this.nestedTestBeansSetterNestedTestBean nestedTestBean, ...;Map<String,TestBean> testBeanMap, ...;this.testBeanMapSet<TestBean> testBeanSet, ...;this.testBeanSetSelfInjectionBean reference, ...;List<SelfInjectionBean> referenceCollection, ...;SelfInjectionCollectionBean reference, ...;List<SelfInjectionCollectionBean> referenceCollection, ...;ObjectFactory<TestBean> testBeanFactory, ...;this.testBeanFactoryObjectFactory<?> testBeanFactory, ...;ObjectProvider<TestBean> testBeanProvider, ...;TestBean consumedTestBean, ...;this.testBeanProvidernew Supplier<TestBean>(...) { ... }ifAvailable(...)new Consumer<TestBean>(...) { ... }ifUnique(...)List<TestBean> resolvednew ArrayList<TestBean>(...)toList(...)orderedStream(...)TestBean testBean3, ...;String string, ...;List<String> stringList, ...;List<Integer> integerList, ...;Map<String,String> stringMap, ...;Map<String,Integer> integerMap, ...;Repository<String> stringRepository, ...;Repository<Integer> integerRepository, ...;...[] stringRepositoryArray, ...;...[] integerRepositoryArray, ...;List<Repository<String>> stringRepositoryList, ...;List<Repository<Integer>> integerRepositoryList, ...;Map<String,Repository<String>> stringRepositoryMap, ...;Map<String,Repository<Integer>> integerRepositoryMap, ...;S string, ...;I integer, ...;List<S> stringList, ...;List<I> integerList, ...;Map<String,S> stringMap, ...;Map<String,I> integerMap, ...;Repository<S> stringRepository, ...;Repository<I> integerRepository, ...;List<Repository<S>> stringRepositoryList, ...;List<Repository<I>> integerRepositoryList, ...;Map<String,Repository<S>> stringRepositoryMap, ...;Map<String,Repository<I>> integerRepositoryMap, ...;Repository<?> stringRepository, ...;Repository<?> integerRepository, ...;List<Repository<?>> stringRepositoryList, ...;List<Repository<?>> integerRepositoryList, ...;Map<String,Repository<?>> stringRepositoryMap, ...;Map<String,Repository<?>> integerRepositoryMap, ...;Repository<?> repository, ...;...[] repositoryArray, ...;List<Repository<?>> repositoryList, ...;Map<String,Repository<?>> repositoryMap, ...;RepositoryFactoryBean<?> repositoryFactoryBean, ...;this.stringthis.stringListthis.integerListthis.stringMapthis.integerMapthis.stringRepositorythis.integerRepositorythis.stringRepositoryArraythis.integerRepositoryArraythis.stringRepositoryListthis.integerRepositoryListthis.stringRepositoryMapthis.integerRepositoryMap/** Pseudo-implementation of EasyMock's {@code MocksControl} class. */AutowiredAnnotationBeanPostProcessorTests.classGenericInterface2<T> gi2, ...;doSomethingMoreGeneric(...)new StringGenericInterface1Impl(...)new GenericInterface1Impl<String>(...)new GenericInterface1Impl<>(...)GenericInterface2<String> stringBean, ...;GenericInterface2<Integer> integerBean, ...;this.stringBeanthis.integerBeanStockMovementDao<StockMovement<>> stockMovementDao, ...;RT obj, ...;this.objsetObj(...)Map<String,TestBean> tbmnew LinkedHashMap<String,TestBean>(...)Set<TestBean> tbsnew LinkedHashSet<TestBean>(...)CustomMap<String,TestBean> tbmnew CustomHashMap<String,TestBean>(...)CustomSet<TestBean> tbsnew CustomHashSet<TestBean>(...)CustomMap<String,TestBean> testBeanMap, ...;CustomSet<TestBean> testBeanSet, ...;TestBean exposedTestBean, ...;new SelfInjectingFactoryBean(...)// Two calls to verify that caching doesn't break re-creation.// Bean name not matching qualifier// TypedStringValue used to be equivalent to an XML-defined argument String// SPR-11521// SPR-15125/** Unit tests for {@link CustomAutowireConfigurer}. ... */CustomAutowireConfigurer cacnew CustomAutowireConfigurer(...)CustomResolver customResolvernew CustomResolver(...)CustomAutowireConfigurerTests.classimport Inject/** Unit tests for {@link org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor} ... */ObjectFactoryQualifierFieldInjectionBean beanObjectFactoryQualifierFieldInjectionBean.classObjectFactoryQualifierFieldInjectionBean anotherBeanObjectFactoryQualifierMethodInjectionBean.classObjectFactoryQualifierMethodInjectionBean beanObjectFactoryQualifierMethodInjectionBean anotherBeanObjectFactoryMethodInjectionBean beanObjectFactoryMethodInjectionBean.classObjectFactoryListFieldInjectionBean beanObjectFactoryListFieldInjectionBean.classObjectFactoryListMethodInjectionBean beanObjectFactoryListMethodInjectionBean.classObjectFactoryMapFieldInjectionBean beanObjectFactoryMapFieldInjectionBean.classObjectFactoryMapMethodInjectionBean beanObjectFactoryMapMethodInjectionBean.class/** Verifies that a dependency on a {@link org.springframework.beans.factory.FactoryBean} ... */NullableFieldInjectionBean beanNullableFieldInjectionBean.classNullableMethodInjectionBean beanNullableMethodInjectionBean.classOptionalFieldInjectionBean beanOptionalFieldInjectionBean.classOptionalMethodInjectionBean beanOptionalMethodInjectionBean.classOptionalListFieldInjectionBean beanOptionalListFieldInjectionBean.classOptionalListMethodInjectionBean beanOptionalListMethodInjectionBean.classProviderOfOptionalFieldInjectionBean beanProviderOfOptionalFieldInjectionBean.classProviderOfOptionalMethodInjectionBean beanProviderOfOptionalMethodInjectionBean.classProvider<TestBean> testBeanFactory, ...;Provider<?> testBeanFactory, ...;Provider<List<TestBean>> testBeanFactory, ...;Provider<Map<String,TestBean>> testBeanFactory, ...;/** Bean with a dependency on a {@link org.springframework.beans.factory.FactoryBean}. */Optional<TestBean> testBean, ...;Optional<List<TestBean>> testBean, ...;Provider<Optional<TestBean>> testBean, ...;AutowiredAnnotationBeanPostProcessor aabppAbstractBean.classBeanConsumer.classAbstractBean beanObject expectedgetBean(...).abstractBeanTestBean expectedgetOneArgument(...)getTwoArguments(...)AbstractMethodError.classgetThreeArguments(...)// overloaded// no @Lookup annotationAbstractBean abstractBean, ...;// gh-25806/** Unit tests for {@link ParameterResolutionDelegate}. ... */isAutowirable(...)assertAutowirableParameters(...)AutowirableClass.classClass<?> innerClassAutowirableClass.InnerAutowirableClass.classAutowirableClass.InnerAutowirableClassParameter[] parametersint parameterIndexparameters.lengthParameter parameterConstructor<?> notAutowirableConstructorAutowireCapableBeanFactory.classgetParameter(...)AutowireCapableBeanFactory beanFactorywillAnswer(...)new Answer<Object>(...) { ... }getArgument(...)DependencyDescriptor intermediateDependencyDescriptor// Configure the mocked BeanFactory to return the DependencyDescriptor for convenience and// to avoid using an ArgumentCaptor.RequiredTestBean.classRequiredTestBean beangetFavouriteColour(...)RequiredAnnotationBeanPostProcessor rabppsetRequiredAnnotationType(...)MyRequired.classRootBeanDefinition beanDefRequiredAnnotationBeanPostProcessor bppRequiredTestBeanFactory.classString favouriteColour, ...;String jobTitle, ...;this.favouriteColourthis.jobTitlenew RequiredTestBean(...)CustomEditorConfigurer cecnew CustomEditorConfigurer(...)DateFormat dfgetDateInstance(...)DateFormat.SHORTsetPropertyEditorRegistrars(...)new PropertyEditorRegistrar[]new CustomDateEditor(...)getDate(...)Map<Class<?>,Class<? extends PropertyEditor>> editorsMyDateEditor.classsetCustomEditors(...)MyTestEditor.classgetStringArray(...).length/** Unit tests for {@link CustomScopeConfigurer}. ... */String FOO_SCOPE, ...;ConfigurableListableBeanFactory factory, ...;CustomScopeConfigurer figurernew CustomScopeConfigurer(...)Map<String,Object> scopessetScopes(...)NoOpScope.classMap<> scopesnew NoOpScope(...)ClassCastException.class// <-- not a valid value...// <-- not a valid value (the key)...MyDeprecatedBean.classDeprecatedBeanWarner warnernew MyDeprecatedBeanWarner(...)DeprecatedBeanWarnerTests.this.beanNameDeprecatedBeanWarnerTests.thisDeprecatedBeanWarnerTests.this.beanDefinitionimport Connection/** Unit tests for {@link FieldRetrievingFactoryBean}. ... */FieldRetrievingFactoryBean frnew FieldRetrievingFactoryBean(...)setStaticField(...)Connection.TRANSACTION_SERIALIZABLEConnection.classsetTargetField(...)PublicFieldHolder targetnew PublicFieldHolder(...)setTargetObject(...)target.publicFieldIllegalArgumentException expectedFieldRetrievingFactoryBeanTests.classgetSomeIntegerArray(...)String publicField, ...;/** Unit tests for {@link MethodInvokingFactoryBean} and {@link MethodInvokingBean}. ... */MethodInvokingFactoryBean mcfbnew MethodInvokingFactoryBean(...)TestClass1 tc1new TestClass1(...)setTargetMethod(...)NoSuchMethodException.classTestClass1.classTestClass1._staticField1Class<?> objTypeInteger isetStaticMethod(...)MethodInvoker methodInvokernew MethodInvoker(...)ArgumentConvertingMethodInvoker methodInvokernew ArgumentConvertingMethodInvoker(...)MethodInvokingBean methodInvokernew MethodInvokingBean(...)int _staticField1, ...;int _field1, ...;// assert that only static OR non static are set, but not both or none// bogus static method// missing method// bogus method// static method// non-static method// verify that we can call a method with args that are subtypes of the// target method arg types// fail on improper argument types at afterPropertiesSet// singleton, non-static// non-singleton, non-static// singleton, static// non-singleton, static// void return value// now see if we can match methods with arguments that have supertype arguments// should passObjectFactoryCreatingFactoryBeanTests.classFactoryTestBean testBeanFactoryTestBean.classObjectFactory<?> objectFactorygetObjectFactory(...)Date date1Date date2ProviderTestBean testBeanProviderTestBean.classProvider<?> providergetProvider(...)String expectedSingletonObjectFactoryCreatingFactoryBean factorynew ObjectFactoryCreatingFactoryBean(...)Object actualSingletonProvider<?> provider, ...;this.provider/** Unit tests for {@link PropertiesFactoryBean}. ... */PropertiesFactoryBeanTests.classResource TEST_PROPS, ...;Resource TEST_PROPS_XML, ...;PropertiesFactoryBean pfbnew PropertiesFactoryBean(...)Properties localPropssetProperties(...)Properties props1Properties props2Properties props3setPropertiesArray(...)new Properties[]setLocalOverride(...)Properties newProps/** Unit tests for {@link PropertyPathFactoryBean}. ... */PropertyPathFactoryBeanTests.classDefaultListableBeanFactory xbfObject result1Object result2Object result3TestBean tbWithInnergetFriends(...)import static BeanDefinitionBuilder.genericBeanDefinitionimport static BeanDefinitionReaderUtils.registerWithGeneratedName/** Unit tests for {@link PropertyPlaceholderConfigurer}. ... */String P1, ...;String P1_LOCAL_PROPS_VAL, ...;String P1_SYSTEM_PROPS_VAL, ...;PropertyPlaceholderConfigurer ppc, ...;Properties ppcProperties, ...;AbstractBeanDefinition p1BeanDef, ...;new PropertyPlaceholderConfigurer(...)clearProperty(...)PropertyPlaceholderConfigurer pcgetSex(...)setSystemPropertiesMode(...)PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_OVERRIDEsetSearchSystemEnvironment(...)/** Creates a scenario in which two PPCs are configured, each with different ... */String P2String P2_LOCAL_PROPS_VALString P2_SYSTEM_PROPS_VALAbstractBeanDefinition p2BeanDefProperties ppc2PropertiesPropertyPlaceholderConfigurer ppc2TestBean p1BeanTestBean p2BeansetIgnoreUnresolvablePlaceholders(...)getCountry(...)PropertyPlaceholderConfigurer ppcsetPlaceholderPrefix(...)setPlaceholderSuffix(...)setNullValue(...)setTrimValues(...)// will now fall all the way back to system environment// has to resort to local propsimport AbstractPreferencesimport PreferencesFactory/** Unit tests for various {@link PropertyResourceConfigurer} implementations including: ... */MockPreferencesFactory.classPropertyResourceConfigurerTests.classResource XTEST_PROPS, ...;// does not existDefaultListableBeanFactory factory, ...;BeanDefinition def1BeanDefinition def2PropertyOverrideConfigurer poc1PropertyOverrideConfigurer poc2new PropertyOverrideConfigurer(...)PropertyOverrideConfigurer pocIndexedTestBean tbsetBeanNameSeparator(...)PropertiesHolder.classPropertiesHolder tbgetHeldProperties(...)setLocations(...)setIgnoreResourceNotFound(...)ConvertingOverrideConfigurer bfppnew ConvertingOverrideConfigurer(...)setIgnoreInvalidKeys(...)BeanInitializationException exdoTestPropertyPlaceholderConfigurer(...)Map<String,String> singletonMapList<Object> friendsSet<Object> someSetMap<Object,Object> someMapMutablePropertyValues innerPvsMutablePropertyValues innerPvs2TestBean inner1TestBean inner2MutablePropertyValues pvs1ChildBeanDefinition bdgetSomeSet(...)PropertyPlaceholderConfigurer.SYSTEM_PROPERTIES_MODE_NEVERPreferencesPlaceholderConfigurer ppcnew PreferencesPlaceholderConfigurer(...)setSystemTreePath(...)setUserTreePath(...)/** {@link PreferencesFactory} to create {@link MockPreferences}. */new MockPreferences(...)Preferences userRoot, ...;Preferences systemRoot, ...;this.systemRootthis.userRoot/** Mock implementation of {@link Preferences} that behaves the same regardless of the ... */new HashMap<String,AbstractPreferences>(...)Map<String,String> values, ...;Map<String,AbstractPreferences> children, ...;AbstractPreferences child// emulate what happens when BFPPs are added to an application context: It's LIFO-based// won't actually do anything since we're not processing through an app ctx// prove that the processor chokes on the invalid keyimport NestedCheckedException/** Unit tests for {@link ServiceLocatorFactoryBean}. ... */TestServiceLocator factoryTestService testServicegetTestService(...)TestServiceLocator.classServiceLocatorFactoryBean.classTestServiceLocator2.classTestService2Locator.classCustomServiceLocatorException1.classCustomServiceLocatorException2.classCustomServiceLocatorException3.classTestServiceLocator2 factoryTestService testBeanTestServiceLocator3 factoryTestService testBean1TestService testBean2TestService testBean3TestService testBean4someFactoryMethod(...)TestServiceLocator3.classboolean condition3ExtendedTestService.classnew ServiceLocatorFactoryBean(...)ServiceLocatorFactoryBean factorysetServiceLocatorInterface(...)setServiceLocatorExceptionClass(...)ExceptionClassWithOnlyZeroArgCtor.classServiceLocatorInterfaceWithExtraNonCompliantMethod locatorServiceLocatorInterfaceWithExtraNonCompliantMethod.class// test string-arg getter with null id// now test with explicit id// now verify failure on bad id// worked when using an ApplicationContext (see commented), fails when using BeanFactory//		StaticApplicationContext ctx = new StaticApplicationContext();//		ctx.registerPrototype("testService", TestService.class, new MutablePropertyValues());//		ctx.registerAlias("testService", "1");//		MutablePropertyValues mpv = new MutablePropertyValues();//		mpv.addPropertyValue("serviceLocatorInterface", TestServiceLocator3.class);//		ctx.registerSingleton("factory", ServiceLocatorFactoryBean.class, mpv);//		ctx.refresh();//		ctx.registerPrototype("testService1", TestService.class, new MutablePropertyValues());//		ctx.registerPrototype("testService2", ExtendedTestService.class, new MutablePropertyValues());//		mpv.addPropertyValue("serviceMappings", "=testService1\n1=testService1\n2=testService2");// should throw, bad (non-interface-type) serviceLocator interface supplied// should throw, bad (invalid-Exception-type) serviceLocatorException class supplied// should throw, bad (non-Exception-type) serviceLocatorException class supplied//bad method (too many args, doesn't obey class contract)/** Simple test to illustrate and verify scope usage. ... */new NoOpScope(...) { ... }List<TestBean> objects, ...;String[] scopeNamesscopeNames.lengthSimpleScopeTests.class/** Shared test types for this package. ... */import DuplicateKeyExceptionimport ByteArrayResourceimport FileSystemResource/** Tests for {@link YamlMapFactoryBean}. ... */new YamlMapFactoryBean(...)YamlMapFactoryBean factory, ...;setResolutionMethod(...)this.factoryYamlMapFactoryBean.ResolutionMethod.OVERRIDE_AND_IGNOREYamlMapFactoryBean.ResolutionMethodsetResources(...)new FileSystemResource(...)new ByteArrayResource(...)YamlProcessor.ResolutionMethod.FIRST_FOUNDYamlProcessor.ResolutionMethodnew AbstractResource(...) { ... }new IOException(...)Map<String,Object> subDuplicateKeyException.classimport ConstructorExceptionimport ParserExceptionimport ScannerExceptionimport static Assertions.entry/** Tests for {@link YamlProcessor}. ... */new YamlProcessor(...) { ... }YamlProcessor processor, ...;setYaml(...)this.processorParserException.classScannerException.classMap<String,Object> flattenedMapMap<String,Object> barList<Object> keysFromPropertiesList<String> keysFromFlattenedMapLinkedHashMap<>.classcontainsExactlyInAnyOrderElementsOf(...)entry(...)URL urlConstructorException.classsetSupportedTypes(...)// Keys in the Properties object are sorted.// But the flattened map retains the order from the input.import MatchStatusimport ResolutionMethod/** Tests for {@link YamlPropertiesFactoryBean}. ... */YamlPropertiesFactoryBean factorynew YamlPropertiesFactoryBean(...)setDocumentMatchers(...)new DocumentMatcher(...) { ... }MatchStatus.NOT_FOUNDsetMatchDefault(...)Map<String,?> maploadAs(...)/** Unit tests for {@link ConstructorArgumentEntry}. ... */CollatingProblemReporter problemReporter, ...;new CollatingProblemReporter(...)setProblemReporter(...)CustomProblemReporterTests.classgetErrors(...).lengthgetErrors(...)new ArrayList<Problem>(...)List<Problem> errors, ...;List<Problem> warnings, ...;this.errorsnew Problem[]this.warningsimport static ArgumentMatchers.isAFailFastProblemReporter reporterProblem problemsetLogger(...)isA(...)Object extractedSourceMockEntry entrynew MockEntry(...)ParseState parseStateMockEntry oneMockEntry twoMockEntry threeParseState originalParseState snapshot/** Unit tests for {@link PassThroughSourceExtractor}. ... *//** Unit tests for {@link PropertyEntry}. ... */import static Assumptions.assumeTrueassumeTrue(...)DocumentBuilderFactory.classServiceLoaderFactoryBean.classServiceLoader<?> serviceLoaderServiceFactoryBean.classServiceListFactoryBean.classList<?> serviceList/** Unit tests for {@link AutowireUtils}. ... */Method notParameterizedMyTypeWithMethods<>.classObject actualMethod notParameterizedWithArgumentsMethod createProxyMethod createNamedProxyWithDifferentTypesMethod createNamedProxyWithDuplicateTypesMethod createMockMethod createNamedMockMethod createVMockMethod extractValueFromMyInterfaceType<>.classMap<Integer,Boolean> mapnew HashMap<Integer,Boolean>(...)Method extractMagicValuenew MySimpleInterfaceType(...)/** Simulates a factory method that wraps the supplied object in a proxy of the ... *//** Similar to {@link #createProxy(Object)} but adds an additional argument before ... *//** Simulates factory methods found in libraries such as Mockito and EasyMock. *//** Similar to {@link #createMock(Class)} but adds an additional method argument ... *//** Similar to {@link #createNamedMock(String, Class)} but adds an additional ... *//** Extract some value of the type supported by the interface (i.e., by a concrete, ... *//** Extract some magic value from the supplied map. */// Ideally we would expect String.class instead of Object.class, but// resolveReturnTypeForFactoryMethod() does not currently support this form of// look-up.// Ideally we would expect Boolean.class instead of Object.class, but this// information is not available at run-time due to type erasure.BeanDefinitionBuilder bdbString dependsOnEntryaddDependsOn(...)RootBeanDefinition otherBdGenericBeanDefinition otherBdGenericBeanDefinition childBdRootBeanDefinition mergedBdimport AbstractCollectionGenericBean<>.classGenericIntegerBean.classList<Integer> inputList<String> input2Map<String,String> input2getPlainMap(...)Map<Short,Integer> inputMap<String,AbstractCollection<?>> inputnew HashMap<String,AbstractCollection<?>>(...)List<?> listSet<?> setMap<?,?> mapUrlSet us/** Tests support for parameterized static {@code factory-method} declarations such as ... */Map<String,Runnable> beans/** Tests support for parameterized instance {@code factory-method} declarations such ... */setTempClassLoader(...)NumberBean nbNumberBean.classString[] numberStoreNamesNumberStore<>.classString[] doubleStoreNamesString[] floatStoreNamesnew GenericTypeAwareAutowireCandidateResolver(...)getDoubleStore(...)getFloatStore(...)numberStoreNames.lengthdoubleStoreNames.lengthfloatStoreNames.lengthNumberStoreFactory.classObjectProvider<NumberStore<?>> numberStoreProviderObjectProvider<NumberStore<Double>> doubleStoreProviderObjectProvider<NumberStore<Float>> floatStoreProviderList<NumberStore<?>> resolvednew ArrayList<NumberStore<?>>(...)NumberStore<?> instanceNumberStore<Double> instanceNumberStore<Float> instanceURI urlNameBeanFactoryGenericsTests.classNumberStore<Double> doubleStore, ...;NumberStore<Float> floatStore, ...;this.doubleStorethis.floatStorenew DoubleStore(...)new FloatStore(...)// SPR-16720DefaultSingletonBeanRegistry beanRegistrynew DefaultSingletonBeanRegistry(...)getSingletonNames(...)getSingletonCount(...)getSingletonNames(...).length/** Unit tests for {@code equals()} and {@code hashCode()} in bean definitions. ... */RootBeanDefinition masterRootBeanDefinition equalRootBeanDefinition notEqualRootBeanDefinition subclassnew RootBeanDefinition(...) { ... }setBaseProperties(...)assertEqualsAndHashCodeContracts(...)ChildBeanDefinition masterChildBeanDefinition equalChildBeanDefinition notEqualChildBeanDefinition subclassnew ChildBeanDefinition(...) { ... }RuntimeBeanReference masterRuntimeBeanReference equalRuntimeBeanReference notEqualRuntimeBeanReference subclassnew RuntimeBeanReference(...) { ... }// Simulate AbstractBeanDefinition.validate() which delegates to// AbstractBeanDefinition.prepareMethodOverrides():// But do not simulate validation of the 'equal' bean. As a consequence, a method// override in 'equal' will be marked as overloaded, but the corresponding// override in 'master' will not. But... the bean definitions should still be// considered equal.// definition.getConstructorArgumentValues().addGenericArgumentValue("foo");isJedi(...)ManagedList<> parentnew ManagedList<>(...)ManagedList<> childList<> mergedList// doesn't make much sense in the context of a list...ManagedMap<> parentnew ManagedMap<>(...)ManagedMap<> childMap<> mergedMapManagedMap<> map// child value for 'one' must override parent value...ManagedProperties parentManagedProperties childManagedProperties mapManagedSet<> parentnew ManagedSet<>(...)ManagedSet<> childSet<> mergedSet// asserts that the set contract is not violated during a merge() operation...PropertiesBeanDefinitionReader reader, ...;TestBean robTestBean sallyimport LocalVariableTableParameterNameDiscovererString JUERGEN, ...;String MARK, ...;ConstructorArgumentValues cavsConstructorArgumentValues cavs1RootBeanDefinition person1ConstructorArgumentValues cavs2RootBeanDefinition person2DependencyDescriptor qualifiedDescriptorQualifiedTestBean.classDependencyDescriptor nonqualifiedDescriptorTestQualifier.classRootBeanDefinition personMethodParameter paramnew LocalVariableTableParameterNameDiscoverer(...)MethodParameter qualifiedParamMethodParameter nonqualifiedParamPerson qualified, ...;Person nonqualified, ...;/** Unit tests for SPR-8954, in which a custom {@link InstantiationAwareBeanPostProcessor} ... */new PredictingBPP(...)Map<String,FactoryBean<>> fbBeansMap<String,AnInterface> aiBeansAnInterface.class/** SPR-10517 */Map<String,AnInterface> beansPredictedType.classimport Permissionsimport Policyimport ProtectionDomainimport PropertyPermissionimport AuthPermissionimport SecurityContextProviderimport ConstructorBeanimport CustomCallbackBeanimport DefaultResourceLoader/** Security test case. Checks whether the container uses its privileges for its ... */SecurityContextProvider provider, ...;String expectedName, ...;this.expectedNamecheckCurrentContext(...)getCurrentSubjectName(...)new PrivilegedAction<String>(...) { ... }Set<Principal> principalsPolicy policygetPolicy(...)URL policyURLsetSecurityManager(...)new SecurityManager(...)ProtectionDomain emptynew ProtectionDomain(...)new Permissions(...)DefaultResourceLoader drlnew DefaultResourceLoader(...)Resource confignew SecurityContextProvider(...) { ... }new AccessControlContext(...)new ProtectionDomain[]setSecurityContextProvider(...)CustomCallbackBean beannew CustomCallbackBean(...)Class<ConstructorBean> clConstructorBean.classSecurityException.classcheckPermission(...)new PropertyPermission(...)mostSpecificCauseOf(...)NonPrivilegedBean.classNonPrivilegedBean beannew PrivilegedAction<NonPrivilegedBean>(...) { ... }Permissions permsProtectionDomain pdnew AuthPermission(...)NonPrivilegedBean.destroyed// setup security// request the beans from non-privileged code// sanity check// the factory is a prototype - ask for multiple instancesnew StubBeanConfigurerSupport(...)TestBean beanInstanceBeanWiringInfoResolver resolverBeanWiringInfoResolver.classBeanConfigurerSupport configurersetBeanWiringInfoResolver(...)BeanWiringInfo.AUTOWIRE_BY_NAMEBeanWiringInfo.AUTOWIRE_BY_TYPE// spouse for autowiring by name...// spouse for autowiring by type.../** Unit tests for the BeanWiringInfo class. ... *//** Unit tests for the ClassNameBeanWiringInfoResolver class. ... */ClassNameBeanWiringInfoResolver resolverLong beanInstancegetFactoryBeanInstanceCount(...)getSomeProperties(...)RootBeanDefinition robDefRootBeanDefinition propsDefTestBean rob2XmlBeanDefinitionReader.VALIDATION_NONEGeneratedNameBean.classGeneratedNameBean topLevel1GeneratedNameBean topLevel2GeneratedNameBean child1GeneratedNameBean child2import BeanDefinitionReader/** Unit and integration tests for the collection merging support. ... */BeanDefinitionReader readerList<> listgetSomeList(...)Set<> setIterator<> itMap<> mapassertMap(...)MixedCollectionBean jumbleList<> lgetJumble(...)Integer[] array1int[] array2/** Simple bean used to check constructor dependency checking. ... */TestBean spouse1, ...;TestBean spouse2, ...;IndexedTestBean other, ...;this.spouse1this.spouse2int factoryBeanInstanceCount, ...;/** Clear static state. */LifecycleAwareBean beanisInitCalled(...)isCustomInitCalled(...)isDestroyCalled(...)isCustomDestroyCalled(...)boolean initCalled, ...;boolean destroyCalled, ...;boolean customInitCalled, ...;boolean customDestroyCalled, ...;this.initCalledthis.destroyCalledthis.customInitCalledthis.customDestroyCalled/** Unit tests for the {@link DelegatingEntityResolver} class. ... */new NoOpEntityResolver(...)TestBean testBean1, ...;DummyFactory dummyFactory, ...;this.dummyFactorythis.testBean1/** With Spring 3.1, bean id attributes (and all other id attributes across the ... */// there should be only oneimport AliasDefinitionimport ImportDefinitionsetSourceExtractor(...)List<> defaultsListDocumentDefaultsDefinition defaultsComponentDefinition componentDefinition1getComponentDefinition(...)BeanDefinition beanDefinition1BeanDefinition innerBd1getInnerBeanDefinitions(...)ComponentDefinition componentDefinition2BeanDefinition beanDefinition2BeanDefinition innerBd2getInnerBeanDefinitions(...).lengthList<> aliasesAliasDefinition aliasDefinition1AliasDefinition aliasDefinition2getAlias(...)List<> importsgetImports(...)ImportDefinition importDefinitiongetImportedResource(...)import FactoryMethodsFactoryMethods fmFactoryMethods fm2getNum(...)getStringValue(...)/** Tests where the static factory method is on a different class. */InstanceFactory.countTestBean tbArgTestBean tbArg2FactoryMethods fm1FactoryMethods fm3FactoryMethods fm4FactoryMethods.classCollections.EMPTY_LISTMailSession sessionnew MailSession(...)// This comes from the test bean// The TestBean is created separately for each bean// The TestBean reference is resolved to a prototype in the factory// First getBean call triggers actual creation of the singleton bean// Check that listInstance is not considered a bean of type FactoryMethods.GeneratedNameBean child, ...;/** Test class for Spring's ability to create objects using ... */String factoryBeanProperty, ...;this.factoryBeanProperty/** Note that overloaded methods are supported. *//** Bean that exposes a simple property that can be set ... */Collection<?> jumble, ...;this.jumble/** Tests for propagating enclosing beans element defaults to nested beans elements. ... */assertLazyInits(...)XmlBeanDefinitionReader xmlBeanDefinitionReaderBeanDefinition fooBeanDefinition barBeanDefinition bazBeanDefinition bizBeanDefinition buzassertMerge(...)TestBean topLevelTestBean firstLevelTestBean secondLevelassertAutowireCandidates(...)InitDestroyBean beanAInitDestroyBean.classInitDestroyBean beanBInitDestroyBean beanCInitDestroyBean beanDbeanA.initMethod1CalledbeanB.initMethod2CalledbeanC.initMethod3CalledbeanD.initMethod2CalledbeanA.destroyMethod1CalledbeanB.destroyMethod2CalledbeanC.destroyMethod3CalledbeanD.destroyMethod2Calledboolean initMethod1Called, ...;boolean initMethod2Called, ...;boolean initMethod3Called, ...;boolean destroyMethod1Called, ...;boolean destroyMethod2Called, ...;boolean destroyMethod3Called, ...;this.initMethod1Calledthis.initMethod2Calledthis.initMethod3Calledthis.destroyMethod1Calledthis.destroyMethod2Calledthis.destroyMethod3Called// has the concrete child bean values// but does not merge the parent values// merges all valuesimport ConfigurableEnvironment/** Tests for new nested beans element support in Spring XML ... */Resource XML, ...;Object fooConfigurableEnvironment env// should not throw NSBDEimport Condition/** Tests various combinations of profile declarations against various profile ... */String PROD_ELIGIBLE_XML, ...;String DEV_ELIGIBLE_XML, ...;String NOT_DEV_ELIGIBLE_XML, ...;String ALL_ELIGIBLE_XML, ...;String MULTI_ELIGIBLE_XML, ...;String MULTI_NEGATED_XML, ...;String MULTI_NOT_DEV_ELIGIBLE_XML, ...;String MULTI_ELIGIBLE_SPACE_DELIMITED_XML, ...;String UNKNOWN_ELIGIBLE_XML, ...;String DEFAULT_ELIGIBLE_XML, ...;String CUSTOM_DEFAULT_ELIGIBLE_XML, ...;String DEFAULT_AND_DEV_ELIGIBLE_XML, ...;String PROD_ACTIVE, ...;String DEV_ACTIVE, ...;String NULL_ACTIVE, ...;String UNKNOWN_ACTIVE, ...;...[] NONE_ACTIVE, ...;...[] MULTI_ACTIVE, ...;String TARGET_BEAN, ...;beanFactoryFor(...)isNot(...)containingTarget(...)is(...)setDefaultProfiles(...)StandardEnvironment envnew Condition<BeanDefinitionRegistry>(...)new Predicate<BeanDefinitionRegistry>(...) { ... }// env.setActiveProfiles(DEV_ACTIVE);//env.setDefaultProfiles("default");/** Simple test of BeanFactory initialization and lifecycle callbacks. ... */boolean initMethodDeclared, ...;BeanFactory owningFactory, ...;boolean postProcessedBeforeInit, ...;boolean inited, ...;boolean initedViaDeclaredInitMethod, ...;boolean postProcessedAfterInit, ...;this.initMethodDeclaredthis.owningFactorythis.initedthis.initedViaDeclaredInitMethodthis.postProcessedBeforeInitthis.postProcessedAfterInit/** Dummy business method that will fail unless the factory ... */postProcessBeforeInit(...)postProcessAfterInit(...)SAXParseException.classXmlBeanDefinitionReader.VALIDATION_XSDTestBean fooimport DummyBeancreateFactory(...)DummyBean nameValueDummyBean.classTestBean nameValueDummyBean nameRefDummyBean typeRefDummyBean derivedBean//		beanFactory.getBean("simple1", DummyBean.class);//		beanFactory.getBean("name-value1", TestBean.class);ITestBean robITestBean sally/** Test class for Spring's ability to create ... */import LinkedCaseInsensitiveMapCollectingReaderEventListener listener, ...;this.listenerInteger minInteger.MIN_VALUEInteger maxComponentDefinition propertiesComponentAbstractBeanDefinition propertiesBeanComponentDefinition constantComponentAbstractBeanDefinition constantBeanMap<> map2List<> list2Set<> set2Set<> innerSetThread.State.NEWThread.StateThread.State.RUNNABLEimport LinkedListimport HasMap/** Tests for collections in XML bean definitions. ... */ListFactoryBean listFactorynew ListFactoryBean(...)SetFactoryBean setFactorynew SetFactoryBean(...)MapFactoryBean mapFactorynew MapFactoryBean(...)setSourceList(...)new LinkedList<>(...)setSourceSet(...)new TreeSet<>(...)setSourceMap(...)new TreeMap<>(...)TestBean jenTestBean daveTestBean verboseObject[] friendsfriends.lengthTestBean rod2Object[] friends2friends2.lengthTestBean lonerHasMap hasMapTestBean jennyHasMap hasMap2Map<> mgetConcurrentSet(...)HashSet<> setnew HashSet<>(...)getIdentityMap(...)getProps(...)getObjectArray(...).lengthgetObjectArray(...)getIntegerArray(...).lengthgetClassArray(...).lengthgetClassArray(...)getClassList(...)MapAndSet samObject obj, ...;//assertTrue("5 beans in reftypes, not " + this.beanFactory.getBeanDefinitionCount(), this.beanFactory.getBeanDefinitionCount() == 5);// Must be a list to support ordering// Our bean doesn't modify the collection:// of course it could be a different copy in a real object.// Should be ordered// Check list// Check nested map in list// Check nested list in list// Check nested mapimport SimpleBeanDefinitionRegistryimport InputStreamResourceSimpleBeanDefinitionRegistry registrynew SimpleBeanDefinitionRegistry(...)setDocumentReaderClass(...)new InputStreamResource(...)getResourceAsStream(...)XmlBeanDefinitionReader.VALIDATION_DTDtestBeanDefinitions(...)InputSource resourcealiases.lengthdoTestValidation(...)import LifecycleBeanimport AbstractListableBeanFactoryTestsDefaultListableBeanFactory parent, ...;setPostProcessed(...)new PostProcessor(...)LifecycleBean.PostProcessorProtectedLifecycleBean.PostProcessorassertCount(...)assertTestBeanCount(...)LifecycleBean beanbusinessMethod(...)ProtectedLifecycleBean beanTestBean validEmpty/** Test that properties with name as well as id creating an alias up front. */List<> beanNamesgetListableBeanFactory(...)TestBean alias1List<> tb1AliasesTestBean alias2TestBean alias3TestBean alias3aTestBean alias3bList<> tb2AliasesTestBean alias4TestBean alias5List<> tb3AliasesMap<> drsDummyReferencer.classITestBean fatherDummyFactory factoryDummyReferencer refDummyReferencer ref2getTestBean1(...)getDummyFactory(...)DummyReferencer ref1TestBean kathyTestBean factoryCreatedisPostProcessed(...)// this.factory.preInstantiateSingletons();// check that not broken by circular reference resolution mechanismimport DefaultNamespaceHandlerResolverimport UtilNamespaceHandler/** Unit and integration tests for the {@link DefaultNamespaceHandlerResolver} class. ... */DefaultNamespaceHandlerResolver resolverUtilNamespaceHandler.classString mappingPath// simply must not bail...// simply must not bail; we don't want non-existent resources to result in an Exceptionimport SimpleBeanInfoValueBean beannew ValueBean(...)Integer valueInteger value, ...;ValueBean.classMyNumberEditor.class/** Unit tests for the {@link ByteArrayPropertyEditor} class. ... */PropertyEditor byteEditor, ...;String textbyte[] bytes/** Unit tests for the {@link CharArrayPropertyEditor} class. ... */PropertyEditor charEditor, ...;char[] chars/** Unit tests for the {@link CustomCollectionEditor} class. ... */CustomCollectionEditor editorCollectionTypeWithNoNoArgCtor.classCollection<?> valueimport PropertyVetoExceptionimport SimpleDateFormatimport Hashtableimport Vector/** Unit tests for the various PropertyEditors in Spring. ... */String tbStringnew TestBeanEditor(...)new OldValueAccessingTestBeanEditor(...)BooleanTestBean tbboolean condition4isBool1(...)String trueStringString falseStringCustomBooleanEditor editortoUpperCase(...)NumberTestBean tbgetShort1(...)getInt1(...)getLong1(...)getFloat1(...)getDouble1(...)getNumberInstance(...)Locale.FRENCHCustomNumberEditor editorNumberFormatException.classPrimitiveArrayBean beangetByteArray(...)getCharArray(...)CharBean cbnew CharBean(...)CharacterEditor editornew Character(...)getMyChar(...)getMyCharacter(...)PropertyEditor charEditorPropertyEditor classEditor/* SPR_2165 - ClassEditor is inconsistent with multidimensional arrays */String[][] chessboardnew String[][]ClassEditor editorString[][][][][] ridiculousChessboardnew String[][][][][]PropertyEditor fileEditorPropertyEditor localeEditorLocale.CANADAString REGEXPropertyEditor patternEditorCustomDateEditor editorint maxLengthString validDateString invalidDatenew SimpleDateFormat(...)toHexString(...)StringTrimmerEditor editorIndexedTestBean beanpopulate(...)setNestedIndexedBean(...)getNestedIndexedBean(...)List<TestBean> resultOldCollectionsBean tbnew OldCollectionsBean(...)Vector<>.classHashtable<>.classgetVector(...)getHashtable(...)PropertyEditor peClassArrayEditor classArrayEditorclasses.lengthClassArrayEditor editorCharsetEditor editorCharset charsetStringTokenizer st...[] byteArray, ...;...[] charArray, ...;this.byteArraythis.charArraychar myChar, ...;Character myCharacter, ...;this.myCharthis.myCharacterVector<?> vector, ...;Hashtable<?,?> hashtable, ...;this.vectorthis.hashtable// expected: should get resolved as class path resource,// and there is no such resource in the class path...// testing on Windows// testing on Unix// ensure setAsText can consume the return value of getAsTextclassPackageAsResourcePath(...)PropertyEditor propertyEditorString fileNameString absolutePathgetAbsolutePath(...)/** Unit tests for the {@link InputStreamEditor} class. ... */InputStream streamString resourceInputStreamEditor editoravailable(...)PropertyEditor pathEditorPath pathtoFile(...)File.separatorChar/** Test the conversion of Strings to {@link java.util.Properties} objects, ... */String sPropertiesEditor pe/** Comments begin with # *//** We'll typically align by indenting with tabs or spaces. ... *//** Unit tests for the {@link ReaderEditor} class. ... */ReaderEditor editorready(...)/** Unit tests for the {@link ResourceBundleEditor} class. ... */ResourceBundleEditorTests.classString BASE_NAME, ...;String MESSAGE_KEY, ...;ResourceBundleEditor editornew ResourceBundleEditor(...)ResourceBundle bundleString stringgetString(...)StringArrayPropertyEditor editorassertTrimmedElements(...)doTestURI(...)PropertyEditor uriEditortoASCIIString(...)PropertyEditor urlEditorgetProtocol(...)ZoneIdEditor editor, ...;ZoneId zoneIdList<> tbsnew ArrayList<>(...)PagedListHolder<> holdernew PagedListHolder<>(...)PagedListHolder<>.DEFAULT_PAGE_SIZEgetPageList(...)setPageSize(...)setIgnoreCase(...)resort(...)nextPage(...)previousPage(...)String age, ...;String extendedInfo, ...;this.extendedInfoMockFilter mockFiltermockFilter.agemockFilter.extendedInfomockFilter.name/** Unit tests for {@link PropertyComparator}. ... */Dog dognew Dog(...)Dog dog2PropertyComparator<Dog> cnew PropertyComparator<Dog>(...)setNickName(...)Comparator<Dog> cDog dog1setFirstName(...)setLastName(...)reversed(...)String nickName, ...;String firstName, ...;String lastName, ...;this.nickNamethis.firstNamethis.lastName(...).nickNameString someProperty, ...;this.somePropertyboolean bool1, ...;Boolean bool2, ...;this.bool1this.bool2new ArrayList<DefaultsDefinition>(...)new LinkedHashMap<String,ComponentDefinition>(...)new LinkedHashMap<String,List<AliasDefinition>>(...)new ArrayList<ImportDefinition>(...)List<DefaultsDefinition> defaults, ...;Map<String,ComponentDefinition> componentDefinitions, ...;Map<String,List<AliasDefinition>> aliasMap, ...;List<ImportDefinition> imports, ...;this.componentDefinitionsCollection<ComponentDefinition> collectionList<AliasDefinition> aliasesthis.aliasMapnew Function<String,List<AliasDefinition>>(...) { ... }new ArrayList<AliasDefinition>(...)this.importsnew Colour(...)Colour RED, ...;Colour BLUE, ...;Colour GREEN, ...;Colour PURPLE, ...;new CustomEnum(...)CustomEnum VALUE_1, ...;CustomEnum VALUE_2, ...;/** Simple bean used to test dependency checking. ... *//** Simple factory to allow testing of FactoryBean support in AbstractBeanFactory. ... */String SINGLETON_NAME, ...;boolean prototypeCreated, ...;/** Default is for factories to return a singleton instance. */AutowireCapableBeanFactory beanFactory, ...;TestBean otherTestBean, ...;/** Return if the bean managed by this factory is a singleton. ... *//** Set if the bean managed by this factory is a singleton. */this.postProcessedthis.otherTestBean/** Was this initialized by invocation of the ... *//** Return the managed object, supporting both singleton ... */TestBean prototypeString co, ...;this.co/** Test class for Spring's ability to create objects using static ... */new FactoryMethods(...)new ExtendedFactoryMethods(...)int num, ...;TestBean tb, ...;String stringValue, ...;/** Constructor is private: not for use outside this class, ... */this.tbthis.numthis.stringValue/** Set via Setter Injection once instance is created. */import EnumMapimport EnumSetSet<Integer> integerSet, ...;Set<? extends Number> numberSet, ...;Set<ITestBean> testBeanSet, ...;List<Resource> resourceList, ...;List<TestBean> testBeanList, ...;List<List<Integer>> listOfLists, ...;ArrayList<String[]> listOfArrays, ...;List<Map<Integer,Long>> listOfMaps, ...;Map<?,?> plainMap, ...;Map<Short,Integer> shortMap, ...;HashMap<Long,?> longMap, ...;Map<Number,Collection<? extends Object>> collectionMap, ...;Map<String,Map<Integer,Long>> mapOfMaps, ...;Map<Integer,List<Integer>> mapOfLists, ...;CustomEnum customEnum, ...;...[] customEnumArray, ...;Set<CustomEnum> customEnumSet, ...;EnumSet<CustomEnum> standardEnumSet, ...;EnumMap<CustomEnum,Integer> standardEnumMap, ...;T genericProperty, ...;List<T> genericListProperty, ...;this.integerSetthis.resourceListthis.shortMapthis.plainMapthis.longMapthis.collectionMapthis.numberSetthis.testBeanListthis.listOfArraysthis.listOfListsthis.mapOfMapsthis.mapOfListsthis.genericPropertythis.genericListPropertythis.customEnumthis.customEnumArraythis.customEnumSetnew HashSet<CustomEnum>(...)Iterator<String> iteratorthis.standardEnumSetthis.standardEnumMapnew GenericBean<>(...)/** Bean exposing a map. Used for bean factory tests. ... */Map<?,?> map, ...;Set<?> set, ...;...[] objectArray, ...;...[] classArray, ...;List<Class<?>> classList, ...;IdentityHashMap<?,?> identityMap, ...;CopyOnWriteArraySet<?> concurrentSet, ...;this.setthis.objectArraythis.classArraythis.classListthis.identityMapthis.concurrentSet/** Interface used for {@link org.springframework.beans.testfixture.beans.TestBean}. ... *//** Throws a given (non-null) exception. *//** Increment the age by one. ... */Collection<?> collection, ...;Set<? super Object> set, ...;SortedSet<? super Object> sortedSet, ...;Map<> map, ...;SortedMap<> sortedMap, ...;TestBean tbXTestBean tbYnew TestBean[]this.collectionthis.sortedSetthis.sortedMap/** Simple test of BeanFactory initialization ... *//** Simple nested test bean used for testing bean factories, AOP framework etc. ... */ntb.companyshort short1, ...;Short short2, ...;int int1, ...;Integer int2, ...;long long1, ...;Long long2, ...;BigInteger bigInteger, ...;float float1, ...;Float float2, ...;double double1, ...;Double double2, ...;BigDecimal bigDecimal, ...;this.short1this.short2this.int1this.int2this.long1this.long2this.bigIntegerthis.float1this.float2this.double1this.double2this.bigDecimal/** @see ... */String CONSTANT, ...;/** Test for non-property method matching. If the parameter is a Throwable, it will be ... */Pet petpet.name/** Serializable implementation of the Person interface. ... */SerializablePerson pp.agep.name/** Bean that changes state on a business invocation, so that ... *//** Simple test bean used for testing bean factories, the AOP framework etc. ... */String country, ...;String sex, ...;boolean jedi, ...;ITestBean spouse, ...;String touchy, ...;...[] someIntegerArray, ...;...[] nestedIntegerArray, ...;...[] someIntArray, ...;...[] nestedIntArray, ...;Date date, ...;Collection<? super Object> friends, ...;Set<?> someSet, ...;Map<?,?> someMap, ...;List<?> someList, ...;Properties someProperties, ...;INestedTestBean doctor, ...;INestedTestBean lawyer, ...;IndexedTestBean nestedIndexedBean, ...;Number someNumber, ...;Colour favouriteColour, ...;Boolean someBoolean, ...;List<?> otherColours, ...;List<?> pets, ...;this.somePropertiesthis.someListthis.someSetthis.someMapthis.sexthis.jedinew ITestBean[]new NumberFormatException(...)this.touchythis.someIntegerArraythis.nestedIntegerArraythis.someIntArraythis.nestedIntArraythis.datethis.friendsthis.doctorthis.lawyerthis.someNumberthis.someBooleanthis.nestedIndexedBeanthis.otherColoursthis.pets/** Used for testing pointcut matching. ... */import MustBeInitialized/** Subclasses must initialize the bean factory and any other variables they need. ... *//** Roderick bean inherits from rod, overriding name only. */TestBean roderick/** Test that InitializingBean objects receive the afterPropertiesSet() callback */MustBeInitialized mbi/** Test that InitializingBean/BeanFactoryAware/DisposableBean objects receive the ... */LifecycleBean lbisDestroyed(...)BeanNotOfRequiredTypeException.classnew Consumer<BeanNotOfRequiredTypeException>(...) { ... }getRequiredType(...)getActualType(...)Object o1TestBean veTestBean dadDummyFactory.SINGLETON_NAME/** Check that we can get the factory bean itself. ... *//** Check that afterPropertiesSet gets called on factory */wasInitialized(...)/** It should be illegal to dereference a normal bean as a factory. */BeanIsNotAFactoryException.class// and rename this class// TODO: refactor in AbstractBeanFactory (tests for AbstractBeanFactory)Object rodObject aliasRodnew Consumer<NoSuchBeanDefinitionException>(...) { ... }// The dummy business method will throw an exception if the// afterPropertiesSet() callback wasn't invoked// necessary callbacks weren't invoked in the right order.// Create alias/** Subclasses must initialize this *//** Subclasses can override this. */String[] defnamesdefnames.lengthString[] defNamesint countIncludingFactoryBeansdefNames.length/** Check that count refers to factory class, not bean class. (We don't know ... *//** Interface that defines common cache operations. ... *//** Return the cache name. *//** Return the underlying native cache provider. *//** Return the value to which this cache maps the specified key. ... *//** Return the value to which this cache maps the specified key, ... *//** Return the value to which this cache maps the specified key, obtaining ... *//** Associate the specified value with the specified key in this cache. ... *//** Atomically associate the specified value with the specified key in this cache ... */ValueWrapper existingValue/** Evict the mapping for this key from this cache if it is present. ... *//** Evict the mapping for this key from this cache if it is present, ... */evict(...)/** Clear the cache through removing all mappings. ... *//** Invalidate the cache through removing all mappings, expecting all ... *//** A (wrapper) object representing a cache value. *//** Return the actual value in the cache. *//** Wrapper exception to be thrown from {@link #get(Object, Callable)} ... *//** Spring's central cache manager SPI. ... *//** Get the cache associated with the given name. ... *//** Get a collection of the cache names known by this manager. ... */import CacheErrorHandlerimport CacheResolverimport KeyGeneratorimport ImportAware/** Abstract base {@code @Configuration} class providing common structure ... */AnnotationAttributes enableCaching, ...;Supplier<CacheManager> cacheManager, ...;Supplier<CacheResolver> cacheResolver, ...;Supplier<KeyGenerator> keyGenerator, ...;Supplier<CacheErrorHandler> errorHandler, ...;this.enableCachingfromMap(...)EnableCaching.classCachingConfigurer configureruseCachingConfigurer(...)/** Extract the configuration from the nominated {@link CachingConfigurer}. */this.cacheManagernew Supplier<CacheManager>(...) { ... }cacheManager(...)this.cacheResolvernew Supplier<CacheResolver>(...) { ... }cacheResolver(...)this.keyGeneratornew Supplier<KeyGenerator>(...) { ... }keyGenerator(...)new Supplier<CacheErrorHandler>(...) { ... }errorHandler(...)import AbstractFallbackCacheOperationSourceimport CacheOperation/** Implementation of the {@link org.springframework.cache.interceptor.CacheOperationSource ... */boolean publicMethodsOnly, ...;Set<CacheAnnotationParser> annotationParsers, ...;/** Create a default AnnotationCacheOperationSource, supporting public methods ... *//** Create a default {@code AnnotationCacheOperationSource}, supporting public methods ... */this.publicMethodsOnlythis.annotationParserssingleton(...)new SpringCacheAnnotationParser(...)/** Create a custom AnnotationCacheOperationSource. ... */new LinkedHashSet<CacheAnnotationParser>(...)CacheAnnotationParser parserdetermineCacheOperations(...)new CacheOperationProvider(...) { ... }parseCacheAnnotations(...)/** Determine the cache operation(s) for the given {@link CacheOperationProvider}. ... */Collection<CacheOperation> opsCollection<CacheOperation> annOpsgetCacheOperations(...)Collection<CacheOperation> combinednew ArrayList<CacheOperation>(...)/** By default, only public methods can be made cacheable. */AnnotationCacheOperationSource otherCosotherCos.annotationParsersotherCos.publicMethodsOnly/** Callback interface providing {@link CacheOperation} instance(s) based on ... *//** Return the {@link CacheOperation} instance(s) provided by the specified parser. ... *//** Strategy interface for parsing known caching annotation types. ... *//** Determine whether the given class is a candidate for cache operations ... *//** Parse the cache definition for the given class, ... *//** Parse the cache definition for the given method, ... *//** {@code @CacheConfig} provides a mechanism for sharing common cache-related ... *//** Names of the default caches to consider for caching operations defined ... *//** The bean name of the default {@link org.springframework.cache.interceptor.KeyGenerator} to ... *//** The bean name of the custom {@link org.springframework.cache.CacheManager} to use to ... *//** The bean name of the custom {@link org.springframework.cache.interceptor.CacheResolver} to use. ... *//** Annotation indicating that a method (or all methods on a class) triggers a ... *//** Alias for {@link #cacheNames}. *//** Names of the caches to use for the cache eviction operation. ... *//** Spring Expression Language (SpEL) expression for computing the key dynamically. ... *//** The bean name of the custom {@link org.springframework.cache.interceptor.KeyGenerator} ... *//** The bean name of the custom {@link org.springframework.cache.interceptor.CacheResolver} ... *//** Spring Expression Language (SpEL) expression used for making the cache ... *//** Whether all the entries inside the cache(s) are removed. ... *//** Whether the eviction should occur before the method is invoked. ... *//** Names of the caches to use for the cache put operation. ... *//** Spring Expression Language (SpEL) expression used to veto the cache put operation. ... *//** Annotation indicating that the result of invoking a method (or all methods ... *//** Names of the caches in which method invocation results are stored. ... *//** Spring Expression Language (SpEL) expression used for making the method ... *//** Spring Expression Language (SpEL) expression used to veto method caching. ... *//** Synchronize the invocation of the underlying method if several threads are ... *//** Group annotation for multiple cache annotations (of different or the same type). ... */import AdviceModeImportSelectorimport AutoProxyRegistrar/** Selects which implementation of {@link AbstractCachingConfiguration} should ... */CachingConfigurationSelector.classString PROXY_JCACHE_CONFIGURATION_CLASS, ...;String CACHE_ASPECT_CONFIGURATION_CLASS_NAME, ...;String JCACHE_ASPECT_CONFIGURATION_CLASS_NAME, ...;boolean jsr107Present, ...;boolean jcacheImplPresent, ...;/** Returns {@link ProxyCachingConfiguration} or {@code AspectJCachingConfiguration} ... */getProxyImports(...)getAspectJImports(...)/** Return the imports to use if the {@link AdviceMode} is set to {@link AdviceMode#PROXY}. ... */AutoProxyRegistrar.classProxyCachingConfiguration.class/** Return the imports to use if the {@link AdviceMode} is set to {@link AdviceMode#ASPECTJ}. ... *//** Interface to be implemented by @{@link org.springframework.context.annotation.Configuration ... *//** Return the cache manager bean to use for annotation-driven cache ... *//** Return the {@link CacheResolver} bean to use to resolve regular caches for ... *//** Return the key generator bean to use for annotation-driven cache management. ... *//** Return the {@link CacheErrorHandler} to use to handle cache-related errors. ... *//** An implementation of {@link CachingConfigurer} with empty methods allowing ... *//** Enables Spring's annotation-driven cache management capability, similar to the ... *//** Indicate whether subclass-based (CGLIB) proxies are to be created as opposed ... *//** Indicate how caching advice should be applied. ... *//** Indicate the ordering of the execution of the caching advisor ... */import CacheManagementConfigUtilsimport CacheInterceptorimport CacheOperationSourceimport Role/** {@code @Configuration} class that registers the Spring infrastructure beans necessary ... */CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAMEBeanFactoryCacheOperationSourceAdvisor advisornew BeanFactoryCacheOperationSourceAdvisor(...)setCacheOperationSource(...)getNumber(...)new AnnotationCacheOperationSource(...)CacheInterceptor interceptornew CacheInterceptor(...)configure(...)import CacheEvictOperationimport CachePutOperationimport CacheableOperation/** Strategy implementation for parsing Spring's {@link Caching}, {@link Cacheable}, ... */Cacheable.classCacheEvict.classCachePut.classCaching.classSet<Class<? extends Annotation>> CACHE_OPERATION_ANNOTATIONS, ...;DefaultCacheConfig defaultConfignew DefaultCacheConfig(...)Collection<CacheOperation> localOpsCollection<? extends Annotation> annsgetAllMergedAnnotations(...)findAllMergedAnnotations(...)new Predicate<? extends Annotation>(...) { ... }new Consumer<? extends Annotation>(...) { ... }parseCacheableAnnotation(...)parseEvictAnnotation(...)parsePutAnnotation(...)parseCachingAnnotation(...)CacheableOperation.BuilderBuilder buildernew Builder(...)CacheableOperation opsetCacheNames(...)cacheNames(...)setCondition(...)condition(...)setUnless(...)unless(...)setKey(...)key(...)setKeyGenerator(...)setCacheManager(...)setCacheResolver(...)setSync(...)sync(...)applyDefault(...)validateCacheOperation(...)CacheEvictOperation.BuilderCacheEvictOperation opsetCacheWide(...)allEntries(...)setBeforeInvocation(...)beforeInvocation(...)CachePutOperation.BuilderCachePutOperation opCacheable[] cacheablescacheable(...)CacheEvict[] cacheEvictsCachePut[] cachePutsCacheable cacheableCacheEvict cacheEvictCachePut cachePut/** Validates the specified {@link CacheOperation}. ... */getKeyGenerator(...)getCacheManager(...)getCacheResolver(...)SpringCacheAnnotationParser.class/** Provides default settings for a given set of cache operations. */Class<?> target, ...;...[] cacheNames, ...;String keyGenerator, ...;String cacheManager, ...;String cacheResolver, ...;/** Apply the defaults to the specified {@link CacheOperation.Builder}. ... */CacheOperation.BuilderCacheConfig annotationCacheConfig.classthis.cacheNamesgetCacheNames(...)// More than one operation found -> local declarations override interface-declared ones...// One of these is set so we should not inherit anything/** Annotations and supporting classes for declarative cache management. ... */import AbstractValueAdaptingCacheimport SerializationDelegate/** Simple {@link org.springframework.cache.Cache} implementation based on the ... */ConcurrentMap<Object,Object> store, ...;SerializationDelegate serialization, ...;/** Create a new ConcurrentMapCache with the specified name. ... *//** Create a new ConcurrentMapCache with the specified name and the ... */this.storethis.serialization/** Return whether this cache stores a copy of each entry ({@code true}) or ... */fromStoreValue(...)new Function<Object,Object>(...) { ... }toStoreValue(...)new ValueRetrievalException(...)toValueWrapper(...)boolean notEmptyObject storeValueserializeToByteArray(...)deserializeFromByteArray(...)/** {@link FactoryBean} for easy configuration of a {@link ConcurrentMapCache} ... */boolean allowNullValues, ...;ConcurrentMapCache cache, ...;/** Specify the name of the cache. ... *//** Specify the ConcurrentMap to use as an internal store ... *//** Set whether to allow {@code null} values ... */this.allowNullValuesthis.cacheConcurrentMapCache.class/** {@link CacheManager} implementation that lazily builds {@link ConcurrentMapCache} ... */new ConcurrentHashMap<String,Cache>(...)ConcurrentMap<String,Cache> cacheMap, ...;boolean storeByValue, ...;/** Construct a dynamic ConcurrentMapCacheManager, ... *//** Construct a static ConcurrentMapCacheManager, ... *//** Specify the set of cache names for this CacheManager's 'static' mode. ... */this.cacheMapcreateConcurrentMapCache(...)/** Specify whether to accept and convert {@code null} values for all caches ... */recreateCaches(...)/** Return whether this cache manager accepts and converts {@code null} values ... *//** Specify whether this cache manager stores a copy of each entry ({@code true} ... */this.storeByValue/** Return whether this cache manager stores a copy of each entry or ... */new SerializationDelegate(...)isStoreByValue(...)Cache cacheEntry<String,Cache> entryMap<>.Entry<String,Cache>/** Create a new ConcurrentMapCache instance for the specified cache name. ... */SerializationDelegate actualSerializationisAllowNullValues(...)// Need to recreate all Cache instances with the new null-value configuration...// Need to recreate all Cache instances with the new store-by-value configuration...// Need to recreate all Cache instances with new ClassLoader in store-by-value mode.../** Implementation package for {@code java.util.concurrent} based caches. ... *//** {@link org.springframework.beans.factory.xml.BeanDefinitionParser} ... */AnnotationDrivenCacheBeanDefinitionParser.classString CACHE_ASPECT_CLASS_NAME, ...;String JCACHE_ASPECT_CLASS_NAME, ...;/** Parses the '{@code <cache:annotation-driven>}' tag. Will ... */String moderegisterCacheAspect(...)registerCacheAdvisor(...)/** Parse the cache resolution strategy to use. If a 'cache-resolver' attribute ... */boolean hasTextextractCacheManager(...)/** Configure the necessary infrastructure to support the Spring's caching annotations. */Object eleSourceRootBeanDefinition sourceDefString sourceNameRootBeanDefinition interceptorDefCacheInterceptor.classRootBeanDefinition advisorDefBeanFactoryCacheOperationSourceAdvisor.classparseCacheResolution(...)parseErrorHandler(...)parseKeyGenerator(...)/** Registers a cache aspect. ... */CacheManagementConfigUtils.CACHE_ASPECT_BEAN_NAME/** Configure the necessary infrastructure to support the standard JSR-107 caching annotations. */CacheManagementConfigUtils.JCACHE_ADVISOR_BEAN_NAMEBeanDefinition sourceDefcreateJCacheOperationSourceBeanDefinition(...)CacheManagementConfigUtils.JCACHE_ASPECT_BEAN_NAME// mode="aspectj"// mode="proxy"// Create the CacheOperationSource definition.// Create the CacheInterceptor definition.// Create the CacheAdvisor definition.// JSR-107 support should create an exception cache resolver with the cache manager// and there is no way to set that exception cache resolver from the namespaceimport AbstractSingleBeanDefinitionParserimport NameMatchCacheOperationSource/** {@link org.springframework.beans.factory.xml.BeanDefinitionParser ... */String CACHEABLE_ELEMENT, ...;String CACHE_EVICT_ELEMENT, ...;String CACHE_PUT_ELEMENT, ...;String METHOD_ATTRIBUTE, ...;String DEFS_ELEMENT, ...;List<Element> cacheDefsaddPropertyReference(...)List<RootBeanDefinition> attributeSourceDefinitionsparseDefinitionsSources(...)ManagedList<RootBeanDefinition> defsnew ManagedList<RootBeanDefinition>(...)parseDefinitionSource(...)Props propnew Props(...)ManagedMap<TypedStringValue,Collection<CacheOperation>> cacheOpMapnew ManagedMap<TypedStringValue,Collection<CacheOperation>>(...)List<Element> cacheableCacheMethodsList<Element> evictCacheMethodsList<Element> putCacheMethodsRootBeanDefinition attributeSourceDefinitionNameMatchCacheOperationSource.classElement opElementTypedStringValue nameHolderCollection<CacheOperation> colnew Function<TypedStringValue,Collection<CacheOperation>>(...) { ... }getAttributeValue(...)String wideString afterString attribute/** Simple, reusable class used for overriding defaults. */String condition, ...;String method, ...;...[] caches, ...;String defaultCachethis.conditionthis.cachesString cacheString[] localCachesString method// Using attributes source.// Assume annotations source.// extract default param for the definition// add cacheable first/** Configuration constants for internal sharing across subpackages. ... */String CACHE_ADVISOR_BEAN_NAME, ...;/** The name of the cache advisor bean. */String CACHE_ASPECT_BEAN_NAME, ...;/** The name of the cache aspect bean. */String JCACHE_ADVISOR_BEAN_NAME, ...;/** The name of the JCache advisor bean. */String JCACHE_ASPECT_BEAN_NAME, ...;/** {@code NamespaceHandler} allowing for the configuration of declarative ... */String CACHE_MANAGER_ATTRIBUTE, ...;String DEFAULT_CACHE_MANAGER_BEAN_NAME, ...;CacheNamespaceHandler.DEFAULT_CACHE_MANAGER_BEAN_NAMECacheNamespaceHandler.CACHE_MANAGER_ATTRIBUTEnew AnnotationDrivenCacheBeanDefinitionParser(...)new CacheAdviceParser(...)/** Support package for declarative caching configuration, with XML ... *//** A base component for invoking {@link Cache} operations and using a ... */SingletonSupplier<CacheErrorHandler> errorHandler, ...;new SimpleCacheErrorHandler(...)/** Set the {@link CacheErrorHandler} instance to use to handle errors ... *//** Return the {@link CacheErrorHandler} to use. *//** Execute {@link Cache#get(Object)} on the specified {@link Cache} and ... */Cache.ValueWrapperhandleCacheGetError(...)getErrorHandler(...)/** Execute {@link Cache#put(Object, Object)} on the specified {@link Cache} ... */handleCachePutError(...)/** Execute {@link Cache#evict(Object)}/{@link Cache#evictIfPresent(Object)} on the ... */evictIfPresent(...)handleCacheEvictError(...)/** Execute {@link Cache#clear()} on the specified {@link Cache} and ... */invalidate(...)handleCacheClearError(...)// If the exception is handled, return a cache miss/** A base {@link CacheResolver} implementation that requires the concrete ... */CacheManager cacheManager, ...;/** Construct a new {@code AbstractCacheResolver}. ... *//** Construct a new {@code AbstractCacheResolver} for the given {@link CacheManager}. ... *//** Set the {@link CacheManager} that this instance should use. *//** Return the {@link CacheManager} that this instance uses. */Collection<String> cacheNamesCollection<Cache> resultString cacheNamegetCache(...)getOperation(...)/** Provide the name of the cache(s) to resolve against the current cache manager. ... */import MethodClassKey/** Abstract implementation of {@link CacheOperation} that caches attributes ... */new ConcurrentHashMap<Object,Collection<CacheOperation>>(...)Collection<CacheOperation> NULL_CACHING_ATTRIBUTE, ...;/** Canonical value held in cache to indicate no caching attribute was ... *//** Logger available to subclasses. ... */Map<Object,Collection<CacheOperation>> attributeCache, ...;/** Cache of CacheOperations, keyed by method on a specific target class. ... *//** Determine the caching attribute for this method invocation. ... */Collection<CacheOperation> cachedthis.attributeCacheCollection<CacheOperation> cacheOpscomputeCacheOperations(...)/** Determine a cache key for the given method and target class. ... */new MethodClassKey(...)Collection<CacheOperation> opDeffindCacheOperations(...)allowPublicMethodsOnly(...)isUserLevelMethod(...)/** Subclasses need to implement this to return the caching attribute for the ... *//** Should only public methods be allowed to have caching semantics? ... */// Don't allow no-public methods as required.// The method may be on an interface, but we need attributes from the target class.// If the target class is null, the method will be unchanged.// First try is the method in the target class.// Second try is the caching operation on the target class.// Fallback is to look at the original method.// Last fallback is the class of the original method./** The base interface that all cache operations must implement. ... *//** Return the cache name(s) associated with the operation. */import AbstractBeanFactoryPointcutAdvisor/** Advisor driven by a {@link CacheOperationSource}, used to include a ... */new CacheOperationSourcePointcut(...) { ... }CacheOperationSource cacheOperationSource, ...;CacheOperationSourcePointcut pointcut, ...;/** Set the cache operation attribute source which is used to find cache ... */this.cacheOperationSourceimport AopProxyUtilsimport AnnotatedElementKeyimport EvaluationContextimport LinkedMultiValueMapimport MultiValueMapimport SupplierUtils/** Base class for caching aspects, such as the {@link CacheInterceptor} or an ... */new ConcurrentHashMap<CacheOperationCacheKey,CacheOperationMetadata>(...)new CacheOperationExpressionEvaluator(...)new SimpleKeyGenerator(...)Map<CacheOperationCacheKey,CacheOperationMetadata> metadataCache, ...;CacheOperationExpressionEvaluator evaluator, ...;SingletonSupplier<KeyGenerator> keyGenerator, ...;SingletonSupplier<CacheResolver> cacheResolver, ...;/** Configure this aspect with the given error handler, key generator and cache resolver/manager ... */new SingletonSupplier<CacheErrorHandler>(...)new SingletonSupplier<KeyGenerator>(...)new SingletonSupplier<CacheResolver>(...)/** Set one or more cache operation sources which are used to find the cache ... */new CompositeCacheOperationSource(...)cacheOperationSources.length/** Set the CacheOperationSource for this cache aspect. ... *//** Return the CacheOperationSource for this cache aspect. *//** Set the default {@link KeyGenerator} that this cache aspect should delegate to ... *//** Return the default {@link KeyGenerator} that this cache aspect delegates to. *//** Set the default {@link CacheResolver} that this cache aspect should delegate ... *//** Return the default {@link CacheResolver} that this cache aspect delegates to. *//** Set the {@link CacheManager} to use to create a default {@link CacheResolver}. ... */new SimpleCacheResolver(...)/** Set the containing {@link BeanFactory} for {@link CacheManager} and other ... */getCacheOperationSource(...)CacheManager.class/** Convenience method to return a String representation of this Method ... */Collection<? extends Cache> cachesresolveCaches(...)CacheOperationMetadata metadatagetCacheOperationMetadata(...)new CacheOperationContext(...)/** Return the {@link CacheOperationMetadata} for the specified operation. ... */CacheOperationCacheKey cacheKeynew CacheOperationCacheKey(...)this.metadataCacheKeyGenerator operationKeyGeneratorCacheResolver operationCacheResolverKeyGenerator.classCacheResolver.classCacheManager cacheManagernew CacheOperationMetadata(...)/** Return a bean with the specified name and type. Used to resolve services that ... *//** Clear the cached metadata. */this.evaluatorCacheOperationSource cacheOperationSourceCollection<CacheOperation> operationsnew CacheOperationContexts(...)/** Execute the underlying operation (typically in case of cache miss) and return ... */ValueWrapper cacheHitfindCachedItem(...)CacheableOperation.classList<CachePutRequest> cachePutRequestsnew ArrayList<CachePutRequest>(...)Object cacheValueisSynchronized(...)CacheOperationContext contextisConditionPassing(...)CacheOperationExpressionEvaluator.NO_RESULTgenerateKey(...)getCaches(...)wrapCacheValue(...)handleSynchronizedGet(...)ValueRetrievalException exCache.ValueRetrievalExceptionrethrowRuntimeException(...)invokeOperation(...)processCacheEvicts(...)CacheEvictOperation.classcollectPutRequests(...)hasCachePut(...)unwrapReturnValue(...)CachePutOperation.classCachePutRequest cachePutRequestInvocationAwareResult invocationResultnew InvocationAwareResult(...)invocationResult.invokedCollection<CacheOperationContext> cachePutContextsCollection<CacheOperationContext> excludednew ArrayList<CacheOperationContext>(...)CacheOperationExpressionEvaluator.RESULT_UNAVAILABLEVariableNotAvailableException exCacheEvictOperation operationcontext.metadata.operationcontext.metadataisBeforeInvocation(...)performCacheEvict(...)isCacheWide(...)logInvalidating(...)doClear(...)doEvict(...)context.metadata.method/** Find a cached item only for {@link CacheableOperation} that passes the condition. ... */ValueWrapper cachedfindInCaches(...)/** Collect the {@link CachePutRequest} for all {@link CacheOperation} using ... */new CachePutRequest(...)ValueWrapper wrapperdoGet(...)boolean passingMultiValueMap<Class<? extends CacheOperation>,CacheOperationContext> contexts, ...;boolean sync, ...;this.contextsnew LinkedMultiValueMap<Class<? extends CacheOperation>,CacheOperationContext>(...)CacheOperation opgetOperationContext(...)this.syncdetermineSyncFlag(...)Collection<CacheOperationContext> resultList<CacheOperationContext> cacheOperationContextsboolean syncEnabledCacheOperationContext cacheOperationContextisSync(...)CacheableOperation operationgetUnless(...)/** Metadata of a cache operation that does not depend on a particular invocation ... */CacheOperation operation, ...;Method targetMethod, ...;AnnotatedElementKey methodKey, ...;KeyGenerator keyGenerator, ...;CacheResolver cacheResolver, ...;this.operationthis.targetMethodthis.methodKeynew AnnotatedElementKey(...)/** A {@link CacheOperationInvocationContext} context for a {@link CacheOperation}. */CacheOperationMetadata metadata, ...;Collection<? extends Cache> caches, ...;Collection<String> cacheNames, ...;Boolean conditionPassing, ...;extractArgs(...)metadata.methodCacheAspectSupport.thismetadata.cacheResolvercreateCacheNames(...)this.metadata.operationthis.metadata.methodObject[] varArgsObject[] combinedArgsvarArgs.lengththis.conditionPassinggetCondition(...)EvaluationContext evaluationContextcreateEvaluationContext(...)this.metadata.methodKeyString unless/** Compute the key for the given caching operation. */generate(...)this.metadata.keyGeneratorthis.metadata.targetClassthis.metadata.targetMethodCollection<String> namesCacheOperationContext context, ...;this.contextcanPutToCache(...)doPut(...)CacheOperation cacheOperation, ...;AnnotatedElementKey methodCacheKey, ...;this.cacheOperationthis.methodCacheKeyCacheOperationCacheKey otherKeyotherKey.cacheOperationotherKey.methodCacheKeyother.cacheOperationother.methodCacheKey/** Internal holder class for recording that a cache method was invoked. */boolean invoked, ...;// Lazily initialize cache resolver via default cache manager...// Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically)// Special handling of synchronized invocation// Directly propagate ThrowableWrapper from the invoker,// or potentially also an IllegalArgumentException etc.// No caching required, only call the underlying method// Process any early evictions// Check if we have a cached item matching the conditions// Collect puts from any @Cacheable miss, if no cached item is found// If there are no put requests, just use the cache hit// Invoke the method if we don't have a cache hit// Collect any explicit @CachePuts// Process any collected put requests, either from @CachePut or a @Cacheable miss// Process any late evictions// Evaluate the conditions *without* the result object because we don't have it yet...// Ignoring failure due to missing result, consider the cache put has to proceed// Check if all puts have been excluded by condition// no @Cacheable operation at all/** A strategy for handling cache-related errors. In most cases, any ... *//** Handle the given runtime exception thrown by the cache provider when ... */import MethodBasedEvaluationContext/** Cache specific evaluation context that adds a method parameters as SpEL ... */Set<String> unavailableVariables, ...;/** Add the specified variable name as unavailable for that context. ... */this.unavailableVariables/** Load the param information only when needed. */new VariableNotAvailableException(...)lookupVariable(...)/** Class describing a cache 'evict' operation. ... */boolean cacheWide, ...;boolean beforeInvocation, ...;/** Create a new {@link CacheEvictOperation} instance from the given builder. ... */this.cacheWideb.cacheWidethis.beforeInvocationb.beforeInvocation/** A builder that can be used to create a {@link CacheEvictOperation}. ... */getOperationDescription(...)new CacheEvictOperation(...)/** Class describing the root object used during the expression evaluation. ... *//** AOP Alliance MethodInterceptor for declarative cache ... */CacheOperationInvoker aopAllianceInvokernew CacheOperationInvoker(...) { ... }new ThrowableWrapper(...)CacheOperationInvoker.ThrowableWrapperThrowableWrapper thgetOriginal(...)/** Base class for cache operations. ... */Set<String> cacheNames, ...;String toString, ...;/** Create a new {@link CacheOperation} instance from the given builder. ... */b.nameb.cacheNamesb.keyb.keyGeneratorb.cacheManagerb.cacheResolverb.conditionthis.toString/** This implementation compares the {@code toString()} results. ... *//** This implementation returns {@code toString()}'s hash code. ... *//** Return an identifying description for this cache operation. ... *//** Base class for builders that can be used to create a {@link CacheOperation}. ... */cacheNames.length/** Return an identifying description for this caching operation. ... */StringBuilder resultimport BeanFactoryResolverimport CachedExpressionEvaluatorimport Expression/** Utility class handling the SpEL expression parsing. ... */new ConcurrentHashMap<ExpressionKey,Expression>(...)Object NO_RESULT, ...;/** Indicate that there is no result variable. */Object RESULT_UNAVAILABLE, ...;/** Indicate that the result variable cannot be used at all. */String RESULT_VARIABLE, ...;/** The name of the variable holding the result object. */Map<ExpressionKey,Expression> keyCache, ...;Map<ExpressionKey,Expression> conditionCache, ...;Map<ExpressionKey,Expression> unlessCache, ...;/** Create an {@link EvaluationContext}. ... */CacheExpressionRootObject rootObjectnew CacheExpressionRootObject(...)CacheEvaluationContext evaluationContextnew CacheEvaluationContext(...)addUnavailableVariable(...)setBeanResolver(...)new BeanFactoryResolver(...)this.keyCachethis.conditionCachethis.unlessCache/** Clear all caches. *//** Representation of the context of the invocation of a cache operation. ... *//** Return the cache operation. *//** Return the target instance on which the method was invoked. *//** Return the method which was invoked. *//** Return the argument list used to invoke the method. *//** Abstract the invocation of a cache operation. ... *//** Invoke the cache operation defined by this instance. Wraps any exception ... *//** Wrap any exception thrown while invoking {@link #invoke()}. */Throwable original, ...;this.original/** Interface used by {@link CacheInterceptor}. Implementations know how to source ... *//** Return the collection of cache operations for this method, ... */import StaticMethodMatcherPointcut/** A Pointcut that matches if the underlying {@link CacheOperationSource} ... */new CacheOperationSourceClassFilter(...)CacheOperationSource casCacheOperationSourcePointcut otherPcCacheOperationSourcePointcut.class/** Obtain the underlying {@link CacheOperationSource} (may be {@code null}). ... *//** {@link ClassFilter} that delegates to {@link CacheOperationSource#isCandidateClass} ... */import AbstractSingletonProxyFactoryBean/** Proxy factory bean for simplified declarative caching handling. ... */CacheInterceptor cacheInterceptor, ...;/** Set one or more sources to find cache operations. ... */setCacheOperationSources(...)this.cacheInterceptor/** Set a pointcut, i.e. a bean that triggers conditional invocation of the ... *//** Class describing a cache 'put' operation. ... */String unless, ...;/** Create a new {@link CachePutOperation} instance from the given builder. ... */this.unlessb.unless/** A builder that can be used to create a {@link CachePutOperation}. ... */new CachePutOperation(...)/** Determine the {@link Cache} instance(s) to use for an intercepted method invocation. ... *//** Return the cache(s) to use for the specified invocation. ... *//** Class describing a cache 'cacheable' operation. ... *//** Create a new {@link CacheableOperation} instance from the given builder. ... */b.sync/** A builder that can be used to create a {@link CacheableOperation}. ... */new CacheableOperation(...)/** Composite {@link CacheOperationSource} implementation that iterates ... */...[] cacheOperationSources, ...;/** Create a new CompositeCacheOperationSource for the given sources. ... */this.cacheOperationSources/** Return the {@code CacheOperationSource} instances that this ... */CacheOperationSource sourceCollection<CacheOperation> cacheOperations/** Cache key generator. Used for creating a key based on the given method ... *//** Generate a key for the given method and its parameters. ... *//** Simple {@link CacheOperationSource} implementation that allows attributes to be matched ... */new LinkedHashMap<String,Collection<CacheOperation>>(...)Map<String,Collection<CacheOperation>> nameMap, ...;/** Keys are method names; values are TransactionAttributes. *//** Set a name/attribute map, consisting of method names ... */new BiConsumer<String,Collection<CacheOperation>>(...) { ... }addCacheMethod(...)/** Add an attribute for a cacheable method. ... */this.nameMapString bestNameMatchNameMatchCacheOperationSource otherTasotherTas.nameMap// look for direct name match// Look for most specific name match./** A {@link CacheResolver} that forces the resolution to a configurable ... *//** Set the cache name(s) that this resolver should use. *//** A simple {@link CacheErrorHandler} that does not handle the ... *//** A simple {@link CacheResolver} that resolves the {@link Cache} instance(s) ... *//** Construct a new {@code SimpleCacheResolver}. ... *//** Construct a new {@code SimpleCacheResolver} for the given {@link CacheManager}. ... *//** Return a {@code SimpleCacheResolver} for the given {@link CacheManager}. ... *//** A simple key as returned from the {@link SimpleKeyGenerator}. ... */new SimpleKey(...)SimpleKey EMPTY, ...;/** An empty key. */...[] params, ...;// Effectively final, just re-calculated on deserialization/** Create a new {@link SimpleKey} instance. ... */this.paramsdeepHashCode(...)deepEquals(...)(...).params// Pre-calculate hashCode field// Expose pre-calculated hashCode field// Re-calculate hashCode field on deserialization/** Simple key generator. Returns the parameter itself if a single non-null ... *//** Generate a key based on the specified parameters. */SimpleKey.EMPTYObject paramimport EvaluationException/** A specific {@link EvaluationException} to mention that a given variable ... *//** AOP-based solution for declarative caching demarcation. ... *//** Spring's generic cache abstraction. ... *//** Abstract base class implementing the common {@link CacheManager} methods. ... */// Early cache initialization on startupinitializeCaches(...)/** Initialize the static configuration of caches. ... */loadCaches(...)Set<String> cacheNamesdecorateCache(...)/** Load the initial caches for this cache manager. ... */// Lazy cache initialization on accessCache missingCachegetMissingCache(...)updateCacheNames(...)/** Check for a registered cache of the given name. ... */// Common cache initialization delegates for subclasses/** Dynamically register an additional Cache with this manager. ... *//** Update the exposed {@link #cacheNames} set with the given name. ... *//** Decorate the given Cache object if necessary. ... */// Overridable template methods for cache initialization/** Return a missing cache with the specified {@code name}, or {@code null} if ... */// Quick check for existing cache...// The provider may support on-demand cache creation...// Fully synchronize now for missing cache registration/** Common base class for {@link Cache} implementations that need to adapt ... *//** Create an {@code AbstractValueAdaptingCache} with the given setting. ... *//** Return whether {@code null} values are allowed in this cache. */lookup(...)/** Perform an actual lookup in the underlying store. ... *//** Convert the given value from the internal store to a user value ... */NullValue.INSTANCE/** Convert the given user value, as passed into the put method, ... *//** Wrap the given store value with a {@link SimpleValueWrapper}, also going ... */new SimpleValueWrapper(...)/** Composite {@link CacheManager} implementation that iterates over ... */new ArrayList<CacheManager>(...)List<CacheManager> cacheManagers, ...;boolean fallbackToNoOpCache, ...;/** Construct an empty CompositeCacheManager, with delegate CacheManagers to ... *//** Construct a CompositeCacheManager from the given delegate CacheManagers. ... */setCacheManagers(...)/** Specify the CacheManagers to delegate to. */this.cacheManagers/** Indicate whether a {@link NoOpCacheManager} should be added at the end of the delegate list. ... */this.fallbackToNoOpCacheSet<String> namesCacheManager manager/** A no operation {@link Cache} implementation suitable for disabling caching. ... *//** Create a {@link NoOpCache} instance with the specified name. ... *//** A basic, no operation {@link CacheManager} implementation suitable ... */ConcurrentMap<String,Cache> caches, ...;/** This implementation always returns a {@link Cache} implementation that will not store items. ... */new Function<String,Cache>(...) { ... }new NoOpCache(...)/** This implementation returns the name of the caches previously requested. *//** Simple serializable class that serves as a {@code null} replacement ... */new NullValue(...)/** The canonical representation of a {@code null} replacement, as used by the ... */NullValue.class/** Simple cache manager working against a given collection of caches. ... *//** Specify the collection of Cache instances to use for this CacheManager. ... */import ValueWrapper/** Straightforward implementation of {@link org.springframework.cache.Cache.ValueWrapper}, ... *//** Create a new SimpleValueWrapper instance for exposing the given value. ... *//** Simply returns the value as given at construction time. *//** Support classes for the org.springframework.cache package. ... *//** Central interface to provide configuration for an application. ... *//** Return the unique id of this application context. ... *//** Return a name for the deployed application that this context belongs to. ... *//** Return a friendly name for this context. ... *//** Return the timestamp when this context was first loaded. ... *//** Return the parent context, or {@code null} if there is no parent ... *//** Expose AutowireCapableBeanFactory functionality for this context. ... *//** Interface to be implemented by any object that wishes to be notified ... *//** Set the ApplicationContext that this object runs in. ... *//** Exception thrown during application context initialization. ... *//** Create a new {@code ApplicationContextException} ... *//** Callback interface for initializing a Spring {@link ConfigurableApplicationContext} ... *//** Initialize the given application context. ... */import EventObject/** Class to be extended by all application events. Abstract as it ... */long timestamp, ...;/** System time when the event happened. *//** Create a new {@code ApplicationEvent}. ... */this.timestamp/** Return the system time in milliseconds when the event occurred. *//** Interface that encapsulates event publication functionality. ... *//** Notify all <strong>matching</strong> listeners registered with this ... */publishEvent(...)/** Set the ApplicationEventPublisher that this object runs in. ... *//** Interface to be implemented by application event listeners. ... *//** Handle an application event. ... *//** Create a new {@code ApplicationListener} for the given payload consumer. ... */new ApplicationListener<PayloadApplicationEvent<T>>(...) { ... }getPayload(...)/** Set the ApplicationStartup that this object runs with. ... */import ProtocolResolver/** SPI interface to be implemented by most if not all application contexts. ... */String CONFIG_LOCATION_DELIMITERS, ...;/** Any number of these characters are considered delimiters between ... */String CONVERSION_SERVICE_BEAN_NAME, ...;/** Name of the ConversionService bean in the factory. ... */String LOAD_TIME_WEAVER_BEAN_NAME, ...;/** Name of the LoadTimeWeaver bean in the factory. If such a bean is supplied, ... */String ENVIRONMENT_BEAN_NAME, ...;/** Name of the {@link Environment} bean in the factory. ... */String SYSTEM_PROPERTIES_BEAN_NAME, ...;/** Name of the System properties bean in the factory. ... */String SYSTEM_ENVIRONMENT_BEAN_NAME, ...;/** Name of the System environment bean in the factory. ... */String APPLICATION_STARTUP_BEAN_NAME, ...;/** Name of the {@link ApplicationStartup} bean in the factory. ... */String SHUTDOWN_HOOK_THREAD_NAME, ...;/** {@link Thread#getName() Name} of the {@linkplain #registerShutdownHook() ... *//** Set the unique id of this application context. ... *//** Set the parent of this application context. ... *//** Set the {@code Environment} for this application context. ... *//** Return the {@code Environment} for this application context in configurable ... *//** Set the {@link ApplicationStartup} for this application context. ... *//** Return the {@link ApplicationStartup} for this application context. ... *//** Add a new BeanFactoryPostProcessor that will get applied to the internal ... *//** Add a new ApplicationListener that will be notified on context events ... *//** Specify the ClassLoader to load class path resources and bean classes with. ... *//** Register the given protocol resolver with this application context, ... *//** Load or refresh the persistent representation of the configuration, which ... *//** Register a shutdown hook with the JVM runtime, closing this context ... *//** Close this application context, releasing all resources and locks that the ... *//** Determine whether this application context is active, that is, ... *//** Return the internal bean factory of this application context. ... *//** Interface to be implemented by any object that wishes to be notified of a ... *//** Set the StringValueResolver to use for resolving embedded definition values. *//** Interface to be implemented by any bean that wishes to be notified ... *//** Set the {@code Environment} that this component runs in. *//** Sub-interface of MessageSource to be implemented by objects that ... *//** Set the parent that will be used to try to resolve messages ... *//** Return the parent of this MessageSource, or {@code null} if none. *//** A common interface defining methods for start/stop lifecycle control. ... *//** Start this component. ... *//** Stop this component, typically in a synchronous fashion, such that the component is ... *//** Check whether this component is currently running. ... *//** Strategy interface for processing Lifecycle beans within the ApplicationContext. ... *//** Notification of context refresh, e.g. for auto-starting components. *//** Notification of context close phase, e.g. for auto-stopping components. *//** Strategy interface for resolving messages, with support for the parameterization ... *//** Try to resolve the message. Return default message if no message was found. ... *//** Try to resolve the message. Treat as an error if the message can't be found. ... *//** Try to resolve the message using all the attributes contained within the ... *//** Set the MessageSource that this object runs in. ... *//** Interface for objects that are suitable for message resolution in a ... *//** Return the codes to be used to resolve this message, in the order that ... *//** Return the array of arguments to be used to resolve this message. ... *//** Return the default message to be used to resolve this message. ... *//** Exception thrown when a message can't be resolved. ... *//** Create a new exception. ... */getDefault(...)import ResolvableTypeProvider/** An {@link ApplicationEvent} that carries an arbitrary payload. ... */T payload, ...;/** Create a new PayloadApplicationEvent. ... */this.payloadforInstance(...)/** Return the payload of the event. *//** Interface for objects that may participate in a phased ... *//** Return the phase value of this object. *//** Interface to be implemented by any object that wishes to be notified of the ... *//** Set the ResourceLoader that this object runs in. ... *//** An extension of the {@link Lifecycle} interface for those objects that require ... */int DEFAULT_PHASE, ...;/** The default phase for {@code SmartLifecycle}: {@code Integer.MAX_VALUE}. ... *//** Returns {@code true} if this {@code Lifecycle} component should get ... *//** Indicates that a Lifecycle component must stop if it is currently running. ... */run(...)/** Return the phase that this lifecycle object is supposed to run in. ... *//** Enumeration used to determine whether JDK proxy-based or ... */new AdviceMode(...)AdviceMode PROXY, ...;/** JDK proxy-based advice. */AdviceMode ASPECTJ, ...;/** AspectJ weaving-based advice. *//** Convenient base class for {@link ImportSelector} implementations that select imports ... */String DEFAULT_ADVICE_MODE_ATTRIBUTE_NAME, ...;/** The default advice mode attribute name. *//** The name of the {@link AdviceMode} attribute for the annotation specified by the ... *//** This implementation resolves the type of annotation from generic metadata and ... */Class<?> annTyperesolveTypeArgument(...)AdviceModeImportSelector<>.classAnnotationAttributes attributesattributesFor(...)AdviceMode adviceModegetEnum(...)getAdviceModeAttributeName(...)String[] importsselectImports(...)/** Determine which classes should be imported based on the given {@code AdviceMode}. ... */import AnnotatedGenericBeanDefinitionimport BeanNameGenerator/** Convenient adapter for programmatic registration of bean classes. ... */AnnotationBeanNameGenerator.INSTANCEnew AnnotationScopeMetadataResolver(...)ScopeMetadataResolver scopeMetadataResolver, ...;ConditionEvaluator conditionEvaluator, ...;/** Create a new {@code AnnotatedBeanDefinitionReader} for the given registry. ... */getOrCreateEnvironment(...)/** Create a new {@code AnnotatedBeanDefinitionReader} for the given registry, ... */this.conditionEvaluatornew ConditionEvaluator(...)registerAnnotationConfigProcessors(...)/** Get the BeanDefinitionRegistry that this reader operates on. *//** Set the {@code Environment} to use when evaluating whether ... *//** Set the {@code BeanNameGenerator} to use for detected bean classes. ... *//** Set the {@code ScopeMetadataResolver} to use for registered component classes. ... */this.scopeMetadataResolver/** Register one or more component classes to be processed. ... */Class<?> componentClassregisterBean(...)/** Register a bean from the given bean class, deriving its metadata from ... */doRegisterBean(...)AnnotatedGenericBeanDefinition abdnew AnnotatedGenericBeanDefinition(...)ScopeMetadata scopeMetadataresolveScopeMetadata(...)BeanDefinitionHolder definitionHoldergetScopeName(...)processCommonDefinitionAnnotations(...)Class<? extends Annotation> qualifierPrimary.classLazy.classapplyScopedProxyMode(...)/** Get the Environment from the given registry if possible, otherwise return a new ... *//** {@link BeanNameGenerator} implementation for bean classes annotated with the ... */new AnnotationBeanNameGenerator(...)AnnotationBeanNameGenerator INSTANCE, ...;/** A convenient constant for a default {@code AnnotationBeanNameGenerator} instance, ... */String COMPONENT_ANNOTATION_CLASSNAME, ...;Map<String,Set<String>> metaAnnotationTypesCache, ...;determineBeanNameFromAnnotation(...)buildDefaultBeanName(...)/** Derive a bean name from one of the annotations on the class. ... */AnnotationMetadata amdSet<String> typesSet<String> metaTypesthis.metaAnnotationTypesCacheisStereotypeWithNameValue(...)/** Check whether the given annotation is a stereotype that is allowed ... */boolean isStereotype/** Derive a default bean name from the given bean definition. ... */String shortClassName// Explicit bean name found.// Fallback: generate a unique default bean name./** Standalone application context, accepting <em>component classes</em> as input &mdash; ... */AnnotatedBeanDefinitionReader reader, ...;ClassPathBeanDefinitionScanner scanner, ...;/** Create a new AnnotationConfigApplicationContext that needs to be populated ... */StartupStep createAnnotatedBeanDefReaderthis.scanner/** Create a new AnnotationConfigApplicationContext with the given DefaultListableBeanFactory. ... *//** Create a new AnnotationConfigApplicationContext, deriving bean definitions ... *//** Create a new AnnotationConfigApplicationContext, scanning for components ... *//** Propagate the given custom {@code Environment} to the underlying ... *//** Provide a custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader} ... */AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR/** Set the {@link ScopeMetadataResolver} to use for registered component classes. ... */// Implementation of AnnotationConfigRegistryStartupStep registerComponentClass/** Perform a scan within the specified base packages. ... */StartupStep scanPackages// Adapt superclass registerBean calls to AnnotatedBeanDefinitionReader/** Parser for the &lt;context:annotation-config/&gt; element. ... */Set<BeanDefinitionHolder> processorDefinitionsCompositeComponentDefinition compDefinitionBeanDefinitionHolder processorDefinition// Obtain bean definitions for all relevant BeanPostProcessors.// Register component for the surrounding <context:annotation-config> element.// Nest the concrete beans in the surrounding component.// Finally register the composite component./** Common interface for annotation config application contexts, ... */import AutowiredAnnotationBeanPostProcessorimport DefaultEventListenerFactoryimport EventListenerMethodProcessorimport AnnotatedTypeMetadata/** Utility class that allows for convenient registration of common ... */AnnotationConfigUtils.classString CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME, ...;/** The bean name of the internally managed Configuration annotation processor. */String CONFIGURATION_BEAN_NAME_GENERATOR, ...;/** The bean name of the internally managed BeanNameGenerator for use when processing ... */String AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME, ...;/** The bean name of the internally managed Autowired annotation processor. */String REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME, ...;/** The bean name of the internally managed Required annotation processor. ... */String COMMON_ANNOTATION_PROCESSOR_BEAN_NAME, ...;/** The bean name of the internally managed JSR-250 annotation processor. */String PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME, ...;/** The bean name of the internally managed JPA annotation processor. */String PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ...;String EVENT_LISTENER_PROCESSOR_BEAN_NAME, ...;/** The bean name of the internally managed @EventListener annotation processor. */String EVENT_LISTENER_FACTORY_BEAN_NAME, ...;/** The bean name of the internally managed EventListenerFactory. */boolean jsr250Present, ...;boolean jpaPresent, ...;/** Register all relevant annotation post processors in the given registry. ... */unwrapDefaultListableBeanFactory(...)Set<BeanDefinitionHolder> beanDefsnew LinkedHashSet<BeanDefinitionHolder>(...)new ContextAnnotationAutowireCandidateResolver(...)ConfigurationClassPostProcessor.classregisterPostProcessor(...)CommonAnnotationBeanPostProcessor.classEventListenerMethodProcessor.classDefaultEventListenerFactory.classgetDefaultListableBeanFactory(...)AnnotationAttributes lazyAnnotationAttributes dependsOnDependsOn.classAnnotationAttributes roleRole.classAnnotationAttributes descriptionDescription.classisAnnotated(...)ScopedProxyMode scopedProxyModegetScopedProxyMode(...)attributesForRepeatable(...)Set<AnnotationAttributes> resultnew LinkedHashSet<AnnotationAttributes>(...)Map<String,Object> containeraddAttributesIfNotNull(...)Map<String,Object> containedAttributes// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.// Direct annotation present?// Container annotation present?// Return merged result/** A {@link ScopeMetadataResolver} implementation that by default checks for ... */ScopedProxyMode defaultProxyMode, ...;Class<? extends Annotation> scopeAnnotationType, ...;/** Construct a new {@code AnnotationScopeMetadataResolver}. ... */this.defaultProxyMode/** Construct a new {@code AnnotationScopeMetadataResolver} using the ... *//** Set the type of annotation that is checked for by this ... */this.scopeAnnotationTypeScopedProxyMode proxyModeScopedProxyMode.DEFAULT/** Registers an {@link org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator ... *//** Register, escalate, and configure the AspectJ auto proxy creator based on the value ... */AnnotationAttributes enableAspectJAutoProxyEnableAspectJAutoProxy.class/** Registers an auto proxy creator against the current {@link BeanDefinitionRegistry} ... *//** Register, escalate, and configure the standard auto proxy creator (APC) against the ... */boolean candidateFoundSet<String> annTypesString annTypeAnnotationAttributes candidateObject modeObject proxyTargetClassAdviceMode.classAdviceMode.PROXY/** Indicates that a method produces a bean to be managed by the Spring container. ... *//** Alias for {@link #name}. ... *//** The name of this bean, or if several names, a primary bean name plus aliases. ... *//** Are dependencies to be injected via convention-based autowiring by name or type? ... *//** Is this bean a candidate for getting autowired into some other bean? ... *//** The optional name of a method to call on the bean instance during initialization. ... *//** The optional name of a method to call on the bean instance upon closing the ... *//** Utilities for processing {@link Bean}-annotated methods. ... */new ConcurrentReferenceHashMap<Method,String>(...)new ConcurrentReferenceHashMap<Method,Boolean>(...)Map<Method,String> beanNameCache, ...;Map<Method,Boolean> scopedProxyCache, ...;AnnotationAttributes beanfindMergedAnnotationAttributes(...)Boolean scopedProxyAnnotationAttributes scope// By default, the bean name is the name of the @Bean-annotated method// Check to see if the user has explicitly set a custom bean name.../** Represents a {@link Configuration @Configuration} class method marked with the ... */this.configurationClassConfiguration.classisOverridable(...)new NonOverridableMethodError(...)getResourceLocation(...)// static @Bean methods have no constraints to validate -> return immediately// instance @Bean methods within @Configuration classes must be overridable to accommodate CGLIB/** A bean definition scanner that detects bean candidates on the classpath, ... */BeanDefinitionDefaults beanDefinitionDefaults, ...;...[] autowireCandidatePatterns, ...;boolean includeAnnotationConfig, ...;/** Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory. ... *//** Create a new {@code ClassPathBeanDefinitionScanner} for the given bean factory and ... */registerDefaultFilters(...)setResourceLoader(...)/** Return the BeanDefinitionRegistry that this scanner operates on. *//** Set the defaults to use for detected beans. ... */this.beanDefinitionDefaults/** Return the defaults to use for detected beans (never {@code null}). ... *//** Set the name-matching patterns for determining autowire candidates. ... */this.autowireCandidatePatterns/** Set the BeanNameGenerator to use for detected bean classes. ... *//** Set the ScopeMetadataResolver to use for detected bean classes. ... *//** Specify the proxy behavior for non-singleton scoped beans. ... *//** Specify whether to register annotation config post-processors. ... */this.includeAnnotationConfigint beanCountAtScanStartdoScan(...)/** Perform a scan within the specified base packages, ... */Set<BeanDefinitionHolder> beanDefinitionsString basePackageSet<BeanDefinition> candidatesfindCandidateComponents(...)BeanDefinition candidatepostProcessBeanDefinition(...)checkCandidate(...)/** Apply further settings to the given bean definition, ... */applyDefaults(...)/** Register the specified bean with the given registry. ... *//** Check the given candidate's bean name, determining whether the corresponding ... */BeanDefinition existingDefBeanDefinition originatingDefisCompatible(...)new ConflictingBeanDefinitionException(...)/** Determine whether the given new bean definition is compatible with ... */// Register annotation config processors, if necessary.// explicitly registered overriding bean// scanned same file twice// scanned equivalent class twiceimport Lookupimport ResourceLoaderAwareimport CandidateComponentsIndeximport CandidateComponentsIndexLoaderimport CachingMetadataReaderFactoryimport MetadataReaderimport MetadataReaderFactoryimport AnnotationTypeFilterimport AssignableTypeFilterimport TypeFilterimport Controllerimport Indexedimport Service/** A component provider that provides candidate components from a base package. Can ... */new ArrayList<TypeFilter>(...)String DEFAULT_RESOURCE_PATTERN, ...;String resourcePattern, ...;List<TypeFilter> includeFilters, ...;List<TypeFilter> excludeFilters, ...;ResourcePatternResolver resourcePatternResolver, ...;MetadataReaderFactory metadataReaderFactory, ...;CandidateComponentsIndex componentsIndex, ...;/** Protected constructor for flexible subclass initialization. ... *//** Create a ClassPathScanningCandidateComponentProvider with a {@link StandardEnvironment}. ... *//** Create a ClassPathScanningCandidateComponentProvider with the given {@link Environment}. ... *//** Set the resource pattern to use when scanning the classpath. ... */this.resourcePattern/** Add an include type filter to the <i>end</i> of the inclusion list. */this.includeFilters/** Add an exclude type filter to the <i>front</i> of the exclusion list. */this.excludeFilters/** Reset the configured type filters. ... *//** Register the default filter for {@link Component @Component}. ... */ClassPathScanningCandidateComponentProvider.classnew AnnotationTypeFilter(...)/** Set the Environment to use when resolving placeholders and evaluating ... *//** Return the {@link BeanDefinitionRegistry} used by this scanner, if any. *//** Set the {@link ResourceLoader} to use for resource locations. ... */this.resourcePatternResolvergetResourcePatternResolver(...)this.metadataReaderFactorynew CachingMetadataReaderFactory(...)this.componentsIndexloadIndex(...)/** Return the ResourceLoader that this component provider uses. *//** Set the {@link MetadataReaderFactory} to use. ... *//** Return the MetadataReaderFactory used by this component provider. *//** Scan the class path for candidate components. ... */indexSupportsIncludeFilters(...)addCandidateComponentsFromIndex(...)scanCandidateComponents(...)/** Determine if the index can be used by this instance. ... */TypeFilter includeFilterindexSupportsIncludeFilter(...)/** Determine if the specified include {@link TypeFilter} is supported by the index. ... */Class<? extends Annotation> annotationisAnnotationDeclaredLocally(...)Indexed.classClass<?> target/** Extract the stereotype to use for the specified compatible filter. ... */new LinkedHashSet<BeanDefinition>(...)boolean traceEnabledboolean debugEnabledTypeFilter filterString stereotypeextractStereotype(...)getCandidateTypes(...)MetadataReader metadataReadergetMetadataReader(...)getMetadataReaderFactory(...)isCandidateComponent(...)ScannedGenericBeanDefinition sbdnew ScannedGenericBeanDefinition(...)String packageSearchPathResourcePatternResolver.CLASSPATH_ALL_URL_PREFIXresolveBasePackage(...)/** Resolve the specified base package into a pattern specification for ... */convertClassNameToResourcePath(...)/** Determine whether the given class does not match any exclude filter ... */TypeFilter tfmatch(...)isConditionMatch(...)/** Determine whether the given class is a candidate component based on any ... */getAnnotationMetadata(...)/** Determine whether the given bean definition qualifies as candidate. ... */AnnotationMetadata metadataisIndependent(...)isConcrete(...)hasAnnotatedMethods(...)/** Clear the local metadata cache, if any, removing all cached class metadata. */clearCache(...)// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.// Clear cache in externally provided MetadataReaderFactory; this is a no-op// for a shared cache since it'll be cleared by the ApplicationContext.import PostConstructimport PreDestroyimport EJBimport QNameimport WebServiceClientimport WebServiceRefimport InitDestroyAnnotationBeanPostProcessorimport InjectionMetadataimport EmbeddedValueResolverimport SimpleJndiBeanFactorynew SimpleJndiBeanFactory(...)loadAnnotationType(...)Class<? extends Annotation> webServiceRefClass, ...;Class<? extends Annotation> ejbClass, ...;Set<Class<? extends Annotation>> resourceAnnotationTypes, ...;Set<String> ignoredResourceTypes, ...;boolean fallbackToDefaultTypeMatch, ...;boolean alwaysUseJndiLookup, ...;BeanFactory jndiFactory, ...;BeanFactory resourceFactory, ...;StringValueResolver embeddedValueResolver, ...;/** Create a new CommonAnnotationBeanPostProcessor, ... */setInitAnnotationType(...)PostConstruct.classsetDestroyAnnotationType(...)PreDestroy.classignoreResourceType(...)/** Ignore the given resource type when resolving {@code @Resource} ... */this.ignoredResourceTypes/** Set whether to allow a fallback to a type match if no explicit name has been ... */this.fallbackToDefaultTypeMatch/** Set whether to always use JNDI lookups equivalent to standard Java EE 5 resource ... */this.alwaysUseJndiLookup/** Specify the factory for objects to be injected into {@code @Resource} / ... */this.jndiFactorythis.resourceFactorythis.embeddedValueResolvernew EmbeddedValueResolver(...)findResourceMetadata(...)buildResourceMetadata(...)new WebServiceRefElement(...)new EjbRefElement(...)new ResourceElement(...)/** Obtain a lazily resolving resource proxy for the given name and type, ... */new TargetSource(...) { ... }element.lookupType/** Obtain the resource object for the given name and type. ... */element.mappedNameelement.nameautowireResource(...)/** Obtain a resource object for the given name and type through autowiring ... */Object resourcegetDependencyDescriptor(...)element.isDefaultNamegetLookupType(...)resolveBeanByName(...)ConfigurableBeanFactory beanFactory/** Class representing generic injection information about an annotated field ... */boolean isDefaultName, ...;Class<?> lookupType, ...;String mappedName, ...;/** Return the resource name for the lookup. *//** Return the desired type for the lookup. */this.lookupType/** Build a DependencyDescriptor for the underlying field/method. */new LookupDependencyDescriptor(...)/** Class representing injection information about an annotated field ... */boolean lazyLookup, ...;String resourceNameClass<?> resourceTypetype(...)String lookupValueLazy lazythis.isDefaultNamecheckResourceType(...)getResourceType(...)this.mappedNamemappedName(...)this.lazyLookupbuildLazyResourceProxy(...)Class<?> elementType, ...;String wsdlLocation, ...;WebServiceRef resourceWebServiceRef.classthis.elementTypeService.classthis.wsdlLocationwsdlLocation(...)Service serviceNoSuchBeanDefinitionException notFoundQName.classWebServiceClient clientAnnWebServiceClient.classnew QName(...)targetNamespace(...)MalformedURLException exgetPort(...)EJB resourceEJB.classString resourceBeanNamebeanName(...)beanInterface(...)/** Extension of the DependencyDescriptor class, ... */// No resource type specified... check field/method.// Service to be created through generated class.// Local match found for explicitly specified local bean name.// JNDI name lookup - may still go to a local BeanFactory.import Repeatable/** Configures component scanning directives for use with @{@link Configuration} classes. ... */ComponentScans.class/** Alias for {@link #basePackages}. ... *//** Base packages to scan for annotated components. ... *//** Type-safe alternative to {@link #basePackages} for specifying the packages ... *//** The {@link BeanNameGenerator} class to be used for naming detected components ... *//** The {@link ScopeMetadataResolver} to be used for resolving the scope of detected components. *//** Indicates whether proxies should be generated for detected components, which may be ... *//** Controls the class files eligible for component detection. ... *//** Indicates whether automatic detection of classes annotated with {@code @Component} ... *//** Specifies which types are eligible for component scanning. ... *//** Specifies which types are not eligible for component scanning. ... *//** Specify whether scanned beans should be registered for lazy initialization. ... *//** Declares the type filter to be used as an {@linkplain ComponentScan#includeFilters ... *//** The type of filter to use. ... *//** Alias for {@link #classes}. ... *//** The class or classes to use as the filter. ... *//** The pattern (or patterns) to use for the filter, as an alternative ... */import AbstractTypeHierarchyTraversingFilterimport AspectJTypeFilterimport RegexPatternTypeFilter/** Parser for the @{@link ComponentScan} annotation. ... */Class<? extends BeanNameGenerator> generatorClassboolean useInheritedGeneratorBeanNameGenerator.classSet<String> basePackagesString[] basePackagesArrayClass<? extends ScopeMetadataResolver> resolverClasssetResourcePattern(...)AnnotationAttributes filtergetAnnotationArray(...)TypeFilter typeFiltertypeFiltersFor(...)addIncludeFilter(...)addExcludeFilter(...)getBeanDefinitionDefaults(...)String pkgString[] tokenizedConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERSgetPackageName(...)new AbstractTypeHierarchyTraversingFilter(...) { ... }List<TypeFilter> typeFiltersFilterType filterTypeClass<?> filterClassClass<Annotation> annotationTypeTypeFilter.classnew AssignableTypeFilter(...)new AspectJTypeFilter(...)new RegexPatternTypeFilter(...)/** Parser for the {@code <context:component-scan/>} element. ... */String BASE_PACKAGE_ATTRIBUTE, ...;String RESOURCE_PATTERN_ATTRIBUTE, ...;String USE_DEFAULT_FILTERS_ATTRIBUTE, ...;String ANNOTATION_CONFIG_ATTRIBUTE, ...;String NAME_GENERATOR_ATTRIBUTE, ...;String SCOPE_RESOLVER_ATTRIBUTE, ...;String SCOPED_PROXY_ATTRIBUTE, ...;String EXCLUDE_FILTER_ELEMENT, ...;String INCLUDE_FILTER_ELEMENT, ...;String FILTER_TYPE_ATTRIBUTE, ...;String FILTER_EXPRESSION_ATTRIBUTE, ...;String[] basePackagesconfigureScanner(...)registerComponents(...)boolean useDefaultFilterscreateScanner(...)setBeanDefinitionDefaults(...)setAutowireCandidatePatterns(...)getAutowireCandidatePatterns(...)parseBeanNameGenerator(...)parseScope(...)parseTypeFilters(...)boolean annotationConfigBeanDefinitionHolder beanDefHolderBeanNameGenerator beanNameGeneratorinstantiateUserDefinedStrategy(...)ScopeMetadataResolver scopeMetadataResolverScopeMetadataResolver.classcreateTypeFilter(...)String filterType// Actually scan for bean definitions and register them.// Delegate bean definition registration to scanner class.// Register ScopeMetadataResolver if class name provided.// Parse exclude and include filter elements./** Container annotation that aggregates several {@link ComponentScan} annotations. ... *//** A single {@code condition} that must be {@linkplain #matches matched} in order ... *//** Determine if the condition matches. ... *//** Context information for use by {@link Condition} implementations. ... *//** Return the {@link BeanDefinitionRegistry} that will hold the bean definition ... *//** Return the {@link ConfigurableListableBeanFactory} that will hold the bean ... *//** Return the {@link Environment} for which the current application is running. *//** Return the {@link ResourceLoader} currently being used. *//** Return the {@link ClassLoader} that should be used to load additional classes ... */import ConfigurationPhase/** Internal class used to evaluate {@link Conditional} annotations. ... */ConditionContextImpl context, ...;/** Create a new {@link ConditionEvaluator} instance. */new ConditionContextImpl(...)/** Determine if an item should be skipped based on {@code @Conditional} annotations. ... */List<Condition> conditionsnew ArrayList<Condition>(...)Conditional.classisConfigurationCandidate(...)ConfigurationPhase.PARSE_CONFIGURATIONConfigurationPhase.REGISTER_BEANString[] conditionClassesgetConditionClasses(...)String conditionClassCondition conditionConfigurationPhase requiredPhasegetConfigurationPhase(...)MultiValueMap<String,Object> attributesgetAllAnnotationAttributes(...)Object valuesClass<?> conditionClass/** Implementation of a {@link ConditionContext}. */deduceBeanFactory(...)deduceEnvironment(...)deduceResourceLoader(...)deduceClassLoader(...)/** Indicates that a component is only eligible for registration when all ... *//** All {@link Condition} classes that must {@linkplain Condition#matches match} ... */import Value/** Indicates that a class declares one or more {@link Bean @Bean} methods and ... *//** Explicitly specify the name of the Spring bean definition associated with the ... *//** Specify whether {@code @Bean} methods should get proxied in order to enforce ... *//** Represents a user-defined {@link Configuration @Configuration} class. ... */new LinkedHashSet<ConfigurationClass>(...)new LinkedHashSet<BeanMethod>(...)new LinkedHashMap<String,Class<? extends BeanDefinitionReader>>(...)new LinkedHashMap<ImportBeanDefinitionRegistrar,AnnotationMetadata>(...)Set<ConfigurationClass> importedBy, ...;Set<BeanMethod> beanMethods, ...;Map<String,Class<? extends BeanDefinitionReader>> importedResources, ...;Map<ImportBeanDefinitionRegistrar,AnnotationMetadata> importBeanDefinitionRegistrars, ...;Set<String> skippedBeanMethods, ...;/** Create a new {@link ConfigurationClass} with the given name. ... *//** Create a new {@link ConfigurationClass} representing a class that was imported ... */this.importedBy/** Return whether this configuration class was registered via @{@link Import} or ... *//** Merge the imported-by declarations from the given configuration class into this one. ... */otherConfigClass.importedBy/** Return the configuration classes that imported this class, ... */this.beanMethodsthis.importedResourcesthis.importBeanDefinitionRegistrarsnew FinalConfigurationProblem(...)BeanMethod beanMethod/** Configuration classes must be non-final to accommodate CGLIB subclassing. */// A configuration class may not be final (CGLIB limitation) unless it declares proxyBeanMethods=falseimport GroovyBeanDefinitionReaderimport StandardMethodMetadata/** Reads a given fully-populated set of ConfigurationClass instances, registering bean ... */ConfigurationClassBeanDefinitionReader.classBeanNameGenerator importBeanNameGenerator, ...;ImportRegistry importRegistry, ...;/** Create a new {@link ConfigurationClassBeanDefinitionReader} instance ... */this.importBeanNameGeneratorthis.importRegistry/** Read {@code configurationModel}, registering bean definitions ... */TrackedConditionEvaluator trackedConditionEvaluatornew TrackedConditionEvaluator(...)ConfigurationClass configClassloadBeanDefinitionsForConfigurationClass(...)/** Read a particular {@link ConfigurationClass}, registering bean definitions ... */removeImportingClass(...)isImported(...)registerBeanDefinitionForImportedConfigurationClass(...)getBeanMethods(...)loadBeanDefinitionsForBeanMethod(...)loadBeanDefinitionsFromImportedResources(...)getImportedResources(...)loadBeanDefinitionsFromRegistrars(...)getImportBeanDefinitionRegistrars(...)/** Register the {@link Configuration} class itself as a bean definition. */AnnotatedGenericBeanDefinition configBeanDefString configBeanName/** Read the given {@link BeanMethod}, registering bean definitions ... */getConfigurationClass(...)MethodMetadata metadataConfigurationClassBeanDefinition beanDefnew ConfigurationClassBeanDefinition(...)Autowire autowireboolean autowireCandidateBeanDefinition beanDefToRegisterconfigClass.skippedBeanMethodsisOverriddenByExistingDefinition(...)setResolvedFactoryMethod(...)getIntrospectedMethod(...)RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTEisAutowire(...)BeanDefinitionHolder proxyDefBeanDefinition existingBeanDefConfigurationClassBeanDefinition ccbdgetFactoryMethodMetadata(...)setNonUniqueFactoryMethodName(...)Map<Class<?>,BeanDefinitionReader> readerInstanceCachenew HashMap<Class<?>,BeanDefinitionReader>(...)new BiConsumer<String,Class<? extends BeanDefinitionReader>>(...) { ... }BeanDefinitionReader.classGroovyBeanDefinitionReader.classBeanDefinitionRegistry.classAbstractBeanDefinitionReader abdrnew BiConsumer<ImportBeanDefinitionRegistrar,AnnotationMetadata>(...) { ... }/** {@link RootBeanDefinition} marker subclass used to signify that a bean definition ... */AnnotationMetadata annotationMetadata, ...;String derivedBeanName, ...;this.annotationMetadatathis.derivedBeanNameoriginal.annotationMetadataoriginal.factoryMethodMetadataoriginal.derivedBeanNameisBeanAnnotated(...)determineBeanNameFor(...)/** Evaluate {@code @Conditional} annotations, tracking results and taking into ... */new HashMap<ConfigurationClass,Boolean>(...)Map<ConfigurationClass,Boolean> skipped, ...;this.skippedboolean allSkippedConfigurationClass importedBygetImportedBy(...)// for RequiredAnnotationBeanPostProcessor.SKIP_REQUIRED_CHECK_ATTRIBUTE// Do we need to mark the bean as skipped by its condition?// Consider name and any aliases// Register aliases even when overridden// Has this effectively been overridden before (e.g. via XML)?// static @Bean method// instance @Bean method// Consider scoping// Replace the original bean definition with the target one, if necessary// Is the existing bean definition one that was created from a configuration class?// -> allow the current bean method to override, since both are at second-pass level.// However, if the bean method is an overloaded case on the same configuration class,// preserve the existing bean definition.// A bean definition resulting from a component scan can be silently overridden// by an @Bean method, as of 4.2...// Has the existing bean definition bean marked as a framework-generated bean?// -> allow the current bean method to override it, since it is application-level// At this point, it's a top-level override (probably XML), just having been parsed// before configuration class processing kicks in...// Default reader selection necessary?// When clearly asking for Groovy, that's what they'll get...// Primarily ".xml" files but for any other extension as well// Instantiate the specified BeanDefinitionReader// Delegate the current ResourceLoader to it if possible// TODO SPR-6310: qualify relative path locations as done in AbstractContextLoader.modifyLocations// The config classes that imported this one were all skipped, therefore we are skipped...import ScopedProxyFactoryBeanimport SimpleInstantiationStrategyimport ClassGeneratorimport ClassEmitterTransformerimport TransformingClassGeneratorimport ObjenesisException/** Enhances {@link Configuration} classes by generating a CGLIB subclass which ... */new BeanMethodInterceptor(...)new BeanFactoryAwareMethodInterceptor(...)new ConditionalCallbackFilter(...)ConfigurationClassEnhancer.class...[] CALLBACKS, ...;// The callbacks to use. Note that these callbacks must be stateless.ConditionalCallbackFilter CALLBACK_FILTER, ...;String BEAN_FACTORY_FIELD, ...;/** Loads the specified class and generates a CGLIB subclass of it equipped with ... */Class<?> enhancedClassnewEnhancer(...)EnhancedConfiguration.class/** Creates a new CGLIB {@link Enhancer} instance. */setUseFactory(...)new BeanFactoryAwareGeneratorStrategy(...)getCallbackTypes(...)/** Uses enhancer to generate a subclass of superclass, ... */registerStaticCallbacks(...)/** Marker interface to be implemented by all @Configuration CGLIB subclasses. ... *//** Conditional {@link Callback}. ... *//** A {@link CallbackFilter} that works by interrogating {@link Callback Callbacks} in the order ... */...[] callbacks, ...;...[] callbackTypes, ...;this.callbacksthis.callbackTypesthis.callbacks.length/** Custom extension of CGLIB's DefaultGeneratorStrategy, introducing a {@link BeanFactory} field. ... */ClassEmitterTransformer transformernew ClassEmitterTransformer(...) { ... }declare_field(...)Constants.ACC_PUBLICend_class(...)new TransformingClassGenerator(...)/** Intercepts the invocation of any {@link BeanFactoryAware#setBeanFactory(BeanFactory)} on ... */invokeSuper(...)isSetBeanFactory(...)/** Intercepts the invocation of any {@link Bean}-annotated methods in order to ensure proper ... *//** Enhance a {@link Bean @Bean} method to check the supplied BeanFactory for the ... */isScopedProxy(...)String scopedBeanNamefactoryContainsBean(...)enhanceFactoryBean(...)isCurrentlyInvokedFactoryMethod(...)BeanFactoryPostProcessor.classresolveBeanReference(...)boolean alreadyInCreationboolean useArgsMethod currentlyInvokedgetCurrentlyInvokedFactoryMethod(...)setCurrentlyInCreation(...)String outerBeanNameObject beanFactory/** Check the BeanFactory to see whether the bean named <var>beanName</var> already ... *//** Check whether the given method corresponds to the container's currently invoked ... *//** Create a subclass proxy that intercepts calls to getObject(), delegating to the current BeanFactory ... */boolean finalClassboolean finalMethodcreateInterfaceProxyForFactoryBean(...)createCglibProxyForFactoryBean(...)Class<?> fbClassObject fbProxysetCallbackType(...)MethodInterceptor.classObjenesisException exsetCallback(...)// Registering callbacks statically (as opposed to thread-local)// is critical for usage in an OSGi environment (SPR-5932)...// Does the actual (non-CGLIB) superclass implement BeanFactoryAware?// If so, call its setBeanFactory() method. If not, just exit.// Determine whether this bean is a scoped-proxy// To handle the case of an inter-bean method reference, we must explicitly check the// container for already cached instances.// First, check to see if the requested bean is a FactoryBean. If so, create a subclass// proxy that intercepts calls to getObject() and returns any cached bean instance.// This ensures that the semantics of calling a FactoryBean from within @Bean methods// is the same as that of referring to a FactoryBean within XML. See SPR-6602.// Scoped proxy factory beans are a special case and should not be further proxied// It is a candidate FactoryBean - go ahead with enhancement// The factory is calling the bean method in order to instantiate and register the bean// (i.e. via a getBean() call) -> invoke the super implementation of the method to actually// create the bean instance.// The user (i.e. not the factory) is requesting this bean through a call to// the bean method, direct or indirect. The bean may have already been marked// as 'in creation' in certain autowiring scenarios; if so, temporarily set// the in-creation status to false in order to avoid an exception.// Stubbed null arguments just for reference purposes,// expecting them to be autowired for regular singleton references?// A safe assumption since @Bean singleton arguments cannot be optional...// Ignore - simply no detailed message then.// No getObject() method -> shouldn't happen, but as long as nobody is trying to call it...// Ideally create enhanced FactoryBean proxy without constructor side effects,// analogous to AOP proxy creation in ObjenesisCglibAopProxy...import SocketExceptionimport UnknownHostExceptionimport Groupimport NestedIOExceptionimport CompositePropertySourceimport MutablePropertySourcesimport PropertySourceimport DefaultPropertySourceFactoryimport PropertySourceFactoryimport ResourcePropertySource/** Parses a {@link Configuration} class definition, populating a collection of ... */new LinkedHashMap<ConfigurationClass,ConfigurationClass>(...)new HashMap<String,ConfigurationClass>(...)new ImportStack(...)new DeferredImportSelectorHandler(...)new SourceClass(...)new DefaultPropertySourceFactory(...)new Comparator<DeferredImportSelectorHolder>(...) { ... }getImportSelector(...)PropertySourceFactory DEFAULT_PROPERTY_SOURCE_FACTORY, ...;Predicate<String> DEFAULT_EXCLUSION_FILTER, ...;Comparator<DeferredImportSelectorHolder> DEFERRED_IMPORT_COMPARATOR, ...;ComponentScanAnnotationParser componentScanParser, ...;Map<ConfigurationClass,ConfigurationClass> configurationClasses, ...;Map<String,ConfigurationClass> knownSuperclasses, ...;List<String> propertySourceNames, ...;ImportStack importStack, ...;DeferredImportSelectorHandler deferredImportSelectorHandler, ...;SourceClass objectSourceClass, ...;/** Create a new {@link ConfigurationClassParser} instance that will be used ... */this.componentScanParsernew ComponentScanAnnotationParser(...)this.deferredImportSelectorHandlerMetadataReader readerprocessConfigurationClass(...)new ConfigurationClass(...)/** Validate each {@link ConfigurationClass} object. ... */this.configurationClassesConfigurationClass existingClassSourceClass sourceClassasSourceClass(...)mergeImportedBy(...)this.knownSuperclassesnew Predicate<ConfigurationClass>(...) { ... }doProcessConfigurationClass(...)/** Apply processing and build a complete {@link ConfigurationClass} by reading the ... */Set<AnnotationAttributes> componentScansComponentScan.classAnnotationAttributes importResourceImportResource.classSet<MethodMetadata> beanMethodsretrieveBeanMethodMetadata(...)processMemberClasses(...)AnnotationAttributes propertySourcePropertySources.classPropertySource.classprocessPropertySource(...)AnnotationAttributes componentScanSet<BeanDefinitionHolder> scannedBeanDefinitionsBeanDefinition bdCandcheckConfigurationClassCandidate(...)processImports(...)String[] resourcesClass<? extends BeanDefinitionReader> readerClassString resolvedResourceaddImportedResource(...)MethodMetadata methodMetadataaddBeanMethod(...)new BeanMethod(...)processInterfaces(...)hasSuperClass(...)String superclassgetSuperClassName(...)getSuperClass(...)/** Register member (nested) classes that happen to be configuration classes themselves. */Collection<SourceClass> memberClassesgetMemberClasses(...)List<SourceClass> candidatesnew ArrayList<SourceClass>(...)SourceClass memberClassSourceClass candidatethis.importStacknew CircularImportProblem(...)asConfigClass(...)/** Register default methods on interfaces implemented by the configuration class. */SourceClass ifc/** Retrieve the metadata for all <code>@Bean</code> methods. */AnnotationMetadata originalgetAnnotatedMethods(...)AnnotationMetadata asmSet<MethodMetadata> asmMethodsSet<MethodMetadata> selectedMethodsnew LinkedHashSet<MethodMetadata>(...)MethodMetadata asmMethodMethodMetadata beanMethod/** Process the given <code>@PropertySource</code> annotation metadata. ... */String encodingboolean ignoreResourceNotFoundClass<? extends PropertySourceFactory> factoryClassPropertySourceFactory factoryPropertySourceFactory.classlocations.lengthString resolvedLocationaddPropertySource(...)createPropertySource(...)this.propertySourceNamesPropertySource<?> existingPropertySource<?> newSourcewithResourceName(...)addFirstPropertySource(...)CompositePropertySource compositenew CompositePropertySource(...)addLast(...)String firstProcessedaddBefore(...)/** Returns {@code @Import} class, considering all meta-annotations. */Set<SourceClass> importsnew LinkedHashSet<SourceClass>(...)Set<SourceClass> visitedcollectImports(...)/** Recursively collect all declared {@code @Import} values. Unlike most ... */SourceClass annotationString annNameImport.classisChainedImportOnStack(...)ImportSelector.classClass<?> candidateClassImportSelector selectorPredicate<String> selectorFiltergetExclusionFilter(...)or(...)handle(...)String[] importClassNamesCollection<SourceClass> importSourceClassesasSourceClasses(...)ImportBeanDefinitionRegistrar.classImportBeanDefinitionRegistrar registraraddImportBeanDefinitionRegistrar(...)registerImport(...)String configClassNameAnnotationMetadata importingClassgetImportingClassFor(...)/** Factory method to obtain a {@link SourceClass} from a {@link ConfigurationClass}. *//** Factory method to obtain a {@link SourceClass} from a {@link Class}. */this.objectSourceClassgetDeclaredAnnotations(...)validateAnnotation(...)/** Factory method to obtain a {@link SourceClass} collection from class names. */List<SourceClass> annotatedClasses/** Factory method to obtain a {@link SourceClass} from a class name. */new NestedIOException(...)new LinkedMultiValueMap<String,AnnotationMetadata>(...)MultiValueMap<String,AnnotationMetadata> imports, ...;lastElement(...)List<AnnotationMetadata> listIterator<AnnotationMetadata> iterator/** Given a stack containing (in order) ... */StringJoiner joinerConfigurationClass configurationClassnew ArrayList<DeferredImportSelectorHolder>(...)List<DeferredImportSelectorHolder> deferredImportSelectors, ...;/** Handle the specified {@link DeferredImportSelector}. If deferred import ... */DeferredImportSelectorHolder holdernew DeferredImportSelectorHolder(...)this.deferredImportSelectorsDeferredImportSelectorGroupingHandler handlernew DeferredImportSelectorGroupingHandler(...)processGroupImports(...)List<DeferredImportSelectorHolder> deferredImportsnew Consumer<DeferredImportSelectorHolder>(...) { ... }new LinkedHashMap<Object,DeferredImportSelectorGrouping>(...)new HashMap<AnnotationMetadata,ConfigurationClass>(...)Map<Object,DeferredImportSelectorGrouping> groupings, ...;Map<AnnotationMetadata,ConfigurationClass> configurationClasses, ...;Class<? extends Group> groupgetImportGroup(...)DeferredImportSelectorGrouping groupingthis.groupingsnew Function<Object,DeferredImportSelectorGrouping>(...) { ... }new DeferredImportSelectorGrouping(...)createGroup(...)Predicate<String> exclusionFiltergetCandidateFilter(...)new Consumer<Entry>(...) { ... }getImportClassName(...)Class<? extends Group> effectiveTypeDefaultDeferredImportSelectorGroup.classGroup.classConfigurationClassParser.this.environmentConfigurationClassParser.this.resourceLoaderConfigurationClassParser.this.registryConfigurationClassParser.thisConfigurationClass configurationClass, ...;DeferredImportSelector importSelector, ...;this.importSelectorDeferredImportSelector.Group group, ...;DeferredImportSelector.GroupList<DeferredImportSelectorHolder> deferredImports, ...;this.groupthis.deferredImports/** Return the imports defined by the group. ... */Group.EntryDeferredImportSelectorHolder deferredImportPredicate<String> mergedFilternew ArrayList<Entry>(...)List<Entry> imports, ...;String importClassNamenew Entry(...)/** Simple wrapper that allows annotated source classes to be dealt with ... */// Class or MetadataReaderInteger ordergetClassMetadata(...)Object sourceToProcessMetadataReader sourceReaderString[] memberClassNamesgetMemberClassNames(...)List<SourceClass> membersmemberClassNames.lengthClass<?> sourceClassClass<?>[] declaredClassesgetDeclaredClasses(...)declaredClasses.lengthClass<?> declaredClassString memberClassNameSet<SourceClass> resultClass<?> ifcClassgetInterfaceNames(...)getRelated(...)Map<String,Object> annotationAttributes(...).metadata/** {@link Problem} registered upon detection of a circular {@link Import}. */element(...)// Otherwise ignore new imported config class; existing non-imported class overrides it.// Explicit bean definition found, probably replacing an import.// Let's remove the old one and go with the new one.// Recursively process the configuration class and its superclass hierarchy.// Recursively process any member (nested) classes first// Process any @PropertySource annotations// Process any @ComponentScan annotations// The config class is annotated with @ComponentScan -> perform the scan immediately// Check the set of scanned definitions for any further config classes and parse recursively if needed// Process any @Import annotations// Process any @ImportResource annotations// Process individual @Bean methods// Process default methods on interfaces// Process superclass, if any// Superclass found, return its annotation metadata and recurse// No superclass -> processing is complete// A default method or other concrete method on a Java 8+ interface...// Try reading the class file via ASM for deterministic declaration order...// Unfortunately, the JVM's standard reflection returns methods in arbitrary// order, even between different runs of the same application on the same JVM.// All reflection-detected methods found in ASM method set -> proceed// No worries, let's continue with the reflection metadata we started with...// Placeholders not resolvable or resource not found when trying to open it// We've already added a version, we need to extend it// Candidate class is an ImportSelector -> delegate to it to determine imports// Candidate class is an ImportBeanDefinitionRegistrar ->// delegate to it to register additional bean definitions// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar ->// process it as an @Configuration class// Sanity test that we can reflectively read annotations,// including Class attributes; if not -> fall back to ASM// Enforce ASM via class name resolution// Never use ASM for core java types// getDeclaredClasses() failed because of non-resolvable dependencies// -> fall back to ASM below// ASM-based resolution - safe for non-resolvable classes as well// Let's skip it if it's not resolvable - we're just looking for candidates// An annotation not present on the classpath is being ignored// by the JVM's class loading -> ignore here as well.// Ignore -> fall back to ASM next, except for core java types.import BeanDefinitionRegistryPostProcessorimport ApplicationStartupAwareimport EnhancedConfiguration/** {@link BeanFactoryPostProcessor} used for bootstrapping processing of ... */FullyQualifiedAnnotationBeanNameGenerator.INSTANCEAnnotationBeanNameGenerator IMPORT_BEAN_NAME_GENERATOR, ...;/** A {@code BeanNameGenerator} using fully qualified class names as default bean names. ... */String IMPORT_REGISTRY_BEAN_NAME, ...;boolean setMetadataReaderFactoryCalled, ...;Set<Integer> registriesPostProcessed, ...;Set<Integer> factoriesPostProcessed, ...;ConfigurationClassBeanDefinitionReader reader, ...;boolean localBeanNameGeneratorSet, ...;BeanNameGenerator componentScanBeanNameGenerator, ...;/* Using short class names as default bean names by default. *//* Using fully qualified class names as default bean names by default. *//** Set the {@link SourceExtractor} to use for generated bean definitions ... *//** Set the {@link ProblemReporter} to use. ... */this.setMetadataReaderFactoryCalled/** Set the {@link BeanNameGenerator} to be used when triggering component scanning ... */this.localBeanNameGeneratorSetthis.componentScanBeanNameGenerator/** Derive further bean definitions from the configuration classes in the registry. */int registryIdthis.registriesPostProcessedthis.factoriesPostProcessedprocessConfigBeanDefinitions(...)/** Prepare the Configuration classes for servicing bean requests at runtime ... */int factoryIdenhanceConfigurationClasses(...)new ImportAwareBeanPostProcessor(...)/** Build and validate a configuration model based on the registry of ... */List<BeanDefinitionHolder> configCandidatesnew ArrayList<BeanDefinitionHolder>(...)SingletonBeanRegistry sbrConfigurationClassParser parsernew ConfigurationClassParser(...)Set<BeanDefinitionHolder> candidatesSet<ConfigurationClass> alreadyParsednew HashSet<ConfigurationClass>(...)ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTEnew Comparator<BeanDefinitionHolder>(...) { ... }int i1int i2BeanNameGenerator generatorStartupStep processConfigSet<ConfigurationClass> configClassesgetConfigurationClasses(...)new ConfigurationClassBeanDefinitionReader(...)getImportRegistry(...)String[] newCandidateNamesSet<String> oldCandidateNamesSet<String> alreadyParsedClasses/** Post-processes a BeanFactory in search of Configuration class BeanDefinitions; ... */StartupStep enhanceConfigClassesMap<String,AbstractBeanDefinition> configBeanDefsnew LinkedHashMap<String,AbstractBeanDefinition>(...)ConfigurationClassEnhancer enhancernew ConfigurationClassEnhancer(...)Object configClassAttrConfigurationClassUtils.CONFIGURATION_CLASS_FULLEntry<String,AbstractBeanDefinition> entryMap<>.Entry<String,AbstractBeanDefinition>AbstractBeanDefinition beanDefClass<?> configClassenhance(...)ImportRegistry irImportRegistry.classsetImportMetadata(...)// within PriorityOrdered// BeanDefinitionRegistryPostProcessor hook apparently not supported...// Simply call processConfigurationClasses lazily at this point then.// Return immediately if no @Configuration classes were found// Sort by previously determined @Order value, if applicable// Detect any custom bean name generation strategy supplied through the enclosing application context// Parse each @Configuration class// Read the model and create bean definitions based on its content// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes// Configuration class (full or lite) or a configuration-derived @Bean method// -> resolve bean class at this point...// nothing to enhance -> return immediately// If a @Configuration class gets proxied, always proxy the target class// Set enhanced subclass of the user-specified bean class// Inject the BeanFactory before AutowiredAnnotationBeanPostProcessor's// postProcessProperties method attempts to autowire other configuration beans.import EventListenerFactory/** Utilities for identifying {@link Configuration} classes. ... */ConfigurationClassUtils.classString CONFIGURATION_CLASS_FULL, ...;String CONFIGURATION_CLASS_LITE, ...;String CONFIGURATION_CLASS_ATTRIBUTE, ...;String ORDER_ATTRIBUTE, ...;Set<String> candidateIndicators, ...;/** Check whether the given bean definition is a candidate for a configuration class ... */Map<String,Object> configBeanPostProcessor.classEventListenerFactory.class/** Check the given metadata for a configuration class candidate ... */String indicator/** Determine the order for the given configuration class metadata. ... */Map<String,Object> orderAttributes/** Determine the order for the given configuration class bean definition, ... */// Can reuse the pre-parsed metadata from the given BeanDefinition...// Check already loaded Class if present...// since we possibly can't even load the class file for this Class.// It's a full or lite configuration candidate... Let's determine the order value, if any.// Do not consider an interface or an annotation...// Any of the typical annotations found?// Finally, let's look for @Bean methods.../** A {@link Condition} that offers more fine-grained control when used with ... *//** Return the {@link ConfigurationPhase} in which the condition should be evaluated. *//** The various configuration phases where the condition could be evaluated. */new ConfigurationPhase(...)ConfigurationPhase PARSE_CONFIGURATION, ...;/** The {@link Condition} should be evaluated as a {@code @Configuration} ... */ConfigurationPhase REGISTER_BEAN, ...;/** The {@link Condition} should be evaluated when adding a regular ... *//** Base class for a {@link Configuration @Configuration} class method. ... */MethodMetadata metadata, ...;getDeclaringClassName(...)/** Marker subclass of {@link IllegalStateException}, allowing for explicit ... */import QualifierAnnotationAutowireCandidateResolver/** Complete implementation of the ... */isLazy(...)buildLazyResolutionProxy(...)Class<?> dependencyType/** A variation of {@link ImportSelector} that runs after all {@code @Configuration} beans ... *//** Return a specific import group. ... *//** Interface used to group results from different import selectors. ... *//** Process the {@link AnnotationMetadata} of the importing @{@link Configuration} ... *//** Return the {@link Entry entries} of which class(es) should be imported ... *//** An entry that holds the {@link AnnotationMetadata} of the importing ... */String importClassName, ...;this.importClassName/** Return the {@link AnnotationMetadata} of the importing ... *//** Return the fully qualified name of the class to import. */entry.metadataentry.importClassName/** Beans on which the current bean depends. Any beans specified are guaranteed to be ... *//** Adds a textual description to bean definitions derived from ... *//** The textual description to associate with the bean definition. *//** Enables support for handling components marked with AspectJ's {@code @Aspect} annotation, ... */AspectJAutoProxyRegistrar.class/** Indicate that the proxy should be exposed by the AOP framework as a {@code ThreadLocal} ... */import DefaultContextLoadTimeWeaverimport LoadTimeWeaver/** Activates a Spring {@link LoadTimeWeaver} for this application context, available as ... */LoadTimeWeavingConfiguration.class/** Whether AspectJ weaving should be enabled. *//** AspectJ weaving enablement options. */new AspectJWeaving(...)AspectJWeaving ENABLED, ...;/** Switches on Spring-based AspectJ load-time weaving. */AspectJWeaving DISABLED, ...;/** Switches off Spring-based AspectJ load-time weaving (even if a ... */AspectJWeaving AUTODETECT, ...;/** Switches on AspectJ load-time weaving if a "META-INF/aop.xml" resource ... */import AnnotationMBeanExporterimport RegistrationPolicy/** Enables default exporting of all standard {@code MBean}s from the Spring context, as ... */MBeanExportConfiguration.class/** The default domain to use when generating JMX ObjectNames. *//** The bean name of the MBeanServer to which MBeans should be exported. Default is to ... *//** The policy to use when attempting to register an MBean under an ... *//** Enumeration of the type filters that may be used in conjunction with ... */new FilterType(...)FilterType ANNOTATION, ...;/** Filter candidates marked with a given annotation. ... */FilterType ASSIGNABLE_TYPE, ...;/** Filter candidates assignable to a given type. ... */FilterType ASPECTJ, ...;/** Filter candidates matching a given AspectJ type pattern expression. ... */FilterType REGEX, ...;/** Filter candidates matching a given regex pattern. ... */FilterType CUSTOM, ...;/** Filter candidates using a given custom ... *//** An extension of {@code AnnotationBeanNameGenerator} that uses the fully qualified ... */new FullyQualifiedAnnotationBeanNameGenerator(...)FullyQualifiedAnnotationBeanNameGenerator INSTANCE, ...;/** A convenient constant for a default {@code FullyQualifiedAnnotationBeanNameGenerator} ... *//** Indicates one or more <em>component classes</em> to import &mdash; typically ... *//** {@link Configuration @Configuration}, {@link ImportSelector}, ... *//** Interface to be implemented by any @{@link Configuration} class that wishes ... *//** Set the annotation metadata of the importing @{@code Configuration} class. *//** Interface to be implemented by types that register additional bean definitions when ... *//** Register bean definitions as necessary based on the given annotation metadata of ... *//** Registry of imported class {@link AnnotationMetadata}. ... *//** Indicates one or more resources containing bean definitions to import. ... *//** Alias for {@link #locations}. ... *//** Resource locations from which to import. ... *//** {@link BeanDefinitionReader} implementation to use when processing ... *//** Interface to be implemented by types that determine which @{@link Configuration} ... *//** Select and return the names of which class(es) should be imported based on ... *//** Return a predicate for excluding classes from the import candidates, to be ... *//** Simple {@link ScopeMetadataResolver} implementation that follows JSR-330 scoping rules: ... */Map<String,String> scopeMap, ...;/** Register an extended JSR-330 scope annotation, mapping it onto a ... */this.scopeMap/** Resolve the given annotation type into a named Spring scope. ... */String foundSet<String> metaAnnsresolveScopeName(...)/** Indicates whether a bean is to be lazily initialized. ... *//** Whether lazy initialization should occur. */import AspectJWeavingimport AspectJWeavingEnabler/** {@code @Configuration} class that registers a {@link LoadTimeWeaver} bean. ... */AnnotationAttributes enableLTW, ...;LoadTimeWeavingConfigurer ltwConfigurer, ...;this.enableLTWEnableLoadTimeWeaving.classthis.ltwConfigurerConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAMELoadTimeWeaver loadTimeWeavergetLoadTimeWeaver(...)new DefaultContextLoadTimeWeaver(...)AspectJWeaving aspectJWeavingAspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCEenableAspectJWeaving(...)// The user has provided a custom LoadTimeWeaver instance// No custom LoadTimeWeaver provided -> fall back to the default// AJ weaving is disabled -> do nothing// No aop.xml present on the classpath -> treat as 'disabled'// aop.xml is present on the classpath -> enable/** Interface to be implemented by ... *//** Create, configure and return the {@code LoadTimeWeaver} instance to be used. Note ... */import MBeanServerimport NamingExceptionimport MBeanServerNotFoundExceptionimport WebSphereMBeanServerFactoryBeanimport JndiLocatorDelegate/** {@code @Configuration} class that registers a {@link AnnotationMBeanExporter} bean. ... */String MBEAN_EXPORTER_BEAN_NAME, ...;AnnotationAttributes enableMBeanExport, ...;EnableMBeanExport.classthis.enableMBeanExportAnnotationMBeanExporter exporternew AnnotationMBeanExporter(...)setupDomain(...)setupServer(...)setupRegistrationPolicy(...)String defaultDomainsetDefaultDomain(...)String serversetServer(...)MBeanServer.classSpecificPlatform specificPlatformMBeanServer mbeanServergetMBeanServer(...)RegistrationPolicy registrationPolicysetRegistrationPolicy(...)/** Specific platforms that might need custom MBean handling. */new SpecificPlatform(...) { ... }/** Weblogic. */new JndiLocatorDelegate(...)NamingException exnew MBeanServerNotFoundException(...)/** Websphere. */WebSphereMBeanServerFactoryBean fbnew WebSphereMBeanServerFactoryBean(...)SpecificPlatform WEBLOGIC, ...;SpecificPlatform WEBSPHERE, ...;String identifyingClass, ...;this.identifyingClassSpecificPlatform environmentenvironment.identifyingClass/** Common delegate code for the handling of parser strategies, e.g. ... *//** Instantiate a class using an appropriate constructor and return the new ... */T instanceconstructors.lengthresolveArgs(...)Object[] parametersresolveParameter(...)Environment.classResourceLoader.classClassLoader.class/** Indicates that a bean should be given preference when multiple candidates ... */import Profiles/** Indicates that a component is eligible for registration when one or more ... */ProfileCondition.class/** The set of profiles for which the annotated component should be registered. *//** {@link Condition} that matches based on the value of a {@link Profile @Profile} ... */MultiValueMap<String,Object> attrsProfile.class/** Annotation providing a convenient and declarative mechanism for adding a ... *//** Indicate the name of this property source. If omitted, the {@link #factory} ... *//** Indicate the resource location(s) of the properties file to be loaded. ... *//** Indicate if a failure to find a {@link #value property resource} should be ... *//** A specific character encoding for the given resources, e.g. "UTF-8". ... *//** Specify a custom {@link PropertySourceFactory}, if any. ... *//** Container annotation that aggregates several {@link PropertySource} annotations. ... *//** Indicates the 'role' hint for a given bean. ... *//** Set the role hint for the associated bean. ... *//** Create a new ScannedGenericBeanDefinition for the class that the ... *//** When used as a type-level annotation in conjunction with ... *//** Alias for {@link #scopeName}. ... *//** Specifies the name of the scope to use for the annotated component/bean. ... *//** Specifies whether a component should be configured as a scoped proxy ... *//** Describes scope characteristics for a Spring-managed bean including the scope ... */String scopeName, ...;ScopedProxyMode scopedProxyMode, ...;/** Set the name of the scope. */this.scopeName/** Get the name of the scope. *//** Set the proxy-mode to be applied to the scoped instance. */this.scopedProxyMode/** Get the proxy-mode to be applied to the scoped instance. *//** Strategy interface for resolving the scope of bean definitions. ... *//** Resolve the {@link ScopeMetadata} appropriate to the supplied ... *//** Delegate factory class used to just introduce an AOP framework dependency ... *//** Enumerates the various scoped-proxy options. ... */new ScopedProxyMode(...)ScopedProxyMode DEFAULT, ...;/** Default typically equals {@link #NO}, unless a different default ... */ScopedProxyMode NO, ...;/** Do not create a scoped proxy. ... */ScopedProxyMode INTERFACES, ...;/** Create a JDK dynamic proxy implementing <i>all</i> interfaces exposed by ... */ScopedProxyMode TARGET_CLASS, ...;/** Create a class-based proxy (uses CGLIB). *//** Annotation support for the Application Context, including JSR-250 "common" ... *//** Abstract parser for &lt;context:property-.../&gt; elements. ... */String propertiesRefString fileEncodingString orderimport AnnotationConfigBeanDefinitionParserimport ComponentScanBeanDefinitionParser/** {@link org.springframework.beans.factory.xml.NamespaceHandler} ... */new PropertyPlaceholderBeanDefinitionParser(...)new PropertyOverrideBeanDefinitionParser(...)new AnnotationConfigBeanDefinitionParser(...)new ComponentScanBeanDefinitionParser(...)new LoadTimeWeaverBeanDefinitionParser(...)new MBeanExportBeanDefinitionParser(...)new MBeanServerBeanDefinitionParser(...)/** Parser for the &lt;context:load-time-weaver/&gt; element. ... */String ASPECTJ_WEAVING_ENABLER_BEAN_NAME, ...;/** The bean name of the internally managed AspectJ weaving enabler. ... */String ASPECTJ_WEAVING_ENABLER_CLASS_NAME, ...;String DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME, ...;String WEAVER_CLASS_ATTRIBUTE, ...;String ASPECTJ_WEAVING_ATTRIBUTE, ...;isAspectJWeavingEnabled(...)isBeanConfigurerAspectEnabled(...)SpringConfiguredBeanDefinitionParser.BEAN_CONFIGURER_ASPECT_CLASS_NAME// Determine default...import AbstractBeanDefinitionParser/** Parser for the &lt;context:mbean-export/&gt; element. ... */String DEFAULT_DOMAIN_ATTRIBUTE, ...;String SERVER_ATTRIBUTE, ...;String REGISTRATION_ATTRIBUTE, ...;String REGISTRATION_IGNORE_EXISTING, ...;String REGISTRATION_REPLACE_EXISTING, ...;AnnotationMBeanExporter.classString serverBeanNameString registrationRegistrationPolicy.FAIL_ON_EXISTINGAbstractBeanDefinition specialServerfindServerForSpecialEnvironment(...)RegistrationPolicy.IGNORE_EXISTINGRegistrationPolicy.REPLACE_EXISTING// Mark as infrastructure bean and attach source location.import MBeanServerFactoryBeanimport JndiObjectFactoryBean/** Parser for the &lt;context:mbean-server/&gt; element. ... */MBeanServerBeanDefinitionParser.classString MBEAN_SERVER_BEAN_NAME, ...;String AGENT_ID_ATTRIBUTE, ...;boolean weblogicPresent, ...;boolean webspherePresent, ...;String agentIdMBeanServerFactoryBean.classJndiObjectFactoryBean.classWebSphereMBeanServerFactoryBean.classimport PropertyOverrideConfigurer/** Parser for the &lt;context:property-override/&gt; element. ... */PropertyOverrideConfigurer.classimport PropertySourcesPlaceholderConfigurer/** Parser for the {@code <context:property-placeholder/>} element. ... */String SYSTEM_PROPERTIES_MODE_ATTRIBUTE, ...;String SYSTEM_PROPERTIES_MODE_DEFAULT, ...;PropertySourcesPlaceholderConfigurer.classString systemPropertiesModeName// As of Spring 3.1, the default value of system-properties-mode has changed from// 'FALLBACK' to 'ENVIRONMENT'. This latter value indicates that resolution of// placeholders against system properties is a function of the Environment and// its current set of PropertySources.// The user has explicitly specified a value for system-properties-mode: revert to// PropertyPlaceholderConfigurer to ensure backward compatibility with 3.0 and earlier.// This is deprecated; to be removed along with PropertyPlaceholderConfigurer itself./** Support package for advanced application context configuration, ... */import ApplicationEventimport ApplicationListener/** Abstract implementation of the {@link ApplicationEventMulticaster} interface, ... */new DefaultListenerRetriever(...)new ConcurrentHashMap<ListenerCacheKey,CachedListenerRetriever>(...)DefaultListenerRetriever defaultRetriever, ...;Map<ListenerCacheKey,CachedListenerRetriever> retrieverCache, ...;this.defaultRetrieverObject singletonTargetthis.defaultRetriever.applicationListenersthis.retrieverCachethis.defaultRetriever.applicationListenerBeans/** Return a Collection containing all ApplicationListeners. ... */getApplicationListeners(...)/** Return a Collection of ApplicationListeners matching the given ... */ListenerCacheKey cacheKeynew ListenerCacheKey(...)CachedListenerRetriever newRetrieverCachedListenerRetriever existingRetrievernew CachedListenerRetriever(...)Collection<ApplicationListener<?>> resultretrieveApplicationListeners(...)/** Actually retrieve the application listeners for the given event and source type. ... */List<ApplicationListener<?>> allListenersnew ArrayList<ApplicationListener<?>>(...)Set<ApplicationListener<?>> filteredListenersnew LinkedHashSet<ApplicationListener<?>>(...)Set<String> filteredListenerBeansSet<ApplicationListener<?>> listenersSet<String> listenerBeansApplicationListener<?> listenersupportsEvent(...)String listenerBeanNameApplicationListener<>.classObject listenerretriever.applicationListenersretriever.applicationListenerBeans/** Filter a bean-defined listener early through checking its generically declared ... */Class<?> listenerTypeGenericApplicationListener.classSmartApplicationListener.classResolvableType genericEventType/** Filter a listener early through checking its generically declared event ... */ResolvableType declaredEventTyperesolveDeclaredEventType(...)/** Determine whether the given listener supports the given event. ... */GenericApplicationListener smartListenernew GenericApplicationListenerAdapter(...)supportsEventType(...)supportsSourceType(...)/** Cache key for ListenerRetrievers, based on event type and source type. */ResolvableType eventType, ...;Class<?> sourceType, ...;this.eventTypethis.sourceTypeListenerCacheKey otherKeyotherKey.eventTypeotherKey.sourceTypeother.eventTypeother.sourceType/** Helper class that encapsulates a specific set of target listeners, ... */Set<ApplicationListener<?>> applicationListeners, ...;Set<String> applicationListenerBeans, ...;Set<ApplicationListener<?>> applicationListenersthis.applicationListenersSet<String> applicationListenerBeansthis.applicationListenerBeans/** Helper class that encapsulates a general set of target listeners. */// Explicitly remove target for a proxy, if registered already,// in order to avoid double invocations of the same listener.// Potential new retriever to populate// Quick check for existing entry on ConcurrentHashMap// Caching a new ListenerRetriever if possible// no need to populate it in retrieveApplicationListeners// If result is null, the existing retriever is not fully populated yet by another thread.// Proceed like caching wasn't possible for this current local attempt.// Add programmatically registered listeners, including ones coming// from ApplicationListenerDetector (singleton beans and inner beans).// Add listeners by bean name, potentially overlapping with programmatically// registered listeners above - but here potentially with additional metadata.// Remove non-matching listeners that originally came from// ApplicationListenerDetector, possibly ruled out by additional// BeanDefinition metadata (e.g. factory method generics) above.// Singleton listener instance (without backing bean definition) disappeared -// probably in the middle of the destruction phase// Ignore - no need to check resolvable type for manually registered singleton// Not fully populated yet/** Base class for events raised for an {@code ApplicationContext}. ... *//** Create a new ContextStartedEvent. ... *//** Get the {@code ApplicationContext} that the event was raised for. *//** Interface to be implemented by objects that can manage a number of ... *//** Add a listener to be notified of all events. ... *//** Add a listener bean to be notified of all events. ... *//** Remove a listener from the notification list. ... *//** Remove a listener bean from the notification list. ... *//** Remove all listeners registered with this multicaster. ... *//** Multicast the given application event to appropriate listeners. ... */import CompletionStageimport Subscriberimport Subscriptionimport PayloadApplicationEventimport ReactiveAdapterimport ReactiveAdapterRegistry/** {@link GenericApplicationListener} adapter that delegates the processing of ... */ApplicationListenerMethodAdapter.classboolean reactiveStreamsPresent, ...;List<ResolvableType> declaredEventTypes, ...;ApplicationContext applicationContext, ...;EventExpressionEvaluator evaluator, ...;/** Construct a new ApplicationListenerMethodAdapter. ... */EventListener annEventListener.classthis.declaredEventTypesresolveDeclaredEventTypes(...)resolveOrder(...)classes(...)List<ResolvableType> typesnew ArrayList<ResolvableType>(...)Class<?> eventTypeOrder ann/** Initialize this instance. */this.applicationContextprocessEvent(...)PayloadApplicationEvent<>.classResolvableType payloadType/** Process the specified {@link ApplicationEvent}, checking if the condition ... */resolveArguments(...)shouldHandle(...)doInvoke(...)handleResult(...)/** Resolve the method arguments to use for the specified {@link ApplicationEvent}. ... */Class<?> declaredEventClassApplicationEvent.classObject payloadsubscribeToPublisher(...)new ReactiveResultHandler(...)whenComplete(...)new BiConsumer<?,Throwable>(...) { ... }handleAsyncError(...)addCallback(...)new SuccessCallback<?>(...) { ... }publishEvents(...)new FailureCallback(...) { ... }Object[] eventsObject eventCollection<?> eventsString condition/** Invoke the event listener method with the given argument values. */getTargetBean(...)assertTargetBean(...)getInvocationErrorMessage(...)Throwable targetException/** Return the target bean instance to use. *//** Return the target listener method. ... *//** Return the condition to use. ... *//** Add additional details such as the bean type and method signature to ... *//** Assert that the target bean class is an instance of the class where the given ... */Class<?> methodDeclaringClassClass<?> targetBeanClassgetDetailedErrorMessage(...)resolvedArgs.lengthPayloadApplicationEvent<?> payloadEventResolvableType eventTypeClass<?> eventClassReactiveAdapter adaptergetAdapter(...)getSharedInstance(...)subscribe(...)toPublisher(...)new EventPublicationSubscriber(...)request(...)// Throw underlying exception/** Event raised when an {@code ApplicationContext} gets closed. ... *//** Creates a new ContextClosedEvent. ... *//** Event raised when an {@code ApplicationContext} gets initialized or refreshed. ... *//** Create a new ContextRefreshedEvent. ... *//** Event raised when an {@code ApplicationContext} gets started. ... *//** Event raised when an {@code ApplicationContext} gets stopped. ... *//** Create a new ContextStoppedEvent. ... *//** Default {@link EventListenerFactory} implementation that supports the ... */new ApplicationListenerMethodAdapter(...)/** Utility class for handling SpEL expression parsing for application events. ... *//** Determine if the condition defined by the specified expression evaluates ... */EventExpressionRootObject rootnew EventExpressionRootObject(...)MethodBasedEvaluationContext evaluationContextnew MethodBasedEvaluationContext(...)/** Root object used during event listener expression evaluation. ... */ApplicationEvent event, ...;this.event/** Annotation that marks a method as a listener for application events. ... *//** Alias for {@link #classes}. *//** The event classes that this listener handles. ... *//** Spring Expression Language (SpEL) expression used for making the event ... *//** Strategy interface for creating {@link ApplicationListener} for methods ... *//** Specify if this factory supports the specified {@link Method}. ... *//** Create an {@link ApplicationListener} for the specified method. ... */import ScopedObjectimport ApplicationContextAware/** Registers {@link EventListener} methods as individual {@link ApplicationListener} instances. ... */boolean shouldIgnoreSpel, ...;/** Boolean flag controlled by a {@code spring.spel.ignore} system property that instructs Spring to ... */ConfigurableApplicationContext applicationContext, ...;List<EventListenerFactory> eventListenerFactories, ...;Set<Class<?>> nonAnnotatedClasses, ...;new EventExpressionEvaluator(...)Map<String,EventListenerFactory> beansList<EventListenerFactory> factoriesnew ArrayList<EventListenerFactory>(...)this.eventListenerFactoriesdetermineTargetClass(...)ScopedObject.classprocessBean(...)this.nonAnnotatedClassesisSpringContainerClass(...)Map<Method,EventListener> annotatedMethodsselectMethods(...)MethodIntrospector.MetadataLookup<EventListener>new MetadataLookup<EventListener>(...) { ... }ConfigurableApplicationContext contextEventListenerFactory factorysupportsMethod(...)ApplicationListener<?> applicationListenercreateApplicationListener(...)addApplicationListener(...)/** Determine whether the given class is an {@code org.springframework} ... */// An unresolvable bean type, probably from a lazy bean - let's ignore it.// An invalid scoped proxy arrangement - let's ignore it.// An unresolvable type in a method signature, probably from a lazy bean - let's ignore it.// Non-empty set of methodsimport ApplicationEventPublisherimport ApplicationEventPublisherAware/** {@link MethodInterceptor Interceptor} that publishes an ... */Constructor<?> applicationEventClassConstructor, ...;ApplicationEventPublisher applicationEventPublisher, ...;/** Set the application event class to publish. ... */this.applicationEventClassConstructorthis.applicationEventPublisherApplicationEvent event/** Extended variant of the standard {@link ApplicationListener} interface, ... *//** Determine whether this listener actually supports the given event type. ... *//** Determine whether this listener actually supports the given source type. ... *//** Determine this listener's order in a set of listeners for the same event. ... *//** {@link GenericApplicationListener} adapter that determines supported event types ... */new ConcurrentReferenceHashMap<Class<?>,ResolvableType>(...)Map<Class<?>,ResolvableType> eventTypeCache, ...;ApplicationListener<ApplicationEvent> delegate, ...;ResolvableType declaredEventType, ...;/** Create a new GenericApplicationListener for the given delegate. ... */this.declaredEventTypeonApplicationEvent(...)Class<? extends ApplicationEvent> eventClass/** Simple implementation of the {@link ApplicationEventMulticaster} interface. ... */Executor taskExecutor, ...;Log lazyLogger, ...;/** Create a new SimpleApplicationEventMulticaster. *//** Create a new SimpleApplicationEventMulticaster for the given BeanFactory. *//** Set a custom executor (typically a {@link org.springframework.core.task.TaskExecutor}) ... */this.taskExecutor/** Return the current task executor for this multicaster. *//** Set the {@link ErrorHandler} to invoke in case an exception is thrown ... *//** Return the current error handler for this multicaster. ... */multicastEvent(...)resolveDefaultEventType(...)ResolvableType typeExecutor executorgetTaskExecutor(...)new Runnable(...) { ... }invokeListener(...)/** Invoke the given listener with the given event. ... */ErrorHandler errorHandlerdoInvokeListener(...)Throwable errClassCastException exmatchesClassCastMessage(...)Log loggerToUsethis.lazyLoggerint moduleSeparatorIndex// Possibly a lambda-defined listener which we could not resolve the generic event type for// -> let's suppress the exception.// On Java 8, the message starts with the class name: "java.lang.String cannot be cast..."// On Java 11, the message starts with "class ..." a.k.a. Class.toString()// On Java 9, the message used to contain the module name: "java.base/java.lang.String cannot be cast..."// Assuming an unrelated class cast failure.../** {@link org.springframework.context.ApplicationListener} decorator that filters ... */GenericApplicationListener delegate, ...;/** Create a SourceFilteringListener for the given event source. ... *//** Create a SourceFilteringListener for the given event source, ... */onApplicationEventInternal(...)forType(...)/** Actually process the event, after having filtered according to the ... *//** Support classes for application events, like standard context events. ... *//** Represent an {@link AnnotatedElement} on a particular {@link Class} ... */AnnotatedElement element, ...;/** Create a new instance with the specified {@link AnnotatedElement} and ... */this.elementAnnotatedElementKey otherKeyotherKey.elementotherKey.targetClassother.elementimport AccessExceptionimport TypedValue/** EL property accessor that knows how to traverse the beans and contextual objects ... */containsObject(...)new TypedValue(...)new AccessException(...)/** EL property accessor that knows how to traverse the beans of a ... */import BeanResolver/** EL bean resolver that operates against a Spring ... *//** Create a new {@link BeanFactoryResolver} for the given factory. ... */import SpelExpressionParser/** Shared utility class used to evaluate and cache SpEL expressions that ... */SpelExpressionParser parser, ...;/** Create a new instance with the specified {@link SpelExpressionParser}. */this.parser/** Create a new instance with a default {@link SpelExpressionParser}. */new SpelExpressionParser(...)/** Return the {@link SpelExpressionParser} to use. *//** Return a shared parameter name discoverer which caches data internally. ... *//** Return the {@link Expression} for the specified SpEL value ... */ExpressionKey expressionKeycreateKey(...)Expression exprparseExpression(...)getParser(...)new ExpressionKey(...)/** An expression key. */AnnotatedElementKey element, ...;ExpressionKey otherKeyotherKey.expressionother.expression/** Read-only EL property accessor that knows how to retrieve keys ... *//** Can read any {@link Environment}, thus always returns true. ... *//** Access the given target object by resolving the given property name against the given target ... *//** Read-only: returns {@code false}. *//** Read-only: no-op. */import MethodVisitorimport CodeFlowimport CompilablePropertyAccessor/** EL property accessor that knows how to traverse the keys ... */new MapAccessException(...)String descriptorlastDescriptor(...)loadTarget(...)insertCheckCast(...)visitLdcInsn(...)visitMethodInsn(...)/** Exception thrown from {@code read} in order to reset a cached ... */import StandardEvaluationContext/** A method-based {@link org.springframework.expression.EvaluationContext} that ... */boolean argumentsLoaded, ...;Object variablethis.argumentsLoadedlazyLoadArguments(...)int argsCount// Shortcut if no args need to be loaded// Expose indexed variables as well as parameter names (if discoverable)// Expose remaining arguments as vararg array for last parameter// Actual argument found - otherwise left as nullimport BeanExpressionExceptionimport ExpressionParserimport SpelParserConfigurationimport StandardTypeConverterimport StandardTypeLocator/** Standard implementation of the ... */new ConcurrentHashMap<String,Expression>(...)new ConcurrentHashMap<BeanExpressionContext,StandardEvaluationContext>(...)new ParserContext(...) { ... }String DEFAULT_EXPRESSION_PREFIX, ...;/** Default expression prefix: "#{". */String DEFAULT_EXPRESSION_SUFFIX, ...;/** Default expression suffix: "}". */String expressionPrefix, ...;String expressionSuffix, ...;ExpressionParser expressionParser, ...;Map<String,Expression> expressionCache, ...;Map<BeanExpressionContext,StandardEvaluationContext> evaluationCache, ...;ParserContext beanExpressionParserContext, ...;/** Create a new {@code StandardBeanExpressionResolver} with default settings. */this.expressionParser/** Create a new {@code StandardBeanExpressionResolver} with the given bean class loader, ... */new SpelParserConfiguration(...)/** Set the prefix that an expression string starts with. ... */this.expressionPrefix/** Set the suffix that an expression string ends with. ... */this.expressionSuffix/** Specify the EL parser to use for expression parsing. ... */this.expressionCacheStandardEvaluationContext secthis.evaluationCachethis.beanExpressionParserContextaddPropertyAccessor(...)new BeanExpressionContextAccessor(...)new BeanFactoryAccessor(...)new MapAccessor(...)new EnvironmentAccessor(...)setTypeLocator(...)new StandardTypeLocator(...)new StandardTypeConverter(...)customizeEvaluationContext(...)new BeanExpressionException(...)/** Template method for customizing the expression evaluation context. ... *//** Expression parsing support within a Spring application context. *//** Strategy interface for determining the current Locale. ... *//** Return the current Locale, which can be fixed or determined dynamically, ... */import NamedInheritableThreadLocal/** Simple holder class that associates a LocaleContext instance ... */new NamedThreadLocal<LocaleContext>(...)new NamedInheritableThreadLocal<LocaleContext>(...)ThreadLocal<LocaleContext> localeContextHolder, ...;ThreadLocal<LocaleContext> inheritableLocaleContextHolder, ...;Locale defaultLocale, ...;// Shared default locale at the framework levelTimeZone defaultTimeZone, ...;// Shared default time zone at the framework level/** Reset the LocaleContext for the current thread. *//** Associate the given LocaleContext with the current thread, ... */setLocaleContext(...)/** Associate the given LocaleContext with the current thread. ... */resetLocaleContext(...)/** Return the LocaleContext associated with the current thread, if any. ... */LocaleContext localeContext/** Associate the given Locale with the current thread, ... */setLocale(...)getLocaleContext(...)TimeZone timeZonegetTimeZone(...)new SimpleTimeZoneAwareLocaleContext(...)new SimpleLocaleContext(...)/** Set a shared default locale at the framework level, ... */LocaleContextHolder.defaultLocale/** Return the Locale associated with the current thread, if any, ... */getLocale(...)/** Return the Locale associated with the given user context, if any, ... *//** Associate the given TimeZone with the current thread, ... */setTimeZone(...)/** Set a shared default time zone at the framework level, ... *//** Return the TimeZone associated with the current thread, if any, ... *//** Return the TimeZone associated with the given user context, if any, ... *//** Simple implementation of the {@link LocaleContext} interface, ... */Locale locale, ...;/** Create a new SimpleLocaleContext that exposes the specified Locale. ... */this.locale/** Simple implementation of the {@link TimeZoneAwareLocaleContext} interface, ... */TimeZone timeZone, ...;/** Create a new SimpleTimeZoneAwareLocaleContext that exposes the specified ... */this.timeZone/** Extension of {@link LocaleContext}, adding awareness of the current time zone. ... *//** Return the current TimeZone, which can be fixed or determined dynamically, ... *//** Abstraction for determining the current Locale, ... */import AntPathMatcher/** Provide access to the candidates that are defined in {@code META-INF/spring.components}. ... */new AntPathMatcher(...)AntPathMatcher pathMatcher, ...;MultiValueMap<String,Entry> index, ...;parseIndex(...)MultiValueMap<String,Entry> indexnew LinkedMultiValueMap<String,Entry>(...)Properties entryString[] stereotypessplit(...)/** Return the candidate types that are associated with the specified stereotype. ... */List<Entry> candidatesparallelStream(...)new Predicate<Entry>(...) { ... }new Function<Entry,String>(...) { ... }t.typeString packageName, ...;this.packageNameisPattern(...)/** Candidate components index loading mechanism for internal use within the framework. ... */CandidateComponentsIndexLoader.classnew ConcurrentReferenceHashMap<ClassLoader,CandidateComponentsIndex>(...)String COMPONENTS_RESOURCE_LOCATION, ...;/** The location to look for components. ... */String IGNORE_INDEX, ...;/** System property that instructs Spring to ignore the index, i.e. ... */boolean shouldIgnoreIndex, ...;ConcurrentMap<ClassLoader,CandidateComponentsIndex> cache, ...;/** Load and instantiate the {@link CandidateComponentsIndex} from ... */ClassLoader classLoaderToUsenew Function<ClassLoader,CandidateComponentsIndex>(...) { ... }doLoadIndex(...)Enumeration<URL> urlsList<Properties> resultnew ArrayList<Properties>(...)int totalCountsum(...)mapToInt(...)new ToIntFunction<Properties>(...) { ... }loadProperties(...)new CandidateComponentsIndex(...)/** Support package for reading and managing the components index. *//** This package builds on the beans package to add support for ... */import AtomicBooleanimport CachedIntrospectionResultsimport ResourceEditorRegistrarimport EmbeddedValueResolverAwareimport HierarchicalMessageSourceimport LifecycleProcessorimport MessageSourceimport MessageSourceAwareimport MessageSourceResolvableimport NoSuchMessageExceptionimport ApplicationEventMulticasterimport ContextClosedEventimport ContextRefreshedEventimport ContextStartedEventimport ContextStoppedEventimport SimpleApplicationEventMulticasterimport StandardBeanExpressionResolverimport LoadTimeWeaverAwareimport LoadTimeWeaverAwareProcessor/** Abstract implementation of the {@link org.springframework.context.ApplicationContext} ... */new ArrayList<BeanFactoryPostProcessor>(...)new AtomicBoolean(...)ContextClosedEvent.classString MESSAGE_SOURCE_BEAN_NAME, ...;/** Name of the MessageSource bean in the factory. ... */String LIFECYCLE_PROCESSOR_BEAN_NAME, ...;/** Name of the LifecycleProcessor bean in the factory. ... */String APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ...;/** Name of the ApplicationEventMulticaster bean in the factory. ... *//** Logger used by this class. Available to subclasses. *//** Unique id for this context, if any. */String displayName, ...;/** Display name. */ApplicationContext parent, ...;/** Parent context. */ConfigurableEnvironment environment, ...;/** Environment used by this context. */List<BeanFactoryPostProcessor> beanFactoryPostProcessors, ...;/** BeanFactoryPostProcessors to apply on refresh. */long startupDate, ...;/** System time in milliseconds when this context started. */AtomicBoolean active, ...;/** Flag that indicates whether this context is currently active. */AtomicBoolean closed, ...;/** Flag that indicates whether this context has been closed already. */Object startupShutdownMonitor, ...;/** Synchronization monitor for the "refresh" and "destroy". */Thread shutdownHook, ...;/** Reference to the JVM shutdown hook, if registered. *//** ResourcePatternResolver used by this context. */LifecycleProcessor lifecycleProcessor, ...;/** LifecycleProcessor for managing the lifecycle of beans within this context. */MessageSource messageSource, ...;/** MessageSource we delegate our implementation of this interface to. */ApplicationEventMulticaster applicationEventMulticaster, ...;/** Helper class used in event publishing. *//** Statically specified listeners. */Set<ApplicationListener<?>> earlyApplicationListeners, ...;/** Local listeners registered before refresh. */Set<ApplicationEvent> earlyApplicationEvents, ...;/** ApplicationEvents published before the multicaster setup. *//** Create a new AbstractApplicationContext with no parent. *//** Create a new AbstractApplicationContext with the given parent context. ... */// Implementation of ApplicationContext interface/** Set a friendly name for this context. ... */this.displayNamecreateEnvironment(...)/** Create and return a new {@link StandardEnvironment}. ... *//** Return this context's internal bean factory as AutowireCapableBeanFactory, ... *//** Return the timestamp (ms) when this context was first loaded. */this.startupDate/** Publish the given event to all listeners. ... */ApplicationEvent applicationEventnew PayloadApplicationEvent<Object>(...)this.earlyApplicationEventsgetApplicationEventMulticaster(...)/** Return the internal ApplicationEventMulticaster used by the context. ... */this.applicationEventMulticaster/** Return the internal LifecycleProcessor used by the context. ... */this.lifecycleProcessor/** Return the ResourcePatternResolver to use for resolving location patterns ... */// Implementation of ConfigurableApplicationContext interfaceEnvironment parentEnvironmentthis.beanFactoryPostProcessors/** Return the list of BeanFactoryPostProcessors that will get applied ... *//** Return the list of statically specified ApplicationListeners. */this.startupShutdownMonitorStartupStep contextRefreshobtainFreshBeanFactory(...)prepareRefresh(...)prepareBeanFactory(...)StartupStep beanPostProcessinvokeBeanFactoryPostProcessors(...)registerBeanPostProcessors(...)initMessageSource(...)initApplicationEventMulticaster(...)onRefresh(...)registerListeners(...)finishBeanFactoryInitialization(...)finishRefresh(...)destroyBeans(...)cancelRefresh(...)resetCommonCaches(...)/** Prepare this context for refreshing, setting its startup date and ... */this.closedinitPropertySources(...)validateRequiredProperties(...)this.earlyApplicationListenersnew LinkedHashSet<ApplicationEvent>(...)/** <p>Replace any stub property sources with actual instances. ... *//** Tell the subclass to refresh the internal bean factory. ... */refreshBeanFactory(...)/** Configure the factory's standard context characteristics, ... */new StandardBeanExpressionResolver(...)new ResourceEditorRegistrar(...)new ApplicationContextAwareProcessor(...)EnvironmentAware.classEmbeddedValueResolverAware.classResourceLoaderAware.classApplicationEventPublisherAware.classMessageSourceAware.classApplicationContextAware.classApplicationStartup.classApplicationEventPublisher.classApplicationContext.classnew ApplicationListenerDetector(...)new LoadTimeWeaverAwareProcessor(...)new ContextTypeMatchClassLoader(...)getSystemProperties(...)getSystemEnvironment(...)/** Instantiate and invoke all registered BeanFactoryPostProcessor beans, ... */getBeanFactoryPostProcessors(...)/** Instantiate and register all BeanPostProcessor beans, ... *//** Initialize the MessageSource. ... */this.messageSourceMessageSource.classHierarchicalMessageSource hmsgetParentMessageSource(...)setParentMessageSource(...)getInternalParentMessageSource(...)DelegatingMessageSource dmsnew DelegatingMessageSource(...)/** Initialize the ApplicationEventMulticaster. ... */ApplicationEventMulticaster.classnew SimpleApplicationEventMulticaster(...)/** Initialize the LifecycleProcessor. ... */LifecycleProcessor.classDefaultLifecycleProcessor defaultProcessornew DefaultLifecycleProcessor(...)/** Template method which can be overridden to add context-specific refresh work. ... *//** Add beans that implement ApplicationListener as listeners. ... */String[] listenerBeanNamesSet<ApplicationEvent> earlyEventsToProcessaddApplicationListenerBean(...)ApplicationEvent earlyEvent/** Finish the initialization of this context's bean factory, ... */String[] weaverAwareNamesLoadTimeWeaverAware.classConversionService.classhasEmbeddedValueResolver(...)new StringValueResolver(...) { ... }String weaverAwareName/** Finish the refresh of this context, invoking the LifecycleProcessor's ... */clearResourceCaches(...)initLifecycleProcessor(...)getLifecycleProcessor(...)new ContextRefreshedEvent(...)registerApplicationContext(...)/** Cancel this context's refresh attempt, resetting the {@code active} flag ... *//** Reset Spring's common reflection metadata caches, in particular the ... *//** Register a shutdown hook {@linkplain Thread#getName() named} ... */this.shutdownHooknew Thread(...) { ... }doClose(...)addShutdownHook(...)getRuntime(...)/** Callback for destruction of this instance, originally attached ... *//** Close this application context, destroying all beans in its bean factory. ... */removeShutdownHook(...)/** Actually performs context closing: publishes a ContextClosedEvent and ... */compareAndSet(...)unregisterApplicationContext(...)new ContextClosedEvent(...)onClose(...)closeBeanFactory(...)/** Template method for destroying all beans that this context manages. ... *//** Template method which can be overridden to add context-specific shutdown work. ... *//** Assert that this context's BeanFactory is currently active, ... */assertBeanFactoryActive(...)/** Return the internal bean factory of the parent context if it implements ... */// Implementation of MessageSource interfacegetMessageSource(...)/** Return the internal MessageSource used by the context. ... *//** Return the internal message source of the parent context if it is an ... */(...).messageSource// Implementation of ResourcePatternResolver interface// Implementation of Lifecycle interfacenew ContextStartedEvent(...)new ContextStoppedEvent(...)/** Subclasses must implement this method to perform the actual configuration load. ... */// Abstract methods that must be implemented by subclasses/** Subclasses must implement this method to release their internal bean factory. ... *//** Subclasses must return their internal bean factory here. They should implement the ... *//** Return information about this context. */ApplicationContext parentgetStartupDate(...)// Eagerly load the ContextClosedEvent class to avoid weird classloader issues// on application shutdown in WebLogic 8.1. (Reported by Dustin Woods.)// Decorate event as an ApplicationEvent if necessary// Multicast right now if possible - or lazily once the multicaster is initialized// Publish event via parent context as well...// Prepare this context for refreshing.// Tell the subclass to refresh the internal bean factory.// Prepare the bean factory for use in this context.// Allows post-processing of the bean factory in context subclasses.// Invoke factory processors registered as beans in the context.// Register bean processors that intercept bean creation.// Initialize message source for this context.// Initialize event multicaster for this context.// Initialize other special beans in specific context subclasses.// Check for listener beans and register them.// Instantiate all remaining (non-lazy-init) singletons.// Last step: publish corresponding event.// Destroy already created singletons to avoid dangling resources.// Reset 'active' flag.// Propagate exception to caller.// Reset common introspection caches in Spring's core, since we// might not ever need metadata for singleton beans anymore...// Switch to active.// Initialize any placeholder property sources in the context environment.// Validate that all properties marked as required are resolvable:// see ConfigurablePropertyResolver#setRequiredProperties// Store pre-refresh ApplicationListeners...// Reset local application listeners to pre-refresh state.// Allow for the collection of early ApplicationEvents,// to be published once the multicaster is available...// For subclasses: do nothing by default.// Tell the internal bean factory to use the context's class loader etc.// Configure the bean factory with context callbacks.// BeanFactory interface not registered as resolvable type in a plain factory.// MessageSource registered (and found for autowiring) as a bean.// Register early post-processor for detecting inner beans as ApplicationListeners.// Detect a LoadTimeWeaver and prepare for weaving, if found.// Set a temporary ClassLoader for type matching.// Register default environment beans.// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)// Make MessageSource aware of parent MessageSource.// Only set parent context as parent MessageSource if no parent MessageSource// registered already.// Use empty MessageSource to be able to accept getMessage calls.// Register statically specified listeners first.// uninitialized to let post-processors apply to them!// Publish early application events now that we finally have a multicaster...// Initialize conversion service for this context.// Register a default embedded value resolver if no bean post-processor// (such as a PropertyPlaceholderConfigurer bean) registered any before:// at this point, primarily for resolution in annotation attribute values.// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.// Stop using the temporary ClassLoader for type matching.// Allow for caching all bean definition metadata, not expecting further changes.// Clear context-level resource caches (such as ASM metadata from scanning).// Initialize lifecycle processor for this context.// Propagate refresh to lifecycle processor first.// Publish the final event.// Participate in LiveBeansView MBean, if active.// No shutdown hook registered yet.// If we registered a JVM shutdown hook, we don't need it anymore now:// We've already explicitly closed the context.// ignore - VM is already shutting down// Check whether an actual close attempt is necessary...// Publish shutdown event.// Stop all Lifecycle beans, to avoid delays during individual destruction.// Destroy all cached singletons in the context's BeanFactory.// Close the state of this context itself.// Let subclasses do some final clean-up if they wish...// Switch to inactive.import MessageFormat/** Abstract implementation of the {@link HierarchicalMessageSource} interface, ... */MessageSource parentMessageSource, ...;Properties commonMessages, ...;boolean useCodeAsDefaultMessage, ...;this.parentMessageSource/** Specify locale-independent common messages, with the message code as key ... */this.commonMessages/** Return a Properties object defining locale-independent common messages, if any. *//** Set whether to use the message code as default message instead of ... */this.useCodeAsDefaultMessage/** Return whether to use the message code as default message instead of ... */getMessageInternal(...)getDefaultMessage(...)renderDefaultMessage(...)String fallbacknew NoSuchMessageException(...)String[] codesgetCodes(...)String defaultMessageString codeString messagecodes.length/** Resolve the given code and arguments as message in the given Locale, ... */Properties commonMessagesgetCommonMessages(...)isAlwaysUseMessageFormat(...)resolveCodeWithoutArguments(...)MessageFormat messageFormatresolveCode(...)String commonMessageformatMessage(...)getMessageFromParent(...)/** Try to retrieve the given message from the parent {@code MessageSource}, if any. ... */MessageSource parent/** Get a default message for the given {@code MessageSourceResolvable}. ... */shouldRenderDefaultMessage(...)/** Return a fallback default message for the given code, if any. ... */isUseCodeAsDefaultMessage(...)/** Searches through the given array of objects, finds any MessageSourceResolvable ... */List<Object> resolvedArgs/** Subclasses can override this method to resolve a message without arguments ... *//** Subclasses must implement this method to resolve a message. ... */// Optimized resolution: no arguments to apply,// therefore no MessageFormat needs to be involved.// Note that the default implementation still uses MessageFormat;// this can be overridden in specific subclasses.// Resolve arguments eagerly, for the case where the message// is defined in a parent MessageSource but resolvable arguments// are defined in the child MessageSource.// Check locale-independent common messages for the given message code.// Not found -> check parent, if any.// Call internal method to avoid getting the default code back// in case of "useCodeAsDefaultMessage" being activated.// Check parent MessageSource, returning null if not found there.// Covers custom MessageSource impls and DelegatingMessageSource.// Not found in parent either.// Given default message does not contain any argument placeholders// (and isn't escaped for alwaysUseMessageFormat either) -> return as-is.// Never format a code-as-default-message, even with alwaysUseMessageFormat=trueimport ApplicationContextException/** Base class for {@link org.springframework.context.ApplicationContext} ... */Boolean allowBeanDefinitionOverriding, ...;Boolean allowCircularReferences, ...;/** Bean factory for this context. *//** Create a new AbstractRefreshableApplicationContext with no parent. *//** Create a new AbstractRefreshableApplicationContext with the given parent context. ... *//** This implementation performs an actual refresh of this context's underlying ... */hasBeanFactory(...)createBeanFactory(...)customizeBeanFactory(...)new ApplicationContextException(...)/** Determine whether this context currently holds a bean factory, ... *//** Overridden to turn it into a no-op: With AbstractRefreshableApplicationContext, ... *//** Create an internal bean factory for this context. ... */getInternalParentBeanFactory(...)/** Customize the internal bean factory used by this context. ... */setAllowCircularReferences(...)/** Load bean definitions into the given bean factory, typically through ... *//** {@link AbstractRefreshableApplicationContext} subclass that adds common handling ... */...[] configLocations, ...;boolean setIdCalled, ...;/** Create a new AbstractRefreshableConfigApplicationContext with no parent. *//** Create a new AbstractRefreshableConfigApplicationContext with the given parent context. ... *//** Set the config locations for this application context in init-param style, ... */setConfigLocations(...)/** Set the config locations for this application context. ... */this.configLocationsresolvePath(...)/** Return an array of resource locations, referring to the XML bean definition ... */getDefaultConfigLocations(...)/** Return the default config locations to use, for the case where no ... *//** Resolve the given path, replacing placeholders with corresponding ... */setId(...)this.setIdCalled/** Sets the id of this context to the bean name by default, ... *//** Triggers {@link #refresh()} if not refreshed in the concrete context's ... */isActive(...)/** Abstract base class for {@code MessageSource} implementations based on ... */Set<String> basenameSet, ...;String defaultEncoding, ...;boolean fallbackToSystemLocale, ...;long cacheMillis, ...;/** Set a single basename, following the basic ResourceBundle convention ... */setBasenames(...)/** Set an array of basenames, each following the basic ResourceBundle convention ... */this.basenameSetaddBasenames(...)/** Add the specified basenames to the existing basename configuration. ... */String basename/** Return this {@code MessageSource}'s basename set, containing entries ... *//** Set the default charset to use for parsing properties files. ... */this.defaultEncoding/** Return the default charset to use for parsing properties files, if any. ... *//** Set whether to fall back to the system Locale if no files for a specific ... */this.fallbackToSystemLocale/** Return whether to fall back to the system Locale if no files for a specific ... *//** Specify a default Locale to fall back to, as an alternative to falling back ... */this.defaultLocale/** Determine a default Locale to fall back to: either a locally specified default ... *//** Set the number of seconds to cache loaded properties files. ... */this.cacheMillis/** Set the number of milliseconds to cache loaded properties files. ... *//** Return the number of milliseconds to cache loaded properties files. ... */import ResourceEntityResolver/** Convenient base class for {@link org.springframework.context.ApplicationContext} ... */boolean validating, ...;/** Create a new AbstractXmlApplicationContext with no parent. *//** Create a new AbstractXmlApplicationContext with the given parent context. ... *//** Set whether to use XML validation. Default is {@code true}. */this.validating/** Loads the bean definitions via an XmlBeanDefinitionReader. ... */XmlBeanDefinitionReader beanDefinitionReaderinitBeanDefinitionReader(...)/** Initialize the bean definition reader used for loading the bean ... *//** Load the bean definitions with the given XmlBeanDefinitionReader. ... */Resource[] configResourcesgetConfigResources(...)String[] configLocationsgetConfigLocations(...)/** Return an array of Resource objects, referring to the XML bean definition ... */// Create a new XmlBeanDefinitionReader for the given BeanFactory.// Configure the bean definition reader with this context's// resource loading environment.// Allow a subclass to provide custom initialization of the reader,// then proceed with actually loading the bean definitions./** {@link BeanPostProcessor} implementation that supplies the {@code ApplicationContext}, ... *//** Create a new ApplicationContextAwareProcessor for the given context. */invokeAwareInterfaces(...)setEmbeddedValueResolver(...)setApplicationEventPublisher(...)setMessageSource(...)setApplicationStartup(...)setApplicationContext(...)/** {@code BeanPostProcessor} that detects beans which implement the {@code ApplicationListener} ... */new ConcurrentHashMap<String,Boolean>(...)ApplicationListenerDetector.classAbstractApplicationContext applicationContext, ...;Map<String,Boolean> singletonNames, ...;this.singletonNamesBoolean flagApplicationEventMulticaster multicasterremoveApplicationListener(...)removeApplicationListenerBean(...)(...).applicationContext// potentially not detected as a listener by getBeanNamesForType retrieval// singleton bean (top-level or inner): register on the fly// inner bean with other scope - can't reliably process events// ApplicationEventMulticaster not initialized yet - no need to remove a listener/** Convenient superclass for application objects that want to be aware of ... *//** Logger that is available to subclasses. *//** ApplicationContext this object runs in. */MessageSourceAccessor messageSourceAccessor, ...;/** MessageSourceAccessor for easy message access. */isContextRequired(...)this.messageSourceAccessorrequiredContextClass(...)new MessageSourceAccessor(...)initApplicationContext(...)/** Determine whether this application object needs to run in an ApplicationContext. ... *//** Determine the context class that any context passed to ... *//** Subclasses can override this for custom initialization behavior. ... *//** Return the ApplicationContext that this object is associated with. ... *//** Obtain the ApplicationContext for actual use. ... */ApplicationContext applicationContextgetApplicationContext(...)/** Return a MessageSourceAccessor for the application context ... */// Reset internal context state.// Initialize with passed-in context.// Ignore reinitialization if same context passed in./** Standalone XML application context, taking the context definition files ... */...[] configResources, ...;/** Create a new ClassPathXmlApplicationContext for bean-style configuration. ... *//** Create a new ClassPathXmlApplicationContext, loading the definitions ... *//** Create a new ClassPathXmlApplicationContext with the given parent, ... */this.configResourcespaths.length/** Special variant of an overriding ClassLoader, used for temporary type ... */new ConcurrentHashMap<String,byte[]>(...)registerAsParallelCapable(...)Method findLoadedClassMethod, ...;Map<String,byte[]> bytesCache, ...;/** Cache for byte array per class name. */new ContextOverridingClassLoader(...)defineClass(...)b.length/** ClassLoader to be created for each loaded class. ... */ClassLoader parentisExcluded(...)ContextTypeMatchClassLoader.thisloadBytesForClass(...)bytes.lengthimport ConversionServiceFactory/** A factory providing convenient access to a ConversionService configured with ... */Set<?> converters, ...;GenericConversionService conversionService, ...;/** Configure the set of custom converter objects that should be added: ... */this.converterscreateConversionService(...)registerConverters(...)/** Create the ConversionService instance returned by this factory bean. ... */// implementing FactoryBeanGenericConversionService.classimport CountDownLatchimport TimeUnitimport Phasedimport SmartLifecycle/** Default implementation of the {@link LifecycleProcessor} strategy. ... */long timeoutPerShutdownPhase, ...;boolean running, ...;/** Specify the maximum time allotted in milliseconds for the shutdown of ... */this.timeoutPerShutdownPhase/** Start all registered beans that implement {@link Lifecycle} and are <i>not</i> ... */// Lifecycle implementationstartBeans(...)this.running/** Stop all registered beans that implement {@link Lifecycle} and <i>are</i> ... */stopBeans(...)// Internal helpersMap<String,Lifecycle> lifecycleBeansgetLifecycleBeans(...)Map<Integer,LifecycleGroup> phasesnew TreeMap<Integer,LifecycleGroup>(...)new BiConsumer<String,Lifecycle>(...) { ... }isAutoStartup(...)int phasegetPhase(...)new Function<Integer,LifecycleGroup>(...) { ... }new LifecycleGroup(...)new Consumer<LifecycleGroup>(...) { ... }/** Start the specified bean as part of the given set of Lifecycle beans, ... */Lifecycle beanString[] dependenciesForBeanString dependencydoStart(...)new HashMap<Integer,LifecycleGroup>(...)int shutdownPhaseLifecycleGroup groupList<Integer> keysreverseOrder(...)Integer key/** Stop the specified bean as part of the given set of Lifecycle beans, ... */doStop(...)countDown(...)/** Retrieve all applicable Lifecycle beans: all singletons that have already been created, ... */// overridable hooksMap<String,Lifecycle> beansnew LinkedHashMap<String,Lifecycle>(...)Lifecycle.classString beanNameToRegisterString beanNameToCheckmatchesBeanType(...)SmartLifecycle.class/** Determine the lifecycle phase of the given bean. ... *//** Helper class for maintaining a group of Lifecycle beans that should be started ... */new ArrayList<LifecycleGroupMember>(...)int phase, ...;long timeout, ...;Map<String,? extends Lifecycle> lifecycleBeans, ...;boolean autoStartupOnly, ...;List<LifecycleGroupMember> members, ...;int smartMemberCount, ...;this.phasethis.timeoutthis.lifecycleBeansthis.autoStartupOnlythis.membersnew LifecycleGroupMember(...)this.smartMemberCountLifecycleGroupMember membermember.nameCountDownLatch latchnew CountDownLatch(...)Set<String> countDownBeanNamesnew LinkedHashSet<E>(...)Set<String> lifecycleBeanNamesmember.beanawait(...)TimeUnit.MILLISECONDSinterrupt(...)/** Adapts the Comparable interface onto the lifecycle phase model. */Lifecycle bean, ...;int thisPhaseint otherPhaseother.bean// Don't wait for beans that aren't running...// Already removed: must have been a dependent bean from another phase/** Spring's default implementation of the {@link MessageSourceResolvable} interface. ... */...[] codes, ...;String defaultMessage, ...;/** Create a new DefaultMessageSourceResolvable. ... */this.codesthis.defaultMessage/** Copy constructor: Create a new instance from another resolvable. ... *//** Return the default code of this resolvable, that is, ... */this.codes.length/** Indicate whether the specified default message needs to be rendered for ... *//** Build a default String representation for this MessageSourceResolvable: ... *//** The default implementation exposes the attributes of this MessageSourceResolvable. ... */resolvableToString(...)MessageSourceResolvable otherResolvable/** Empty {@link MessageSource} that delegates all calls to the parent MessageSource. ... *//** Convenient base class for components with a need for embedded value resolution ... *//** Resolve the given embedded value through this instance's {@link StringValueResolver}. ... *//** Create a new FileSystemXmlApplicationContext for bean-style configuration. ... *//** Create a new FileSystemXmlApplicationContext, loading the definitions ... *//** Create a new FileSystemXmlApplicationContext with the given parent, ... *//** Resolve resource paths as file system paths. ... *//** Generic ApplicationContext implementation that holds a single internal ... */boolean customClassLoader, ...;AtomicBoolean refreshed, ...;/** Create a new GenericApplicationContext. ... *//** Create a new GenericApplicationContext with the given DefaultListableBeanFactory. ... *//** Create a new GenericApplicationContext with the given parent. ... *//** Set the parent of this application context, also setting ... *//** Set a ResourceLoader to use for this context. If set, the context will ... *//** This implementation delegates to this context's ResourceLoader if set, ... */// ResourceLoader / ResourcePatternResolver override if necessary/** This implementation delegates to this context's ResourceLoader if it ... */this.customClassLoader/** Do nothing: We hold a single internal BeanFactory and rely on callers ... */// Implementations of AbstractApplicationContext's template methodsthis.refreshed/** Not much to do: We hold a single internal BeanFactory that will never ... *//** Return the single internal BeanFactory held by this context ... *//** Return the underlying bean factory of this context, ... */// Implementation of BeanDefinitionRegistry/** Register a bean from the given bean class, optionally providing explicit ... */// Convenient methods for registering individual beansnew BeanDefinitionCustomizer(...) { ... }/** Register a bean from the given bean class, optionally customizing its ... *//** Register a bean from the given bean class, using the given supplier for ... */ClassDerivedBeanDefinition beanDefinitionnew ClassDerivedBeanDefinition(...)String nameToUse/** {@link RootBeanDefinition} marker subclass for {@code #registerBean} based ... */Constructor<?> primaryCtorConstructor<?>[] publicCtorspublicCtors.length/** An {@link org.springframework.context.ApplicationContext} implementation that extends ... */new GroovyBeanDefinitionReader(...)GroovyBeanDefinitionReader reader, ...;BeanWrapper contextWrapper, ...;/** Create a new GenericGroovyApplicationContext that needs to be ... *//** Create a new GenericGroovyApplicationContext, loading bean definitions ... *//** Exposes the underlying {@link GroovyBeanDefinitionReader} for convenient access ... *//** Delegates the given environment to underlying {@link GroovyBeanDefinitionReader}. ... *//** Load bean definitions from the given Groovy scripts or XML files. ... */resourceNames.length// Implementation of the GroovyObject interfacethis.contextWrapper/** Convenient application context with built-in XML support. ... *//** Create a new GenericXmlApplicationContext that needs to be ... *//** Create a new GenericXmlApplicationContext, loading bean definitions ... *//** Exposes the underlying {@link XmlBeanDefinitionReader} for additional ... *//** Delegates the given environment to underlying {@link XmlBeanDefinitionReader}. ... *//** Load bean definitions from the given XML resources. ... */// Convenient methods for loading XML bean definition filesimport ManagementFactoryimport ObjectName/** Adapter for live beans view exposure, building a snapshot of current beans ... */new LinkedHashSet<ConfigurableApplicationContext>(...)String MBEAN_DOMAIN_PROPERTY_NAME, ...;/** The "MBean Domain" property name. */String MBEAN_APPLICATION_KEY, ...;/** The MBean application key. */Set<ConfigurableApplicationContext> applicationContexts, ...;String applicationName, ...;String mbeanDomainMBeanServer servergetPlatformMBeanServer(...)getApplicationName(...)registerMBean(...)new LiveBeansView(...)new ObjectName(...)unregisterMBean(...)/** Generate a JSON snapshot of current beans and their dependencies, ... */Set<ConfigurableApplicationContext> contextsfindApplicationContexts(...)generateJson(...)/** Find all applicable ApplicationContexts for the current application. ... *//** Actually generate a JSON snapshot of the beans in the given ApplicationContexts. ... */Iterator<ConfigurableApplicationContext> itConfigurableListableBeanFactory bfboolean elementAppendedisBeanEligible(...)appendArray(...)getEscapedResourceDescription(...)/** Determine whether the specified bean is eligible for inclusion in the ... *//** Determine a resource description for the given bean definition and ... */char characterarr.length/** MBean operation interface for the {@link LiveBeansView} feature. ... *//** Generate a JSON snapshot of current beans and their dependencies. */import LocaleContextHolder/** Helper class for easy access to messages from a MessageSource, ... *//** Create a new MessageSourceAccessor, using LocaleContextHolder's locale ... *//** Create a new MessageSourceAccessor, using the given default locale. ... *//** Return the default locale to use if no explicit locale has been given. ... *//** Retrieve the message for the given code and the default Locale. ... */getDefaultLocale(...)/** Retrieve the message for the given code and the given Locale. ... *//** Retrieve the given MessageSourceResolvable (e.g. an ObjectError instance) ... *//** Helper class that allows for accessing a Spring ... *//** Create a new MessageSourceResourceBundle for the given MessageSource and Locale. ... *//** This implementation resolves the code in the MessageSource. ... */NoSuchMessageException ex/** This implementation checks whether the target MessageSource can resolve ... *//** This implementation throws {@code UnsupportedOperationException}, ... *//** This implementation exposes the specified Locale for introspection ... *//** Base class for message source implementations, providing support infrastructure ... */new HashMap<String,Map<Locale,MessageFormat>>(...)new MessageFormat(...)MessageFormat INVALID_MESSAGE_FORMAT, ...;boolean alwaysUseMessageFormat, ...;Map<String,Map<Locale,MessageFormat>> messageFormatsPerMessage, ...;/** Cache to hold already generated MessageFormats per message. ... *//** Set whether to always apply the {@code MessageFormat} rules, ... */this.alwaysUseMessageFormat/** Return whether to always apply the MessageFormat rules, parsing even ... *//** Render the given default message String. The default message is ... *//** Format the given message String, using cached MessageFormats. ... */this.messageFormatsPerMessageMap<Locale,MessageFormat> messageFormatsPerLocalenew HashMap<Locale,MessageFormat>(...)createMessageFormat(...)/** Create a MessageFormat for the given message and Locale. ... *//** Template method for resolving argument objects. ... */// Invalid message format - probably not intended for formatting,// rather using a message structure with no arguments involved...// Silently proceed with raw message if format not enforced.../** Delegate for AbstractApplicationContext's post-processor handling. ... */Set<String> processedBeansString[] postProcessorNamesList<BeanFactoryPostProcessor> priorityOrderedPostProcessorsList<String> orderedPostProcessorNamesList<String> nonOrderedPostProcessorNamesList<BeanFactoryPostProcessor> orderedPostProcessorsList<BeanFactoryPostProcessor> nonOrderedPostProcessorsList<BeanFactoryPostProcessor> regularPostProcessorsList<BeanDefinitionRegistryPostProcessor> registryProcessorsnew ArrayList<BeanDefinitionRegistryPostProcessor>(...)List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessorsBeanDefinitionRegistryPostProcessor.classboolean reiterateBeanFactoryPostProcessor postProcessorBeanDefinitionRegistryPostProcessor registryProcessorpostProcessBeanDefinitionRegistry(...)String ppNamePriorityOrdered.classsortPostProcessors(...)invokeBeanDefinitionRegistryPostProcessors(...)String postProcessorNameint beanProcessorTargetCountpostProcessorNames.lengthgetBeanPostProcessorCount(...)List<BeanPostProcessor> priorityOrderedPostProcessorsnew ArrayList<BeanPostProcessor>(...)List<BeanPostProcessor> internalPostProcessorsList<BeanPostProcessor> orderedPostProcessorsList<BeanPostProcessor> nonOrderedPostProcessorsnew BeanPostProcessorChecker(...)BeanPostProcessor ppComparator<Object> comparatorToUse/** Invoke the given BeanDefinitionRegistryPostProcessor beans. */BeanDefinitionRegistryPostProcessor postProcessorStartupStep postProcessBeanDefRegistry/** Invoke the given BeanFactoryPostProcessor beans. */StartupStep postProcessBeanFactory/** Register the given BeanPostProcessor beans. */addBeanPostProcessors(...)BeanPostProcessor postProcessor/** BeanPostProcessor that logs an info message when a bean is created during ... */BeanPostProcessorChecker.classint beanPostProcessorTargetCount, ...;this.beanPostProcessorTargetCountisInfrastructureBean(...)RootBeanDefinition.ROLE_INFRASTRUCTURE// WARNING: Although it may appear that the body of this method can be easily// refactored to avoid the use of multiple loops and multiple lists, the use// of multiple lists and multiple passes over the names of processors is// intentional. We must ensure that we honor the contracts for PriorityOrdered// and Ordered processors. Specifically, we must NOT cause processors to be// instantiated (via getBean() invocations) or registered in the ApplicationContext// in the wrong order.// Before submitting a pull request (PR) to change this method, please review the// list of all declined PRs involving changes to PostProcessorRegistrationDelegate// to ensure that your proposal does not result in a breaking change:// https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22// Invoke BeanDefinitionRegistryPostProcessors first, if any.// uninitialized to let the bean factory post-processors apply to them!// Separate between BeanDefinitionRegistryPostProcessors that implement// PriorityOrdered, Ordered, and the rest.// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.// Now, invoke the postProcessBeanFactory callback of all processors handled so far.// Invoke factory processors registered with the context instance.// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,// Ordered, and the rest.// skip - already processed in first phase above// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.// Next, invoke the BeanFactoryPostProcessors that implement Ordered.// Finally, invoke all other BeanFactoryPostProcessors.// Clear cached merged bean definitions since the post-processors might have// modified the original metadata, e.g. replacing placeholders in values...// Register BeanPostProcessorChecker that logs an info message when// a bean is created during BeanPostProcessor instantiation, i.e. when// a bean is not eligible for getting processed by all BeanPostProcessors.// Separate between BeanPostProcessors that implement PriorityOrdered,// First, register the BeanPostProcessors that implement PriorityOrdered.// Next, register the BeanPostProcessors that implement Ordered.// Now, register all regular BeanPostProcessors.// Finally, re-register all internal BeanPostProcessors.// Re-register post-processor for detecting inner beans as ApplicationListeners,// moving it to the end of the processor chain (for picking up proxies etc).// Nothing to sort?// Bulk addition is more efficient against our CopyOnWriteArrayList thereimport PlaceholderConfigurerSupportimport ConfigurablePropertyResolverimport PropertiesPropertySourceimport PropertySourcesimport PropertySourcesPropertyResolver/** Specialization of {@link PlaceholderConfigurerSupport} that resolves ${...} placeholders ... */String LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, ...;/** {@value} is the name given to the {@link PropertySource} for the set of ... */String ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, ...;/** {@value} is the name given to the {@link PropertySource} that wraps the ... */MutablePropertySources propertySources, ...;PropertySources appliedPropertySources, ...;/** Customize the set of {@link PropertySources} to be used by this configurer. ... */this.propertySourcesnew MutablePropertySources(...)/** {@code PropertySources} from the given {@link Environment} ... *//** Processing occurs by replacing ${...} placeholders in bean definitions by resolving each ... */new PropertySource<Environment>(...) { ... }PropertySource<?> localPropertySourcenew PropertiesPropertySource(...)this.localOverrideaddFirst(...)new PropertySourcesPropertyResolver(...)this.appliedPropertySourcessetValueSeparator(...)/** Implemented for compatibility with ... *//** Return the property sources that were actually applied during ... */import ReentrantLock/** Spring-specific {@link org.springframework.context.MessageSource} implementation ... */new ConcurrentHashMap<String,Map<Locale,List<String>>>(...)new ConcurrentHashMap<String,PropertiesHolder>(...)new ConcurrentHashMap<Locale,PropertiesHolder>(...)String PROPERTIES_SUFFIX, ...;String XML_SUFFIX, ...;Properties fileEncodings, ...;boolean concurrentRefresh, ...;ConcurrentMap<String,Map<Locale,List<String>>> cachedFilenames, ...;// Cache to hold filename lists per LocaleConcurrentMap<String,PropertiesHolder> cachedProperties, ...;// Cache to hold already loaded properties per filenameConcurrentMap<Locale,PropertiesHolder> cachedMergedProperties, ...;/** Set per-file charsets to use for parsing properties files. ... */this.fileEncodings/** Specify whether to allow for concurrent refresh behavior, i.e. one thread ... */this.concurrentRefresh/** Set the ResourceLoader to use for loading bundle properties files. ... *//** Resolves the given message code as key in the retrieved bundle files, ... */getCacheMillis(...)PropertiesHolder propHoldergetMergedProperties(...)getBasenameSet(...)List<String> filenamescalculateAllFilenames(...)MessageFormat resultgetMessageFormat(...)/** Get a PropertiesHolder that contains the actually visible properties ... */PropertiesHolder mergedHolderthis.cachedMergedPropertiesnewProperties(...)long latestTimestampString[] basenamesPropertiesHolder existingbasenames.lengthgetFileTimestamp(...)new PropertiesHolder(...)/** Calculate all filenames for the given bundle basename and Locale. ... */Map<Locale,List<String>> localeMapthis.cachedFilenamesLocale defaultLocalecalculateFilenamesForLocale(...)List<String> fallbackFilenamesString fallbackFilenameMap<Locale,List<String>> existingnew ConcurrentHashMap<Locale,List<String>>(...)/** Calculate the filenames for the given bundle basename and Locale, ... */String languagegetLanguage(...)String countryString variantgetVariant(...)StringBuilder temp/** Get a PropertiesHolder for the given filename, either from the ... */this.cachedPropertieslong originalTimestampgetRefreshTimestamp(...)PropertiesHolder existingHoldertryLock(...)propHolder.refreshLockrefreshProperties(...)/** Refresh the PropertiesHolder for the given bundle filename. ... */long refreshTimestamplong fileTimestamplastModified(...)setRefreshTimestamp(...)/** Load the properties from the given resource. ... */String resourceFilenameloadFromXml(...)getDefaultEncoding(...)/** Template method for creating a plain new {@link Properties} instance. ... *//** Clear the resource bundle cache. ... *//** Clear the resource bundle caches of this MessageSource and all its ancestors. ... */clearCacheIncludingAncestors(...)/** PropertiesHolder for caching. ... */new ReentrantLock(...)new ConcurrentHashMap<String,Map<Locale,MessageFormat>>(...)long fileTimestamp, ...;long refreshTimestamp, ...;ReentrantLock refreshLock, ...;ConcurrentMap<String,Map<Locale,MessageFormat>> cachedMessageFormats, ...;/** Cache to hold already generated MessageFormats per message code. */this.fileTimestampthis.refreshTimestampMap<Locale,MessageFormat> localeMapthis.cachedMessageFormatsMap<Locale,MessageFormat> existingnew ConcurrentHashMap<Locale,MessageFormat>(...)// Filenames for given Locale// Filenames for default Locale, if any// Entry for fallback locale that isn't already in filenames list.// Filename for default bundle file// Up to date// At this point, we need to refresh...// A populated but stale holder -> could keep using it.// Getting refreshed by another thread already ->// let's return the existing properties for the time being.// Last-modified timestamp of file will just be read if caching with timeout.// Probably a class path resource: cache it forever.// Empty holder representing "not valid".// Resource does not exist.// Empty holder representing "not found".import URLConnectionimport MissingResourceExceptionimport PropertyResourceBundle/** {@link org.springframework.context.MessageSource} implementation that ... */new ConcurrentHashMap<String,Map<Locale,ResourceBundle>>(...)new ConcurrentHashMap<ResourceBundle,Map<String,Map<Locale,MessageFormat>>>(...)new MessageSourceControl(...)ClassLoader bundleClassLoader, ...;Map<String,Map<Locale,ResourceBundle>> cachedResourceBundles, ...;/** Cache to hold loaded ResourceBundles. ... */Map<ResourceBundle,Map<String,Map<Locale,MessageFormat>>> cachedBundleMessageFormats, ...;/** Cache to hold already generated MessageFormats. ... */MessageSourceControl control, ...;setDefaultEncoding(...)/** Set the ClassLoader to load resource bundles with. ... */this.bundleClassLoader/** Return the ClassLoader to load resource bundles with. ... *//** Resolves the given message code as key in the registered resource bundles, ... */Set<String> basenamesgetResourceBundle(...)getStringOrNull(...)/** Return a ResourceBundle for the given basename and Locale, ... */doGetBundle(...)Map<Locale,ResourceBundle> localeMapthis.cachedResourceBundlesnew Function<String,Map<Locale,ResourceBundle>>(...) { ... }new ConcurrentHashMap<Locale,ResourceBundle>(...)MissingResourceException ex/** Obtain the resource bundle for the given basename and Locale. ... */getBundleClassLoader(...)MessageSourceControl controlthis.control/** Load a property-based resource bundle from the given reader. ... */new PropertyResourceBundle(...)/** Load a property-based resource bundle from the given input stream, ... *//** Return a MessageFormat for the given bundle and code, ... */Map<String,Map<Locale,MessageFormat>> codeMapthis.cachedBundleMessageFormatsnew Function<ResourceBundle,Map<String,Map<Locale,MessageFormat>>>(...) { ... }new Function<String,Map<Locale,MessageFormat>>(...) { ... }/** Efficiently retrieve the String value for the specified key, ... *//** Show the configuration of this MessageSource. *//** Custom implementation of {@code ResourceBundle.Control}, adding support ... */ResourceBundle.ControlString bundleNametoBundleName(...)toResourceName(...)boolean reloadFlagnew PrivilegedExceptionAction<InputStream>(...) { ... }URLConnection connectionopenConnection(...)setUseCaches(...)InputStreamReader bundleReaderloadBundle(...)InputStream bundleStreamnewBundle(...)long cacheMillisgetTimeToLive(...)needsReload(...)// Fresh ResourceBundle.getBundle call in order to let ResourceBundle// do its native caching, at the expense of more extensive lookup steps.// Cache forever: prefer locale cache over repeated getBundle calls.// Assume bundle not found// -> do NOT throw the exception to allow for checking parent message source.// Probably in a Jigsaw environment on JDK 9+// Fallback: plain getBundle lookup without Control handle// Assume key not found for some other reason// Special handling of default encoding// Delegate handling of "java.class" format to standard Control/** A simple thread-backed {@link Scope} implementation. ... */new NamedThreadLocal<Map<String,Object>>(...) { ... }SimpleThreadScope.classThreadLocal<Map<String,Object>> threadScope, ...;Map<String,Object> scopethis.threadScopeObject scopedObject// NOTE: Do NOT modify the following to use Map::computeIfAbsent. For details,// see https://github.com/spring-projects/spring-framework/issues/25801./** {@link org.springframework.context.ApplicationContext} implementation ... */StaticMessageSource staticMessageSource, ...;/** Create a new StaticApplicationContext. ... *//** Create a new StaticApplicationContext with the given parent. ... */this.staticMessageSourcenew StaticMessageSource(...)/** Overridden to turn it into a no-op, to be more lenient towards test cases. *//** Return the internal StaticMessageSource used by this context. ... *//** Register a singleton bean with the underlying bean factory. ... *//** Register a prototype bean with the underlying bean factory. ... *//** Associate the given message with the given code. ... */addMessage(...)getStaticMessageSource(...)// Initialize and register a StaticMessageSource./** Simple implementation of {@link org.springframework.context.MessageSource} ... */new HashMap<String,Map<Locale,MessageHolder>>(...)Map<String,Map<Locale,MessageHolder>> messageMap, ...;Map<Locale,MessageHolder> localeMapthis.messageMapMessageHolder holdernew MessageHolder(...)new Function<String,Map<Locale,MessageHolder>>(...) { ... }new HashMap<Locale,MessageHolder>(...)/** Associate the given message values with the given keys as codes. ... */new BiConsumer<String,String>(...) { ... }MessageFormat cachedFormat, ...;this.cachedFormat/** Classes supporting the org.springframework.context package, ... */import ClassFileTransformerimport IllegalClassFormatExceptionimport ClassPreProcessorAgentAdapterimport InstrumentationLoadTimeWeaver/** Post-processor that registers AspectJ's ... */String ASPECTJ_AOP_XML_RESOURCE, ...;/** The {@code aop.xml} resource location. */LoadTimeWeaver loadTimeWeaver, ...;this.loadTimeWeaver/** Enable AspectJ weaving with the given {@link LoadTimeWeaver}. ... */isInstrumentationAvailable(...)new InstrumentationLoadTimeWeaver(...)addTransformer(...)new AspectJClassBypassingClassFileTransformer(...)new ClassPreProcessorAgentAdapter(...)/** ClassFileTransformer decorator that suppresses processing of AspectJ ... */ClassFileTransformer delegate, ...;transform(...)import InstrumentationSavingAgentimport ReflectiveLoadTimeWeaverimport GlassFishLoadTimeWeaverimport JBossLoadTimeWeaverimport TomcatLoadTimeWeaverimport WebLogicLoadTimeWeaverimport WebSphereLoadTimeWeaver/** Default {@link LoadTimeWeaver} bean for use in an application context, ... */LoadTimeWeaver serverSpecificLoadTimeWeavercreateServerSpecificLoadTimeWeaver(...)new ReflectiveLoadTimeWeaver(...)getInstrumentableClassLoader(...)/* This method never fails, allowing to try other possible ways to use an ... */new TomcatLoadTimeWeaver(...)new GlassFishLoadTimeWeaver(...)new JBossLoadTimeWeaver(...)new WebSphereLoadTimeWeaver(...)new WebLogicLoadTimeWeaver(...)removeTransformers(...)getThrowawayClassLoader(...)/** Set the {@link LoadTimeWeaver} of this object's containing ... *//** {@link org.springframework.beans.factory.config.BeanPostProcessor} ... *//** Create a new {@code LoadTimeWeaverAwareProcessor} that will ... *//** Create a new {@code LoadTimeWeaverAwareProcessor} for the given ... *//** Create a new {@code LoadTimeWeaverAwareProcessor}. ... */LoadTimeWeaver ltwLoadTimeWeaver.classsetLoadTimeWeaver(...)/** Load-time weaving support for a Spring application context, building on Spring's ... */import EJBHomeimport EJBObjectimport RemoteConnectFailureExceptionimport RemoteLookupFailureException/** Base class for interceptors proxying remote Stateless Session Beans. ... */boolean refreshHomeOnConnectFailure, ...;boolean homeAsComponent, ...;/** Set whether to refresh the EJB home on connect failure. ... */this.refreshHomeOnConnectFailure/** Check for EJB3-style home object that serves as EJB component directly. */this.homeAsComponentgetCreateMethod(...)/** Fetches an EJB home object and delegates to {@code doInvoke}. ... */RemoteConnectFailureException exhandleRemoteConnectFailure(...)RemoteException exisConnectFailure(...)/** Determine whether the given RMI exception indicates a connect failure. ... */getJndiName(...)refreshAndRetry(...)/** Refresh the EJB home object and retry the given invocation. ... */refreshHome(...)new RemoteLookupFailureException(...)/** Perform the given invocation on the current EJB home. ... *//** Return a new instance of the stateless session bean. ... */Object ejbInstance/** Remove the given EJB instance. ... */// An EJB3 Session Bean...import Contextimport JndiObjectLocator/** Base class for AOP interceptors invoking local or remote Stateless Session Beans. ... */boolean lookupHomeOnStartup, ...;boolean cacheHome, ...;boolean exposeAccessContext, ...;Object cachedHome, ...;/** The EJB's home object, potentially cached. ... */Method createMethod, ...;/** The no-arg create() method required on EJB homes, potentially cached. */Object homeMonitor, ...;/** Set whether to look up the EJB home object on startup. ... */this.lookupHomeOnStartup/** Set whether to cache the EJB home object once it has been located. ... */this.cacheHome/** Set whether to expose the JNDI environment context for all access to the target ... */this.exposeAccessContext/** Fetches EJB home on startup, if necessary. ... *//** Refresh the cached home object, if applicable. ... */this.homeMonitorObject homethis.cachedHomethis.createMethod/** Determine the create method of the given EJB home object. ... */new EjbAccessException(...)/** Return the EJB home object to use. Called for each invocation. ... */isHomeRefreshable(...)/** Return whether the cached EJB home object is potentially ... *//** Prepares the thread context if necessary, and delegates to ... */Context ctxgetJndiTemplate(...)invokeInContext(...)releaseContext(...)/** Perform the given invocation on the current EJB home, ... *//** Invokes the {@code create()} method on the cached EJB home object. ... */getHome(...)Method createMethodToUse// look up EJB home and create method// Cache the EJB create() method that must be declared on the home interface.// Invoke create() method on EJB home object./** Exception that gets thrown when an EJB stub cannot be accessed properly. ... *//** Constructor for EjbAccessException. ... */import CreateExceptionimport EJBLocalHomeimport EJBLocalObject/** Invoker for a local Stateless Session Bean. ... *//** This implementation "creates" a new EJB instance for each invocation. ... */Object ejbgetSessionBeanInstance(...)Method ejbMethodThrowable targetExreleaseSessionBeanInstance(...)/** Return an EJB instance to delegate the call to. ... */newSessionBeanInstance(...)/** Release the given EJB instance. ... */removeSessionBeanInstance(...)// directly implemented// not directly implemented/** Convenient {@link FactoryBean} for local Stateless Session Bean (SLSB) proxies. ... */Class<?> businessInterface, ...;/** The business interface of the EJB we're proxying. *//** EJBLocalObject. *//** Set the business interface of the EJB we're proxying. ... */this.businessInterface/** Return the business interface of the EJB we're proxying. *//** Basic invoker for a remote Stateless Session Bean. ... */boolean cacheSessionBean, ...;Object beanInstance, ...;Object beanInstanceMonitor, ...;/** Set whether to cache the actual session bean object. ... */this.cacheSessionBeaninvokeRemoteMethod(...)RemoteException rexconvertRmiAccessException(...)/** Return an EJB component instance to delegate the call to. ... */this.beanInstanceMonitor/** Reset the cached session bean instance, if necessary. *//** Remove the cached session bean instance, if necessary. *//** Convenient {@link FactoryBean} for remote SLSB proxies. ... *//** EJBObject. *//** This package contains classes that allow easy access to EJBs. ... */import AbstractSimpleBeanDefinitionParserimport static BeanDefinitionParserDelegate.DEFAULT_VALUEimport static BeanDefinitionParserDelegate.LAZY_INIT_ATTRIBUTEimport static BeanDefinitionParserDelegate.TRUE_VALUE/** Abstract base class for BeanDefinitionParsers which build ... */String ENVIRONMENT, ...;String ENVIRONMENT_REF, ...;String JNDI_ENVIRONMENT, ...;Object envValueString envRef// Specific environment settings defined, overriding any shared properties.// Check whether there is a reference to shared environment properties...new JndiLookupBeanDefinitionParser(...)new LocalStatelessSessionBeanDefinitionParser(...)new RemoteStatelessSessionBeanDefinitionParser(...)/** Simple {@link org.springframework.beans.factory.xml.BeanDefinitionParser} implementation that ... */String DEFAULT_REF, ...;String DEFAULT_OBJECT, ...;String defaultValueString defaultRefimport LocalStatelessSessionProxyFactoryBeanimport SimpleRemoteStatelessSessionProxyFactoryBean/** Support package for EJB/Java EE-related configuration, ... *//** A factory that creates formatters to format values of fields annotated with a particular ... *//** The types of fields that may be annotated with the &lt;A&gt; annotation. *//** Get the Printer to print the value of a field of {@code fieldType} annotated with ... *//** Get the Parser to parse a submitted value for a field of {@code fieldType} ... *//** Formats objects of type T. ... *//** Registers {@link Converter Converters} and {@link Formatter Formatters} with ... *//** Register Formatters and Converters with a FormattingConversionService ... */import ConverterRegistry/** A registry of field formatting logic. ... *//** Adds a Printer to print fields of a specific type. ... *//** Adds a Parser to parse fields of a specific type. ... *//** Adds a Formatter to format fields of a specific type. ... *//** Adds a Formatter to format fields of the given type. ... *//** Adds a Printer/Parser pair to format fields of a specific type. ... *//** Adds a Formatter to format fields annotated with a specific format annotation. ... *//** Parses text strings to produce instances of T. ... *//** Parse a text String to produce a T. ... *//** Prints objects of type T for display. ... *//** Print the object of type T for display. ... *//** Declares that a field or method parameter should be formatted as a date or time. ... *//** The style pattern to use to format the field. ... *//** The ISO pattern to use to format the field. ... *//** The custom pattern to use to format the field. ... *//** Common ISO date time format patterns. */new ISO(...)ISO DATE, ...;/** The most common ISO Date Format {@code yyyy-MM-dd}, ... */ISO TIME, ...;/** The most common ISO Time Format {@code HH:mm:ss.SSSXXX}, ... */ISO DATE_TIME, ...;/** The most common ISO DateTime Format {@code yyyy-MM-dd'T'HH:mm:ss.SSSXXX}, ... */ISO NONE, ...;/** Indicates that no ISO-based format pattern should be applied. *//** Declares that a field or method parameter should be formatted as a number. ... *//** Common number format styles. */new Style(...)Style DEFAULT, ...;/** The default format for the annotated type: typically 'number' but possibly ... */Style NUMBER, ...;/** The general-purpose number format for the current locale. */Style PERCENT, ...;/** The percent format for the current locale. */Style CURRENCY, ...;/** The currency format for the current locale. *//** Annotations for declaratively configuring field formatting rules. */import Formatterimport ISO/** A formatter for {@link java.util.Date} types. ... */DateFormat.DEFAULTMap<ISO,String> formatsnew EnumMap<ISO,String>(...)ISO.classISO.DATEISO.TIMEISO.DATE_TIMETimeZone UTC, ...;Map<ISO,String> ISO_PATTERNS, ...;String pattern, ...;int style, ...;String stylePattern, ...;ISO iso, ...;boolean lenient, ...;/** Create a new default DateFormatter. *//** Create a new DateFormatter for the given date pattern. */this.pattern/** Set the pattern to use to format date values. ... *//** Set the ISO format used for this date. ... */this.iso/** Set the style to use to format date values. ... */this.style/** Set the two character to use to format date values. The first character used for ... */this.stylePattern/** Set the TimeZone to normalize the date values into, if any. *//** Specify whether or not parsing is to be lenient. Default is false. ... */this.lenientgetDateFormat(...)DateFormat dateFormatcreateDateFormat(...)setLenient(...)ISO.NONESimpleDateFormat formatint dateStylegetStylePatternForChar(...)int timeStylegetDateTimeInstance(...)getTimeInstance(...)DateFormat.MEDIUMDateFormat.LONGDateFormat.FULLimport Calendarimport FormatterRegistrarimport FormatterRegistry/** Configures basic date formatting for use with Spring, primarily for ... */DateFormatter dateFormatter, ...;/** Set a global date formatter to register. ... */this.dateFormatteraddDateConverters(...)addFormatter(...)addFormatterForFieldType(...)Calendar.classaddFormatterForFieldAnnotation(...)new DateTimeFormatAnnotationFormatterFactory(...)/** Add date converters to the specified registry. ... */new DateToLongConverter(...)new DateToCalendarConverter(...)new CalendarToDateConverter(...)new CalendarToLongConverter(...)new LongToDateConverter(...)new LongToCalendarConverter(...)getTime(...)Calendar calendargetTimeInMillis(...)setTimeInMillis(...)// In order to retain back compatibility we only register Date/Calendar// types when a user defined formatter is specified (see SPR-10105)import EmbeddedValueResolutionSupportimport AnnotationFormatterFactoryimport Parserimport Printerimport DateTimeFormat/** Formats fields annotated with the {@link DateTimeFormat} annotation using a {@link DateFormatter}. ... */Set<Class<?>> fieldTypesSet<Class<?>> FIELD_TYPES, ...;getFormatter(...)DateFormatter formatternew DateFormatter(...)String stylestyle(...)setStylePattern(...)setIso(...)iso(...)import DateTimeZoneimport DateTimeFormatterimport ISODateTimeFormat/** Factory that creates a Joda-Time {@link DateTimeFormatter}. ... */String style, ...;/** Create a new {@code DateTimeFormatterFactory} instance. *//** Create a new {@code DateTimeFormatterFactory} instance. ... *//** Set the ISO format used to format date values. ... *//** Set the two characters to use to format date values, in Joda-Time style. ... *//** Set the {@code TimeZone} to normalize the date values into, if any. ... *//** Create a new {@code DateTimeFormatter} using this factory. ... */createDateTimeFormatter(...)mediumDateTime(...)DateTimeFormatter dateTimeFormatterforPattern(...)date(...)time(...)dateTime(...)forStyle(...)withZone(...)forTimeZone(...)/** {@link FactoryBean} that creates a Joda-Time {@link DateTimeFormatter}. ... */DateTimeFormatter dateTimeFormatter, ...;this.dateTimeFormatterDateTimeFormatter.classimport DateTime/** Parses Joda {@link DateTime} instances using a {@link DateTimeFormatter}. ... */DateTimeFormatter formatter, ...;/** Create a new DateTimeParser. ... */this.formatterparseDateTime(...)import Duration/** {@link Formatter} implementation for a Joda-Time {@link Duration}, ... */import LocalDateimport LocalTimeimport ReadableInstantimport ReadablePartial/** Formats fields annotated with the {@link DateTimeFormat} annotation using Joda-Time. ... */ReadableInstant.classLocalDate.classLocalTime.classDateTimeFormatter formatterReadablePartial.classnew ReadablePartialPrinter(...)new ReadableInstantPrinter(...)new MillisecondInstantPrinter(...)new LocalDateParser(...)new LocalTimeParser(...)new LocalDateTimeParser(...)new DateTimeParser(...)/** Factory method used to create a {@link DateTimeFormatter}. ... */DateTimeFormatterFactory factorynew DateTimeFormatterFactory(...)setStyle(...)// Create the set of field types that may be annotated with @DateTimeFormat.// Note: the 3 ReadablePartial concrete types are registered explicitly since// addFormatterForFieldType rules exist for each of these types// (if we did not do this, the default byType rules for LocalDate, LocalTime,// and LocalDateTime would take precedence over the annotation rule, which// is not what we want)// assumes Calendar->ReadableInstant converter is registered// assumes Date->Long converter is registeredimport Chronologyimport LocaleContextimport TimeZoneAwareLocaleContext/** A context that holds user-specific Joda-Time settings such as the user's ... */Chronology chronology, ...;DateTimeZone timeZone, ...;/** Set the user's chronology (calendar system). */this.chronology/** Return the user's chronology (calendar system), if any. *//** Set the user's time zone. ... *//** Return the user's time zone, if any. *//** Get the DateTimeFormatter with the this context's settings ... */withChronology(...)/** A holder for a thread-local {@link JodaTimeContext} ... */new NamedThreadLocal<JodaTimeContext>(...)ThreadLocal<JodaTimeContext> jodaTimeContextHolder, ...;/** Reset the JodaTimeContext for the current thread. *//** Associate the given JodaTimeContext with the current thread. ... */resetJodaTimeContext(...)/** Return the JodaTimeContext associated with the current thread, if any. ... *//** Obtain a DateTimeFormatter with user-specific settings applied to the given base Formatter. ... */DateTimeFormatter formatterToUsewithLocale(...)JodaTimeContext contextgetJodaTimeContext(...)import Instantimport MutableDateTimeimport DateFormatterRegistrar/** Installs lower-level type converters required to integrate ... *//** Install the converters into the converter registry. ... */new DateTimeToLocalDateConverter(...)new DateTimeToLocalTimeConverter(...)new DateTimeToLocalDateTimeConverter(...)new DateTimeToDateMidnightConverter(...)new DateTimeToMutableDateTimeConverter(...)new DateTimeToInstantConverter(...)new DateTimeToDateConverter(...)new DateTimeToCalendarConverter(...)new DateTimeToLongConverter(...)new DateToReadableInstantConverter(...)new CalendarToReadableInstantConverter(...)new LongToReadableInstantConverter(...)new LocalDateTimeToLocalDateConverter(...)new LocalDateTimeToLocalTimeConverter(...)toLocalDate(...)toLocalTime(...)toLocalDateTime(...)toDateMidnight(...)toMutableDateTime(...)toInstant(...)toDate(...)toGregorianCalendar(...)getMillis(...)/** Used when printing a {@code java.util.Date} field with a ReadableInstantPrinter. ... */new DateTime(...)/** Used when printing a {@code java.util.Calendar} field with a ReadableInstantPrinter. ... *//** Used when printing a Long field with a ReadableInstantPrinter. ... */import MonthDayimport Periodimport YearMonth/** Configures Joda-Time's formatting system for use with Spring. ... */new EnumMap<Type,DateTimeFormatter>(...)Type.classnew Type(...)Type DATE, ...;Type TIME, ...;Type DATE_TIME, ...;Map<Type,DateTimeFormatter> formatters, ...;/** User defined formatters. */Map<Type,DateTimeFormatterFactory> factories, ...;/** Factories used when specific formatters have not been specified. */this.factoriesnew EnumMap<Type,DateTimeFormatterFactory>(...)/** Set whether standard ISO formatting should be applied to all date/time types. ... */Type.DATEType.TIMEType.DATE_TIME/** Set the default format style of Joda {@link LocalDate} objects. ... *//** Set the default format style of Joda {@link LocalTime} objects. ... *//** Set the default format style of Joda {@link LocalDateTime} and {@link DateTime} objects, ... *//** Set the formatter that will be used for objects representing date values. ... */this.formatters/** Set the formatter that will be used for objects representing time values. ... *//** Set the formatter that will be used for objects representing date and time values. ... */DateTimeFormatter dateFormatterDateTimeFormatter timeFormatteraddFormatterForFields(...)Period.classnew PeriodFormatter(...)Duration.classnew DurationFormatter(...)YearMonth.classnew YearMonthFormatter(...)MonthDay.classnew MonthDayFormatter(...)new JodaDateTimeFormatAnnotationFormatterFactory(...)DateTimeFormatter fallbackFormattergetFallbackFormatter(...)shortDate(...)shortTime(...)shortDateTime(...)// In order to retain backwards compatibility we only register Date/Calendar/** Parses Joda {@link org.joda.time.LocalDate} instances using a ... */parseLocalDate(...)/** Parses Joda {@link org.joda.time.LocalDateTime} instances using a ... */parseLocalDateTime(...)/** Parses Joda {@link org.joda.time.LocalTime} instances using a ... */parseLocalTime(...)/** Prints Long instances using a Joda {@link DateTimeFormatter}. ... *//** Create a new ReadableInstantPrinter. ... */print(...)/** {@link Formatter} implementation for a Joda-Time {@link MonthDay}, ... *//** {@link Formatter} implementation for a Joda-Time {@link Period}, ... *//** Prints Joda-Time {@link ReadableInstant} instances using a {@link DateTimeFormatter}. ... *//** Prints Joda-Time {@link ReadablePartial} instances using a {@link DateTimeFormatter}. ... *//** {@link Formatter} implementation for a Joda-Time {@link YearMonth}, ... *//** Integration with Joda-Time for formatting Joda date and time types as well as standard JDK Date types. *//** Formatters for {@code java.util.Date} properties. *//** A context that holds user-specific <code>java.time</code> (JSR-310) settings ... */ZoneId timeZone, ...;toZoneId(...)/** A holder for a thread-local user {@link DateTimeContext}. ... */new NamedThreadLocal<DateTimeContext>(...)ThreadLocal<DateTimeContext> dateTimeContextHolder, ...;/** Reset the DateTimeContext for the current thread. *//** Associate the given DateTimeContext with the current thread. ... */resetDateTimeContext(...)/** Return the DateTimeContext associated with the current thread, if any. ... */DateTimeContext contextgetDateTimeContext(...)import OffsetDateTimeimport ZonedDateTimeimport GregorianCalendarnew ZonedDateTimeToLocalDateConverter(...)new ZonedDateTimeToLocalTimeConverter(...)new ZonedDateTimeToLocalDateTimeConverter(...)new ZonedDateTimeToOffsetDateTimeConverter(...)new ZonedDateTimeToInstantConverter(...)new OffsetDateTimeToLocalDateConverter(...)new OffsetDateTimeToLocalTimeConverter(...)new OffsetDateTimeToLocalDateTimeConverter(...)new OffsetDateTimeToZonedDateTimeConverter(...)new OffsetDateTimeToInstantConverter(...)new CalendarToZonedDateTimeConverter(...)new CalendarToOffsetDateTimeConverter(...)new CalendarToLocalDateConverter(...)new CalendarToLocalTimeConverter(...)new CalendarToLocalDateTimeConverter(...)new CalendarToInstantConverter(...)new LongToInstantConverter(...)new InstantToLongConverter(...)toZonedDateTime(...)ofInstant(...)ofEpochMilli(...)toOffsetDateTime(...)calendarToZonedDateTime(...)toEpochMilli(...)import FormatStyleimport ResolverStyle/** Factory that creates a JSR-310 {@link java.time.format.DateTimeFormatter}. ... */FormatStyle dateStyle, ...;FormatStyle timeStyle, ...;/** Set the style to use for date types. */this.dateStyle/** Set the style to use for time types. */this.timeStyle/** Set the style to use for date and time types. */convertStyleCharacter(...)FormatStyle.SHORTFormatStyle.MEDIUMFormatStyle.LONGFormatStyle.FULLofLocalizedDateTime(...)String patternToUsewithResolverStyle(...)ofPattern(...)ResolverStyle.STRICTDateTimeFormatter.ISO_DATEDateTimeFormatter.ISO_TIMEDateTimeFormatter.ISO_DATE_TIMEofLocalizedDate(...)ofLocalizedTime(...)// Using strict parsing to align with Joda-Time and standard DateFormat behavior:// otherwise, an overflow like e.g. Feb 29 for a non-leap-year wouldn't get rejected.// However, with strict parsing, a year digit needs to be specified as 'u'.../** {@link FactoryBean} that creates a JSR-310 {@link java.time.format.DateTimeFormatter}. ... */import Monthimport OffsetTimeimport Year/** Configures the JSR-310 <code>java.time</code> formatting system for use with Spring. ... *//** User-defined formatters. *//** Set the default format style of {@link java.time.LocalDate} objects. ... */setDateStyle(...)/** Set the default format style of {@link java.time.LocalTime} objects. ... */setTimeStyle(...)/** Set the default format style of {@link java.time.LocalDateTime} objects. ... */setDateTimeStyle(...)DateTimeFormatter dfDateTimeFormatter tfDateTimeFormatter dtfnew TemporalAccessorPrinter(...)new TemporalAccessorParser(...)DateTimeFormatter.ISO_LOCAL_DATEDateTimeFormatter.ISO_LOCAL_TIMEDateTimeFormatter.ISO_LOCAL_DATE_TIMEZonedDateTime.classOffsetDateTime.classOffsetTime.classInstant.classnew InstantFormatter(...)Year.classnew YearFormatter(...)Month.classnew MonthFormatter(...)new Jsr310DateTimeFormatAnnotationFormatterFactory(...)// Efficient ISO_LOCAL_* variants for printing since they are twice as fast.../** {@link Formatter} implementation for a JSR-310 {@link Duration}, ... *//** {@link Formatter} implementation for a JSR-310 {@link java.time.Instant}, ... */isAlphabetic(...)DateTimeFormatter.RFC_1123_DATE_TIME// assuming RFC-1123 value a la "Tue, 3 Jun 2008 11:05:30 GMT"// assuming UTC instant a la "2007-12-03T10:15:30.00Z"import TemporalAccessor/** Formats fields annotated with the {@link DateTimeFormat} annotation using the ... */isLocal(...)/** {@link Formatter} implementation for a JSR-310 {@link MonthDay}, ... *//** {@link Formatter} implementation for a JSR-310 {@link Month}, ... *//** {@link Formatter} implementation for a JSR-310 {@link Period}, ... *//** {@link Parser} implementation for a JSR-310 {@link java.time.temporal.TemporalAccessor}, ... */Class<? extends TemporalAccessor> temporalAccessorType, ...;/** Create a new TemporalAccessorParser for the given TemporalAccessor type. ... */this.temporalAccessorType/** {@link Printer} implementation for a JSR-310 {@link java.time.temporal.TemporalAccessor}, ... *//** Create a new TemporalAccessorPrinter. ... *//** {@link Formatter} implementation for a JSR-310 {@link Year}, ... *//** {@link Formatter} implementation for a JSR-310 {@link YearMonth}, ... *//** Integration with the JSR-310 <code>java.time</code> package in JDK 8. */import ParsePosition/** Abstract formatter for Numbers, ... */getNumberFormat(...)NumberFormat formatParsePosition positionnew ParsePosition(...)Number numbergetErrorIndex(...)new ParseException(...)getIndex(...)/** Obtain a concrete NumberFormat for the specified locale. ... */// indicates a part of the string that was not parsedimport RoundingModeimport DecimalFormat/** A BigDecimal formatter for number values in currency style. ... */int fractionDigits, ...;RoundingMode roundingMode, ...;Currency currency, ...;/** Specify the desired number of fraction digits. ... */this.fractionDigits/** Specify the rounding mode to use for decimal parsing. ... */this.roundingMode/** Specify the currency, if known. */this.currency/** Specify the pattern to use to format number values. ... */BigDecimal decimalsetScale(...)DecimalFormat formatgetCurrencyInstance(...)setParseBigDecimal(...)setMaximumFractionDigits(...)setMinimumFractionDigits(...)setRoundingMode(...)setCurrency(...)applyPattern(...)import Style/** Formats fields annotated with the {@link NumberFormat} annotation. ... */NumberUtils.STANDARD_NUMBER_TYPESconfigureFormatterFrom(...)new NumberStyleFormatter(...)Style styleStyle.CURRENCYnew CurrencyStyleFormatter(...)Style.PERCENTnew PercentStyleFormatter(...)/** A general-purpose number formatter using NumberFormat's number style. ... *//** Create a new NumberStyleFormatter without a pattern. *//** Create a new NumberStyleFormatter with the specified pattern. ... */DecimalFormat decimalFormat/** A formatter for number values in percent style. ... */getPercentInstance(...)import CurrencyUnitimport Monetary/** Formatter for JSR-354 {@link javax.money.CurrencyUnit} values, ... */getCurrency(...)import MonetaryAmountimport CurrencyStyleFormatterimport NumberStyleFormatterimport PercentStyleFormatter/** Formats {@link javax.money.MonetaryAmount} fields annotated ... */String CURRENCY_CODE_PATTERN, ...;MonetaryAmount.classnew PatternDecoratingFormatter(...)Style.NUMBERnew NumberDecoratingFormatter(...)Formatter<Number> numberFormatter, ...;this.numberFormatterCurrencyUnit currencyUnitNumber numberValuesetNumber(...)getDefaultAmountFactory(...)CurrencyStyleFormatter formatterCurrency currencydetermineCurrency(...)// Could not possibly contain a currency code ->// try with locale and likely let it fail on parse.// A pattern without a currency code...import MonetaryAmountFormatimport MonetaryFormats/** Formatter for JSR-354 {@link javax.money.MonetaryAmount} values, ... */String formatName, ...;/** Create a locale-driven MonetaryAmountFormatter. *//** Create a new MonetaryAmountFormatter for the given format name. ... */this.formatName/** Specify the format name, to be resolved by the JSR-354 provider ... */getMonetaryAmountFormat(...)/** Obtain a MonetaryAmountFormat for the given locale. ... */getAmountFormat(...)/** Integration with the JSR-354 <code>javax.money</code> package. *//** Formatters for {@code java.lang.Number} properties. *//** An API for defining Formatters to format field model values for display in a UI. */import DateTimeFormatterRegistrarimport NumberFormatAnnotationFormatterFactoryimport CurrencyUnitFormatterimport Jsr354NumberFormatAnnotationFormatterFactoryimport MonetaryAmountFormatter/** A specialization of {@link FormattingConversionService} configured by default with ... */DefaultFormattingConversionService.classboolean jsr354Present, ...;boolean jodaTimePresent, ...;/** Create a new {@code DefaultFormattingConversionService} with the set of ... */addDefaultConverters(...)addDefaultFormatters(...)/** Add formatters appropriate for most environments: including number formatters, ... */new NumberFormatAnnotationFormatterFactory(...)new CurrencyUnitFormatter(...)new MonetaryAmountFormatter(...)new Jsr354NumberFormatAnnotationFormatterFactory(...)registerFormatters(...)new DateTimeFormatterRegistrar(...)new JodaTimeFormatterRegistrar(...)new DateFormatterRegistrar(...)// Default handling of number values// Default handling of monetary values// Default handling of date-time values// just handling JSR-310 specific date and time types// handles Joda-specific types as well as Date, Calendar, Long// regular DateFormat-based Date, Calendar, Long converters/** Adapter that bridges between {@link Formatter} and {@link PropertyEditor}. ... */Formatter<Object> formatter, ...;/** Create a new {@code FormatterPropertyEditorAdapter} for the given {@link Formatter}. ... *//** Determine the {@link Formatter}-declared field type. ... */getFieldType(...)import ConditionalGenericConverterimport GenericConverter/** A {@link org.springframework.core.convert.ConversionService} implementation ... */new ConcurrentHashMap<AnnotationConverterKey,GenericConverter>(...)Map<AnnotationConverterKey,GenericConverter> cachedPrinters, ...;Map<AnnotationConverterKey,GenericConverter> cachedParsers, ...;Printer<>.classnew PrinterConverter(...)Parser<>.classnew ParserConverter(...)Class<? extends Annotation> annotationTypegetFieldTypes(...)new AnnotationPrinterConverter(...)new AnnotationParserConverter(...)Formatter<>.classgetDecoratedClass(...)AnnotationFormatterFactory<>.classClass<?> fieldType, ...;TypeDescriptor printerObjectType, ...;Printer<> printer, ...;this.fieldTypethis.printerObjectTyperesolvePrinterObjectType(...)this.printernew ConvertiblePair(...)isAssignableTo(...)Parser<?> parser, ...;TypeDescriptor resultTypeAnnotationFormatterFactory<> annotationFormatterFactory, ...;this.annotationFormatterFactoryAnnotationConverterKey converterKeynew AnnotationConverterKey(...)GenericConverter converterPrinter<?> printergetPrinter(...)FormattingConversionService.thisParser<?> parserAnnotation annotation, ...;AnnotationConverterKey otherKeyotherKey.fieldTypeotherKey.annotation/** A factory providing convenient access to a {@code FormattingConversionService} ... */Set<?> formatters, ...;Set<FormatterRegistrar> formatterRegistrars, ...;boolean registerDefaultFormatters, ...;FormattingConversionService conversionService, ...;/** Configure the set of custom converter objects that should be added. ... *//** Configure the set of custom formatter objects that should be added. ... *//** <p>Configure the set of FormatterRegistrars to invoke to register ... */this.formatterRegistrars/** Indicate whether default formatters should be registered or not. ... */this.registerDefaultFormattersnew DefaultFormattingConversionService(...)Object formatterFormatterRegistrar registrarFormattingConversionService.class/** Support classes for the formatting package, ... */import Instrumentation/** {@link LoadTimeWeaver} relying on VM {@link Instrumentation}. ... */new ArrayList<ClassFileTransformer>(...)InstrumentationLoadTimeWeaver.classboolean AGENT_CLASS_PRESENT, ...;Instrumentation instrumentation, ...;List<ClassFileTransformer> transformers, ...;/** Create a new InstrumentationLoadTimeWeaver for the default ClassLoader. *//** Create a new InstrumentationLoadTimeWeaver for the given ClassLoader. ... */this.instrumentationgetInstrumentation(...)FilteringClassFileTransformer actualTransformernew FilteringClassFileTransformer(...)this.transformers/** We have the ability to weave the current class loader when starting the ... *//** This implementation always returns a {@link SimpleThrowawayClassLoader}. *//** Remove all registered transformers, in inverse order of registration. */removeTransformer(...)/** Check whether an Instrumentation instance is available for the current VM. ... *//** Obtain the Instrumentation instance for the current VM, if available. ... *//** Inner class to avoid InstrumentationSavingAgent dependency. *//** Decorator that only applies the given target transformer to a specific ClassLoader. */ClassFileTransformer targetTransformer, ...;ClassLoader targetClassLoader, ...;this.targetTransformerthis.targetClassLoader/** Defines the contract for adding one or more ... *//** Add a {@code ClassFileTransformer} to be applied by this ... *//** Return a {@code ClassLoader} that supports instrumentation ... *//** Return a throwaway {@code ClassLoader}, enabling classes to be ... *//** {@link LoadTimeWeaver} which uses reflection to delegate to an underlying ClassLoader ... */ReflectiveLoadTimeWeaver.classString ADD_TRANSFORMER_METHOD_NAME, ...;String GET_THROWAWAY_CLASS_LOADER_METHOD_NAME, ...;Method addTransformerMethod, ...;Method getThrowawayClassLoaderMethod, ...;/** Create a new ReflectiveLoadTimeWeaver for the current context class ... *//** Create a new SimpleLoadTimeWeaver for the given class loader. ... */Method addTransformerMethodClassFileTransformer.classMethod getThrowawayClassLoaderMethodthis.addTransformerMethodthis.getThrowawayClassLoaderMethodClassLoader target// getThrowawayClassLoader method is optional/** Subclass of ShadowingClassLoader that overrides attempts to ... */new Enumeration<URL>(...) { ... }Enumeration<URL> EMPTY_URL_ENUMERATION, ...;Map<String,String> overrides, ...;/** Key is asked for value: value is actual value. *//** Create a new ResourceOverridingShadowingClassLoader, ... *//** Return the resource (if any) at the new path ... *//** Ensure that a resource with the given path is not found. ... *//** Copy all overrides from the given ClassLoader. ... */String overriddenPathString overriddenLocation/** ClassLoader decorator that shadows an enclosing ClassLoader, ... */new HashMap<String,Class<?>>(...)...[] DEFAULT_EXCLUDED_PACKAGES, ...;/** Packages that are excluded by default. */ClassLoader enclosingClassLoader, ...;List<ClassFileTransformer> classFileTransformers, ...;Map<String,Class<?>> classCache, ...;/** Create a new ShadowingClassLoader, decorating the given ClassLoader, ... *//** Create a new ShadowingClassLoader, decorating the given ClassLoader. ... */this.enclosingClassLoaderString excludedPackageexcludePackage(...)/** Add the given ClassFileTransformer to the list of transformers that this ... */this.classFileTransformers/** Copy all ClassFileTransformers from the given ClassLoader to the list of ... */other.classFileTransformersshouldShadow(...)Class<?> clsthis.classCachedoLoadClass(...)/** Determine whether the given class should be excluded from shadowing. ... */isEligibleForShadowing(...)/** Determine whether the specified class is eligible for shadowing ... */String internalNamenew ClassNotFoundException(...)copyToByteArray(...)applyTransformers(...)int packageSeparatorString packageNamedefinePackage(...)ClassFileTransformer transformerbyte[] transformedIllegalClassFormatException ex// Additional check for defining the package, if not defined yet./** Simplistic implementation of an instrumentable {@code ClassLoader}. ... */WeavingTransformer weavingTransformer, ...;/** Create a new SimpleInstrumentableClassLoader for the given ClassLoader. ... */this.weavingTransformernew WeavingTransformer(...)/** Add a {@link ClassFileTransformer} to be applied by this ClassLoader. ... */transformIfNecessary(...)/** {@code LoadTimeWeaver} that builds and exposes a ... */SimpleInstrumentableClassLoader classLoader, ...;/** Create a new {@code SimpleLoadTimeWeaver} for the current context ... */new SimpleInstrumentableClassLoader(...)/** Create a new {@code SimpleLoadTimeWeaver} for the given ... *//** This implementation builds a {@link SimpleThrowawayClassLoader}. *//** ClassLoader that can be used to load classes without bringing them ... *//** Create a new SimpleThrowawayClassLoader for the given ClassLoader. ... *//** ClassFileTransformer-based weaver, allowing for a list of transformers to be ... *//** Create a new WeavingTransformer for the given class loader. ... *//** Add a class file transformer to be applied by this weaver. ... *//** Apply transformation on a given class byte definition. ... */byte[] resultClassFileTransformer cft/** {@link LoadTimeWeaver} implementation for GlassFish's ... */String INSTRUMENTABLE_LOADER_CLASS_NAME, ...;Method copyMethod, ...;/** Create a new instance of the {@link GlassFishLoadTimeWeaver} class using ... */Class<?> instrumentableLoaderClassClassLoader clazzLoaderthis.copyMethod// Detect transformation-aware ClassLoader by traversing the hierarchy// (as in GlassFish, Spring can be loaded by the WebappClassLoader)./** Support for class instrumentation on GlassFish. */import SimpleThrowawayClassLoader/** {@link LoadTimeWeaver} implementation for JBoss's instrumentable ClassLoader. ... */String DELEGATING_TRANSFORMER_CLASS_NAME, ...;String WRAPPER_TRANSFORMER_CLASS_NAME, ...;Object delegatingTransformer, ...;Method addTransformer, ...;/** Create a new instance of the {@link JBossLoadTimeWeaver} class using ... */Field transformerObject suggestedTransformerMethod addTransformerthis.delegatingTransformerField wrappedTransformerthis.addTransformer/** Support for class instrumentation on JBoss AS 6 and 7. *//** Support package for load time weaving based on class loaders, ... *//** {@link org.springframework.instrument.classloading.LoadTimeWeaver} implementation ... *//** Create a new instance of the {@link TomcatLoadTimeWeaver} class using ... */Method copyMethod// Could still be a custom variant of a convention-compatible ClassLoader// We're on an earlier version of Tomcat, probably with Spring's TomcatInstrumentableClassLoader// Check for Tomcat's new copyWithoutTransformers on InstrumentableClassLoader first// Fallback: expecting TomcatInstrumentableClassLoader's getThrowawayClassLoader/** Support for class instrumentation on Tomcat. *//** Reflective wrapper around a WebLogic 10 class loader. Used to ... */String GENERIC_CLASS_LOADER_NAME, ...;String CLASS_PRE_PROCESSOR_NAME, ...;Class<?> wlPreProcessorClass, ...;Method addPreProcessorMethod, ...;Method getClassFinderMethod, ...;Method getParentMethod, ...;Constructor<?> wlGenericClassLoaderConstructor, ...;Class<?> wlGenericClassLoaderClassthis.wlPreProcessorClassthis.addPreProcessorMethodthis.getClassFinderMethodthis.getParentMethodthis.wlGenericClassLoaderConstructorInvocationHandler adapternew WebLogicClassPreProcessorAdapter(...)Object adapterInstanceObject classFinderObject parent// arguments for 'clone'-like method/** Adapter that implements WebLogic ClassPreProcessor interface, delegating to a ... */ClassFileTransformer transformer, ...;ClassLoader loader, ...;/** Construct a new {@link WebLogicClassPreProcessorAdapter}. */this.transformerthis.loaderinitialize(...)preProcess(...)/** {@link LoadTimeWeaver} implementation for WebLogic's instrumentable ... */WebLogicClassLoaderAdapter classLoader, ...;/** Creates a new instance of the {@link WebLogicLoadTimeWeaver} class using ... */new WebLogicClassLoaderAdapter(...)/** Support for class instrumentation on BEA WebLogic 10+. *//** Reflective wrapper around a WebSphere 7+ class loader. Used to ... */String COMPOUND_CLASS_LOADER_NAME, ...;String PLUGINS_FIELD, ...;Class<?> wsPreProcessorClass, ...;Method addPreDefinePlugin, ...;Constructor<? extends ClassLoader> cloneConstructor, ...;Field transformerList, ...;Class<?> wsCompoundClassLoaderClassthis.cloneConstructorthis.wsPreProcessorClassthis.addPreDefinePluginthis.transformerListnew WebSphereClassPreDefinePlugin(...)ClassLoader loader// Clear out the transformers (copied as well)import CodeSource/** Adapter that implements WebSphere 7.0 ClassPreProcessPlugin interface, ... *//** Create a new {@link WebSphereClassPreDefinePlugin}. ... */String dummyClassDummy.class// First force the full class loading of the weaver by invoking transformation on a dummy class// NB: WebSphere passes className as "." without class while the transformer expects a VM "/" format/** {@link LoadTimeWeaver} implementation for WebSphere's instrumentable ClassLoader. ... */WebSphereClassLoaderAdapter classLoader, ...;/** Create a new instance of the {@link WebSphereLoadTimeWeaver} class using ... */new WebSphereClassLoaderAdapter(...)/** Support for class instrumentation on IBM WebSphere Application Server 7+. *//** General base exception to be thrown on JMX errors. ... *//** Constructor for JmxException. ... *//** Exception thrown when we cannot locate an instance of an {@code MBeanServer}, ... *//** Create a new {@code MBeanServerNotFoundException} with the ... */import MBeanServerConnectionimport JMXConnectorimport JMXConnectorFactoryimport JMXServiceURLimport JmxUtils/** Internal helper class for managing a JMX connector. ... */ConnectorDelegate.classJMXConnector connector, ...;/** Connects to the remote {@code MBeanServer} using the configured {@code JMXServiceURL}: ... */this.connectorconnect(...)getMBeanServerConnection(...)locateMBeanServer(...)/** Closes any {@code JMXConnector} that may be managed by this interceptor. */import JMRuntimeException/** Thrown when trying to invoke an operation on a proxy that is not exposed ... *//** Create a new {@code InvalidInvocationException} with the supplied ... */import JmxException/** Thrown when an invocation on an MBean resource failed with an exception (either ... *//** Create a new {@code InvocationFailureException} with the supplied ... *//** Create a new {@code InvocationFailureException} with the ... */import Attributeimport InstanceNotFoundExceptionimport JMExceptionimport JMXimport MBeanAttributeInfoimport MBeanExceptionimport MBeanInfoimport MBeanOperationInfoimport MBeanServerInvocationHandlerimport MalformedObjectNameExceptionimport OperationsExceptionimport ReflectionExceptionimport RuntimeErrorExceptionimport RuntimeMBeanExceptionimport RuntimeOperationsExceptionimport CompositeDataimport TabularDataimport ObjectNameManager/** {@link org.aopalliance.intercept.MethodInterceptor} that routes calls to an ... */new ConnectorDelegate(...)new HashMap<Method,String[]>(...)MBeanServerConnection server, ...;JMXServiceURL serviceUrl, ...;Map<String,?> environment, ...;String agentId, ...;boolean connectOnStartup, ...;boolean refreshOnConnectFailure, ...;ObjectName objectName, ...;boolean useStrictCasing, ...;Class<?> managementInterface, ...;ConnectorDelegate connector, ...;MBeanServerConnection serverToUse, ...;MBeanServerInvocationHandler invocationHandler, ...;Map<String,MBeanAttributeInfo> allowedAttributes, ...;Map<MethodCacheKey,MBeanOperationInfo> allowedOperations, ...;Map<Method,String[]> signatureCache, ...;Object preparationMonitor, ...;/** Set the {@code MBeanServerConnection} used to connect to the ... */this.server/** Set the service URL of the remote {@code MBeanServer}. */this.serviceUrlnew JMXServiceURL(...)/** Specify the environment for the JMX connector. ... *//** Allow Map access to the environment to be set for the connector, ... *//** Set the agent id of the {@code MBeanServer} to locate. ... */this.agentId/** Set whether or not the proxy should connect to the {@code MBeanServer} ... */this.connectOnStartup/** Set whether to refresh the MBeanServer connection on connect failure. ... */this.refreshOnConnectFailure/** Set the {@code ObjectName} of the MBean which calls are routed to, ... */this.objectName/** Set whether to use strict casing for attributes. Enabled by default. ... */this.useStrictCasing/** Set the management interface of the target MBean, exposing bean property ... */this.managementInterface/** Return the management interface of the target MBean, ... *//** Prepares the {@code MBeanServerConnection} if the "connectOnStartup" ... *//** Ensures that an {@code MBeanServerConnection} is configured and attempts ... */this.preparationMonitorthis.serverToUsethis.invocationHandlernew MBeanServerInvocationHandler(...)isMXBeanInterface(...)retrieveMBeanInfo(...)/** Loads the management interface info for the configured MBean into the caches. ... */MBeanInfo infogetMBeanInfo(...)MBeanAttributeInfo[] attributeInfoMBeanOperationInfo[] operationInfogetOperations(...)this.allowedAttributesattributeInfo.lengthMBeanAttributeInfo infoElethis.allowedOperationsoperationInfo.lengthMBeanOperationInfo infoEleparameterInfoToTypes(...)new MBeanInfoRetrievalException(...)InstanceNotFoundException exReflectionException ex/** Return whether this client interceptor has already been prepared, ... *//** Route the invocation to the configured managed resource.. ... */handleConnectFailure(...)/** Refresh the connection and retry the MBean invocation if possible. ... *//** Route the invocation to the configured managed resource. Correctly routes JavaBean property ... */invokeAttribute(...)convertResultValueIfNecessary(...)MBeanException exRuntimeMBeanException exRuntimeErrorException exgetTargetError(...)RuntimeOperationsException exRuntimeException rexOperationsException exnew InvalidInvocationException(...)JMException exnew InvocationFailureException(...)new MBeanConnectFailureException(...)getAttributeName(...)MBeanAttributeInfo infnew Attribute(...)/** Routes a method invocation (not a property get/set) to the corresponding ... */MethodCacheKey keyMBeanOperationInfo infoString[] signaturethis.signatureCachegetMethodSignature(...)/** Convert the given result object (from attribute access or operation invocation) ... */Method fromMethodCompositeData.classCompositeData[] arrayconvertDataArrayToTargetArray(...)convertDataArrayToTargetCollection(...)TabularData.classTabularData[] arrayObject resultArrayCollection<Object> resultColl/** Simple wrapper class around a method name and its signature. ... *//** Create a new instance of {@code MethodCacheKey} with the supplied ... */MethodCacheKey otherKeyotherKey.nameotherKey.parameterTypesother.nameother.parameterTypes.lengthother.parameterTypes// Use the JDK's own MBeanServerInvocationHandler, in particular for native MXBean support.// Non-strict casing can only be achieved through custom invocation handling.// Only partial MXBean support available!// if we are this far this shouldn't happen, but...// Lazily connect to MBeanServer if necessary.// This one is only thrown by the JMX 1.2 RI, not by the JDK 1.5 JMX code.// If no attribute is returned, we know that it is not defined in the// management interface./** Thrown when an invocation failed because of an I/O problem on the ... *//** Create a new {@code MBeanConnectFailureException} ... *//** Thrown if an exception is encountered when trying to retrieve ... *//** Create a new {@code MBeanInfoRetrievalException} with the ... *//** Creates a proxy to a managed resource running either locally or remotely. ... */Class<?> proxyInterface, ...;Object mbeanProxy, ...;/** Set the interface that the generated proxy will implement. ... */this.proxyInterface/** Checks that the {@code proxyInterface} has been specified and then ... */getManagementInterface(...)setManagementInterface(...)this.mbeanProxyimport NotificationListenerHolder/** Registrar object that associates a specific {@link javax.management.NotificationListener} ... */...[] actualObjectNames, ...;getNotificationListener(...)this.mappedObjectNames/** Registers the specified {@code NotificationListener}. ... */this.actualObjectNamesgetResolvedObjectNames(...)ObjectName actualObjectNameaddNotificationListener(...)getNotificationFilter(...)getHandback(...)new JmxException(...)/** Unregisters the specified {@code NotificationListener}. */removeNotificationListener(...)/** Provides support for accessing remote MBean resources. *//** Exception thrown in case of failure when exporting an MBean. ... *//** Create a new {@code MBeanExportException} with the ... *//** Interface that defines the set of MBean export operations that are intended to be ... *//** Register the supplied resource with JMX. If the resource is not a valid MBean already, ... *//** Remove the specified MBean from the underlying MBeanServer registry. ... */import DynamicMBeanimport NotCompliantMBeanExceptionimport NotificationListenerimport StandardMBeanimport ModelMBeanimport ModelMBeanInfoimport RequiredModelMBeanimport AutodetectCapableMBeanInfoAssemblerimport MBeanInfoAssemblerimport SimpleReflectiveMBeanInfoAssemblerimport KeyNamingStrategyimport ObjectNamingStrategyimport SelfNamingimport ModelMBeanNotificationPublisherimport NotificationPublisherAwareimport MBeanRegistrationSupport/** JMX exporter that allows for exposing any <i>Spring-managed bean</i> to a ... */new SimpleReflectiveMBeanInfoAssembler(...)new KeyNamingStrategy(...)new LinkedHashMap<NotificationListenerBean,ObjectName[]>(...)... | ...MBeanExporter.classint AUTODETECT_NONE, ...;/** Autodetection mode indicating that no autodetection should be used. */int AUTODETECT_MBEAN, ...;/** Autodetection mode indicating that only valid MBeans should be autodetected. */int AUTODETECT_ASSEMBLER, ...;/** Autodetection mode indicating that only the {@link MBeanInfoAssembler} should be able ... */int AUTODETECT_ALL, ...;/** Autodetection mode indicating that all autodetection mechanisms should be used. */String WILDCARD, ...;/** Wildcard used to map a {@link javax.management.NotificationListener} ... */String MR_TYPE_OBJECT_REFERENCE, ...;/** Constant for the JMX {@code mr_type} "ObjectReference". */String CONSTANT_PREFIX_AUTODETECT, ...;/** Prefix for the autodetect constants defined in this class. *//** The beans to be exposed as JMX managed resources, with JMX names as keys. */Integer autodetectMode, ...;/** The autodetect mode to use for this MBeanExporter. */boolean allowEagerInit, ...;/** Whether to eagerly initialize candidate beans when autodetecting MBeans. */MBeanInfoAssembler assembler, ...;/** Stores the MBeanInfoAssembler to use for this exporter. */ObjectNamingStrategy namingStrategy, ...;/** The strategy to use for creating ObjectNames for an object. */boolean ensureUniqueRuntimeObjectNames, ...;/** Indicates whether Spring should modify generated ObjectNames. */boolean exposeManagedResourceClassLoader, ...;/** Indicates whether Spring should expose the managed resource ClassLoader in the MBean. */Set<String> excludedBeans, ...;/** A set of bean names that should be excluded from autodetection. */...[] listeners, ...;/** The MBeanExporterListeners registered with this exporter. */...[] notificationListeners, ...;/** The NotificationListeners to register for the MBeans registered by this exporter. */Map<NotificationListenerBean,ObjectName[]> registeredNotificationListeners, ...;/** Map of actually registered NotificationListeners. *//** Stores the ClassLoader to use for generating lazy-init proxies. *//** Stores the BeanFactory for use in autodetection process. *//** Supply a {@code Map} of beans to be registered with the JMX ... *//** Set whether to autodetect MBeans in the bean factory that this exporter ... */this.autodetectMode/** Set the autodetection mode to use. ... *//** Set the autodetection mode to use by name. ... *//** Specify whether to allow eager initialization of candidate beans ... */this.allowEagerInit/** Set the implementation of the {@code MBeanInfoAssembler} interface to use ... */this.assembler/** Set the implementation of the {@code ObjectNamingStrategy} interface ... */this.namingStrategy/** Indicates whether Spring should ensure that {@link ObjectName ObjectNames} ... */this.ensureUniqueRuntimeObjectNames/** Indicates whether or not the managed resource should be exposed on the ... */this.exposeManagedResourceClassLoader/** Set the list of names for beans that should be excluded from autodetection. */this.excludedBeans/** Add the name of bean that should be excluded from autodetection. *//** Set the {@code MBeanExporterListener}s that should be notified ... *//** Set the {@link NotificationListenerBean NotificationListenerBeans} ... */this.notificationListeners/** Set the {@link NotificationListener NotificationListeners} to register ... */List<NotificationListenerBean> notificationListenersnew ArrayList<NotificationListenerBean>(...)new BiConsumer<?,? extends NotificationListener>(...) { ... }NotificationListenerBean beannew NotificationListenerBean(...)setMappedObjectName(...)new NotificationListenerBean[]/** This callback is only required for resolution of bean names in the ... */// Lifecycle in bean factory: automatically register/unregister beans/** Kick off bean registration automatically after the regular singleton instantiation phase. ... */registerBeans(...)registerNotificationListeners(...)unregisterNotificationListeners(...)unregisterBeans(...)/** Unregisters all beans that this exported has exposed via JMX ... */// Implementation of MBeanExportOperations interfaceObjectName objectNamegetObjectName(...)appendIdentityToObjectName(...)new MBeanExportException(...)registerManagedResource(...)isMBean(...)doRegister(...)ModelMBean mbeancreateAndConfigureMBean(...)injectNotificationPublisherIfNecessary(...)new UnableToRegisterMBeanException(...)doUnregister(...)/** Register the defined beans with the {@link MBeanServer}. ... */// Exporter implementationint modeautodetect(...)new AutodetectCallback(...) { ... }includeBean(...)registerBeanNameOrInstance(...)/** Return whether the specified bean definition should be considered as lazy-init. ... *//** Register an individual bean with the {@link #setServer MBeanServer}. ... */isBeanDefinitionLazyInit(...)registerLazyInit(...)replaceNotificationListenerBeanNameKeysIfNecessary(...)registerBeanInstance(...)Map<String,?> beansOfSameTypeEntry<String,?> entryMap<>.Entry<String,?>/** Replace any bean names used as keys in the {@code NotificationListener} ... */NotificationListenerBean notificationListenerreplaceObjectName(...)/** Registers an existing MBean or an MBean adapter for a plain bean ... */Object mbeanToExposeDynamicMBean adaptedBeanadaptMBeanIfPossible(...)/** Register beans that are configured for lazy initialization with the ... */LazyInitTargetSource targetSourceNotificationPublisherAwareLazyTargetSource targetSourcenew NotificationPublisherAwareLazyTargetSource(...)setModelMBean(...)setObjectName(...)/** Retrieve the {@code ObjectName} for a bean. ... *//** Determine whether the given bean class qualifies as an MBean as-is. ... *//** Build an adapted MBean for the given bean instance, if possible. ... */getMXBeanInterface(...)new NotCompliantMBeanException(...)new StandardMBean(...)getMBeanInterface(...)/** Creates an MBean that is configured with the appropriate management ... */createModelMBean(...)setModelMBeanInfo(...)setManagedResource(...)/** Create an instance of a class that implements {@code ModelMBean}. ... */new SpringModelMBean(...)new RequiredModelMBean(...)/** Gets the {@code ModelMBeanInfo} for the bean with the supplied key ... */ModelMBeanInfo info/** Performs the actual autodetection process, delegating to an ... */// Autodetection processSet<String> beanNamesisBeanDefinitionAbstract(...)include(...)containsInstance(...)CannotLoadBeanClassException ex/** Indicates whether or not a particular bean name is present in the excluded beans list. *//** Return whether the specified bean definition should be considered as abstract. *//** If the supplied managed resource implements the {@link NotificationPublisherAware} an instance of ... */// Notification and listener managementsetNotificationPublisher(...)new ModelMBeanNotificationPublisher(...)/** Register the configured {@link NotificationListener NotificationListeners} ... */ObjectName[] mappedObjectNamesgetRegisteredObjectNames(...)this.registeredNotificationListenersObjectName mappedObjectName/** Unregister the configured {@link NotificationListener NotificationListeners} ... */new BiConsumer<NotificationListenerBean,ObjectName[]>(...) { ... }/** Called when an MBean is registered. Notifies all registered ... */notifyListenersOfRegistration(...)/** Called when an MBean is unregistered. Notifies all registered ... */notifyListenersOfUnregistration(...)/** Notifies all registered {@link MBeanExporterListener MBeanExporterListeners} of the ... */MBeanExporterListener listenermbeanRegistered(...)mbeanUnregistered(...)/** Internal callback interface for the autodetection process. */// Inner classes for internal use/** Called during the autodetection process to decide whether ... *//** Extension of {@link LazyInitTargetSource} that will inject a ... */ModelMBean modelMBean, ...;this.modelMBean// Get the listener from the map value.// Get the ObjectName from the map key.// This listener is mapped to a specific ObjectName.// If no server was provided then try to find one. This is useful in an environment// where there is already an MBeanServer loaded.// Unregister beans already registered by this exporter.// The beans property may be null, for example if we are relying solely on autodetection.// Use AUTODETECT_ALL as default in no beans specified explicitly.// Perform autodetection, if desired.// Autodetect any beans that are already MBeans.// Allow the assembler a chance to vote for bean inclusion.// Bean name pointing to a potentially lazy-init bean in the factory.// Plain bean instance -> register it directly.// A straight MBean... Let's create a simple lazy-init CGLIB proxy for it.// A simple bean... Let's create a lazy-init ModelMBean proxy with notification support.// Not already registered for JMX exposure.// otherwise ignore beans where the class is not resolvable// Mapped to all MBeans registered by the MBeanExporter./** A listener that allows application code to be notified when an MBean is ... *//** Called by {@link MBeanExporter} after an MBean has been <i>successfully</i> ... *//** Helper class that aggregates a {@link javax.management.NotificationListener}, ... *//** Create a new instance of the {@link NotificationListenerBean} class. *//** Create a new instance of the {@link NotificationListenerBean} class. ... */setNotificationListener(...)import AttributeListimport AttributeNotFoundExceptionimport InvalidAttributeValueExceptionimport InvalidTargetObjectTypeException/** Extension of the {@link RequiredModelMBean} class that ensures the ... */getContextClassLoader(...)ClassLoader managedResourceClassLoader, ...;/** Stores the {@link ClassLoader} to use for invocations. Defaults ... *//** Construct a new SpringModelMBean instance with an empty {@link ModelMBeanInfo}. ... *//** Construct a new SpringModelMBean instance with the given {@link ModelMBeanInfo}. ... *//** Sets managed resource to expose and stores its {@link ClassLoader}. */this.managedResourceClassLoader/** Switches the {@link Thread#getContextClassLoader() context ClassLoader} for the ... */ClassLoader currentClassLoadersetContextClassLoader(...)setAttributes(...)/** Exception thrown when we are unable to register an MBean, ... *//** Create a new {@code UnableToRegisterMBeanException} with the ... */import MergedAnnotationPredicatesimport RepeatableContainersimport InvalidMetadataExceptionimport JmxAttributeSource/** Implementation of the {@code JmxAttributeSource} interface that ... */MergedAnnotation<ManagedResource> annwithNonMergedAttributes(...)ManagedResource.classManagedResource beannew ManagedResource(...)List<PropertyValue> listnew InvalidMetadataException(...)MergedAnnotation<ManagedAttribute> annManagedAttribute.classManagedAttribute beannew ManagedAttribute(...)removePropertyValue(...)MergedAnnotation<ManagedMetric> annManagedMetric.classMergedAnnotation<ManagedOperation> annManagedOperation.classList<MergedAnnotation<? extends Annotation>> annsgetRepeatableAnnotations(...)ManagedOperationParameter.classManagedOperationParameters.classcopyPropertiesToBeanArray(...)ManagedNotification.classManagedNotifications.classfirstRunOf(...)new Function<MergedAnnotation<? extends Annotation>,Object>(...) { ... }getAggregateIndex(...)new Function<MergedAnnotation<? extends Annotation>,MergedAnnotation<? extends Annotation>>(...) { ... }T[] beansMergedAnnotation<? extends Annotation> annT beanimport MBeanExporterimport MetadataMBeanInfoAssemblerimport MetadataNamingStrategy/** Convenient subclass of Spring's standard {@link MBeanExporter}, ... */new AnnotationJmxAttributeSource(...)new MetadataNamingStrategy(...)this.annotationSourcenew MetadataMBeanInfoAssembler(...)AnnotationJmxAttributeSource annotationSource, ...;MetadataNamingStrategy metadataNamingStrategy, ...;MetadataMBeanInfoAssembler metadataAssembler, ...;setNamingStrategy(...)this.metadataNamingStrategysetAssembler(...)this.metadataAssemblersetAutodetectMode(...)/** Specify the default domain to be used for generating ObjectNames ... *//** Method-level annotation that indicates to expose a given bean property as a ... *//** Set the default value for the attribute in a {@link javax.management.Descriptor}. *//** Set the description for the attribute in a {@link javax.management.Descriptor}. *//** Set the currency time limit field in a {@link javax.management.Descriptor}. *//** Set the persistPolicy field in a {@link javax.management.Descriptor}. *//** Set the persistPeriod field in a {@link javax.management.Descriptor}. */import MetricType/** Type-level annotation that indicates a JMX notification emitted by a bean. ... *//** Type-level annotation that indicates JMX notifications emitted by a bean, ... *//** Method-level annotation that indicates to expose a given method as a ... *//** Method-level annotation used to provide metadata about operation parameters, ... *//** Class-level annotation that indicates to register instances of a class ... *//** Alias for the {@link #objectName} attribute, for simple default usage. *//** Java 5 annotations for MBean exposure. ... */import ModelMBeanNotificationInfoimport JmxMetadataUtilsimport ManagedNotification/** Base class for MBeanInfoAssemblers that support configurable ... */new HashMap<String,ModelMBeanNotificationInfo[]>(...)...[] notificationInfos, ...;Map<String,ModelMBeanNotificationInfo[]> notificationInfoMappings, ...;ModelMBeanNotificationInfo[] infosnew ModelMBeanNotificationInfo[]notificationInfos.lengthManagedNotification notificationInfoconvertToModelMBeanNotificationInfo(...)this.notificationInfosthis.notificationInfoMappingsextractNotificationMetadata(...)ModelMBeanNotificationInfo[] resultManagedNotification mnCollection<?> colList<ModelMBeanNotificationInfo> resultnew ArrayList<ModelMBeanNotificationInfo>(...)Object colValueimport Descriptorimport ModelMBeanAttributeInfoimport ModelMBeanConstructorInfoimport ModelMBeanInfoSupportimport ModelMBeanOperationInfo/** Abstract implementation of the {@code MBeanInfoAssembler} interface ... *//** Create an instance of the {@code ModelMBeanInfoSupport} class supplied with all ... */new ModelMBeanInfoSupport(...)getAttributeInfo(...)getConstructorInfo(...)getOperationInfo(...)getNotificationInfo(...)Descriptor descgetMBeanDescriptor(...)checkManagedBean(...)populateMBeanDescriptor(...)setMBeanDescriptor(...)/** Check the given bean instance, throwing an IllegalArgumentException ... *//** Return the actual bean class of the given bean instance. ... *//** Return the class or interface to expose for the given bean. ... */getClassToExpose(...)/** Return the class or interface to expose for the given bean class. ... *//** Get the class name of the MBean resource. ... *//** Get the description of the MBean resource. ... */String targetClassName/** Called after the {@code ModelMBeanInfo} instance has been constructed but ... *//** Get the constructor metadata for the MBean resource. Subclasses should implement ... */new ModelMBeanConstructorInfo[]/** Get the notification metadata for the MBean resource. Subclasses should implement ... *//** Get the attribute metadata for the MBean resource. Subclasses should implement ... *//** Get the operation metadata for the MBean resource. Subclasses should implement ... */import MBeanParameterInfo/** Builds on the {@link AbstractMBeanInfoAssembler} superclass to ... */String FIELD_GET_METHOD, ...;/** Identifies a getter method in a JMX {@link Descriptor}. */String FIELD_SET_METHOD, ...;/** Identifies a setter method in a JMX {@link Descriptor}. */String FIELD_ROLE, ...;/** Constant identifier for the role field in a JMX {@link Descriptor}. */String ROLE_GETTER, ...;/** Constant identifier for the getter role field value in a JMX {@link Descriptor}. */String ROLE_SETTER, ...;/** Constant identifier for the setter role field value in a JMX {@link Descriptor}. */String ROLE_OPERATION, ...;/** Identifies an operation (method) in a JMX {@link Descriptor}. */String FIELD_VISIBILITY, ...;/** Constant identifier for the visibility field in a JMX {@link Descriptor}. */int ATTRIBUTE_OPERATION_VISIBILITY, ...;/** Lowest visibility, used for operations that correspond to ... */String FIELD_CLASS, ...;/** Constant identifier for the class field in a JMX {@link Descriptor}. */String FIELD_LOG, ...;/** Constant identifier for the log field in a JMX {@link Descriptor}. */String FIELD_LOG_FILE, ...;/** Constant identifier for the logfile field in a JMX {@link Descriptor}. */String FIELD_CURRENCY_TIME_LIMIT, ...;/** Constant identifier for the currency time limit field in a JMX {@link Descriptor}. */String FIELD_DEFAULT, ...;/** Constant identifier for the default field in a JMX {@link Descriptor}. */String FIELD_PERSIST_POLICY, ...;/** Constant identifier for the persistPolicy field in a JMX {@link Descriptor}. */String FIELD_PERSIST_PERIOD, ...;/** Constant identifier for the persistPeriod field in a JMX {@link Descriptor}. */String FIELD_PERSIST_LOCATION, ...;/** Constant identifier for the persistLocation field in a JMX {@link Descriptor}. */String FIELD_PERSIST_NAME, ...;/** Constant identifier for the persistName field in a JMX {@link Descriptor}. */String FIELD_DISPLAY_NAME, ...;/** Constant identifier for the displayName field in a JMX {@link Descriptor}. */String FIELD_UNITS, ...;/** Constant identifier for the units field in a JMX {@link Descriptor}. */String FIELD_METRIC_TYPE, ...;/** Constant identifier for the metricType field in a JMX {@link Descriptor}. */String FIELD_METRIC_CATEGORY, ...;/** Constant identifier for the custom metricCategory field in a JMX {@link Descriptor}. */Integer defaultCurrencyTimeLimit, ...;/** Default value for the JMX field "currencyTimeLimit". *//** Indicates whether or not strict casing is being used for attributes. */boolean exposeClassDescriptor, ...;/** Set the default for the JMX field "currencyTimeLimit". ... */this.defaultCurrencyTimeLimit/** Return default value for the JMX field "currencyTimeLimit", if any. *//** Return whether strict casing for attributes is enabled. *//** Set whether to expose the JMX descriptor field "class" for managed operations. ... */this.exposeClassDescriptor/** Return whether to expose the JMX descriptor field "class" for managed operations. *//** Iterate through all properties on the MBean class and gives subclasses ... */PropertyDescriptor[] propsList<ModelMBeanAttributeInfo> infosnew ArrayList<ModelMBeanAttributeInfo>(...)PropertyDescriptor propMethod getterincludeReadAttribute(...)includeWriteAttribute(...)String attrNameisUseStrictCasing(...)String descriptiongetAttributeDescription(...)ModelMBeanAttributeInfo infonew ModelMBeanAttributeInfo(...)getDescriptor(...)setField(...)populateAttributeDescriptor(...)setDescriptor(...)new ModelMBeanAttributeInfo[]/** Iterate through all methods on the MBean class and gives subclasses the chance ... */List<ModelMBeanOperationInfo> infosnew ArrayList<ModelMBeanOperationInfo>(...)ModelMBeanOperationInfo infocreateModelMBeanOperationInfo(...)isExposeClassDescriptor(...)getClassForDescriptor(...)includeOperation(...)populateOperationDescriptor(...)new ModelMBeanOperationInfo[]/** Creates an instance of {@code ModelMBeanOperationInfo} for the ... */MBeanParameterInfo[] paramsgetOperationParameters(...)new ModelMBeanOperationInfo(...)MBeanOperationInfo.UNKNOWN/** Return the class to be used for the JMX descriptor field "class". ... *//** Allows subclasses to vote on the inclusion of a particular attribute accessor. ... *//** Allows subclasses to vote on the inclusion of a particular attribute mutator. ... *//** Allows subclasses to vote on the inclusion of a particular operation. ... *//** Get the description for a particular attribute. ... *//** Get the description for a particular operation. ... *//** Create parameter info for the given method. ... */ParameterNameDiscoverer paramNameDiscovererMBeanParameterInfo[] infonew MBeanParameterInfo[]Class<?>[] typeParametersinfo.lengthnew MBeanParameterInfo(...)/** Allows subclasses to add extra fields to the {@code Descriptor} for an MBean. ... */applyDefaultCurrencyTimeLimit(...)/** Allows subclasses to add extra fields to the {@code Descriptor} for a ... *//** Set the {@code currencyTimeLimit} field to the specified ... */getDefaultCurrencyTimeLimit(...)/** Apply the given JMX "currencyTimeLimit" value to the given descriptor. ... */// If both getter and setter are null, then this does not need exposing.// Attributes need to have their methods exposed as// operations to the JMX server as well.// allow getters and setters to be marked as operations directly// number of cache seconds// "always cache"// "never cache"/** Extends the {@code MBeanInfoAssembler} to add autodetection logic. ... *//** Indicate whether a particular bean should be included in the registration ... *//** Subclass of {@code AbstractReflectiveMBeanInfoAssembler} that allows for ... */...[] managedInterfaces, ...;Properties interfaceMappings, ...;/** Mappings of bean keys to an array of classes. */Map<String,Class<?>[]> resolvedInterfaceMappings, ...;/** Set the array of interfaces to use for creating the management info. ... */this.managedInterfaces/** Set the mappings of bean keys to a comma-separated list of interface names. ... */this.interfaceMappingsthis.resolvedInterfaceMappingsresolveInterfaceMappings(...)/** Resolve the given interface mappings, turning class names into Class objects. ... */Map<String,Class<?>[]> resolvedMappingsEnumeration<?> enString beanKeyresolveClassNames(...)/** Resolve the given class names into Class objects. ... *//** Check to see if the {@code Method} is declared in ... */isPublicInInterface(...)/** Check to see if the {@code Method} is both public and declared in ... */isDeclaredInInterface(...)/** Checks to see if the given method is declared in a managed ... */Class<?>[] ifacesMethod ifcMethod/** Interface to be implemented by all classes that can ... *//** Create the ModelMBeanInfo for the given managed resource. ... */import ManagedAttributeimport ManagedMetricimport ManagedOperationimport ManagedOperationParameterimport ManagedResource/** Implementation of the {@link MBeanInfoAssembler} interface that reads ... */JmxAttributeSource attributeSource, ...;/** Create a new {@code MetadataMBeanInfoAssembler} which needs to be ... *//** Create a new {@code MetadataMBeanInfoAssembler} for the given ... */this.attributeSource/** Set the {@code JmxAttributeSource} implementation to use for ... *//** Throws an IllegalArgumentException if it encounters a JDK dynamic proxy. ... *//** Used for autodetection of beans. Checks to see if the bean's class has a ... */getManagedResource(...)obtainAttributeSource(...)/** Vote on the inclusion of an attribute accessor. ... */hasManagedAttribute(...)hasManagedMetric(...)/** Votes on the inclusion of an attribute mutator. ... *//** Votes on the inclusion of an operation. ... */hasManagedOperation(...)/** Checks to see if the given Method has the {@code ManagedAttribute} attribute. */getManagedAttribute(...)/** Checks to see if the given Method has the {@code ManagedMetric} attribute. */getManagedMetric(...)/** Checks to see if the given Method has the {@code ManagedOperation} attribute. ... */getManagedOperation(...)/** Reads managed resource description from the source level metadata. ... */ManagedResource mr/** Creates a description for the attribute corresponding to this property ... */ManagedAttribute getterManagedAttribute setterManagedMetric metric/** Retrieves the description for the supplied {@code Method} from the ... */ManagedAttribute maManagedOperation mo/** Reads {@code MBeanParameterInfo} from the {@code ManagedOperationParameter} ... */ManagedOperationParameter[] paramsgetManagedOperationParameters(...)MBeanParameterInfo[] parameterInfoClass<?>[] methodParametersManagedOperationParameter param/** Reads the {@link ManagedNotification} metadata from the {@code Class} of the managed resource ... */ManagedNotification[] notificationAttributesgetManagedNotifications(...)ModelMBeanNotificationInfo[] notificationInfosnotificationAttributes.lengthManagedNotification attribute/** Adds descriptor fields from the {@code ManagedResource} attribute ... */applyCurrencyTimeLimit(...)getCurrencyTimeLimit(...)isLog(...)getLogFile(...)getPersistPolicy(...)getPersistPeriod(...)getPersistName(...)getPersistLocation(...)/** Adds descriptor fields from the {@code ManagedAttribute} attribute or the {@code ManagedMetric} attribute ... */ManagedAttribute gmaManagedAttribute smapopulateMetricDescriptor(...)ManagedAttribute.EMPTYresolveObjectDescriptor(...)String persistPolicyresolveStringDescriptor(...)int persistPeriodresolveIntDescriptor(...)getUnit(...)getCategory(...)getMetricType(...)/** Adds descriptor fields from the {@code ManagedAttribute} attribute ... *//** Determines which of two {@code int} values should be used as the value ... *//** Locates the value of a descriptor based on values attached ... *//** {@code AbstractReflectiveMBeanInfoAssembler} subclass that allows ... */Set<String> ignoredMethods, ...;Map<String,Set<String>> ignoredMethodMappings, ...;/** Set the array of method names to be <b>ignored</b> when creating the management info. ... */this.ignoredMethods/** Set the mappings of bean keys to a comma-separated list of method names. ... */this.ignoredMethodMappingsnew HashMap<String,Set<String>>(...)keys(...)String[] methodNamesisNotIgnored(...)/** Determine whether the given method is supposed to be included, ... */Set<String> methodNames/** Subclass of {@code AbstractReflectiveMBeanInfoAssembler} that allows ... */Set<String> managedMethods, ...;/** Stores the set of method names to use for creating the management interface. */Map<String,Set<String>> methodMappings, ...;/** Stores the mappings of bean keys to an array of method names. *//** Set the array of method names to use for creating the management info. ... */this.managedMethodsthis.methodMappings/** Simple subclass of {@code AbstractReflectiveMBeanInfoAssembler} ... *//** Provides a strategy for MBeanInfo assembly. Used by MBeanExporter to ... *//** Base class for all JMX metadata classes. ... */int currencyTimeLimit, ...;/** Set a description for this attribute. *//** Return a description for this attribute. *//** Set a currency time limit for this attribute. */this.currencyTimeLimit/** Return a currency time limit for this attribute. *//** Thrown by the {@code JmxAttributeSource} when it encounters ... *//** Create a new {@code InvalidMetadataException} with the supplied ... *//** Interface used by the {@code MetadataMBeanInfoAssembler} to ... *//** Implementations should return an instance of {@code ManagedResource} ... *//** Implementations should return an instance of {@code ManagedAttribute} ... *//** Implementations should return an instance of {@code ManagedMetric} ... *//** Implementations should return an instance of {@code ManagedOperation} ... *//** Implementations should return an array of {@code ManagedOperationParameter} ... *//** Implementations should return an array of {@link ManagedNotification ManagedNotifications} ... *//** Utility methods for converting Spring JMX metadata into their plain JMX equivalents. ... *//** Convert the supplied {@link ManagedNotification} into the corresponding ... */String[] notifTypesgetNotificationTypes(...)new ModelMBeanNotificationInfo(...)/** Metadata that indicates to expose a given bean property as JMX attribute. ... */ManagedAttribute EMPTY, ...;/** Empty attributes. */Object defaultValue, ...;String persistPolicy, ...;int persistPeriod, ...;/** Set the default value of this attribute. */this.defaultValue/** Return the default value of this attribute. */this.persistPolicythis.persistPeriod/** Metadata that indicates to expose a given bean property as a JMX attribute, ... */MetricType.GAUGEString category, ...;MetricType metricType, ...;String unit, ...;/** The category of this metric (ex. throughput, performance, utilization). */this.category/** A display name for this metric. *//** A description of how this metric's values change over time. */this.metricType/** The persist period for this metric. *//** The persist policy for this metric. *//** The expected unit of measurement values. */this.unit/** Metadata that indicates a JMX notification emitted by a bean. ... */...[] notificationTypes, ...;/** Set a single notification type, or a list of notification types ... */this.notificationTypes/** Set a list of notification types. *//** Return the list of notification types. *//** Set the name of this notification. *//** Return the name of this notification. *//** Set a description for this notification. *//** Return a description for this notification. *//** Metadata that indicates to expose a given method as JMX operation. ... *//** Metadata about JMX operation parameters. ... *//** Set the index of this parameter in the operation signature. *//** Return the index of this parameter in the operation signature. *//** Set the name of this parameter in the operation signature. *//** Return the name of this parameter in the operation signature. *//** Set a description for this parameter. *//** Return a description for this parameter. *//** Metadata indicating that instances of an annotated class ... */String objectName, ...;boolean log, ...;String logFile, ...;String persistName, ...;String persistLocation, ...;/** Set the JMX ObjectName of this managed resource. *//** Return the JMX ObjectName of this managed resource. */this.logFilethis.persistNamethis.persistLocation/** Provides generic JMX metadata classes and basic support for reading ... *//** An implementation of the {@code ObjectNamingStrategy} interface that ... */String TYPE_KEY, ...;/** The type key. */String HASH_CODE_KEY, ...;/** The hash code key. *//** Returns an instance of {@code ObjectName} based on the identity ... */String domainHashtable<String,String> keysnew Hashtable<String,String>(...)/** {@code ObjectNamingStrategy} implementation that builds ... *//** {@code Log} instance for this class. */Properties mappings, ...;/** Stores the mappings of bean key to {@code ObjectName}. */...[] mappingLocations, ...;/** Stores the {@code Resource}s containing properties that should be loaded ... */Properties mergedMappings, ...;/** Stores the result of merging the {@code mappings} {@code Properties} ... *//** Set local properties, containing object name mappings, e.g. via ... */this.mappings/** Set a location of a properties file to be loaded, ... */this.mappingLocations/** Set location of properties files to be loaded, ... *//** Merges the {@code Properties} configured in the {@code mappings} and ... */this.mergedMappingsResource locationfillProperties(...)/** Attempts to retrieve the {@code ObjectName} via the given key, trying to ... */String objectName/** An implementation of the {@link ObjectNamingStrategy} interface ... *//** The {@code JmxAttributeSource} implementation to use for reading metadata. */String defaultDomain, ...;/** Create a new {@code MetadataNamingStrategy} which needs to be ... *//** Create a new {@code MetadataNamingStrategy} for the given ... *//** Set the implementation of the {@code JmxAttributeSource} interface to use ... */this.defaultDomain/** Reads the {@code ObjectName} from the source-level metadata associated ... */Class<?> managedClassMalformedObjectNameException exHashtable<String,String> properties// Check that an object name has been specified./** Strategy interface that encapsulates the creation of {@code ObjectName} instances. ... *//** Obtain an {@code ObjectName} for the supplied bean. ... *//** Interface that allows infrastructure components to provide their own ... *//** Return the {@code ObjectName} for the implementing object. ... *//** Provides a strategy for ObjectName creation. Used by MBeanExporter ... */import AttributeChangeNotificationimport Notificationimport ModelMBeanNotificationBroadcaster/** {@link NotificationPublisher} implementation that uses the infrastructure ... */ModelMBeanNotificationBroadcaster modelMBean, ...;/** The {@link ModelMBean} instance wrapping the managed resource into which this ... *//** The {@link ObjectName} associated with the {@link ModelMBean modelMBean}. */Object managedResource, ...;/** The managed resource associated with the {@link ModelMBean modelMBean}. *//** Create a new instance of the {@link ModelMBeanNotificationPublisher} class ... */this.managedResource/** Send the supplied {@link Notification} using the wrapped ... */replaceNotificationSourceIfNecessary(...)sendAttributeChangeNotification(...)sendNotification(...)new UnableToSendNotificationException(...)/** Replaces the notification source if necessary to do so. ... *//** Simple interface allowing Spring-managed MBeans to publish JMX notifications ... *//** Send the specified {@link javax.management.Notification} to all registered ... *//** Interface to be implemented by any Spring-managed resource that is to be ... *//** Set the {@link NotificationPublisher} instance for the current managed resource instance. *//** Thrown when a JMX {@link javax.management.Notification} is unable to be sent. ... *//** Create a new instance of the {@link UnableToSendNotificationException} ... *//** Provides supporting infrastructure to allow Spring-created MBeans ... *//** This package provides declarative creation and registration of ... *//** This package contains Spring's JMX support, which includes registration of ... */import JMXConnectorServerimport JMXConnectorServerFactoryimport MBeanServerForwarder/** {@link FactoryBean} that creates a JSR-160 {@link JMXConnectorServer}, ... */String DEFAULT_SERVICE_URL, ...;/** The default service URL. */String serviceUrl, ...;Map<String,Object> environment, ...;MBeanServerForwarder forwarder, ...;boolean threaded, ...;boolean daemon, ...;JMXConnectorServer connectorServer, ...;/** Set the service URL for the {@code JMXConnectorServer}. *//** Set the environment properties used to construct the {@code JMXConnectorServer} ... *//** Set the environment properties used to construct the {@code JMXConnector} ... *//** Set an MBeanServerForwarder to be applied to the {@code JMXConnectorServer}. */this.forwarder/** Set the {@code ObjectName} used to register the {@code JMXConnectorServer} ... *//** Set whether the {@code JMXConnectorServer} should be started in a separate thread. */this.threaded/** Set whether any threads started for the {@code JMXConnectorServer} should be ... */this.daemon/** Start the connector server. If the {@code threaded} flag is set to {@code true}, ... */JMXServiceURL urlthis.connectorServernewJMXConnectorServer(...)setMBeanServerForwarder(...)JMXConnectorServer serverToStartThread connectorThreadJMXConnectorServer.class/** Stop the {@code JMXConnectorServer} managed by an instance of this class. ... */// Create the JMX service URL.// Create the connector server now.// Set the given MBeanServerForwarder, if any.// Do we want to register the connector with the MBean server?// Start the connector server asynchronously (in a separate thread).// Start the connector server in the same thread.// Unregister the connector server if startup failed.import MBeanServerFactory/** Collection of generic utility methods to support Spring JMX. ... */JmxUtils.classString IDENTITY_OBJECT_NAME_KEY, ...;/** The key used when extending an existing {@link ObjectName} with the ... */String MBEAN_SUFFIX, ...;/** Suffix used to identify an MBean interface. *//** Attempt to find a locally running {@code MBeanServer}. Fails if no ... */List<MBeanServer> serversfindMBeanServer(...)SecurityException ex/** Convert an array of {@code MBeanParameterInfo} into an array of ... */paramInfo.length/** Create a {@code String[]} representing the argument signature of a ... *//** Return the JMX attribute name to use for the given JavaBeans property. ... *//** Append an additional key/value pair to an existing {@link ObjectName} with the key being ... */Hashtable<String,String> keyPropertiesgetKeyPropertyList(...)getDomain(...)DynamicMBean.class/** Return the Standard MBean interface for the given class, if any ... */String mbeanInterfaceNameClass<?>[] implementedInterfacesClass<?> iface/** Return the Java 6 MXBean interface exists for the given class, if any ... */// null means any registered server, but "" specifically means the platform server// Check to see if an MBeanServer is registered.// Attempt to load the PlatformMBeanServer.import InstanceAlreadyExistsExceptionimport ObjectInstance/** Provides supporting infrastructure for registering MBeans with an ... */new LinkedHashSet<ObjectName>(...)MBeanServer server, ...;/** The {@code MBeanServer} instance being used to register beans. */Set<ObjectName> registeredBeans, ...;/** The beans that have been registered by this exporter. */RegistrationPolicy registrationPolicy, ...;/** The policy used when registering an MBean and finding that it already exists. ... *//** Specify the {@code MBeanServer} instance with which all beans should ... *//** Return the {@code MBeanServer} that the beans will be registered with. *//** The policy to use when attempting to register an MBean ... */this.registrationPolicy/** Actually register the MBean with the server. The behavior when encountering ... */this.registeredBeansObjectInstance registeredBeanInstanceAlreadyExistsException exInstanceNotFoundException ex2onRegister(...)/** Unregisters all beans that have been registered by an instance of this class. */Set<ObjectName> snapshot/** Actually unregister the specified MBean from the server. ... */boolean actuallyUnregisteredisRegistered(...)onUnregister(...)/** Return the {@link ObjectName ObjectNames} of all registered beans. */new ObjectName[]/** Called when an MBean is registered under the given {@link ObjectName}. Allows ... *//** Called when an MBean is unregistered under the given {@link ObjectName}. Allows ... */// Track registration and notify listeners.// MBean might already have been unregistered by an external processimport AbstractLazyCreationTargetSource/** {@link FactoryBean} that creates a JMX 1.2 {@code MBeanServerConnection} ... */MBeanServerConnection connection, ...;JMXConnectorLazyInitTargetSource connectorTargetSource, ...;/** Set whether to connect to the server on startup. ... *//** Creates a {@code JMXConnector} for the given settings ... */createLazyConnection(...)/** Connects to the remote {@code MBeanServer} using the configured service URL and ... */this.connection/** Creates lazy proxies for the {@code JMXConnector} and {@code MBeanServerConnection}. */TargetSource connectionTargetSourcenew MBeanServerConnectionLazyInitTargetSource(...)this.connectorTargetSourcenew JMXConnectorLazyInitTargetSource(...)JMXConnector.classMBeanServerConnection.class/** Closes the underlying {@code JMXConnector}. */isInitialized(...)/** Lazily creates a {@code JMXConnector} using the configured service URL ... *//** Lazily creates an {@code MBeanServerConnection}. *//** {@link FactoryBean} that obtains a {@link javax.management.MBeanServer} reference ... */boolean locateExistingServerIfPossible, ...;boolean registerWithFactory, ...;boolean newlyRegistered, ...;/** Set whether or not the {@code MBeanServerFactoryBean} should attempt ... */this.locateExistingServerIfPossible/** Set the default domain to be used by the {@code MBeanServer}, ... *//** Set whether to register the {@code MBeanServer} with the ... */this.registerWithFactory/** Creates the {@code MBeanServer} instance. */MBeanServerNotFoundException excreateMBeanServer(...)this.newlyRegistered/** Attempt to locate an existing {@code MBeanServer}. ... *//** Create a new {@code MBeanServer} instance and register it with the ... */newMBeanServer(...)/** Unregisters the {@code MBeanServer} instance, if necessary. */releaseMBeanServer(...)// Try to locate existing MBeanServer, if desired.// If agentId was specified, we were only supposed to locate that// specific MBeanServer; so let's bail if we can't find it.// Create a new MBeanServer and register it, if desired./** Represents how the measurement values of a {@code ManagedMetric} will change over time. ... */new MetricType(...)MetricType GAUGE, ...;/** The measurement values may go up or down over time. */MetricType COUNTER, ...;/** The measurement values will always increase. */import NotificationFilterNotificationListener notificationListener, ...;NotificationFilter notificationFilter, ...;Object handback, ...;Set<Object> mappedObjectNames, ...;/** Set the {@link javax.management.NotificationListener}. */this.notificationListener/** Get the {@link javax.management.NotificationListener}. *//** Set the {@link javax.management.NotificationFilter} associated ... */this.notificationFilter/** Return the {@link javax.management.NotificationFilter} associated ... *//** Set the (arbitrary) object that will be 'handed back' as-is by an ... */this.handback/** Return the (arbitrary) object that will be 'handed back' as-is by an ... *//** Set the {@link javax.management.ObjectName}-style name of the single MBean ... *//** Set an array of {@link javax.management.ObjectName}-style names of the MBeans ... *//** Return the list of {@link javax.management.ObjectName} String representations for ... */ObjectName[] resolvedObject objectNameNotificationListenerHolder otherNlhotherNlh.notificationListenerotherNlh.notificationFilterotherNlh.handbackotherNlh.mappedObjectNames/** Helper class for the creation of {@link javax.management.ObjectName} instances. ... *//** Retrieve the {@code ObjectName} instance corresponding to the supplied name. ... */new MalformedObjectNameException(...)/** Retrieve an {@code ObjectName} instance for the specified domain and a ... *//** Retrieve an {@code ObjectName} instance with the specified domain name ... *//** Indicates registration behavior when attempting to register an MBean that already ... */new RegistrationPolicy(...)RegistrationPolicy FAIL_ON_EXISTING, ...;/** Registration should fail when attempting to register an MBean under a name that ... */RegistrationPolicy IGNORE_EXISTING, ...;/** Registration should ignore the affected MBean when attempting to register an MBean ... */RegistrationPolicy REPLACE_EXISTING, ...;/** Registration should replace the affected MBean when attempting to register an MBean ... *//** {@link FactoryBean} that obtains a WebSphere {@link javax.management.MBeanServer} ... */String ADMIN_SERVICE_FACTORY_CLASS, ...;String GET_MBEAN_FACTORY_METHOD, ...;String GET_MBEAN_SERVER_METHOD, ...;MBeanServer mbeanServer, ...;Class<?> adminServiceClassMethod getMBeanFactoryMethodObject mbeanFactoryMethod getMBeanServerMethodthis.mbeanServer/* this.mbeanServer = AdminServiceFactory.getMBeanFactory().getMBeanServer(); *//** Contains support classes for connecting to local and remote {@code MBeanServer}s ... *//** Convenient superclass for JNDI accessors, providing "jndiTemplate" ... */new JndiTemplate(...)/** Logger, available to subclasses. */JndiTemplate jndiTemplate, ...;/** Set the JNDI template to use for JNDI lookups. ... */this.jndiTemplate/** Return the JNDI template to use for JNDI lookups. *//** Set the JNDI environment to use for JNDI lookups. ... *//** Return the JNDI environment to use for JNDI lookups. *//** Callback interface to be implemented by classes that need to perform an ... *//** Do something with the given JNDI context. ... */import InitialContext/** {@link JndiLocatorSupport} subclass with public lookup methods, ... */String IGNORE_JNDI_PROPERTY_NAME, ...;/** System property that instructs Spring to ignore a default JNDI environment, i.e. ... */boolean shouldIgnoreDefaultJndiEnvironment, ...;/** Configure a {@code JndiLocatorDelegate} with its "resourceRef" property set to ... */JndiLocatorDelegate jndiLocatorsetResourceRef(...)/** Check whether a default JNDI environment, as in a Java EE environment, ... */new InitialContext(...)/** Convenient superclass for classes that can locate any number of JNDI objects. ... */String CONTAINER_PREFIX, ...;/** JNDI prefix used in a Java EE container. */boolean resourceRef, ...;/** Set whether the lookup occurs in a Java EE container, i.e. if the prefix ... */this.resourceRef/** Return whether the lookup occurs in a Java EE container. *//** Perform an actual JNDI lookup for the given name via the JndiTemplate. ... */String convertedNameconvertJndiName(...)T jndiObject/** Convert the given JNDI name into the actual JNDI name to use. ... */isResourceRef(...)// Try fallback to originally specified name...// Prepend container prefix if not already specified and no other scheme given./** RuntimeException to be thrown in case of JNDI lookup failures, ... *//** Construct a new JndiLookupFailureException, ... *//** {@link org.springframework.beans.factory.FactoryBean} that looks up a ... */boolean lookupOnStartup, ...;boolean cache, ...;Object defaultObject, ...;Object jndiObject, ...;/** Specify the proxy interface to use for the JNDI object. ... *//** Specify multiple proxy interfaces to use for the JNDI object. ... *//** Set whether to look up the JNDI object on startup. Default is "true". ... */this.lookupOnStartup/** Set whether to cache the JNDI object once it has been located. ... *//** Specify a default object to fall back to if the JNDI lookup fails. ... */this.defaultObject/** Look up the JNDI object and store it. */this.jndiObjectcreateJndiObjectProxy(...)getExpectedType(...)lookupWithFallback(...)/** Lookup variant that returns the specified "defaultObject" ... */ClassLoader originalClassLoaderoverrideThreadContextClassLoader(...)TypeMismatchNamingException ex/** Return the singleton JNDI object. *//** Inner class to just introduce an AOP dependency when actually creating a proxy. */JndiObjectTargetSource targetSourcenew JndiObjectTargetSource(...)String jndiNamesetJndiTemplate(...)setJndiName(...)setExpectedType(...)setLookupOnStartup(...)jof.lookupOnStartupsetCache(...)jof.cachejof.proxyInterfacesjof.beanClassLoaderjof.exposeAccessContextnew JndiContextExposingInterceptor(...)/** Interceptor that exposes the JNDI context for all method invocations, ... */// Just optional - for getting a specifically configured TypeConverter if needed.// We'll simply fall back to a SimpleTypeConverter if no specific one available.// We need to create a proxy for this...// We need a proxy and a JndiObjectTargetSource.// Locate specified JNDI object.// Always let TypeMismatchNamingException through -// we don't want to fall back to the defaultObject in this case.// Create a JndiObjectTargetSource that mirrors the JndiObjectFactoryBean's configuration.// Create a proxy with JndiObjectFactoryBean's proxy interface and the JndiObjectTargetSource./** Convenient superclass for JNDI-based service locators, ... */String jndiName, ...;Class<?> expectedType, ...;/** Specify the JNDI name to look up. If it doesn't begin with "java:comp/env/" ... */this.jndiName/** Return the JNDI name to look up. *//** Specify the type that the located JNDI object is supposed ... */this.expectedType/** Return the type that the located JNDI object is supposed ... *//** Perform the actual JNDI lookup for this locator's target resource. ... *//** AOP {@link org.springframework.aop.TargetSource} that provides ... */Object cachedObject, ...;this.cachedObjectnew JndiLookupFailureException(...)/** {@link PropertySource} implementation that reads properties from an underlying Spring ... *//** Create a new {@code JndiPropertySource} with the given name ... */createDefaultResourceRefLocator(...)/** Create a new {@code JndiPropertySource} with the given name and the given ... *//** This implementation looks up and returns the value associated with the given ... */// We're in resource-ref (prefixing with "java:comp/env") mode. Let's not bother// with property names with a colon it since they're probably just containing a// default value clause, very unlikely to match including the colon part even in// a textual property source, and effectively never meant to match that way in// JNDI where a colon indicates a separator between JNDI scheme and actual name.import NameNotFoundException/** Helper class that simplifies JNDI operations. It provides methods to lookup and ... */Properties environment, ...;/** Create a new JndiTemplate instance. *//** Create a new JndiTemplate instance, using the given environment. *//** Set the environment for the JNDI InitialContext. *//** Return the environment for the JNDI InitialContext, if any. *//** Execute the given JNDI context callback implementation. ... */doInContext(...)/** Obtain a JNDI context corresponding to this template's configuration. ... */createInitialContext(...)/** Release a JNDI context as obtained from {@link #getContext()}. ... *//** Create a new JNDI initial context. Invoked by {@link #getContext}. ... */Hashtable<?,?> icEnvProperties envnew Hashtable<Object,Object>(...)/** Look up the object with the given name in the current JNDI context. ... */new JndiCallback<Object>(...) { ... }new NameNotFoundException(...)Object jndiObjectnew TypeMismatchNamingException(...)/** Bind the given object to the current JNDI context, using the given name. ... */bind(...)/** Rebind the given object to the current JNDI context, using the given name. ... */rebind(...)/** Remove the binding for the given name from the current JNDI context. ... */unbind(...)/** Properties editor for JndiTemplate objects. Allows properties of type ... */// empty environment// we have a non-empty properties string/** Exception thrown if a type mismatch is encountered for an object ... *//** Construct a new TypeMismatchNamingException, ... *//** Return the required type for the lookup, if available. *//** Return the actual type that the lookup returned, if available. *//** The classes in this package make JNDI easier to use, ... */import JndiLocatorSupportimport TypeMismatchNamingException/** Simple JNDI-based implementation of Spring's ... */Set<String> shareableResources, ...;/** JNDI names of resources that are known to be shareable, i.e. can be cached *//** Cache of shareable singleton objects: bean name to bean instance. */Map<String,Class<?>> resourceTypes, ...;/** Cache of the types of nonshareable resources: bean name to bean type. *//** Add the name of a shareable JNDI resource, ... */this.shareableResources/** Set a list of names of shareable JNDI resources, ... */doGetSingleton(...)NameNotFoundException exthis.resourceTypesdoGetType(...)Object singleton/** Support classes for JNDI usage, ... *//** Generic remote access exception. A service proxy for any remoting ... *//** Use serialVersionUID from Spring 1.2 for interoperability. *//** Constructor for RemoteAccessException. ... *//** RemoteAccessException subclass to be thrown when no connection ... *//** Constructor for RemoteConnectFailureException. ... *//** RemoteAccessException subclass to be thrown when the execution ... *//** Constructor for RemoteInvocationFailureException. ... *//** RemoteAccessException subclass to be thrown in case of a lookup failure, ... *//** Constructor for RemoteLookupFailureException. ... *//** RemoteAccessException subclass to be thrown in case of a failure ... *//** Constructor for RemoteProxyFailureException. ... *//** Constructor for RemoteTimeoutException. ... *//** Exception hierarchy for Spring's remoting infrastructure, ... */import RMIClassLoaderimport ConfigurableObjectInputStream/** Special ObjectInputStream subclass that falls back to a specified codebase ... */String codebaseUrl, ...;/** Create a new CodebaseAwareObjectInputStream for the given InputStream and codebase. ... */this.codebaseUrl// If codebaseUrl is set, try to load the class with the RMIClassLoader.// Else, propagate the ClassNotFoundException.import RemoteInvocationFailureExceptionimport DefaultRemoteInvocationFactoryimport RemoteInvocationimport RemoteInvocationFactory/** {@link org.aopalliance.intercept.MethodInterceptor} for accessing RMI services ... */new DefaultRemoteInvocationFactory(...)Class<?> serviceInterface, ...;RemoteInvocationFactory remoteInvocationFactory, ...;boolean lookupStubOnStartup, ...;boolean cacheStub, ...;boolean refreshStubOnConnectFailure, ...;Object cachedStub, ...;Object stubMonitor, ...;/** Set the interface of the service to access. ... */this.serviceInterface/** Return the interface of the service to access. *//** Set the RemoteInvocationFactory to use for this accessor. ... */this.remoteInvocationFactory/** Return the RemoteInvocationFactory used by this accessor. *//** Set whether to look up the RMI stub on startup. Default is "true". ... */this.lookupStubOnStartup/** Set whether to cache the RMI stub once it has been located. ... */this.cacheStub/** Set whether to refresh the RMI stub on connect failure. ... */this.refreshStubOnConnectFailure/** Fetches the RMI stub on startup, if necessary. ... */Object remoteObjlookupStub(...)getServiceInterface(...)boolean isImplthis.cachedStub/** Create the RMI stub, typically by looking it up. ... *//** Return the RMI stub to use. Called for each invocation. ... */this.stubMonitor/** Fetches an RMI stub and delegates to {@link #doInvoke}. ... */Object stubgetStub(...)/** Refresh the stub and retry the remote invocation if necessary. ... *//** Refresh the RMI stub and retry the given invocation. ... */Object freshStub/** Perform the given invocation on the given RMI stub. ... */new RemoteInvocationFailureException(...)/** Apply the given AOP method invocation to the given {@link RmiInvocationHandler}. ... */createRemoteInvocation(...)/** Create a new RemoteInvocation object for the given AOP method invocation. ... */getRemoteInvocationFactory(...)/** Convert the given RMI RemoteException that happened during remote access ... */// Cache RMI stub on initialization?// RMI invoker// traditional RMI stub/** {@link FactoryBean} for RMI proxies from JNDI. ... */Object serviceProxy, ...;this.serviceProxyimport Remoteimport JndiTemplate/** Service exporter which binds RMI services to JNDI. ... */Class<?> portableRemoteObjectJndiRmiServiceExporter.classRemote.classMethod exportObject, ...;Method unexportObject, ...;Remote exportedObject, ...;/** Set the JNDI name of the exported RMI service. *//** Initialize this service exporter, binding the specified service to JNDI. ... */this.exportedObjectgetObjectToExport(...)invokePortableRemoteObject(...)/** Rebind the specified service to JNDI, for recovering in case ... *//** Unbind the RMI service from JNDI on bean factory shutdown. */// java.corba module not available on JDK 9+// Initialize and cache exported object.import ObjectOutputStreamimport OutputStreamimport RemoteInvocationBasedExporterimport RemoteInvocationResult/** Abstract base class for remote service exporters that explicitly deserialize ... */String CONTENT_TYPE_SERIALIZED_OBJECT, ...;/** Default content type: "application/x-java-serialized-object". */String contentType, ...;boolean acceptProxyClasses, ...;/** Specify the content type to use for sending remote invocation responses. ... */this.contentType/** Return the content type to use for sending remote invocation responses. *//** Set whether to accept deserialization of proxy classes. ... */this.acceptProxyClasses/** Return whether to accept deserialization of proxy classes. *//** Initialize this service exporter. */getProxyForService(...)/** Create an ObjectInputStream for the given InputStream. ... */new CodebaseAwareObjectInputStream(...)isAcceptProxyClasses(...)/** Perform the actual reading of an invocation result object from the ... */readObject(...)RemoteInvocation.class/** Create an ObjectOutputStream for the given OutputStream. ... */new ObjectOutputStream(...)/** Perform the actual writing of the given invocation result object ... */writeObject(...)/** Convenient superclass for RMI-based remote exporters. Provides a facility ... *//** Determine the object to export: either the service object itself ... */getService(...)new RmiInvocationWrapper(...)/** Redefined here to be visible to RmiInvocationWrapper. ... */// determine remote object// conventional RMI serviceimport URLStreamHandlerimport Namingimport NotBoundExceptionimport LocateRegistryimport Registryimport RMIClientSocketFactoryimport RemoteInvocationBasedAccessorimport RemoteInvocationUtils/** {@link org.aopalliance.intercept.MethodInterceptor} for accessing conventional ... */RMIClientSocketFactory registryClientSocketFactory, ...;Remote cachedStub, ...;/** Set a custom RMI client socket factory to use for accessing the RMI registry. ... */this.registryClientSocketFactory/** Fetches RMI stub on startup, if necessary. ... */Remote remoteObjgetServiceUrl(...)Remote stubnew DummyURLStreamHandler(...)String protocolString hostgetHost(...)int portRegistry registrynew MalformedURLException(...)NotBoundException ex/** Fetches an RMI stub and delegates to {@code doInvoke}. ... */Remote freshStubThrowable exToThrowfillInClientStackTraceIfPossible(...)/** Dummy URLStreamHandler that's just specified to suppress the standard ... */// RMIClientSocketFactory specified for registry access.// Unfortunately, due to RMI API limitations, this means// that we need to parse the RMI URL ourselves and perform// straight LocateRegistry.getRegistry/Registry.lookup calls.// Can proceed with standard RMI lookup API...import ConnectIOExceptionimport NoSuchObjectExceptionimport StubNotFoundExceptionimport RemoteAccessExceptionimport RemoteProxyFailureException/** Factored-out methods for performing invocations within an RMI client. ... */RmiClientInterceptorUtils.class/** Perform a raw method invocation on the given RMI stub, ... */Method stubMethodnew RemoteProxyFailureException(...)/** Wrap the given arbitrary exception that happened during remote access ... */RemoteException.classnew RemoteAccessException(...)/** Convert the given RemoteException that happened during remote access ... */new RemoteConnectFailureException(...)/** Interface for RMI invocation handlers instances on the server, ... *//** Return the name of the target interface that this invoker operates on. ... *//** Apply the given invocation to the target object. ... *//** Server-side implementation of {@link RmiInvocationHandler}. An instance ... */RmiBasedExporter rmiExporter, ...;/** Create a new RmiInvocationWrapper for the given object. ... */this.rmiExporter/** Exposes the exporter's service interface, if any, as target interface. ... *//** Delegates the actual invocation handling to the RMI exporter. ... *//** {@link FactoryBean} for RMI proxies, supporting both conventional RMI services ... */import RMIServerSocketFactoryimport UnicastRemoteObject/** {@link FactoryBean} that locates a {@link java.rmi.registry.Registry} and ... */Registry.REGISTRY_PORTString host, ...;int port, ...;RMIClientSocketFactory clientSocketFactory, ...;RMIServerSocketFactory serverSocketFactory, ...;Registry registry, ...;boolean alwaysCreate, ...;boolean created, ...;/** Set the host of the registry for the exported RMI service, ... */this.host/** Return the host of the registry for the exported RMI service. *//** Set the port of the registry for the exported RMI service, ... */this.port/** Return the port of the registry for the exported RMI service. *//** Set a custom RMI client socket factory to use for the RMI registry. ... */this.clientSocketFactory/** Set a custom RMI server socket factory to use for the RMI registry. ... */this.serverSocketFactory/** Set whether to always create the registry in-process, ... */this.alwaysCreate/** Locate or create the RMI registry. ... */Registry regtestRegistry(...)this.createdcreateRegistry(...)LocateRegistry.class/** Test the given RMI registry, calling some operation on it to ... */list(...)Registry.class/** Unexport the RMI registry on bean factory shutdown, ... */unexportObject(...)// Check socket factories for registry.// Fetch RMI registry to expose.// Host explicitly specified: only lookup possible.// Retrieve existing registry.// Assume no registry found -> create new one.import AlreadyBoundException/** RMI exporter that exposes the specified service as RMI object with the specified name. ... */String serviceName, ...;int servicePort, ...;// anonymous portString registryHost, ...;int registryPort, ...;RMIServerSocketFactory registryServerSocketFactory, ...;boolean alwaysCreateRegistry, ...;boolean replaceExistingBinding, ...;boolean createdRegistry, ...;/** Set the name of the exported RMI service, ... */this.serviceName/** Set the port that the exported RMI service will use. ... */this.servicePort/** Set a custom RMI client socket factory to use for exporting the service. ... *//** Set a custom RMI server socket factory to use for exporting the service. ... *//** Specify the RMI registry to register the exported service with. ... */this.registryHostthis.registryPortthis.registryServerSocketFactorythis.alwaysCreateRegistry/** Set whether to replace an existing binding in the RMI registry, ... */this.replaceExistingBinding/** Initialize this service exporter, registering the service as RMI object. ... */checkService(...)this.createdRegistryexportObject(...)AlreadyBoundException exunexportObjectSilently(...)/** Locate or create the RMI registry for this exporter. ... *//** Unbind the RMI service from the registry on bean factory shutdown. *//** Unexport the registered RMI object, logging any exception that arises. */NoSuchObjectException ex// Check socket factories for exported object.// Check socket factories for RMI registry.// Determine RMI registry to use.// Export RMI object.// Bind RMI object to registry.// Already an RMI object bound for the specified service name...// Registry binding failed: let's unexport the RMI object as well./** RemoteInvocationFailureException subclass that provides the details ... *//** Constructor for SoapFaultException. ... *//** Return the SOAP fault code. *//** Return the SOAP fault code as a {@code QName} object. *//** Return the descriptive SOAP fault string. *//** Return the actor that caused this fault. *//** Default implementation of the {@link RemoteInvocationExecutor} interface. ... *//** Default implementation of the {@link RemoteInvocationFactory} interface. ... */new RemoteInvocation(...)/** Abstract base class for classes that access a remote service. ... *//** Abstract base class for classes that export a remote service. ... */Object service, ...;Boolean registerTraceInterceptor, ...;...[] interceptors, ...;/** Set the service to export. ... */this.service/** Return the service to export. *//** Set the interface of the service to export. ... *//** Return the interface of the service to export. *//** Set whether to register a RemoteInvocationTraceInterceptor for exported ... */this.registerTraceInterceptorthis.interceptors/** Check whether the service reference has been set. ... *//** Check whether a service reference has been set, ... */Class<?> serviceInterfaceObject service/** Get a proxy for the given service object, implementing the specified ... */checkServiceInterface(...)new RemoteInvocationTraceInterceptor(...)getExporterName(...)AdvisorAdapterRegistry adapterRegistry/** Return a short name for this exporter. ... *//** Encapsulates a remote invocation, providing core method invocation properties ... *//** use serialVersionUID from Spring 1.1 for interoperability. */Map<String,Serializable> attributes, ...;/** Create a new RemoteInvocation for the given AOP method invocation. ... *//** Create a new RemoteInvocation for the given parameters. ... *//** Create a new RemoteInvocation for JavaBean-style deserialization ... *//** Set the name of the target method. ... *//** Return the name of the target method. *//** Set the parameter types of the target method. ... *//** Return the parameter types of the target method. *//** Set the arguments for the target method call. ... *//** Return the arguments for the target method call. *//** Add an additional invocation attribute. Useful to add additional ... */this.attributesnew HashMap<String,Serializable>(...)/** Retrieve the attribute for the given key, if any. ... *//** Set the attributes Map. Only here for special purposes: ... *//** Return the attributes Map. Mainly here for debugging purposes: ... *//** Perform this invocation on the given target object. ... *//** Abstract base class for remote service accessors that are based ... *//** Recreate the invocation result contained in the given RemoteInvocationResult object. ... */recreate(...)/** Abstract base class for remote service exporters that are based ... */new DefaultRemoteInvocationExecutor(...)RemoteInvocationExecutor remoteInvocationExecutor, ...;/** Set the RemoteInvocationExecutor to use for this exporter. ... */this.remoteInvocationExecutor/** Return the RemoteInvocationExecutor used by this exporter. *//** Apply the given remote invocation to the given target object. ... */getRemoteInvocationExecutor(...)/** Apply the given remote invocation to the given target object, wrapping ... */new RemoteInvocationResult(...)/** Strategy interface for executing a {@link RemoteInvocation} on a target object. ... *//** Strategy interface for creating a {@link RemoteInvocation} from an AOP Alliance ... *//** Create a serializable RemoteInvocation object from the given AOP ... *//** Encapsulates a remote invocation result, holding a result value or an exception. ... *//** Use serialVersionUID from Spring 1.1 for interoperability. */Throwable exception, ...;/** Create a new RemoteInvocationResult for the given result value. ... *//** Create a new RemoteInvocationResult for the given exception. ... */this.exception/** Create a new RemoteInvocationResult for JavaBean-style deserialization ... *//** Set the result value returned by a successful invocation of the ... *//** Return the result value returned by a successful invocation ... *//** Set the exception thrown by an unsuccessful invocation of the ... *//** Return the exception thrown by an unsuccessful invocation ... *//** Return whether this invocation result holds an exception. ... *//** Return whether this invocation result holds an InvocationTargetException, ... *//** Recreate the invocation result, either returning the result value ... *//** AOP Alliance MethodInterceptor for tracing remote invocations. ... */RemoteInvocationTraceInterceptor.classString exporterNameClause, ...;/** Create a new RemoteInvocationTraceInterceptor. */this.exporterNameClause/** Create a new RemoteInvocationTraceInterceptor. ... *//** General utilities for handling remote invocations. ... *//** Fill the current client-side stack trace into the given exception. ... */StackTraceElement[] clientStackSet<Throwable> visitedExceptionsnew HashSet<Throwable>(...)Throwable exToUpdateStackTraceElement[] serverStackStackTraceElement[] combinedStacknew StackTraceElement[]serverStack.lengthclientStack.lengthsetStackTrace(...)/** Generic support base class for remote accessor and exporters, ... *//** Return the ClassLoader that this accessor operates in, ... *//** Override the thread context ClassLoader with the environment's bean ClassLoader ... *//** Reset the original thread context ClassLoader if necessary. ... */import InetSocketAddressimport Authenticatorimport Filterimport HttpContextimport HttpHandlerimport HttpServer/** {@link org.springframework.beans.factory.FactoryBean} that creates a simple ... */String hostname, ...;int backlog, ...;int shutdownDelay, ...;Executor executor, ...;Map<String,HttpHandler> contexts, ...;List<Filter> filters, ...;Authenticator authenticator, ...;HttpServer server, ...;/** Specify the HTTP server's port. Default is 8080. *//** Specify the HTTP server's hostname to bind to. Default is localhost; ... */this.hostname/** Specify the HTTP server's TCP backlog. Default is -1, ... */this.backlog/** Specify the number of seconds to wait until HTTP exchanges have ... */this.shutdownDelay/** Set the JDK concurrent executor to use for dispatching incoming requests. ... */this.executor/** Register {@link com.sun.net.httpserver.HttpHandler HttpHandlers} ... *//** Register common {@link com.sun.net.httpserver.Filter Filters} to be ... *//** Register a common {@link com.sun.net.httpserver.Authenticator} to be ... */this.authenticatorInetSocketAddress addressnew InetSocketAddress(...)setExecutor(...)new BiConsumer<String,HttpHandler>(...) { ... }HttpContext httpContextgetFilters(...)setAuthenticator(...)HttpServer.class/** Abstract base class for classes that access remote services via URLs. ... *//** Set the URL of this remote accessor's target service. ... *//** Return the URL of this remote accessor's target service. *//** Extension of the Runnable interface, adding special callbacks ... *//** Return whether the Runnable's operation is long-lived ... *//** General exception to be thrown on scheduling failures, ... *//** Constructor for SchedulingException. ... *//** A {@link org.springframework.core.task.TaskExecutor} extension exposing ... *//** Does this {@code TaskExecutor} prefer short-lived tasks over long-lived tasks? ... */import Clockimport ScheduledFuture/** Task scheduler interface that abstracts the scheduling of ... *//** Return the clock to use for scheduling purposes. ... */systemDefaultZone(...)/** Schedule the given {@link Runnable}, invoking it whenever the trigger ... *//** Schedule the given {@link Runnable}, invoking it at the specified execution time. ... */schedule(...)/** Schedule the given {@link Runnable}, invoking it at the specified execution time ... */scheduleAtFixedRate(...)toMillis(...)/** Schedule the given {@link Runnable}, starting as soon as possible and ... */scheduleWithFixedDelay(...)/** Schedule the given {@link Runnable}, starting as soon as possible and invoking it with ... *//** Common interface for trigger objects that determine the next execution time ... *//** Determine the next execution time according to the given trigger context. ... *//** Context object encapsulating last execution times and last completion time ... *//** Return the clock to use for trigger calculation. ... *//** Return the last <i>scheduled</i> execution time of the task, ... *//** Return the last <i>actual</i> execution time of the task, ... *//** Return the last completion time of the task, ... */import AsyncUncaughtExceptionHandler/** Abstract base {@code Configuration} class providing common structure for enabling ... */AnnotationAttributes enableAsync, ...;Supplier<Executor> executor, ...;Supplier<AsyncUncaughtExceptionHandler> exceptionHandler, ...;this.enableAsyncEnableAsync.class/** Collect any {@link AsyncConfigurer} beans through autowiring. */AsyncConfigurer configurergetAsyncExecutor(...)getAsyncUncaughtExceptionHandler(...)import AsyncExecutionInterceptor/** Specialization of {@link AsyncExecutionInterceptor} that delegates method execution to ... *//** Create a new {@code AnnotationAsyncExecutionInterceptor} with the given executor ... *//** Create a new {@code AnnotationAsyncExecutionInterceptor} with the given executor. ... */Async asyncAsync.class// Maintainer's note: changes made here should also be made in// AnnotationAsyncExecutionAspect#getExecutorQualifier/** Annotation that marks a method as a candidate for <i>asynchronous</i> execution. ... *//** A qualifier value for the specified asynchronous operation(s). ... */import AbstractPointcutAdvisorimport AnnotationMatchingPointcut/** Advisor that activates asynchronous method execution through the {@link Async} ... *//** Create a new {@code AsyncAnnotationAdvisor} for bean-style configuration. *//** Create a new {@code AsyncAnnotationAdvisor} for the given task executor. ... */Set<Class<? extends Annotation>> asyncAnnotationTypesAsyncAnnotationAdvisor.classbuildAdvice(...)buildPointcut(...)/** Set the 'async' annotation type. ... */new HashSet<Class<? extends Annotation>>(...)/** Set the {@code BeanFactory} to be used when looking up executors by qualifier. */AnnotationAsyncExecutionInterceptor interceptornew AnnotationAsyncExecutionInterceptor(...)/** Calculate a pointcut for the given async annotation types, if any. ... */ComposablePointcut resultClass<? extends Annotation> asyncAnnotationTypePointcut cpcPointcut mpc// If EJB 3.1 API not present, simply ignore.import AbstractBeanFactoryAwareAdvisingPostProcessor/** Bean post-processor that automatically applies asynchronous invocation ... */AnnotationAsyncExecutionInterceptor.DEFAULT_TASK_EXECUTOR_BEAN_NAMEClass<? extends Annotation> asyncAnnotationType, ...;setBeforeExistingAdvisors(...)/** Configure this post-processor with the given executor and exception handler suppliers, ... *//** Set the {@link Executor} to use when invoking methods asynchronously. ... *//** Set the {@link AsyncUncaughtExceptionHandler} to use to handle uncaught ... *//** Set the 'async' annotation type to be detected at either class or method ... */this.asyncAnnotationTypeAsyncAnnotationAdvisor advisornew AsyncAnnotationAdvisor(...)setAsyncAnnotationType(...)/** Selects which implementation of {@link AbstractAsyncConfiguration} should ... */String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME, ...;/** Returns {@link ProxyAsyncConfiguration} or {@code AspectJAsyncConfiguration} ... */ProxyAsyncConfiguration.class/** The {@link Executor} instance to be used when processing async ... *//** The {@link AsyncUncaughtExceptionHandler} instance to be used ... *//** A convenience {@link AsyncConfigurer} that implements all methods ... */import FailureCallbackimport ListenableFutureCallbackimport SuccessCallback/** A pass-through {@code Future} handle that can be used for method signatures ... */V value, ...;Throwable executionException, ...;/** Create a new AsyncResult holder. ... */this.executionExceptionnew ExecutionException(...)onFailure(...)exposedException(...)onSuccess(...)CompletableFuture<V> completablenew CompletableFuture<V>(...)completeExceptionally(...)completedFuture(...)/** Create a new async result which exposes the given value from {@link Future#get()}. ... */new AsyncResult<V>(...)/** Create a new async result which exposes the given exception as an ... *//** Determine the exposed exception: either the cause of a given ... */// Ignore/** Enables Spring's asynchronous method execution capability, similar to functionality ... */AsyncConfigurationSelector.class/** Indicate the 'async' annotation type to be detected at either class ... *//** Indicate how async advice should be applied. ... *//** Indicate the order in which the {@link AsyncAnnotationBeanPostProcessor} ... */import Triggerimport ScheduledTaskRegistrar/** Enables Spring's scheduled task execution capability, similar to ... */SchedulingConfiguration.classimport TaskManagementConfigUtilsTaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAMEAsyncAnnotationBeanPostProcessor bppnew AsyncAnnotationBeanPostProcessor(...)Class<? extends Annotation> customAsyncAnnotation/** Annotation that marks a method to be scheduled. Exactly one of the ... */Schedules.classScheduledTaskRegistrar.CRON_DISABLEDString CRON_DISABLED, ...;/** A special cron expression value that indicates a disabled trigger: {@value}. ... *//** A cron-like expression, extending the usual UN*X definition to include triggers ... *//** A time zone for which the cron expression will be resolved. By default, this ... *//** Execute the annotated method with a fixed period in milliseconds between the ... *//** Execute the annotated method with a fixed period in milliseconds between ... *//** Number of milliseconds to delay before the first execution of a ... */import ScheduledExecutorServiceimport TaskSchedulerimport CronTaskimport FixedDelayTaskimport FixedRateTaskimport ScheduledTaskimport ScheduledTaskHolderimport CronTriggerimport ScheduledMethodRunnable/** Bean post-processor that registers methods annotated with @{@link Scheduled} ... */new IdentityHashMap<Object,Set<ScheduledTask>>(...)String DEFAULT_TASK_SCHEDULER_BEAN_NAME, ...;/** The default name of the {@link TaskScheduler} bean to pick up: {@value}. ... */ScheduledTaskRegistrar registrar, ...;Object scheduler, ...;Map<Object,Set<ScheduledTask>> scheduledTasks, ...;/** Create a default {@code ScheduledAnnotationBeanPostProcessor}. */this.registrarnew ScheduledTaskRegistrar(...)/** Create a {@code ScheduledAnnotationBeanPostProcessor} delegating to the ... *//** Set the {@link org.springframework.scheduling.TaskScheduler} that will invoke ... */this.scheduler/** Making a {@link BeanFactory} available is optional; if not set, ... *//** Setting an {@link ApplicationContext} is optional: If set, registered ... */finishRegistration(...)setScheduler(...)Map<String,SchedulingConfigurer> beansSchedulingConfigurer.classList<SchedulingConfigurer> configurersnew ArrayList<SchedulingConfigurer>(...)SchedulingConfigurer configurerconfigureTasks(...)hasTasks(...)getScheduler(...)setTaskScheduler(...)resolveSchedulerBean(...)TaskScheduler.classScheduledExecutorService.classNoUniqueBeanDefinitionException ex2NoSuchBeanDefinitionException ex3T schedulerNamedBeanHolder<T> holderScheduled.classMap<Method,Set<Scheduled>> annotatedMethodsMethodIntrospector.MetadataLookup<Set<Scheduled>>new MetadataLookup<Set<Scheduled>>(...) { ... }Set<Scheduled> scheduledMethodsgetMergedRepeatableAnnotations(...)new BiConsumer<Method,Set<Scheduled>>(...) { ... }new Consumer<Scheduled>(...) { ... }processScheduled(...)/** Process the given {@code @Scheduled} method declaration on the given bean. ... */Runnable runnablecreateRunnable(...)boolean processedScheduleString errorMessageSet<ScheduledTask> tasksnew LinkedHashSet<ScheduledTask>(...)long initialDelayinitialDelay(...)String initialDelayStringinitialDelayString(...)String croncron(...)long fixedDelayfixedDelay(...)String fixedDelayStringfixedDelayString(...)long fixedRatefixedRate(...)String fixedRateStringfixedRateString(...)parseDelayAsLong(...)String zonezone(...)Scheduled.CRON_DISABLEDscheduleCronTask(...)new CronTask(...)new CronTrigger(...)scheduleFixedDelayTask(...)new FixedDelayTask(...)scheduleFixedRateTask(...)new FixedRateTask(...)this.scheduledTasksSet<ScheduledTask> regTasksnew Function<Object,Set<ScheduledTask>>(...) { ... }/** Create a {@link Runnable} for the given bean instance, ... */Method invocableMethodnew ScheduledMethodRunnable(...)isP(...)parseLong(...)/** Return all currently scheduled tasks, from {@link Scheduled} methods ... */Set<ScheduledTask> resultCollection<Set<ScheduledTask>> allTasksgetScheduledTasks(...)ScheduledTask taskcancel(...)// Remove resolved singleton classes from cache// Not running in an ApplicationContext -> register tasks early...// Running in an ApplicationContext -> register tasks this late...// giving other ContextRefreshedEvent listeners a chance to perform// their work at the same time (e.g. Spring Batch's job registration).// Search for TaskScheduler bean...// Search for ScheduledExecutorService bean next...// Giving up -> falling back to default scheduler within the registrar...// Determine initial delay// Check cron expression// At this point we don't need to differentiate between initial delay set or not anymore// Check fixed delay// Check fixed rate// Check whether we had any attribute set// Finally register the scheduled tasks/** Container annotation that aggregates several {@link Scheduled} annotations. ... *//** {@code @Configuration} class that registers a {@link ScheduledAnnotationBeanPostProcessor} ... */TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAMEnew ScheduledAnnotationBeanPostProcessor(...)/** Optional interface to be implemented by @{@link ... *//** Callback allowing a {@link org.springframework.scheduling.TaskScheduler ... *//** Java 5 annotation for asynchronous method execution. */import Executorsimport ManagedExecutorsimport ManagedTaskimport TaskDecoratorimport SchedulingAwareRunnableimport SchedulingTaskExecutor/** Adapter that takes a {@code java.util.concurrent.Executor} and exposes ... */ConcurrentTaskScheduler.classClass<?> managedExecutorServiceClass, ...;Executor concurrentExecutor, ...;TaskExecutorAdapter adaptedExecutor, ...;/** Create a new ConcurrentTaskExecutor, using a single thread executor as default. ... */this.concurrentExecutornewSingleThreadExecutor(...)this.adaptedExecutor/** Create a new ConcurrentTaskExecutor, using the given {@link java.util.concurrent.Executor}. ... */getAdaptedExecutor(...)/** Specify the {@link java.util.concurrent.Executor} to delegate to. ... *//** Return the {@link java.util.concurrent.Executor} that this adapter delegates to. *//** Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable} ... */setTaskDecorator(...)new ManagedTaskExecutorAdapter(...)/** TaskExecutorAdapter subclass that wraps all provided Runnables and Callables ... */buildManagedTask(...)/** Delegate that wraps a given Runnable/Callable  with a JSR-236 ManagedTask, ... */Map<String,String> propertiesManagedTask.LONGRUNNING_HINTisLongLived(...)ManagedTask.IDENTITY_NAMEmanagedTask(...)// JSR-236 API not available...import RejectedExecutionExceptionimport LastExecutionimport ManagedScheduledExecutorServiceimport TaskRejectedExceptionimport SimpleTriggerContextimport TaskUtils/** Adapter that takes a {@code java.util.concurrent.ScheduledExecutorService} and ... */Class<?> managedScheduledExecutorServiceClass, ...;ScheduledExecutorService scheduledExecutor, ...;boolean enterpriseConcurrentScheduler, ...;Clock clock, ...;/** Create a new ConcurrentTaskScheduler, ... */this.scheduledExecutorinitScheduledExecutor(...)/** Create a new ConcurrentTaskScheduler, using the given ... *//** Create a new ConcurrentTaskScheduler, using the given {@link java.util.concurrent.Executor} ... */this.enterpriseConcurrentSchedulernewSingleThreadScheduledExecutor(...)/** Specify the {@link java.util.concurrent.ScheduledExecutorService} to delegate to. ... *//** Provide an {@link ErrorHandler} strategy. *//** Set the clock to use for scheduling purposes. ... */this.clocknew EnterpriseConcurrentTriggerScheduler(...)decorateTask(...)getDefaultErrorHandler(...)new ReschedulingRunnable(...)RejectedExecutionException exnew TaskRejectedException(...)millis(...)Runnable resultdecorateTaskWithErrorHandler(...)/** Delegate that adapts a Spring Trigger to a JSR-236 Trigger. ... */ManagedScheduledExecutorService executornew Trigger(...) { ... }nextExecutionTime(...)new SimpleTriggerContext(...)getScheduledStart(...)getRunStart(...)getRunEnd(...)import ThreadFactoryimport CustomizableThreadCreator/** Implementation of the {@link java.util.concurrent.ThreadFactory} interface, ... *//** Create a new CustomizableThreadFactory with default thread name prefix. *//** Create a new CustomizableThreadFactory with the given thread name prefix. ... */createThread(...)/** JNDI-based variant of {@link CustomizableThreadFactory}, performing a default lookup ... */JndiLocatorDelegate jndiLocator, ...;ThreadFactory threadFactory, ...;this.jndiLocatorsetJndiEnvironment(...)/** Specify a JNDI name of the {@link java.util.concurrent.ThreadFactory} to delegate to, ... */this.threadFactoryThreadFactory.classnewThread(...)/** JNDI-based variant of {@link ConcurrentTaskExecutor}, performing a default lookup for ... *//** Specify a JNDI name of the {@link java.util.concurrent.Executor} to delegate to, ... */setConcurrentExecutor(...)/** JNDI-based variant of {@link ConcurrentTaskScheduler}, performing a default lookup for ... */ScheduledExecutorService executorsetScheduledExecutor(...)import ExecutorServiceimport RejectedExecutionHandlerimport RunnableFutureimport ThreadPoolExecutor/** Base class for setting up a {@link java.util.concurrent.ExecutorService} ... */new AbortPolicy(...)ThreadPoolExecutor.AbortPolicyboolean threadNamePrefixSet, ...;RejectedExecutionHandler rejectedExecutionHandler, ...;boolean waitForTasksToCompleteOnShutdown, ...;long awaitTerminationMillis, ...;ExecutorService executor, ...;/** Set the ThreadFactory to use for the ExecutorService's thread pool. ... */setThreadNamePrefix(...)this.threadNamePrefixSet/** Set the RejectedExecutionHandler to use for the ExecutorService. ... */this.rejectedExecutionHandler/** Set whether to wait for scheduled tasks to complete on shutdown, ... */this.waitForTasksToCompleteOnShutdown/** Set the maximum number of seconds that this executor is supposed to block ... */this.awaitTerminationMillis/** Variant of {@link #setAwaitTerminationSeconds} with millisecond precision. ... *//** Calls {@code initialize()} after the container applied all property values. ... *//** Set up the ExecutorService. */initializeExecutor(...)/** Create the target {@link java.util.concurrent.ExecutorService} instance. ... *//** Calls {@code shutdown} when the BeanFactory destroys ... */shutdown(...)/** Perform a shutdown on the underlying ExecutorService. ... */Runnable remainingTaskshutdownNow(...)cancelRemainingTask(...)awaitTerminationIfNecessary(...)/** Cancel the given remaining task which never commended execution, ... *//** Wait for the executor to terminate, according to the value of the ... */awaitTermination(...)import ForkJoinPool/** A Spring {@link FactoryBean} that builds and exposes a preconfigured {@link ForkJoinPool}. ... */availableProcessors(...)ForkJoinPool.defaultForkJoinWorkerThreadFactoryboolean commonPool, ...;int parallelism, ...;ForkJoinPool.ForkJoinWorkerThreadFactory threadFactory, ...;ForkJoinPool.ForkJoinWorkerThreadFactoryThread.UncaughtExceptionHandler uncaughtExceptionHandler, ...;Thread.UncaughtExceptionHandlerboolean asyncMode, ...;int awaitTerminationSeconds, ...;ForkJoinPool forkJoinPool, ...;/** Set whether to expose JDK 8's 'common' {@link ForkJoinPool}. ... */this.commonPool/** Specify the parallelism level. Default is {@link Runtime#availableProcessors()}. */this.parallelism/** Set the factory for creating new ForkJoinWorkerThreads. ... *//** Set the handler for internal worker threads that terminate due to unrecoverable errors ... */this.uncaughtExceptionHandler/** Specify whether to establish a local first-in-first-out scheduling mode for forked tasks ... */this.asyncMode/** Set the maximum number of seconds that this ForkJoinPool is supposed to block ... */this.awaitTerminationSecondsthis.forkJoinPoolcommonPool(...)new ForkJoinPool(...)ForkJoinPool.classTimeUnit.SECONDS// Ignored for the common pool.// Wait for all tasks to terminate - works for the common pool as well.import Delayedimport TimeoutExceptionimport DelegatingErrorHandlingRunnable/** Internal adapter that reschedules an underlying {@link Runnable} according ... */Trigger trigger, ...;SimpleTriggerContext triggerContext, ...;ScheduledExecutorService executor, ...;ScheduledFuture<?> currentFuture, ...;Date scheduledExecutionTime, ...;Object triggerContextMonitor, ...;this.triggerthis.triggerContextthis.triggerContextMonitorthis.scheduledExecutionTimegetClock(...)this.currentFutureDate actualExecutionTimeDate completionTimeupdate(...)isCancelled(...)obtainCurrentFuture(...)isDone(...)ScheduledFuture<?> currgetDelay(...)long diffimport ScheduledThreadPoolExecutor/** {@link org.springframework.beans.factory.FactoryBean} that sets up ... */int poolSize, ...;...[] scheduledExecutorTasks, ...;boolean removeOnCancelPolicy, ...;boolean continueScheduledExecutionAfterException, ...;boolean exposeUnconfigurableExecutor, ...;ScheduledExecutorService exposedExecutor, ...;/** Set the ScheduledExecutorService's pool size. ... */this.poolSize/** Register a list of ScheduledExecutorTask objects with the ScheduledExecutorService ... */this.scheduledExecutorTasks/** Set the remove-on-cancel mode on {@link ScheduledThreadPoolExecutor}. ... */this.removeOnCancelPolicy/** Specify whether to continue the execution of a scheduled task ... */this.continueScheduledExecutionAfterException/** Specify whether this FactoryBean should expose an unconfigurable ... */this.exposeUnconfigurableExecutorcreateExecutor(...)setRemoveOnCancelPolicy(...)registerTasks(...)this.exposedExecutorunconfigurableScheduledExecutorService(...)/** Create a new {@link ScheduledExecutorService} instance. ... */new ScheduledThreadPoolExecutor(...)/** Register the specified {@link ScheduledExecutorTask ScheduledExecutorTasks} ... */ScheduledExecutorTask taskgetRunnableToSchedule(...)isOneTimeTask(...)getTimeUnit(...)isFixedRate(...)getPeriod(...)/** Determine the actual Runnable to schedule for the given task. ... */new DelegatingErrorHandlingRunnable(...)getRunnable(...)TaskUtils.LOG_AND_SUPPRESS_ERROR_HANDLERTaskUtils.LOG_AND_PROPAGATE_ERROR_HANDLER// Register specified ScheduledExecutorTasks, if necessary.// Wrap executor with an unconfigurable decorator./** JavaBean that describes a scheduled executor task, consisting of the ... */Runnable runnable, ...;long delay, ...;long period, ...;TimeUnit timeUnit, ...;boolean fixedRate, ...;/** Create a new ScheduledExecutorTask, ... *//** Create a new ScheduledExecutorTask, with default ... */this.runnablethis.delay/** Create a new ScheduledExecutorTask. ... */this.periodthis.fixedRate/** Set the Runnable to schedule as executor task. *//** Return the Runnable to schedule as executor task. *//** Set the delay before starting the task for the first time, ... *//** Return the delay before starting the job for the first time. *//** Set the period between repeated task executions, in milliseconds. ... *//** Return the period between repeated task executions. *//** Is this task only ever going to execute once? ... *//** Specify the time unit for the delay and period values. ... */this.timeUnit/** Return the time unit for the delay and period values. *//** Set whether to schedule as fixed-rate execution, rather than ... *//** Return whether to schedule as fixed-rate execution. */import BlockingQueueimport LinkedBlockingQueueimport SynchronousQueue/** JavaBean that allows for configuring a {@link java.util.concurrent.ThreadPoolExecutor} ... */int corePoolSize, ...;int maxPoolSize, ...;int keepAliveSeconds, ...;boolean allowCoreThreadTimeOut, ...;int queueCapacity, ...;ExecutorService exposedExecutor, ...;/** Set the ThreadPoolExecutor's core pool size. ... */this.corePoolSize/** Set the ThreadPoolExecutor's maximum pool size. ... */this.maxPoolSize/** Set the ThreadPoolExecutor's keep-alive seconds. ... */this.keepAliveSeconds/** Specify whether to allow core threads to time out. This enables dynamic ... */this.allowCoreThreadTimeOut/** Set the capacity for the ThreadPoolExecutor's BlockingQueue. ... */this.queueCapacityBlockingQueue<Runnable> queuecreateQueue(...)ThreadPoolExecutor executorallowCoreThreadTimeOut(...)unconfigurableExecutorService(...)/** Create a new instance of {@link ThreadPoolExecutor} or a subclass thereof. ... */new ThreadPoolExecutor(...)/** Create the BlockingQueue to use for the ThreadPoolExecutor. ... */new LinkedBlockingQueue<Runnable>(...)new SynchronousQueue<Runnable>(...)ExecutorService.classimport ListenableFutureTasknew ConcurrentReferenceHashMap<Runnable,Object>(...)ConcurrentReferenceHashMap<>.ReferenceType.WEAKConcurrentReferenceHashMap<>.ReferenceTypeObject poolSizeMonitor, ...;TaskDecorator taskDecorator, ...;ThreadPoolExecutor threadPoolExecutor, ...;Map<Runnable,Object> decoratedTaskMap, ...;// Runnable decorator to user-level FutureTask, if differentthis.poolSizeMonitorthis.threadPoolExecutorsetCorePoolSize(...)/** Return the ThreadPoolExecutor's core pool size. */setMaximumPoolSize(...)/** Return the ThreadPoolExecutor's maximum pool size. */setKeepAliveTime(...)/** Return the ThreadPoolExecutor's keep-alive seconds. */this.taskDecorator/** Note: This method exposes an {@link ExecutorService} to its base class ... */new ThreadPoolExecutor(...) { ... }Runnable decorated/** Return the underlying ThreadPoolExecutor for native access. ... *//** Return the current pool size. ... */getPoolSize(...)/** Return the number of currently active threads. ... */getActiveCount(...)getThreadPoolExecutor(...)ExecutorService executorListenableFutureTask<Object> futurenew ListenableFutureTask<Object>(...)ListenableFutureTask<T> futurenew ListenableFutureTask<T>(...)Object originalthis.decoratedTaskMap// Not initialized yet: assume core pool size.// Not initialized yet: assume no active threads.// Cancel associated user-level Future handle as well/** Implementation of Spring's {@link TaskScheduler} interface, wrapping ... */new ConcurrentReferenceHashMap<Object,ListenableFuture<?>>(...)Map<Object,ListenableFuture<?>> listenableFutureMap, ...;// Underlying ScheduledFutureTask to user-level ListenableFuture handle, if any/** Set a custom {@link ErrorHandler} strategy. *//** Return the underlying ScheduledExecutorService for native access. ... *//** Return the underlying ScheduledThreadPoolExecutor, if available. ... */getScheduledThreadPoolExecutor(...)/** Return the current setting for the remove-on-cancel mode. ... */getRemoveOnCancelPolicy(...)// SchedulingTaskExecutor implementationgetScheduledExecutor(...)errorHandlingTask(...)Callable<T> taskToUsenew DelegatingErrorHandlingCallable<T>(...)ListenableFutureTask<Object> listenableFutureexecuteAndTrack(...)ListenableFutureTask<T> listenableFutureFuture<?> scheduledFuturethis.listenableFutureMapListenableFuture<?> listenableFuture// TaskScheduler implementationCallable<V> delegate, ...;// Not initialized yet: assume initial pool size.// Not initialized yet: return our setting for the time being.// Cancel associated user-level ListenableFuture handle as well/** Scheduling convenience classes for the {@code java.util.concurrent} ... *//** Parser for the 'annotation-driven' element of the 'task' namespace. ... */String ASYNC_EXECUTION_ASPECT_CLASS_NAME, ...;registerAsyncExecutionAspect(...)String executorString exceptionHandlerAopNamespaceUtils.PROXY_TARGET_CLASS_ATTRIBUTEString schedulerTaskManagementConfigUtils.ASYNC_EXECUTION_ASPECT_BEAN_NAME// Register component for the surrounding <task:annotation-driven> element.// Nest the concrete post-processor bean in the surrounding component./** {@link ScheduledTaskRegistrar} subclass which redirects the actual scheduling ... */scheduleTasks(...)/** {@link TriggerTask} implementation defining a {@code Runnable} to be executed according ... *//** Create a new {@code CronTask}. ... *//** Return the cron expression defining when the task should be executed. *//** Parser for the 'executor' element of the 'task' namespace. ... */String keepAliveSecondsString queueCapacityString poolSizeconfigureRejectionPolicy(...)String rejectionPolicyString policyClassName/** Specialization of {@link IntervalTask} for fixed-delay semantics. ... *//** Create a new {@code FixedDelayTask}. ... *//** Specialization of {@link IntervalTask} for fixed-rate semantics. ... *//** Create a new {@code FixedRateTask}. ... *//** {@link Task} implementation defining a {@code Runnable} to be executed at a given ... */long interval, ...;long initialDelay, ...;/** Create a new {@code IntervalTask}. ... */this.intervalthis.initialDelay/** Create a new {@code IntervalTask} with no initial delay. ... *//** Return how often in milliseconds the task should be executed. *//** Return the initial delay before first execution of the task. *//** A representation of a scheduled task at runtime, ... */Task task, ...;ScheduledFuture<?> future, ...;this.task/** Return the underlying task (typically a {@link CronTask}, ... *//** Trigger cancellation of this scheduled task. */ScheduledFuture<?> futurethis.future/** Common interface for exposing locally scheduled tasks. ... *//** Return an overview of the tasks that have been scheduled by this instance. */import ConcurrentTaskScheduler/** Helper bean for registering tasks with a {@link TaskScheduler}, typically using cron ... */new HashMap<Task,ScheduledTask>(...)TaskScheduler taskScheduler, ...;ScheduledExecutorService localExecutor, ...;List<TriggerTask> triggerTasks, ...;List<CronTask> cronTasks, ...;List<IntervalTask> fixedRateTasks, ...;List<IntervalTask> fixedDelayTasks, ...;Map<Task,ScheduledTask> unresolvedTasks, ...;Set<ScheduledTask> scheduledTasks, ...;/** Set the {@link TaskScheduler} to register scheduled tasks with. */this.taskScheduler/** Set the {@link TaskScheduler} to register scheduled tasks with, or a ... */new ConcurrentTaskScheduler(...)/** Return the {@link TaskScheduler} instance for this registrar (may be {@code null}). *//** Specify triggered tasks as a Map of Runnables (the tasks) and Trigger objects ... */this.triggerTasksnew ArrayList<TriggerTask>(...)new BiConsumer<Runnable,Trigger>(...) { ... }addTriggerTask(...)new TriggerTask(...)/** Specify triggered tasks as a list of {@link TriggerTask} objects. Primarily used ... *//** Get the trigger tasks as an unmodifiable list of {@link TriggerTask} objects. ... *//** Specify triggered tasks as a Map of Runnables (the tasks) and cron expressions. ... */this.cronTasksnew ArrayList<CronTask>(...)new BiConsumer<Runnable,String>(...) { ... }addCronTask(...)/** Specify triggered tasks as a list of {@link CronTask} objects. Primarily used by ... *//** Get the cron tasks as an unmodifiable list of {@link CronTask} objects. ... *//** Specify triggered tasks as a Map of Runnables (the tasks) and fixed-rate values. ... */this.fixedRateTasksnew ArrayList<IntervalTask>(...)new BiConsumer<Runnable,Long>(...) { ... }addFixedRateTask(...)/** Specify fixed-rate tasks as a list of {@link IntervalTask} objects. Primarily used ... *//** Get the fixed-rate tasks as an unmodifiable list of {@link IntervalTask} objects. ... *//** Specify triggered tasks as a Map of Runnables (the tasks) and fixed-delay values. ... */this.fixedDelayTasksaddFixedDelayTask(...)/** Specify fixed-delay tasks as a list of {@link IntervalTask} objects. Primarily used ... *//** Get the fixed-delay tasks as an unmodifiable list of {@link IntervalTask} objects. ... *//** Add a Runnable task to be triggered per the given {@link Trigger}. ... *//** Add a {@code TriggerTask}. ... *//** Add a {@link Runnable} task to be triggered per the given cron {@code expression}. ... *//** Add a {@link CronTask}. ... *//** Add a {@code Runnable} task to be triggered at the given fixed-rate interval. ... */new IntervalTask(...)/** Add a fixed-rate {@link IntervalTask}. ... *//** Add a Runnable task to be triggered with the given fixed delay. ... *//** Add a fixed-delay {@link IntervalTask}. ... *//** Return whether this {@code ScheduledTaskRegistrar} has any tasks registered. ... *//** Calls {@link #scheduleTasks()} at bean construction time. *//** Schedule all registered tasks against the underlying ... */this.localExecutorTriggerTask taskaddScheduledTask(...)scheduleTriggerTask(...)CronTask taskIntervalTask task/** Schedule the specified trigger task, either right away if possible ... */ScheduledTask scheduledTaskthis.unresolvedTasksboolean newTasknew ScheduledTask(...)scheduledTask.futuregetTrigger(...)/** Schedule the specified cron task, either right away if possible ... *//** Schedule the specified fixed-rate task, either right away if possible ... */FixedRateTask taskToUsegetInterval(...)getInitialDelay(...)Date startTime/** Schedule the specified fixed-delay task, either right away if possible ... */FixedDelayTask taskToUse/** Return all locally registered tasks that have been scheduled by this registrar. ... *//** Parser for the 'scheduled-tasks' element of the scheduling namespace. ... */String ELEMENT_SCHEDULED, ...;long ZERO_INITIAL_DELAY, ...;ManagedList<RuntimeBeanReference> cronTaskListnew ManagedList<RuntimeBeanReference>(...)ManagedList<RuntimeBeanReference> fixedDelayTaskListManagedList<RuntimeBeanReference> fixedRateTaskListManagedList<RuntimeBeanReference> triggerTaskListString schedulerRefNode childElement taskElementString cronAttributeString fixedDelayAttributeString fixedRateAttributeString triggerAttributeString initialDelayAttributeboolean hasCronAttributeboolean hasFixedDelayAttributeboolean hasFixedRateAttributeboolean hasTriggerAttributeboolean hasInitialDelayAttributeString runnableNamerunnableReference(...)isScheduledElement(...)intervalTaskReference(...)cronTaskReference(...)String triggerNametriggerTaskReference(...)beanReference(...)// lazy scheduled tasks are a contradiction in terms -> force to false// Check that 'ref' and 'method' are specified// Continue with the possible next task element// with the possible next task element// Extract the source of the current task/** Parser for the 'scheduler' element of the 'task' namespace. ... *//** Holder class defining a {@code Runnable} to be executed as a task, typically at a ... *//** Create a new {@code Task}. ... *//** Return the underlying task. */import ThreadPoolTaskExecutor/** {@link FactoryBean} for creating {@link ThreadPoolTaskExecutor} instances, ... */String poolSize, ...;Integer queueCapacity, ...;Integer keepAliveSeconds, ...;ThreadPoolTaskExecutor target, ...;ThreadPoolTaskExecutor executornew ThreadPoolTaskExecutor(...)determinePoolSizeRange(...)setQueueCapacity(...)setKeepAliveSeconds(...)setRejectedExecutionHandler(...)int corePoolSizeint maxPoolSizesetAllowCoreThreadTimeOut(...)int valuesetMaxPoolSize(...)ThreadPoolTaskExecutor.class// No queue-capacity provided, so unbounded// Actually set 'corePoolSize' to the upper bound of the range// but allow core threads to timeout...// Non-zero lower bound implies a core-max size range...String SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME, ...;/** The bean name of the internally managed Scheduled annotation processor. */String ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME, ...;/** The bean name of the internally managed Async annotation processor. */String ASYNC_EXECUTION_ASPECT_BEAN_NAME, ...;/** The bean name of the internally managed AspectJ async execution aspect. *//** {@code NamespaceHandler} for the 'task' namespace. ... */new AnnotationDrivenBeanDefinitionParser(...)new ExecutorBeanDefinitionParser(...)new ScheduledTasksBeanDefinitionParser(...)new SchedulerBeanDefinitionParser(...)/** {@link Task} implementation defining a {@code Runnable} to be executed ... *//** Create a new {@link TriggerTask}. ... *//** Return the associated trigger. *//** Support package for declarative scheduling configuration, ... *//** General exceptions for Spring's scheduling support, ... */import DateTimeExceptionimport ValueRange/** Efficient bitwise-operator extension of {@link CronField}. ... */long MASK, ...;BitsCronField zeroNanos, ...;long bits, ...;// we store at most 60 bits, for seconds and minutes, so a 64-bit long suffices/** Return a {@code BitsCronField} enabled for 0 nano seconds. */BitsCronField fieldnew BitsCronField(...)Type.NANOsetBit(...)/** Parse the given value into a seconds {@code BitsCronField}, the first entry of a cron expression. */parseField(...)Type.SECOND/** Parse the given value into a minutes {@code BitsCronField}, the second entry of a cron expression. */Type.MINUTE/** Parse the given value into a hours {@code BitsCronField}, the third entry of a cron expression. */Type.HOUR/** Parse the given value into a days of months {@code BitsCronField}, the fourth entry of a cron expression. */parseDate(...)Type.DAY_OF_MONTH/** Parse the given value into a month {@code BitsCronField}, the fifth entry of a cron expression. */Type.MONTH/** Parse the given value into a days of week {@code BitsCronField}, the sixth entry of a cron expression. */BitsCronField resultType.DAY_OF_WEEKgetBit(...)clearBit(...)BitsCronField.TypeString[] fieldsString fieldint slashPosValueRange rangeparseRange(...)setBits(...)String rangeStrString deltaStrint deltagetMinimum(...)getMaximum(...)int hyphenPoscheckValidValue(...)int minint maxint currentint nextnextSetBit(...)rollForward(...)CronExpression.MAX_ATTEMPTSelapseUntil(...)... & ...this.bits... << ...long resultnumberOfTrailingZeros(...)long minMasklong maxMask... >>> ......|=......&=...~...BitsCronField otherother.bits// cron supports 0 for Sunday; we use 7 like java.time/** Extension of {@link CronField} that wraps an array of cron fields. ... */...[] fields, ...;this.fields/** Composes the given fields into a {@link CronField}. */fields.lengthnew CompositeCronField(...)T resultCronField fieldT candidatenextOrSame(...)CompositeCronField otherimport ChronoUnit/** Representation of a ... */int MAX_ATTEMPTS, ...;...[] MACROS, ...;new CronField[]zeroNanos(...)/** Parse the given ... */resolveMacros(...)CronField secondsparseSeconds(...)CronField minutesparseMinutes(...)CronField hoursparseHours(...)CronField daysOfMonthparseDaysOfMonth(...)CronField monthsparseMonth(...)CronField daysOfWeekparseDaysOfWeek(...)new CronExpression(...)MACROS.length/** Calculate the next {@link Temporal} that matches this expression. ... */addTo(...)ChronoUnit.NANOSnextOrSameInternal(...)CronExpression otherother.fields/** Return the expression string used to create this {@code CronExpression}. ... */// to make sure we end up at 0 nanos, we add an extra fieldimport ChronoFieldimport BiFunction/** Single field in a cron pattern. Created using the {@code parse*} methods, ... */...[] MONTHS, ...;...[] DAYS, ...;Type type, ...;/** Return a {@code CronField} enabled for 0 nano seconds. *//** Parse the given value into a seconds {@code CronField}, the first entry of a cron expression. *//** Parse the given value into a minutes {@code CronField}, the second entry of a cron expression. *//** Parse the given value into a hours {@code CronField}, the third entry of a cron expression. *//** Parse the given value into a days of months {@code CronField}, the fourth entry of a cron expression. */isQuartzDaysOfMonthField(...)parseList(...)new BiFunction<String,Type,CronField>(...) { ... }/** Parse the given value into a month {@code CronField}, the fifth entry of a cron expression. */replaceOrdinals(...)/** Parse the given value into a days of week {@code CronField}, the sixth entry of a cron expression. */isQuartzDaysOfWeekField(...)CronField[] cronFieldscompose(...)list.lengthString replacement/** Get the next or same {@link Temporal} in the sequence matching this ... *//** Represents the type of cron field, i.e. seconds, minutes, hours, ... */ChronoField.NANO_OF_SECONDChronoField.SECOND_OF_MINUTEChronoField.MINUTE_OF_HOURChronoField.HOUR_OF_DAYChronoField.DAY_OF_MONTHChronoField.MONTH_OF_YEARChronoField.DAY_OF_WEEKType NANO, ...;Type SECOND, ...;Type MINUTE, ...;Type HOUR, ...;Type DAY_OF_MONTH, ...;Type MONTH, ...;Type DAY_OF_WEEK, ...;ChronoField field, ...;...[] lowerOrders, ...;this.lowerOrders/** Return the value of this type for the given temporal. ... *//** Return the general range of this type. For instance, this methods ... *//** Check whether the given value is valid, i.e. whether it falls in ... */checkValidIntValue(...)DateTimeException ex/** Elapse the given temporal for the difference between the current ... */getBaseUnit(...)long amount/** Roll forward the give temporal until it reaches the next higher ... *//** Reset this and all lower order fields of the given temporal to their ... */ChronoField lowerOrderisSupported(...)adjustInto(...)import BitSet/** Date sequence generator for a ... */new BitSet(...)BitSet months, ...;BitSet daysOfMonth, ...;BitSet daysOfWeek, ...;BitSet hours, ...;BitSet minutes, ...;BitSet seconds, ...;/** Construct a {@code CronSequenceGenerator} from the pattern provided, ... *//** Return the cron pattern that this sequence generator has been built for. *//** Get the next {@link Date} in the sequence matching the Cron pattern and ... */new GregorianCalendar(...)Calendar.MILLISECONDdoNext(...)Calendar.YEARCalendar.SECONDList<Integer> resetsint secondList<Integer> emptyListint updateSecondfindNext(...)this.secondsCalendar.MINUTEint minuteint updateMinutethis.minutesCalendar.HOUR_OF_DAYint hourint updateHourthis.hoursCalendar.DAY_OF_WEEKint dayOfWeekint dayOfMonthCalendar.DAY_OF_MONTHint updateDayOfMonthfindNextDay(...)this.daysOfMonththis.daysOfWeekint monthCalendar.MONTHint updateMonththis.months/** Search the bits provided for the next set bit after the value provided, ... */int nextValue/** Reset the calendar setting all the fields provided to zero. */int field/** Parse the given pattern expression. */// Parsing logic invoked by the constructorareValidCronFields(...)setNumberHits(...)setDaysOfMonth(...)setMonths(...)setDays(...)/** Replace the values in the comma-separated list (case insensitive) ... */String[] listString itemBitSet monthsint[] rangegetRange(...)String[] splitsplit.lengthint[] result/** Determine whether the specified expression represents a valid cron pattern. ... */new CronSequenceGenerator(...)CronSequenceGenerator otherCronotherCron.monthsotherCron.daysOfMonthotherCron.daysOfWeekotherCron.hoursotherCron.minutesotherCron.seconds/* The plan: ... */// First, just reset the milliseconds and try to calculate from there...// We arrived at the original timestamp - round up to the next whole second and try again...// the DAY_OF_WEEK values in java.util.Calendar start with 1 (Sunday),// but in the cron pattern, they start with 0, so we subtract 1 here// roll over if needed// Sunday can be represented as 0 or 7// Days of month start with 1 (in Cron and Calendar) so add one// ... and remove it from the front// Months start with 1 in Cron and 0 in Calendar, so push the values first into a longer bit set// ... and then rotate it to the front of the months// Not an incrementer so it must be a range (possibly empty)import TriggerContext/** {@link Trigger} implementation for cron expressions. ... */CronExpression expression, ...;ZoneId zoneId, ...;/** Build a {@code CronTrigger} from the pattern provided in the default time zone. ... */systemDefault(...)/** Build a {@code CronTrigger} from the pattern provided in the given time zone. ... */this.zoneId/** Return the cron pattern that this trigger has been built with. */Date datelastCompletionTime(...)ZonedDateTime dateTimeZonedDateTime nextDate scheduledlastScheduledExecutionTime(...)(...).expression// Previous task apparently executed too early...// Let's simply use the last calculated execution time then,// in order to prevent accidental re-fires in the same second./** Runnable wrapper that catches any exception or error thrown from its ... */Runnable delegate, ...;/** Create a new DelegatingErrorHandlingRunnable. ... */UndeclaredThrowableException exgetUndeclaredThrowable(...)/** Adapter that implements the {@link Runnable} interface as a configurable ... */getInvocationFailureMessage(...)/** Build a message for an invocation failure exception. ... */// Do not throw exception, else the main loop of the scheduler might stop!/** A trigger for periodic task execution. The period may be applied as either ... *//** Create a trigger with the given period in milliseconds. *//** Create a trigger with the given period and time unit. The time unit will ... *//** Return this trigger's period. ... *//** Return this trigger's time unit (milliseconds by default). ... *//** Specify the delay for the initial execution. It will be evaluated in ... *//** Return the initial delay, or 0 if none. ... *//** Specify whether the periodic interval should be measured between the ... *//** Return whether this trigger uses fixed rate ({@code true}) or ... *//** Returns the time after which a task should run again. */Date lastExecutionDate lastCompletionPeriodicTrigger otherTriggerotherTrigger.fixedRateotherTrigger.initialDelayotherTrigger.periodimport TemporalAdjusterimport TemporalAdjusters/** Extension of {@link CronField} for ... */Type rollForwardType, ...;TemporalAdjuster adjuster, ...;/** Constructor for fields that need to roll forward over a different type ... */this.adjusterthis.rollForwardType/** Returns whether the given value is a Quartz day-of-month field. *//** Parse the given value into a days of months {@code QuartzCronField}, the fourth entry of a cron expression. ... */int idxTemporalAdjuster adjusterlastWeekdayOfMonth(...)lastDayOfMonth(...)int offsetlastDayWithOffset(...)new QuartzCronField(...)weekdayNearestTo(...)/** Returns whether the given value is a Quartz day-of-week field. *//** Parse the given value into a days of week {@code QuartzCronField}, the sixth entry of a cron expression. ... */DayOfWeek dayOfWeekparseDayOfWeek(...)lastInMonth(...)int ordinaldayOfWeekInMonth(...)/** Returns an adjuster that resets to midnight. */new TemporalAdjuster(...) { ... }ChronoField.NANO_OF_DAYwith(...)/** Returns an adjuster that returns a new temporal set to the last ... */Temporal resultrollbackToMidnight(...)/** Returns an adjuster that returns the last weekday of the month. */Temporal lastDomint dowminus(...)ChronoUnit.DAYS/** Return a temporal adjuster that finds the nth-to-last day of the month. ... */plus(...)/** Return a temporal adjuster that finds the weekday nearest to the given ... */cast(...)atMidnight(...)/** Return a temporal adjuster that finds the last of the given doy-of-week ... *//** Returns a temporal adjuster that finds {@code ordinal}-th occurrence of ... *//** Rolls back the given {@code result} to midnight. When ... */adjust(...)QuartzCronField other// "LW"// "L"// "L-[0-9]+"// "[0-9]+W"// "[0-7]L"// "[0-7]#[0-9]+"// cron is 0 based; java.time 1 based// Saturday// Sunday// dayOfMonth is a weekday// dayOfMonth is a Saturday, so Friday before// dayOfMonth is a Sunday, so Monday after// dayOfMonth is the 1st, so Monday 3rd// exception for "1W" fields: execute on nearest Monday// We ended up before the start, roll forward and try again/** Variant of {@link MethodInvokingRunnable} meant to be used for processing ... *//** Create a {@code ScheduledMethodRunnable} for the given target instance, ... *//** Return the target instance to call the method on. *//** Return the target method to call. *//** Simple data holder implementation of the {@link TriggerContext} interface. ... */Date lastScheduledExecutionTime, ...;Date lastActualExecutionTime, ...;Date lastCompletionTime, ...;/** Create a SimpleTriggerContext with all time values set to {@code null}, ... *//** Create a SimpleTriggerContext with the given time values, ... */this.lastScheduledExecutionTimethis.lastActualExecutionTimethis.lastCompletionTime/** Update this holder's state with the latest time values. ... *//** Utility methods for decorating tasks with error handling. ... */new LoggingErrorHandler(...)new PropagatingErrorHandler(...)ErrorHandler LOG_AND_SUPPRESS_ERROR_HANDLER, ...;/** An ErrorHandler strategy that will log the Exception but perform ... */ErrorHandler LOG_AND_PROPAGATE_ERROR_HANDLER, ...;/** An ErrorHandler strategy that will log at error level and then ... *//** Decorate the task for error handling. If the provided {@link ErrorHandler} ... */ErrorHandler eh/** Return the default {@link ErrorHandler} implementation based on the boolean ... *//** An {@link ErrorHandler} implementation that logs the Throwable at error ... */LoggingErrorHandler.class/** Generic support classes for scheduling. ... *//** Exception to be thrown on script compilation failure. ... */ScriptSource scriptSource, ...;/** Constructor for ScriptCompilationException. ... */this.scriptSource/** Return the source for the offending script. ... *//** Spring's strategy interface for evaluating a script. ... *//** Evaluate the given script. ... *//** Evaluate the given script with the given arguments. ... *//** Script definition interface, encapsulating the configuration ... *//** Return a locator that points to the source of the script. ... *//** Return the business interfaces that the script is supposed to implement. ... *//** Return whether the script requires a config interface to be ... *//** Factory method for creating the scripted Java object. ... *//** Determine the type of the scripted Java object. ... *//** Determine whether a refresh is required (e.g. through ... *//** Interface that defines the source of a script. ... *//** Retrieve the current script source text as String. ... *//** Indicate whether the underlying script data has been modified since ... *//** Determine a class name for the underlying script. ... */import EvalErrorimport Interpreterimport ScriptCompilationExceptionimport ScriptEvaluatorimport ScriptSource/** BeanShell-based implementation of Spring's {@link ScriptEvaluator} strategy interface. ... *//** Construct a new BshScriptEvaluator. *//** Construct a new BshScriptEvaluator. ... */Interpreter interpreternew Interpreter(...)eval(...)getScriptAsString(...)new ScriptCompilationException(...)EvalError eximport ScriptFactory/** {@link org.springframework.scripting.ScriptFactory} implementation ... */String scriptSourceLocator, ...;...[] scriptInterfaces, ...;Class<?> scriptClass, ...;Object scriptClassMonitor, ...;boolean wasModifiedForTypeCheck, ...;/** Create a new BshScriptFactory for the given script source. ... */this.scriptSourceLocatorthis.scriptInterfaces/** BeanShell scripts do require a config interface. *//** Load and parse the BeanShell script via {@link BshScriptUtils}. ... */this.scriptClassMonitorboolean requiresScriptEvaluationthis.wasModifiedForTypeCheckthis.scriptClassevaluateBshScript(...)createBshObject(...)determineBshObjectType(...)// New script content: Let's check whether it evaluates to a Class.// A Class: We'll cache the Class here and create an instance// outside of the synchronized block.// Not a Class: OK, we'll simply create BeanShell objects// through evaluating the script for every call later on.// For this first-time check, let's simply return the// already evaluated object.// A Class: We need to create an instance for every call.// Not a Class: We need to evaluate the script for every call.import Primitiveimport XThis/** Utility methods for handling BeanShell-scripted objects. ... *//** Create a new BeanShell-scripted object from the given script source. ... *//** Create a new BeanShell-scripted object from the given script source, ... *//** Evaluate the specified BeanShell script based on the given script source, ... */XThis xtnew BshObjectInvocationHandler(...)/** InvocationHandler that invokes a BeanShell script method. */XThis xt, ...;this.xtisProxyForSameBshObject(...)Primitive.NULLPrimitive.VOIDnew BshExecutionException(...)(...).xt/** Exception to be thrown on script execution failure. */// Simple BeanShell script: Let's create a proxy for it, implementing the given interfaces./** Package providing integration of ... *//** {@code NamespaceHandler} that supports the wiring of ... */registerScriptBeanDefinitionParser(...)new ScriptingDefaultsParser(...)new ScriptBeanDefinitionParser(...)import ScriptFactoryPostProcessor/** Utilities for use with {@link LangNamespaceHandler}. ... */String SCRIPT_FACTORY_POST_PROCESSOR_BEAN_NAME, ...;/** The unique name under which the internally managed {@link ScriptFactoryPostProcessor} is ... *//** Register a {@link ScriptFactoryPostProcessor} bean definition in the supplied ... */ScriptFactoryPostProcessor.class/** BeanDefinitionParser implementation for the '{@code <lang:groovy/>}', ... */String ENGINE_ATTRIBUTE, ...;String SCRIPT_SOURCE_ATTRIBUTE, ...;String INLINE_SCRIPT_ELEMENT, ...;String SCRIPT_INTERFACES_ATTRIBUTE, ...;String REFRESH_CHECK_DELAY_ATTRIBUTE, ...;String CUSTOMIZER_REF_ATTRIBUTE, ...;String scriptFactoryClassName, ...;/** The {@link org.springframework.scripting.ScriptFactory} class that this ... *//** Create a new instance of this parser, creating bean definitions for the ... */this.scriptFactoryClassName/** Parses the dynamic object element and returns the resulting bean definition. ... */String engineresolveScriptSource(...)int autowireModeBeanDefinitionDefaults beanDefinitionDefaultsString initMethodString refreshCheckDelayString proxyTargetClassint constructorArgNumregisterScriptFactoryPostProcessorIfNecessary(...)ScriptFactoryPostProcessor.LANGUAGE_ATTRIBUTEString destroyMethodScriptFactoryPostProcessor.REFRESH_CHECK_DELAY_ATTRIBUTEScriptFactoryPostProcessor.PROXY_TARGET_CLASS_ATTRIBUTEString customizerBeanName/** Resolves the script source from either the '{@code script-source}' attribute or ... */boolean hasScriptSourceList<Element> elementsElement inlineElement/** Scripted beans may be anonymous as well. */// Engine attribute only supported for <lang:std>// Resolve the script source.// Set up infrastructure.// Create script factory bean definition.// Determine bean scope.// Determine autowire mode.// Only "byType" and "byName" supported, but maybe other default inherited...// Parse depends-on list of bean names.// Retrieve the defaults for bean definitions within this parser context// Determine init method and destroy method.// Attach any refresh metadata.// Attach any proxy target class metadata.// Add constructor arguments.// This is used for Groovy. It's a bean reference to a customizer bean.// Add any property definitions that need adding./** A {@link BeanDefinitionParser} for use when loading scripting XML. ... *//** Support package for Spring's dynamic language machinery, ... *//** Strategy used by {@link GroovyScriptFactory} to allow the customization of ... *//** Customize the supplied {@link GroovyObject}. ... */import GroovyRuntimeExceptionimport CompilerConfigurationimport CompilationCustomizerimport ResourceScriptSource/** Groovy-based implementation of Spring's {@link ScriptEvaluator} strategy interface. ... */new CompilerConfiguration(...)CompilerConfiguration compilerConfiguration, ...;/** Construct a new GroovyScriptEvaluator. *//** Construct a new GroovyScriptEvaluator. ... *//** Set a custom compiler configuration for this evaluator. ... */this.compilerConfiguration/** Return this evaluator's compiler configuration (never {@code null}). ... *//** Set one or more customizers to be applied to this evaluator's compiler configuration. ... */addCompilationCustomizers(...)GroovyShell groovyShellnew Binding(...)GroovyRuntimeException eximport GroovyClassLoaderimport Scriptimport CompilationFailedExceptionGroovyObjectCustomizer groovyObjectCustomizer, ...;GroovyClassLoader groovyClassLoader, ...;Class<?> scriptResultClass, ...;CachedResultHolder cachedResult, ...;/** Create a new GroovyScriptFactory for the given script source. ... *//** Create a new GroovyScriptFactory for the given script source, ... */this.groovyObjectCustomizerignoreDependencyType(...)MetaClass.classhasCompatibleConfiguration(...)this.groovyClassLoaderbuildGroovyClassLoader(...)/** Return the GroovyClassLoader used by this script factory. *//** Build a {@link GroovyClassLoader} for the given {@code ClassLoader}. ... */new GroovyClassLoader(...)/** Groovy scripts determine their interfaces themselves, ... *//** Groovy scripts do not need a config interface, ... *//** Loads and parses the Groovy script via the GroovyClassLoader. ... */Class<?> scriptClassToExecutethis.cachedResultthis.cachedResult.objectparseClass(...)getGroovyClassLoader(...)suggestedClassName(...)Script.classexecuteScript(...)this.scriptResultClassCompilationFailedException exnew CachedResultHolder(...)/** Instantiate the given Groovy script class and run it if necessary. ... */GroovyObject goo/** Wrapper that holds a temporarily cached result object. */// New script content...// A Groovy script, probably creating an instance: let's execute it.// Process re-execution outside of the synchronized block.// Allow metaclass and other customization.// An instance of the scripted class: let's return it as-is./** Core interfaces for Spring's scripting support. */import BeanFactoryRefreshableTargetSource/** Subclass of {@link BeanFactoryRefreshableTargetSource} that determines whether ... */ScriptFactory scriptFactory, ...;boolean isFactoryBean, ...;/** Create a new RefreshableScriptTargetSource. ... */this.scriptFactorythis.isFactoryBean/** Determine whether a refresh is required through calling ... */requiresScriptedObjectRefresh(...)/** Obtain a fresh target object, retrieving a FactoryBean if necessary. *//** {@link org.springframework.scripting.ScriptSource} implementation ... */EncodedResource resource, ...;long lastModified, ...;Object lastModifiedMonitor, ...;/** Create a new ResourceScriptSource for the given resource. ... *//** Return the {@link org.springframework.core.io.Resource} to load the ... *//** Set the encoding used for reading the script resource. ... */this.lastModifiedMonitorthis.lastModifiedretrieveLastModifiedTime(...)copyToString(...)/** Retrieve the current last-modified timestamp of the underlying resource. ... */stripFilenameExtension(...)import BeanDefinitionValidationExceptionimport InterfaceMaker/** {@link org.springframework.beans.factory.config.BeanPostProcessor} that ... */new ConcurrentHashMap<String,ScriptSource>(...)String INLINE_SCRIPT_PREFIX, ...;/** The {@link org.springframework.core.io.Resource}-style prefix that denotes ... *//** The {@code refreshCheckDelay} attribute. *//** The {@code proxyTargetClass} attribute. */String LANGUAGE_ATTRIBUTE, ...;/** The {@code language} attribute. */String SCRIPT_FACTORY_NAME_PREFIX, ...;String SCRIPTED_OBJECT_NAME_PREFIX, ...;long defaultRefreshCheckDelay, ...;boolean defaultProxyTargetClass, ...;DefaultListableBeanFactory scriptBeanFactory, ...;Map<String,ScriptSource> scriptSourceCache, ...;/** Map from bean name String to ScriptSource object. */this.defaultRefreshCheckDelay/** Flag to signal that refreshable proxies should be created to proxy the target class not its interfaces. ... */this.defaultProxyTargetClassthis.scriptBeanFactoryScriptFactory.classString scriptFactoryBeanNameString scriptedObjectBeanNameScriptFactory scriptFactoryScriptSource scriptSourcegetScriptSource(...)getScriptSourceLocator(...)Class<?>[] interfacesgetScriptInterfaces(...)Class<?> scriptedTypegetScriptedObjectType(...)prepareScriptBeans(...)long refreshCheckDelayresolveRefreshCheckDelay(...)Class<?> scriptedObjectTypeRefreshableScriptTargetSource tsnew RefreshableScriptTargetSource(...)resolveProxyTargetClass(...)createRefreshableProxy(...)/** Prepare the script beans in the internal BeanFactory that this ... */Class<?>[] scriptedInterfacesBeanDefinition objectBdcreateScriptedObjectBeanDefinition(...)createScriptFactoryBeanDefinition(...)requiresConfigInterface(...)Class<?> configInterfacecreateConfigInterface(...)/** Get the refresh check delay for the given {@link ScriptFactory} {@link BeanDefinition}. ... */Object attributeValue/** Create a ScriptFactory bean definition based on the given script definition, ... */GenericBeanDefinition scriptBd/** Obtain a ScriptSource for the given bean, lazily creating it ... */this.scriptSourceCachenew Function<String,ScriptSource>(...) { ... }convertToScriptSource(...)/** Convert the given script source locator to a ScriptSource instance. ... */new StaticScriptSource(...)new ResourceScriptSource(...)/** Create a config interface for the given bean definition, defining setter ... */InterfaceMaker makernew InterfaceMaker(...)String setterNameSignature signaturenew Signature(...)Type.VOID_TYPEnew Type[]/** Create a bean definition for the scripted object, based on the given script ... */GenericBeanDefinition objectBd/** Create a refreshable proxy for the given AOP TargetSource. ... */DelegatingIntroductionInterceptor introductionTargetSource.class/** Destroy the inner bean factory (used for scripts) on shutdown. */// Required so that references (up container hierarchies) are correctly resolved.// We only apply special treatment to ScriptFactory implementations here.// Returned type may be null if the factory is unable to determine the type.// Avoid recreation of the script bean definition in case of a prototype.// force use of Class.getClassLoader()import ScriptException/** Exception decorating a {@link javax.script.ScriptException} coming out of ... */ScriptException scriptException, ...;/** Construct a new script eval exception with the specified original exception. */this.scriptExceptionimport Bindingsimport ScriptEngineimport ScriptEngineManager/** {@code javax.script} (JSR-223) based implementation of Spring's {@link ScriptEvaluator} ... */String engineName, ...;Bindings globalBindings, ...;ScriptEngineManager scriptEngineManager, ...;/** Construct a new {@code StandardScriptEvaluator}. *//** Construct a new {@code StandardScriptEvaluator} for the given class loader. ... */this.scriptEngineManagernew ScriptEngineManager(...)/** Construct a new {@code StandardScriptEvaluator} for the given JSR-223 ... *//** Set the name of the language meant for evaluating the scripts (e.g. "Groovy"). ... */this.engineName/** Set the name of the script engine for evaluating the scripts (e.g. "Groovy"), ... *//** Set the globally scoped bindings on the underlying script engine manager, ... */Bindings bindingsgetBindings(...)ScriptEngineManager scriptEngineManagerthis.globalBindingssetBindings(...)ScriptEngine enginegetScriptEngine(...)ScriptException exnew StandardScriptEvalException(...)/** Obtain the JSR-223 ScriptEngine to use for the given script. ... */retrieveEngineByName(...)String extensiongetFilenameExtension(...)getEngineByExtension(...)import Invocable/** {@link org.springframework.scripting.ScriptFactory} implementation based ... */String scriptEngineName, ...;ScriptEngine scriptEngine, ...;/** Create a new StandardScriptFactory for the given script source. ... */this.scriptEngineName/** Load and parse the script via JSR-223's ScriptEngine. */Object scriptevaluateScript(...)boolean adaptationRequiredClass<?> requestedIfcadaptToInterfaces(...)Class<?> scriptClassScriptEngine scriptEnginethis.scriptEngineretrieveScriptEngine(...)Class<?> adaptedIfcactualInterfaces.lengthInvocable invocablegetInterface(...)import ScriptContextimport ScriptEngineFactoryimport SimpleBindings/** Common operations for dealing with a JSR-223 {@link ScriptEngine}. ... *//** Retrieve a {@link ScriptEngine} from the given {@link ScriptEngineManager} ... */getEngineByName(...)Set<String> engineNamesScriptEngineFactory engineFactorygetEngineFactories(...)List<String> factoryNamesgetNames(...)ScriptContext.GLOBAL_SCOPEnew SimpleBindings(...)// Special case: getEngineByName returned null but engine is present...// Let's assume it failed to initialize (which ScriptEngineManager silently swallows).// If it happens to initialize fine now, alright, but we really expect an exception./** Static implementation of the ... */String script, ...;String className, ...;/** Create a new StaticScriptSource for the given script. ... */setScript(...)this.className/** Set a fresh script String, overriding the previous script. ... */this.script/** Support classes for Spring's scripting package. ... *//** Indicates that an annotated class is a "component". ... *//** The value may indicate a suggestion for a logical component name, ... *//** Indicates that an annotated class is a "Controller" (e.g. a web controller). ... *//** Indicate that the annotated element represents a stereotype for the index. ... *//** Indicates that an annotated class is a "Repository", originally defined by ... *//** Indicates that an annotated class is a "Service", originally defined by Domain-Driven ... *//** Annotations denoting the roles of types or methods in the overall architecture ... *//** Implementation of the {@link Model} interface based on a {@link ConcurrentHashMap} ... *//** Construct a new, empty {@code ConcurrentModel}. *//** Construct a new {@code ModelMap} containing the supplied attribute ... */addAttribute(...)/** Construct a new {@code ModelMap} containing the supplied attribute. ... */Entry<? extends String,?> entryMap<>.Entry<? extends String,?>/** Add the supplied attribute under the supplied name. ... *//** Add the supplied attribute to this {@code Map} using a ... */getVariableName(...)/** Copy all attributes in the supplied {@code Collection} into this ... *//** Copy all attributes in the supplied {@code Map} into this {@code Map}. ... *//** Copy all attributes in the supplied {@code Map} into this {@code Map}, ... *//** Does this model contain an attribute of the given name? ... *//** Subclass of {@link ModelMap} that implements the {@link Model} interface. ... */addAllAttributes(...)mergeAttributes(...)/** Java-5-specific interface that defines a holder for model attributes. ... *//** Return the attribute value for the given name, if any. ... *//** Return the current set of model attributes as a Map. *//** Implementation of {@link java.util.Map} for use when building model data for use ... *//** Construct a new, empty {@code ModelMap}. *//** Sub-interface of ThemeSource to be implemented by objects that ... *//** Set the parent that will be used to try to resolve theme messages ... *//** Return the parent of this ThemeSource, or {@code null} if none. *//** A Theme can resolve theme-specific messages, codes, file paths, etcetera ... *//** Return the name of the theme. ... *//** Return the specific MessageSource that resolves messages ... *//** Interface to be implemented by objects that can resolve {@link Theme Themes}. ... *//** Return the Theme instance for the given theme name. ... *//** Contains classes defining the application context subinterface ... */import HierarchicalThemeSourceimport Themeimport ThemeSource/** Empty ThemeSource that delegates all calls to the parent ThemeSource. ... */ThemeSource parentThemeSource, ...;this.parentThemeSourcegetTheme(...)import ResourceBundleMessageSource/** {@link ThemeSource} implementation that looks up an individual ... */new ConcurrentHashMap<String,Theme>(...)String basenamePrefix, ...;Boolean fallbackToSystemLocale, ...;Map<String,Theme> themeCache, ...;/** Map from theme name to Theme instance. */this.themeCacheTheme themeinitParent(...)/** Set the prefix that gets applied to the ResourceBundle basenames, ... */this.basenamePrefix/** Set the default charset to use for parsing resource bundle files. ... *//** Set whether to fall back to the system Locale if no files for a ... *//** This implementation returns a SimpleTheme instance, holding a ... */MessageSource messageSourcecreateMessageSource(...)new SimpleTheme(...)/** Create a MessageSource for the given basename, ... */ResourceBundleMessageSource messageSourcenew ResourceBundleMessageSource(...)setBasename(...)setFallbackToSystemLocale(...)/** Initialize the MessageSource of the given theme with the ... */HierarchicalMessageSource messageSourcegetParentThemeSource(...)Theme parentTheme// Update existing Theme objects.// Usually there shouldn't be any at the time of this call./** Default {@link Theme} implementation, wrapping a name and an ... *//** Create a SimpleTheme. ... *//** Utility class for UI application context implementations. ... */UiApplicationContextUtils.classString THEME_SOURCE_BEAN_NAME, ...;/** Name of the ThemeSource bean in the factory. ... *//** Initialize the ThemeSource for the given application context, ... */ThemeSource themeSourceThemeSource.classHierarchicalThemeSource htssetParentThemeSource(...)HierarchicalThemeSource themeSourcenew DelegatingThemeSource(...)new ResourceBundleThemeSource(...)// Make ThemeSource aware of parent ThemeSource.// Only set parent context as parent ThemeSource if no parent ThemeSource// Use default ThemeSource to be able to accept getTheme calls, either// delegating to parent context's default or to local ResourceBundleThemeSource./** Classes supporting the org.springframework.ui.context package. ... *//** Generic support for UI layer concepts. ... *//** Abstract implementation of the {@link BindingResult} interface and ... */new DefaultMessageCodesResolver(...)new ArrayList<ObjectError>(...)MessageCodesResolver messageCodesResolver, ...;List<ObjectError> errors, ...;Map<String,Class<?>> fieldTypes, ...;Map<String,Object> fieldValues, ...;Set<String> suppressedFields, ...;/** Create a new AbstractBindingResult instance. ... *//** Set the strategy to use for resolving errors into message codes. ... */this.messageCodesResolver/** Return the strategy to use for resolving errors into message codes. */// Implementation of the Errors interfaceaddError(...)new ObjectError(...)resolveMessageCodes(...)String fixedFieldfixedField(...)getActualFieldValue(...)FieldError fenew FieldError(...)reject(...)getAllErrors(...)List<ObjectError> resultObjectError objectErrorList<FieldError> resultnew ArrayList<FieldError>(...)isMatchingFieldError(...)FieldError fieldErrorgetFieldError(...)getRejectedValue(...)formatFieldValue(...)isBindingFailure(...)this.fieldValues/** This default implementation determines the type based on the actual ... */this.fieldTypes/** Return a model Map for the obtained state, exposing an Errors ... */// Implementation of BindingResult interfaceMap<String,Object> model/** This implementation delegates to the ... */PropertyEditorRegistry editorRegistrygetPropertyEditorRegistry(...)Class<?> valueTypeToUse/** This implementation returns {@code null}. */getMessageCodesResolver(...)/** Mark the specified disallowed field as suppressed. ... */this.suppressedFields/** Return the list of fields that were suppressed during the bind process. ... */BindingResult otherResult/** Return the wrapped target object. */// Template methods to be implemented/overridden by subclasses/** Extract the actual field value for the given field. ... *//** Format the given value for the specified field. ... */// We're at the top of the nested object hierarchy,// so the present level is not a field but rather the top object.// The best we can do is register a global error here...// Use rejected value in case of error, current field value otherwise.// Do not apply formatting on binding failures like type mismatches.// Mapping from name to target object.// Errors instance, even if no errors.import NoSuchElementException/** Abstract implementation of the {@link Errors} interface. Provides common ... */new ArrayDeque<String>(...)Deque<String> nestedPathStack, ...;doSetNestedPath(...)this.nestedPathStackString formerNestedPathNoSuchElementException ex/** Actually set the nested path. ... */canonicalFieldName(...)Errors.NESTED_PATH_SEPARATOR/** Transform the given field into its full path, ... *//** Determine the canonical field name for the given field. ... */rejectValue(...)getGlobalErrors(...)getFieldErrors(...)getGlobalErrorCount(...)List<ObjectError> globalErrorsgetFieldErrorCount(...)List<FieldError> fieldErrorsFieldError errorgetFieldValue(...)/** Check whether the given FieldError matches the given field. ... */regionMatches(...)getErrorCount(...)ObjectError error// Optimization: use charAt and regionMatches instead of endsWith and startsWith (SPR-11304)import ConfigurablePropertyAccessorimport ConvertingPropertyEditorAdapter/** Abstract base class for {@link BindingResult} implementations that work with ... *//** Create a new AbstractPropertyBindingResult instance. ... */getPropertyAccessor(...)/** Returns the underlying PropertyAccessor. ... *//** Returns the canonical property name. ... *//** Determines the field type from the property type. ... *//** Fetches the field value from the PropertyAccessor. ... *//** Formats the field value based on registered PropertyEditors. ... */PropertyEditor customEditorString textValueTypeDescriptor fieldDescTypeDescriptor strDesc/** Retrieve the custom PropertyEditor for the given field, if any. ... *//** This implementation exposes a PropertyEditor adapter for a Formatter, ... */Class<?> valueTypeForLookupfindEditor(...)TypeDescriptor ptdnew ConvertingPropertyEditorAdapter(...)/** Provide the PropertyAccessor to work with, according to the ... */// Try custom editor...// If the PropertyEditor returned null, there is no appropriate// text representation for this value: only use it if non-null.// Try custom converter.../** Default implementation of the {@link Errors} and {@link BindingResult} ... */BeanWrapper beanWrapper, ...;/** Creates a new instance of the {@link BeanPropertyBindingResult} class. ... *//** Returns the {@link BeanWrapper} that this instance uses. ... */createBeanWrapper(...)/** Create a new {@link BeanWrapper} for the underlying target object. ... *//** Thrown when binding errors are considered fatal. Implements the ... */BindingResult bindingResult, ...;/** Create a new BindException instance for a BindingResult. ... */this.bindingResult/** Create a new BindException instance for a target bean. ... */new BeanPropertyBindingResult(...)/** Return the BindingResult that this BindException wraps. */setNestedPath(...)pushNestedPath(...)popNestedPath(...)addAllErrors(...)hasErrors(...)hasGlobalErrors(...)getGlobalError(...)hasFieldErrors(...)getModel(...)getRawFieldValue(...)recordFieldValue(...)recordSuppressedField(...)getSuppressedFields(...)/** Returns diagnostic information about the errors held in this object. */import PropertyAccessException/** Strategy for processing {@code DataBinder}'s missing field errors, ... *//** Apply the missing field error to the given BindException. ... *//** Translate the given {@code PropertyAccessException} to an appropriate ... *//** General interface that represents binding results. Extends the ... */BindingResult.classString MODEL_KEY_PREFIX, ...;/** Prefix for the name of the BindingResult instance in a model, ... *//** Return the wrapped target object, which may be a bean, an object with ... *//** Return a model Map for the obtained state, exposing a BindingResult ... *//** Extract the raw field value for the given field. ... *//** Return the underlying PropertyEditorRegistry. ... *//** Resolve the given error code into message codes. ... *//** Resolve the given error code into message codes for the given field. ... *//** Add a custom {@link ObjectError} or {@link FieldError} to the errors list. ... *//** Record the given value for the specified field. ... *//** Convenience methods for looking up BindingResults in a model Map. ... *//** Find the BindingResult for the given name in the given model. ... */Object attrBindingResult.MODEL_KEY_PREFIX/** Find a required BindingResult for the given name in the given model. ... */BindingResult bindingResultgetBindingResult(...)import PropertyBatchUpdateExceptionimport FormatterPropertyEditorAdapter/** Binder that allows for setting property values onto a target object, ... */new DefaultBindingErrorProcessor(...)new ArrayList<Validator>(...)DataBinder.classString DEFAULT_OBJECT_NAME, ...;/** Default object name used for binding: "target". */int DEFAULT_AUTO_GROW_COLLECTION_LIMIT, ...;/** Default limit for array and collection growing: 256. *//** We'll create a lot of DataBinder instances: Let's use a static logger. */AbstractPropertyBindingResult bindingResult, ...;boolean directFieldAccess, ...;SimpleTypeConverter typeConverter, ...;boolean ignoreUnknownFields, ...;boolean ignoreInvalidFields, ...;...[] allowedFields, ...;...[] disallowedFields, ...;...[] requiredFields, ...;BindingErrorProcessor bindingErrorProcessor, ...;List<Validator> validators, ...;/** Create a new DataBinder instance, with default object name. ... *//** Create a new DataBinder instance. ... *//** Return the name of the bound object. *//** Set whether this binder should attempt to "auto-grow" a nested path that contains a null value. ... *//** Specify the limit for array and collection auto-growing. ... *//** Return the current limit for array and collection auto-growing. *//** Initialize standard JavaBean property access for this DataBinder. ... */this.directFieldAccess/** Create the {@link AbstractPropertyBindingResult} instance using standard ... */BeanPropertyBindingResult resultinitConversion(...)setMessageCodesResolver(...)/** Initialize direct field access for this DataBinder, ... *//** Create the {@link AbstractPropertyBindingResult} instance using direct ... */DirectFieldBindingResult resultnew DirectFieldBindingResult(...)/** Return the internal BindingResult held by this DataBinder, ... */createDirectFieldBindingResult(...)createBeanPropertyBindingResult(...)/** Return the underlying PropertyAccessor of this binder's BindingResult. */getInternalBindingResult(...)/** Return this binder's underlying SimpleTypeConverter. *//** Return the underlying TypeConverter of this binder's BindingResult. */getSimpleTypeConverter(...)/** Return the BindingResult instance created by this DataBinder. ... *//** Set whether to ignore unknown fields, that is, whether to ignore bind ... */this.ignoreUnknownFields/** Return whether to ignore unknown fields when binding. *//** Set whether to ignore invalid fields, that is, whether to ignore bind ... */this.ignoreInvalidFields/** Return whether to ignore invalid fields when binding. *//** Register fields that should be allowed for binding. Default is all ... */this.allowedFields/** Return the fields that should be allowed for binding. ... *//** Register fields that should <i>not</i> be allowed for binding. Default is none. ... */this.disallowedFields/** Return the fields that should <i>not</i> be allowed for binding. ... *//** Register fields that are required for each binding process. ... */this.requiredFields/** Return the fields that are required for each binding process. ... *//** Set the strategy to use for processing binding errors, that is, ... */this.bindingErrorProcessor/** Return the strategy for processing binding errors. *//** Set the Validator to apply after each binding step. ... */assertValidators(...)this.validatorsValidator validator/** Add Validators to apply after each binding step. ... *//** Replace the Validators to apply after each binding step. ... *//** Return the primary Validator to apply after each binding step, if any. *//** Return the Validators to apply after data binding. */// Implementation of PropertyEditorRegistry/TypeConverter interface/** Add a custom formatter, applying it to all fields matching the ... */FormatterPropertyEditorAdapter adapternew FormatterPropertyEditorAdapter(...)/** Add a custom formatter for the field type specified in {@link Formatter} class, ... *//** Add a custom formatter, applying it to the specified field types only, if any, ... *//** Bind the given property values to this binder's target. ... */doBind(...)/** Actual implementation of the binding process, working with the ... */checkAllowedFields(...)checkRequiredFields(...)/** Check the given property values against the allowed fields, ... */isAllowed(...)/** Return if the given field is allowed for binding. ... */String[] allowedgetAllowedFields(...)String[] disallowedgetDisallowedFields(...)/** Check the given property values against the required fields, ... */String[] requiredFieldsgetRequiredFields(...)Map<String,PropertyValue> propertyValuesnew HashMap<String,PropertyValue>(...)boolean emptyprocessMissingFieldError(...)getBindingErrorProcessor(...)/** Apply given property values to the target object. ... */isIgnoreUnknownFields(...)isIgnoreInvalidFields(...)PropertyBatchUpdateException exgetPropertyAccessExceptions(...)processPropertyAccessException(...)/** Invoke the specified Validators, if any. ... */getValidators(...)/** Invoke the specified Validators, if any, with the given validation hints. ... *//** Close this DataBinder, which may result in throwing ... */new BindException(...)// Use bind error processor to create FieldError.// Remove property from property values to bind:// It has already caused a field error with a rejected value.// Bind request parameters onto target object.// Use bind error processor to create FieldErrors.// Call each validator with the same binding resultimport DefaultMessageSourceResolvable/** Default {@link BindingErrorProcessor} implementation. ... */String MISSING_FIELD_ERROR_CODE, ...;/** Error code that a missing field error (i.e. a required field not ... */getArgumentsForBindError(...)getErrorCode(...)Object rejectedValuegetLocalizedMessage(...)/** Return FieldError arguments for a binding error on the given field. ... */new DefaultMessageSourceResolvable(...)// Create field error with code "required".// Create field error with the exceptions's code, e.g. "typeMismatch"./** Default implementation of the {@link MessageCodesResolver} interface. ... */Format.PREFIX_ERROR_CODEString CODE_SEPARATOR, ...;/** The separator that this implementation uses when resolving message codes. */MessageCodeFormatter DEFAULT_FORMATTER, ...;MessageCodeFormatter formatter, ...;/** Specify a prefix to be applied to any code built by this resolver. ... *//** Return the prefix to be applied to any code built by this resolver. ... *//** Specify the format for message codes built by this resolver. ... *//** Build the code list for the given code and field: an ... */Set<String> codeListList<String> fieldListbuildFieldList(...)addCodes(...)addCode(...)postProcessMessageCode(...)/** Add both keyed and non-keyed entries for the supplied {@code field} ... */String plainFieldint keyIndexint endKeyIndex/** Post-process the given message code, built by this resolver. ... *//** Common message code formats. ... */new Format(...) { ... }/** Prefix the error code at the beginning of the generated message code. e.g.: ... */toDelimitedString(...)/** Postfix the error code at the end of the generated message code. e.g.: ... */Format PREFIX_ERROR_CODE, ...;Format POSTFIX_ERROR_CODE, ...;/** Concatenate the given elements, delimiting each with ... */StringJoiner rtnString element/** Special implementation of the Errors and BindingResult interfaces, ... */ConfigurablePropertyAccessor directFieldAccessor, ...;/** Create a new DirectFieldBindingResult instance. ... *//** Returns the DirectFieldAccessor that this instance uses. ... */this.directFieldAccessorcreateDirectFieldAccessor(...)/** Create a new DirectFieldAccessor for the underlying target object. ... */forDirectFieldAccess(...)/** Stores and exposes information about data-binding and validation ... */PropertyAccessor.NESTED_PROPERTY_SEPARATORString NESTED_PATH_SEPARATOR, ...;/** The separator between path elements in a nested path, ... *//** Return the name of the bound root object. *//** Allow context to be changed so that standard validators can validate ... *//** Return the current nested path of this {@link Errors} object. ... *//** Push the given sub path onto the nested path stack. ... *//** Pop the former nested path from the nested path stack. ... *//** Register a global error for the entire target object, ... *//** Register a field error for the specified field of the current object ... *//** Add all errors from the given {@code Errors} instance to this ... *//** Return if there were any errors. *//** Return the total number of errors. *//** Get all errors, both global and field ones. ... *//** Are there any global errors? ... *//** Return the number of global errors. ... *//** Get all global errors. ... *//** Get the <i>first</i> global error, if any. ... *//** Are there any field errors? ... *//** Return the number of errors associated with a field. ... *//** Get all errors associated with a field. ... *//** Get the <i>first</i> error associated with a field, if any. ... *//** Are there any errors associated with the given field? ... *//** Return the number of errors associated with the given field. ... *//** Get all errors associated with the given field. ... *//** Get the first error associated with the given field, if any. ... *//** Return the current value of the given field, either the current ... *//** Return the type of a given field. ... *//** Encapsulates a field error, that is, a reason for rejecting a specific ... */String field, ...;Object rejectedValue, ...;boolean bindingFailure, ...;/** Create a new FieldError instance. ... */this.rejectedValuethis.bindingFailure/** Return the affected field of the object. *//** Return the rejected field value. *//** Return whether this error represents a binding failure ... */FieldError otherError/** Map-based implementation of the BindingResult interface, ... */Map<?,?> target, ...;/** Create a new MapBindingResult instance. ... *//** Return the target Map to bind onto. *//** A strategy interface for formatting message codes. ... *//** Build and return a message code consisting of the given fields, ... *//** Strategy interface for building message codes from validation error codes. ... *//** Build message codes for the given error code and object name. ... *//** Build message codes for the given error code and field specification. ... *//** Encapsulates an object error, that is, a global reason for rejecting ... *//** Create a new instance of the ObjectError class. ... *//** Return the name of the affected object. *//** Preserve the source behind this error: possibly an {@link Exception} ... *//** Unwrap the source behind this error: possibly an {@link Exception} ... *//** Check the source behind this error: possibly an {@link Exception} ... */ObjectError otherError/** Extended variant of the {@link Validator} interface, adding support for ... *//** Validate the supplied {@code target} object, which must be of a type of {@link Class} ... *//** Validate the supplied value for the specified field on the target type, ... *//** Utility class offering convenient methods for invoking a {@link Validator} ... */ValidationUtils.class/** Invoke the given {@link Validator} for the supplied object and ... */invokeValidator(...)/** Invoke the given {@link Validator}/{@link SmartValidator} for the supplied object and ... *//** Reject the given field with the given error code if the value is empty. ... */rejectIfEmpty(...)/** Reject the given field with the given error code and default message ... *//** Reject the given field with the given error code and error arguments ... *//** Reject the given field with the given error code, error arguments ... *//** Reject the given field with the given error code if the value is empty ... */rejectIfEmptyOrWhitespace(...)/** A validator for application-specific objects. ... *//** Can this {@link Validator} {@link #validate(Object, Errors) validate} ... *//** Validate the supplied {@code target} object, which must be ... *//** Variant of JSR-303's {@link javax.validation.Valid}, supporting the ... *//** Specify one or more validation groups to apply to the validation step ... *//** Support classes for annotation-based constraint evaluation, ... */import ConstraintViolationimport Validationimport Validatorimport ValidatorFactory/** Simple {@link BeanPostProcessor} that checks JSR-303 constraint annotations ... */Validator validator, ...;boolean afterInitialization, ...;/** Set the JSR-303 Validator to delegate to for validating beans. ... */this.validator/** Set the JSR-303 ValidatorFactory to delegate to for validating beans, ... */getValidator(...)/** Choose whether to perform validation after bean initialization ... */this.afterInitializationbuildDefaultValidatorFactory(...)doValidate(...)/** Perform validation of the given bean. ... */Object objectToValidateSet<ConstraintViolation<Object>> resultIterator<ConstraintViolation<Object>> itConstraintViolation<Object> violationgetPropertyPath(...)import MessageInterpolatorimport TraversableResolverimport ValidatorContext/** Configurable bean class that exposes a specific JSR-303 Validator ... */ValidatorFactory validatorFactory, ...;MessageInterpolator messageInterpolator, ...;TraversableResolver traversableResolver, ...;/** Set the ValidatorFactory to obtain the target Validator from. ... */this.validatorFactory/** Specify a custom MessageInterpolator to use for this Validator. */this.messageInterpolator/** Specify a custom TraversableResolver to use for this Validator. */this.traversableResolverValidatorContext validatorContextusingContext(...)MessageInterpolator targetInterpolatorgetMessageInterpolator(...)messageInterpolator(...)new LocaleContextMessageInterpolator(...)traversableResolver(...)setTargetValidator(...)import ConstraintValidatorFactoryimport ParameterNameProviderimport ValidationExceptionimport ValidationProviderResolverimport GenericBootstrapimport ProviderSpecificBootstrapimport ResourceBundleMessageInterpolator/** This is the central class for {@code javax.validation} (JSR-303) setup in a Spring ... */Class<> providerClass, ...;ValidationProviderResolver validationProviderResolver, ...;ConstraintValidatorFactory constraintValidatorFactory, ...;Map<String,String> validationPropertyMap, ...;/** Specify the desired provider class, if any. ... */this.providerClass/** Specify a JSR-303 {@link ValidationProviderResolver} for bootstrapping the ... */this.validationProviderResolver/** Specify a custom MessageInterpolator to use for this ValidatorFactory ... *//** Specify a custom Spring MessageSource for resolving validation messages, ... */buildMessageInterpolator(...)/** Specify a custom TraversableResolver to use for this ValidatorFactory ... *//** Specify a custom ConstraintValidatorFactory to use for this ValidatorFactory. ... */this.constraintValidatorFactory/** Set the ParameterNameDiscoverer to use for resolving method and constructor ... *//** Specify resource locations to load XML constraint mapping files from, if any. *//** Specify bean validation properties to be passed to the validation provider. ... */this.validationPropertyMap/** Specify bean validation properties to be passed to the validation provider as a Map. ... *//** Allow Map access to the bean validation properties to be passed to the validation provider, ... */Configuration<?> configurationConstraintValidatorFactory targetConstraintValidatorFactoryProviderSpecificBootstrap<> bootstrapbyProvider(...)providerResolver(...)GenericBootstrap bootstrapbyDefaultProvider(...)Method eclMethodgetDefaultMessageInterpolator(...)new SpringConstraintValidatorFactory(...)getAutowireCapableBeanFactory(...)constraintValidatorFactory(...)configureParameterNameProvider(...)addMapping(...)postProcessConfiguration(...)buildValidatorFactory(...)ParameterNameProvider defaultProvidergetDefaultParameterNameProvider(...)parameterNameProvider(...)new ParameterNameProvider(...) { ... }/** Post-process the given Bean Validation configuration, ... */getTraversableResolver(...)getConstraintValidatorFactory(...)getParameterNameProvider(...)/* @Override ... */// instead which will fully support a getClockProvider() call as well.// Obtain the native ValidatorFactory through unwrap(ValidatorFactory.class)// To be resolved once Spring Framework requires Bean Validation 2.0+.// a hard dependency on the new javax.validation.ClockProvider interface.// Bean Validation 2.0: currently not implemented here since it would implyValidatorFactory.classunwrap(...)ValidationException exnew ValidationException(...)/** Inner class to avoid a hard-coded Hibernate Validator dependency. */new ResourceBundleMessageInterpolator(...)new MessageSourceResourceBundleLocator(...)// Try Hibernate Validator 5.2's externalClassLoader(ClassLoader) method// Ignore - no Hibernate Validator 5.2+ or similar provider// Allow for custom post-processing before we actually build the ValidatorFactory.// ignore - we'll try ValidatorFactory unwrapping next// ignore if just being asked for ValidatorFactory/** Delegates to a target {@link MessageInterpolator} implementation but enforces Spring's ... */MessageInterpolator targetInterpolator, ...;/** Create a new LocaleContextMessageInterpolator, wrapping the given target interpolator. ... */this.targetInterpolatorinterpolate(...)import ResourceBundleLocatorimport MessageSourceResourceBundle/** Implementation of Hibernate Validator 4.3/5.x's {@link ResourceBundleLocator} interface, ... *//** Build a MessageSourceResourceBundleLocator for the given MessageSource. ... */new MessageSourceResourceBundle(...)import ConstraintViolationExceptionimport ExecutableValidatorimport Validated/** An AOP Alliance {@link MethodInterceptor} implementation that delegates to a ... *//** Create a new MethodValidationInterceptor using a default JSR-303 validator underneath. *//** Create a new MethodValidationInterceptor using the given JSR-303 ValidatorFactory. ... *//** Create a new MethodValidationInterceptor using the given JSR-303 Validator. ... */Class<?>[] groupsdetermineValidationGroups(...)ExecutableValidator execValforExecutables(...)Method methodToValidateisFactoryBeanMetadataMethod(...)validateParameters(...)new ConstraintViolationException(...)validateReturnValue(...)Class<?> factoryBeanType/** Determine the validation groups to validate against for the given method invocation. ... */Validated validatedAnnValidated.class// Avoid Validator invocation on FactoryBean.getObjectType/isSingleton// Standard Bean Validation 1.1 API// Probably a generic type mismatch between interface and impl as reported in SPR-12237 / HV-1011// Let's try to find the bridged method on the implementation class...// Call from interface-based proxy handle, allowing for an efficient check?// Call from CGLIB proxy handle, potentially implementing a FactoryBean method?/** A convenient {@link BeanPostProcessor} implementation that delegates to a ... */Class<? extends Annotation> validatedAnnotationType, ...;/** Set the 'validated' annotation type. ... */this.validatedAnnotationType/** Set the JSR-303 Validator to delegate to for validating methods. ... */Validator.class/** Set the JSR-303 ValidatorFactory to delegate to for validating methods, ... */createMethodValidationAdvice(...)/** Create AOP advice for method validation purposes, to be applied ... */new MethodValidationInterceptor(...)// Unwrap to the native Validator with forExecutables support/** {@link LocalValidatorFactoryBean} subclass that simply turns ... */import ConstraintValidator/** JSR-303 {@link ConstraintValidatorFactory} implementation that delegates to a ... *//** Create a new SpringConstraintValidatorFactory for the given BeanFactory. ... */// Bean Validation 1.1 releaseInstance methodimport ElementKindimport ConstraintDescriptorimport NotReadablePropertyExceptionimport BindingResultimport Errorsimport FieldErrorimport ObjectErrorimport SmartValidator/** Adapter that takes a JSR-303 {@code javax.validator.Validator} and ... */Set<String> internalAnnotationAttributes, ...;Validator targetValidator, ...;/** Create a new SpringValidatorAdapter for the given JSR-303 Validator. ... */this.targetValidator// Implementation of Spring Validator interfaceprocessConstraintViolations(...)asValidationGroups(...)validateValue(...)/** Turn the specified validation hints into JSR-303 validation groups. ... */Set<Class<?>> groupsObject hint/** Process the given JSR-303 ConstraintViolations, adding corresponding errors to ... */determineField(...)ConstraintDescriptor<?> cdgetConstraintDescriptor(...)String errorCodedetermineErrorCode(...)Object[] errorArgsgetArgumentsForConstraint(...)String nestedFieldString[] errorCodesnew ViolationObjectError(...)new ViolationFieldError(...)/** Determine a field for the given constraint violation. ... */boolean firstPath.NodeisInIterable(...)Object indexElementKind.PROPERTY/** Determine a Spring-reported error code for the given constraint descriptor. ... *//** Return FieldError arguments for a validation error on the given field. ... */List<Object> argumentsMap<String,Object> attributesToExposenew TreeMap<String,Object>(...)getResolvableField(...)new ResolvableAttribute(...)/** Build a resolvable wrapper for the specified field, allowing to resolve the field's ... *//** Extract the rejected value behind the given constraint violation, ... */Object invalidValuegetInvalidValue(...)getLeafBean(...)/** Indicate whether this violation's interpolated message has remaining ... */containsSpringStylePlaceholder(...)// Implementation of JSR-303 Validator interfacevalidateProperty(...)getConstraintsForClass(...)/** Wrapper for a String attribute which can be resolved via a {@code MessageSource}, ... */String resolvableString, ...;this.resolvableString/** Subclass of {@code ObjectError} with Spring-style default message rendering. */SpringValidatorAdapter adapter, ...;ConstraintViolation<?> violation, ...;this.adapterthis.violationrequiresMessageFormat(...)/** Subclass of {@code FieldError} with Spring-style default message rendering. */// Can do custom FieldError registration with invalid value from ConstraintViolation,// as necessary for Hibernate Validator compatibility (non-indexed set path in field)// got no BindingResult - can only do standard rejectValue call// with automatic extraction of the current field value// Using a TreeMap for alphabetical ordering of attribute names// Possibly a bean constraint with property path: retrieve the actual property value.// However, explicitly avoid this for "address[]" style paths that we can't handle.// ignore if just being asked for plain Validator/** Support classes for integrating a JSR-303 Bean Validation provider ... *//** Provides data binding and validation functionality, ... */import ConcurrentModel/** Subclass of {@link ConcurrentModel} that automatically removes ... */removeBindingResultIfNecessary(...)String resultKeyBindingResult resultimport ExtendedModelMap/** Subclass of {@link org.springframework.ui.ExtendedModelMap} that automatically removes ... */new BiConsumer<? extends String,?>(...) { ... }String bindingResultKey/** Support classes for handling validation results. */DevComponent.PROFILE_NAMEString PROFILE_NAME, ...;ProfileAnnotatedComponent.PROFILE_NAMEProfileAnnotatedComponent.BEAN_NAMEString BEAN_NAME, ...;ProfileMetaAnnotatedComponent.BEAN_NAMEimport Lazyimport AsyncResultFooDao fooDao, ...;findFoo(...)this.fooDaonew AsyncResult<String>(...)/** Not a plain String value - needs to be ignored during name detection. */import Asyncimport DependsOnimport AbstractApplicationContextcomparing(...)new Function<MessageBean,String>(...) { ... }Comparator<MessageBean> COMPARATOR_BY_MESSAGE, ...;// Just to test ASM5's bytecode parsing of INVOKESPECIAL/STATIC on interfacesList<ListableBeanFactory> listableBeanFactory, ...;ApplicationEventPublisher eventPublisher, ...;ApplicationContext context, ...;...[] configurableContext, ...;AbstractApplicationContext genericContext, ...;fooDao(...)getThreadLocalCount(...)/** Marker class for {@code example.scannable} package. ... */new ThreadLocal<Integer>(...)int useCount, ...;ThreadLocal<Integer> threadLocalCount, ...;this.useCountimport ComponentScannew ConfigurableComponent(...)// override of scanned class/** Aspect used as part of before advice binding tests and ... */AdviceBindingCollaborator collaborator, ...;this.collaborator// "advice" methodsoneIntArg(...)oneObjectArg(...)oneIntAndOneObject(...)needsJoinPoint(...)needsJoinPointStaticPart(...)/** Collaborator interface that makes it easy to test this aspect is ... */import AdviceBindingCollaborator/** Tests for various parameter binding scenarios with before advice. ... */AdviceBindingCollaborator mockCollaborator, ...;ITestBean testBeanProxy, ...;TestBean testBeanTarget, ...;ClassPathXmlApplicationContext ctxAdviceBindingTestAspect afterAdviceAspectAdviceBindingCollaborator.classsetCollaborator(...)this.testBeanProxythis.testBeanTarget// we need the real target too, not just the proxy...import AfterReturningAdviceBindingCollaboratorimport static Mockito.verifyNoInteractionsAfterReturningAdviceBindingTestAspect afterAdviceAspect, ...;AfterReturningAdviceBindingCollaborator mockCollaborator, ...;AfterReturningAdviceBindingCollaborator.classoneString(...)returnsThis(...)oneTestBeanArg(...)ITestBean[] spousesgetSpouses(...)testBeanArrayArg(...)verifyNoInteractions(...)objectMatchNoArgs(...)haveBirthday(...)oneInt(...)getCollaborator(...)stringMatchNoArgs(...)import AfterThrowingAdviceBindingCollaboratorAfterThrowingAdviceBindingTestAspect afterThrowingAdviceAspect, ...;AfterThrowingAdviceBindingCollaborator mockCollaborator, ...;AfterThrowingAdviceBindingCollaborator.classnoArgs(...)oneThrowable(...)noArgsOnThrowableMatch(...)oneRuntimeException(...)noArgsOnRuntimeExceptionMatch(...)// working as expected through mocking.// collaborator interface that makes it easy to test this aspect isAfterThrowingAdviceBindingCollaborator collaborator, ...;import AroundAdviceBindingCollaboratorAroundAdviceBindingCollaborator mockCollaborator, ...;ApplicationContext ctx, ...;AroundAdviceBindingTestAspect aroundAdviceAspectITestBean injectedTestBeanAroundAdviceBindingCollaborator.classjustJoinPoint(...)AroundAdviceBindingCollaborator collaborator, ...;/** Collaborator interface that makes it easy to test this aspect ... */Object tbObject tb2PrecedenceTestAspect highPrecedenceAspect, ...;PrecedenceTestAspect lowPrecedenceAspect, ...;SimpleSpringBeforeAdvice highPrecedenceSpringAdvice, ...;SimpleSpringBeforeAdvice lowPrecedenceSpringAdvice, ...;PrecedenceTestAspect.CollaboratorCollaborator collaboratornew PrecedenceVerifyingCollaborator(...)this.highPrecedenceAspectthis.lowPrecedenceAspectthis.highPrecedenceSpringAdvicethis.lowPrecedenceSpringAdvice...[] EXPECTED, ...;int adviceInvocationNumber, ...;String expectingEXPECTED.lengthcheckAdvice(...)Collaborator collaborator, ...;beforeAdviceOne(...)beforeAdviceTwo(...)int retaroundAdviceOne(...)aroundAdviceTwo(...)afterAdviceOne(...)afterAdviceTwo(...)PrecedenceTestAspect.Collaborator collaborator, ...;/* (non-Javadoc) ... */// this order confirmed by running the same aspects (minus the Spring AOP advisors)// through AspectJ...// 1// 2// 3,  before proceed// 4,  before proceed// 5// 6// 7// 8// 9,  before proceed// 10, before proceed// 11, after proceed// 12, after proceed// 13// 14// 15, after proceed// 16, after proceed// 17// 18//System.out.println("[" + adviceInvocationNumber + "] " + whatJustHappened + " ==> " + EXPECTED[adviceInvocationNumber]);CallCountingInterceptor interceptor, ...;import AspectJProxyFactory/** Test for correct application of the bean() PCD for &#64;AspectJ-based aspects. ... */ITestBean testBean1, ...;CounterAspect counterAspect, ...;counterAspect.countITestBean testBeanAspectJProxyFactory factoryCounterAspect myCounterAspectnew CounterAspect(...)ITestBean proxyTestBeanmyCounterAspect.count// Call two methods to test for SPR-3953-like condition/** Test for correct application of the bean() PCD for XML-based AspectJ aspects. ... */ITestBean testBean2, ...;ITestBean testBeanContainingNestedBean, ...;Map<?,?> testFactoryBean1, ...;Map<?,?> testFactoryBean2, ...;Counter counterAspect, ...;ITestBean interceptThis, ...;ITestBean dontInterceptThis, ...;TestInterceptor testInterceptor, ...;ClassPathXmlApplicationContext ctx, ...;// We don't need to test all combination of pointcuts due to BeanNamePointcutMatchingTeststhis.counterAspectthis.testBeanContainingNestedBeanthis.testFactoryBean1this.testFactoryBean2this.interceptThisthis.dontInterceptThistestInterceptor.interceptionCountint interceptionCount, ...;AdviceBindingTestAspect beforeAdviceAspect/** A simple counter for use in simple tests (for example, how many times an advice was executed) ... */TopsyTurvyAspect aspect, ...;TopsyTurvyTarget target, ...;AspectCollaborator collabnew AspectCollaborator(...)this.aspectcollab.beforeFiredgetX(...)collab.aroundFiredcollab.afterReturningFired/** public visibility is required */beforeAdviceFired(...)afterReturningAdviceFired(...)aroundAdviceFired(...)int x, ...;this.xTopsyTurvyAspect.Collaboratorboolean afterReturningFired, ...;boolean aroundFired, ...;boolean beforeFired, ...;this.afterReturningFiredthis.aroundFiredthis.beforeFiredNoMethodsBean noMethodsBean, ...;Counter counter, ...;Object introductionObject, ...;// on the introduction, in which case this would not be a problem.// Perhaps generated advisor bean definition could be made to depend// to org.springframework..* it also matches introduction.// TODO if you change type pattern from org.springframework.beans..*// Invoke a non-advised method/** Tests to check if the first implicit join point argument is correctly processed. ... */// nothing to really test; it is enough if we don't get error while creating the app context// nothing to really test; it is enough if we don't get error while creating app context/** Integration tests for overloaded advice. ... *//** Test for SPR-3522. Arguments changed on a call to proceed should be ... */SimpleBean testBean, ...;ProceedTestingAspect firstTestAspect, ...;ProceedTestingAspect secondTestAspect, ...;setMyFloat(...)getLastBeforeFloatValue(...)this.firstTestAspectsetSex(...)getLastBeforeStringValue(...)this.secondTestAspectgetLastAroundStringValue(...)float aFloat, ...;this.aFloatString lastBeforeStringValue, ...;String lastAroundStringValue, ...;float lastBeforeFloatValue, ...;float fvthis.lastBeforeStringValuethis.lastAroundStringValuefloat tjpArgabs(...)this.lastBeforeFloatValue/** Check that an aspect that depends on another bean, where the referenced bean ... */checkXmlAspect(...)checkAtAspectJAspect(...)ICounter counterJoinPointMonitorAspect callCountingAspectcallCountingAspect.beforeExecutionscallCountingAspect.aroundExecutionsJoinPointMonitorAtAspectJAspect callCountingAspectICounter counter, ...;/** The counter property is purposefully not used in the aspect to avoid distraction ... */int beforeExecutions, ...;int aroundExecutions, ...;/* The counter property is purposefully not used in the aspect to avoid distraction ... *//** See SPR-1682. ... */ToBeAdvised toBeAdvised, ...;this.toBeAdvisedNonSerializableFoo nonSerializableBean, ...;SerializableFoo serializableBean, ...;Bar bar, ...;this.serializableBeanthis.nonSerializableBean//strange looking interfaces are just to set up certain test conditions.../** Tests for target selection matching (see SPR-3783). ... */TestInterface testImpl1, ...;TestInterface testImpl2, ...;TestAspect testAspectForTestImpl1, ...;TestAspect testAspectForAbstractTestImpl, ...;testAspectForTestImpl1.counttestAspectForAbstractTestImpl.counttestInterceptor.countinterfaceMethod(...)// include the advised method's implementation (instead a base class should include it)// Reproducing bug requires that the class specified in target() pointcut doesn'tTestInterface testBean, ...;TestInterface testAnnotatedClassBean, ...;TestInterface testAnnotatedMethodBean, ...;doIt(...)counter.thisAsClassCountercounter.thisAsInterfaceCountercounter.targetAsClassCountercounter.targetAsInterfaceCountercounter.thisAsClassAndTargetAsClassCountercounter.thisAsInterfaceAndTargetAsInterfaceCountercounter.atTargetClassAnnotationCountercounter.atAnnotationMethodAnnotationCounterint thisAsClassCounter, ...;int thisAsInterfaceCounter, ...;int targetAsClassCounter, ...;int targetAsInterfaceCounter, ...;int thisAsClassAndTargetAsClassCounter, ...;int thisAsInterfaceAndTargetAsInterfaceCounter, ...;int thisAsInterfaceAndTargetAsClassCounter, ...;int atTargetClassAnnotationCounter, ...;int atAnnotationMethodAnnotationCounter, ...;Counter thisAsClassCounter, ...;Counter thisAsInterfaceCounter, ...;Counter targetAsClassCounter, ...;Counter targetAsInterfaceCounter, ...;Counter thisAsClassAndTargetAsClassCounter, ...;Counter thisAsInterfaceAndTargetAsInterfaceCounter, ...;Counter thisAsInterfaceAndTargetAsClassCounter, ...;// not annotatedAnnotatedTestBean testBean, ...;doThis(...)doThat(...)doTheOther(...)/** Test for ensuring the aspects aren't advised. See SPR-3893 for more details. ... */AnInterface interfaceExtendingAspectITestBean adrianLazyTestBean.instantiationsint instantiations, ...;import AspectMetadataimport MethodInvokingFactoryBean/** Integration tests for AspectJ auto-proxying. Includes mixing with Spring AOP Advisors ... */Log factoryLog, ...;ClassPathXmlApplicationContext bfnewContext(...)MethodInvokingFactoryBean factoryBeangetTargetObject(...)ClassPathXmlApplicationContext acITestBean shouldBeWeaveddoTestAspectsAndAdvisorAreApplied(...)GenericApplicationContext childAcITestBean beanFromChildContextThatShouldBeWeavedTestBeanAdvisor tbaMultiplyReturnValue mrvgetMultiple(...)tba.countmrv.invocationsITestBean adrian1ITestBean adrian2int explicitlySetAgetestAgeAspect(...)age(...)AdviceUsingThisJoinPoint aspectInstancegetLastMethodEntered(...)ProxyConfig pcUnreliableBean beanRetryAspect aspectint attemptsunreliable(...)getBeginCalls(...)getRollbackCalls(...)getCommitCalls(...)/** Returns a new {@link ClassPathXmlApplicationContext} for the file ending in <var>fileSuffix</var>. */qName(...)/** Returns the relatively qualified name for <var>fileSuffix</var>. ... */long totalTimeMillisgetLastTaskName(...)String lastEntry, ...;this.lastEntryint beginCalls, ...;int commitCalls, ...;int rollbackCalls, ...;/** Retry Advice */boolean retrythis.beginCallsthis.commitCallsRetryableException rethis.rollbackCallsint calls, ...;this.callsnew RetryableException(...)// Create a child factory with a bean that should be woven// Register the advisor auto proxy creator with subclass//testAspectsAndAdvisorAreApplied(childAc, (ITestBean) ac.getBean("adrian"));// Does not trigger advice or count// Fire aspect//assertEquals("Any other setter does not increment", 2, adrian1.getAge());//(AdviceUsingThisJoinPoint) Aspects.aspectOf(AdviceUsingThisJoinPoint.class);//assertEquals("method-execution(int TestBean.getAge())",aspectInstance.getLastMethodEntered());ExceptionHandlingAspect aspectIOException exceptionThrownaspect.handledaspect.lastExceptionint handled, ...;IOException lastException, ...;doArray(...).lengthdoArray(...)String annValue/** Integration tests for AspectJ auto proxying. Includes mixing with Spring AOP ... */BenchmarkTests.classString ASPECTJ_CONTEXT, ...;String SPRING_AOP_CONTEXT, ...;testRepeatedAroundAdviceInvocations(...)testBeforeAdviceWithoutJoinPoint(...)testAfterReturningAdviceWithoutJoinPoint(...)testMix(...)/** Change the return number to a higher number to make this test useful. */getLastTaskTimeMillis(...)Advised aint afterTakesInt, ...;new TraceAfterReturningAdvice(...)int beforeStringReturn, ...;new TraceBeforeAdvice(...)// Hits joinpoint// Hit all 3 joinpoints// Invoke three non-advised methodsService service, ...;serveMe(...)//return pjp.proceed();import Employee/** Tests ensuring that after-returning advice for generic parameters bound to ... */GenericReturnTypeVariationClass testBean, ...;getStrings(...)counterAspect.getStringsInvocationsCountcounterAspect.getIntegersInvocationsCountgetIntegers(...)counterAspect.getRawsInvocationsCountcounterAspect.getNumbersInvocationsCountgetTestBeans(...)counterAspect.getTestBeanInvocationsCountgetEmployees(...)new ArrayList<Employee>(...)int getRawsInvocationsCount, ...;int getStringsInvocationsCount, ...;int getIntegersInvocationsCount, ...;int getNumbersInvocationsCount, ...;int getTestBeanInvocationsCount, ...;/** Tests for AspectJ pointcut expression matching when working with bridge methods. ... */genericDerivedInterfaceMethod(...)genericBaseInterfaceMethod(...)DerivedInterface<String> testBean, ...;GenericCounterAspect counterAspect, ...;/** Tests that pointcut matching is correct with generic method parameter. ... */GenericInterface<String> testBean, ...;save(...)counterAspect.genericInterfaceGenericArgExecutionCountsaveAll(...)counterAspect.genericInterfaceGenericCollectionArgExecutionCountcounterAspect.genericInterfaceSubtypeGenericCollectionArgExecutionCountint genericInterfaceGenericArgExecutionCount, ...;int genericInterfaceGenericCollectionArgExecutionCount, ...;int genericInterfaceSubtypeGenericCollectionArgExecutionCount, ...;new Predicate<BeanDefinitionStoreException>(...) { ... }new Predicate<BeanCreationException>(...) { ... }/** Unit tests for aop namespace. ... */CountingBeforeAdvice getAgeCounterCountingBeforeAdvice getNameCounterCountingAspectJAdvice advicegetBeforeCount(...)getAfterCount(...)int beforeCount, ...;int afterCount, ...;int aroundCount, ...;this.beforeCountthis.afterCountthis.aroundCount// check the advice detailsMethodLocatingFactoryBean factory, ...;new MethodLocatingFactoryBean(...)setMethodName(...)import MarshalExceptionimport SQLExceptionimport LockMixinimport LockMixinAdvisorimport LockedExceptionimport NameMatchMethodPointcutimport HotSwappableTargetSourceimport CountingAfterReturningAdvicenew MockTargetSource(...)MockTargetSource mockTargetSource, ...;/** Make a clean target source available if code wants to use it. ... *//** Set in CGLIB or JDK mode. *//** Is a target always required? */AdvisedSupport pcAopProxy aop/** Simple test that if we set values we can get them out again. */int age1int age2TestBean target1isSerializable(...)SerializablePerson spAdvice iSerializablePerson personTargetCountingThrowsAdvice ctanew CountingThrowsAdvice(...)Advised a1Advised a2NopInterceptor ninew CountingAfterReturningAdvice(...)/** Check that the two MethodInvocations necessary are independent and ... */NopInterceptor di1ITestBean advised1TestBean target2NopInterceptor di2ITestBean advised2new ProxyMatcherInterceptor(...)new CheckMethodInvocationIsSameInAndOutInterceptor(...)new CheckMethodInvocationViaThreadLocalIsSameInAndOutInterceptor(...)INeedsToSeeProxy targetnew TargetChecker(...)INeedsToSeeProxy proxiedincrementViaThis(...)incrementViaProxy(...)NeedsToSeeProxy etnew NeedsToSeeProxy(...)testContext(...)/** @param */MethodInterceptor miassertNoInvocationContext(...)requiresTarget(...)/** Test that the proxy returns itself when the ... */new OwnSpouse(...)ProxyCreatorSupport pcException expectedExceptionnew Predicate<Exception>(...) { ... }/** An interceptor throws a checked exception not on the method signature. ... */Exception unexpectedExceptionnew Consumer<UndeclaredThrowableException>(...) { ... }RuntimeException unexpectedExceptionnew Predicate<RuntimeException>(...) { ... }/** Check that although a method is eligible for advice chain optimization and ... */NeedsToSeeProxy targetINeedsToSeeProxy.classInvocationCheckExposedInvocationTestBean expectedTargetnew InvocationCheckExposedInvocationTestBean(...)TrapTargetInterceptor tiinew TrapTargetInterceptor(...) { ... }/** Throw an exception if there is an Invocation. *//** Test stateful interceptor */ProxyFactory pcnew LockMixinAdvisor(...)testTestBeanIntroduction(...)new LockMixin(...)LockedException.classITestBean tnew StringSetterNullReplacementAdvice(...)long tsTimeStamped intronew DummyIntroductionAdviceImpl(...)/** Check that the introduction advice isn't allowed to introduce interfaces ... *//** Note that an introduction can't throw an unexpected checked exception, ... */new MyDi(...)/** Should only be able to introduce interfaces, not classes. *//** Check that casting to Advised can't get around advice freeze. */ITestBean proxy1ITestBean proxy2HashMap<ITestBean,Object> hnew HashMap<ITestBean,Object>(...)Object value1Object value2/** Check that the string is informative. */MethodBeforeAdvice mbaString proxyConfigStringtoProxyConfigString(...)CountingBeforeAdvice mbaCountingAdvisorListener lnew CountingAdvisorListener(...)RefreshCountingAdvisorChainFactory acfnew RefreshCountingAdvisorChainFactory(...)addListener(...)l.activatesacf.refreshesl.adviceChangesremoveListener(...)TestDynamicPointcutAdvice dpnew TestDynamicPointcutAdvice(...)dp.countTestDynamicPointcutForSettersOnly dpnew TestDynamicPointcutForSettersOnly(...)this.mockTargetSourceTestStaticPointcutAdvice spnew TestStaticPointcutAdvice(...)/** There are times when we want to call proceed() twice. ... */MethodInterceptor twoBirthdayInterceptorMethodInvocation clone1MethodInvocation clone2StaticMethodMatcherPointcutAdvisor advisornew StaticMethodMatcherPointcutAdvisor(...) { ... }/** We want to change the arguments on a clone: it shouldn't affect the original. */MethodInterceptor nameReverterMethodInvocation cloneString oldNameNameSaver savernew NameSaver(...)String name1String name2List<Object> names, ...;saver.namesOverloads targetnew Overloads(...)NopInterceptor overLoadVoidsNopInterceptor overLoadIntsIOverloads proxyoverload(...)noAdvice(...)Advised configIOther anew AllInstancesAreEqual(...)IOther bNopInterceptor i1NopInterceptor i2ProxyFactory pfaProxyFactory pfbIOther proxyAIOther proxyBAdvisor matchesNoArgsMapAwareMethodInterceptor mami1new MapAwareMethodInterceptor(...)Map<String,String> firstValuesToAddMapAwareMethodInterceptor mami2MapAwareMethodInterceptor mami3MapAwareMethodInterceptor mami4Map<String,String> secondValuesToAddMapAwareMethodInterceptor mami5Map<String,String> finalExpectedMapAwareMethodInterceptor mami6Map<String,String> expectedValues, ...;Map<String,String> valuesToAdd, ...;this.expectedValuesthis.valuesToAddReflectiveMethodInvocation rmigetUserAttributes(...)CountingMultiAdvice ccanew CountingMultiAdvice(...)SpecializedUncheckedException.classnew SpecializedUncheckedException(...)CountingBeforeAdvice banew CountingBeforeAdvice(...) { ... }NopInterceptor nop1SummingAfterAdvice aanew SummingAfterAdvice(...)Advisor matchesIntint sum, ...;aa.sumCountingAfterReturningAdvice carException excnew Consumer<Throwable>(...) { ... }Advisor matchesEchoInvocationsEcho targetIEcho proxiedFileNotFoundException fexsetA(...)getA(...)new Predicate<FileNotFoundException>(...) { ... }MarshalException mexnew MarshalException(...)MarshalException.classnew Predicate<MarshalException>(...) { ... }Object retval/** ExposeInvocation must be set to true. */String taskMethodInvocation currentSystem.err/** Same thing for a proxy. ... *//** Fires on setter methods that take a string. Replaces null arg with "". */MethodInterceptor cleaner, ...;new DynamicMethodMatcherPointcut(...) { ... }boolean run/** Note that trapping the Invocation as in previous version of this test ... */INeedsToSeeProxy thisViaProxycheckAdvised(...)int adviceChanges, ...;int activates, ...;AdvisedSupport expectedSource, ...;this.expectedSourceint refreshes, ...;UncheckedException.classint gets, ...;int releases, ...;/** Check that gets and releases match *///Add no interceptors// This isn't serializable// Try various advice types/* expected */// Will throw exception if it fails// Check we can manipulate state of p2// This should work as SerializablePerson is equal// Check we can add a new advisor to the target// Permit proxy and invocation checkers to get context from AopContext// Must be first// = 1 invocation// = 2 invocations// = 3 invocations// Means extra call on advised 2// = 4 invocations on 1 and another one on 2// Got hit by call to advised1.getSpouse().getAge()// = 5 invocations, as reentrant call to spouse is advised also// 1 invocation// 2 invocations// Should fail to get proxy as exposeProxy wasn't set to true// Test return value// Keep CGLIB happy// We don't care about the object// Note: exception param below isn't used// Now let's try it with the special target// It will complain if it can't get the proxy// Assert that target matches BEFORE invocation returns// We don't use an IntroductionAdvisor, we can just add an advice that implements IntroductionInfo// Unlock// Null replacement magic should work// will remove di// Unchanged// Check it still works: proxy factory state shouldn't have been corrupted// TODO May fail on either call: may want to tighten up definition// TODO used to catch UnknownAdviceTypeException, but// with CGLIB some errors are in proxy creation and are wrapped// in aspect exception. Error message is still fine.//assertTrue(ex.getMessage().indexOf("ntroduction") > -1);// Didn't get removed// Can now remove it// Should be automatically added as a listener// No longer counting// Change to a new static target// Change to a new dynamic target// Change back, relying on casting to Advised// Could apply dynamically to getAge/setAge but not to getName// Statically vetoed// Applies statically but not dynamically// Clone the invocation to proceed three times// "The Moor's Last Sigh": this technology can cause premature aging// Should return the age before the third, AOP-induced birthday// Return the final age produced by 3 birthdays/** Changes the name, then changes it back. */// Original method invocation should be unaffected by changes to argument list of clone// NameReverter saved it back// This class just checks proxy is bound before getTarget() call// Just test anything: it will fail if context wasn't found// Equality checks were handled by the proxy// When we invoke A, it's NopInterceptor will have count == 1// and won't think it's equal to B's NopInterceptor// Won't throw an exception// Will fail, after invoking Nop1// Nop2 didn't get invoked when the exception was thrown// Shouldn't have changed value in joinpoint// On exception it won't be invoked// Reacts to ServletException and RemoteException// Will be advised but doesn't match// Subclass of RemoteException// We know it can only be invoked if there's a single parameter of type string// TODO replace this check: no longer possible//assertEquals(advised.getTarget(), this);/** Additional and overridden tests for CGLIB proxies. ... */CglibProxyTests.classString DEPENDENCY_CHECK_CONTEXT, ...;new CglibAopProxy(...)ProtectedMethodTestBean beannew ProtectedMethodTestBean(...)ProtectedMethodTestBean proxybean.valuePackageMethodTestBean beannew PackageMethodTestBean(...)PackageMethodTestBean proxyCglibTestBean beannew CglibTestBean(...)CglibTestBean proxyPrivateCglibTestBean beannew PrivateCglibTestBean(...)PrivateCglibTestBean proxyCglibTestBean targetCglibAopProxy aopMethodInterceptor advicenew Pointcut(...) { ... }getIntroductionAdvisorProxy(...)NoArgCtorTestBean targetnew NoArgCtorTestBean(...)NoArgCtorTestBean proxysetConstructorArguments(...)CglibAopProxy cglibSerializable.classExceptionThrower beannew ExceptionThrower(...)ExceptionThrower proxydoTest(...)isCatchInvoked(...)isFinallyInvoked(...)ApplicationContext ctxCountingBeforeAdvice advicenew MyBean(...)MyBean proxydoWithVarargs(...)MyEnum.AMyOtherEnum.CMyEnum A, ...;MyEnum B, ...;MyOtherEnum C, ...;MyOtherEnum D, ...;boolean catchInvoked, ...;boolean finallyInvoked, ...;boolean called, ...;Dependency dependency, ...;ClassWithComplexConstructor selfReference, ...;this.dependencythis.selfReferencemethod(...)int a, ...;this.aJdkDynamicAopProxy aopExposedInvocationTestBean expectedTargetnew ExposedInvocationTestBean(...) { ... }FooBar beannew FooBar(...)ProxyCreatorSupport asFoo proxygetBarThis(...)getFooThis(...)Named.classJdkDynamicAopProxy aopProxyNamed proxyNamed namednew VarargTestBean(...)VarargTestInterface proxyPerson personperson.name/** Integration test for Objenesis proxy creation. ... */ClassWithComplexConstructor beanClassWithComplexConstructor.classDebugInterceptor.classgetDependency(...)import TestApplicationListenerimport static Assertions.assertThatIOExceptionProxyFactoryBeanTests.classString CONTEXT, ...;String SERIALIZATION_CONTEXT, ...;String AUTOWIRING_CONTEXT, ...;String DBL_TARGETSOURCE_CONTEXT, ...;String NOTLAST_TARGETSOURCE_CONTEXT, ...;String TARGETSOURCE_CONTEXT, ...;String INVALID_CONTEXT, ...;String FROZEN_CONTEXT, ...;String PROTOTYPE_CONTEXT, ...;String THROWS_ADVICE_CONTEXT, ...;String INNER_BEAN_TARGET_CONTEXT, ...;BeanFactory factory, ...;TestApplicationListener.classITestBean test1/** Test that it's forbidden to specify TargetSource in both ... */testDoubleTargetSourceIsRejected(...)havingCause(...)ProxyFactoryBean pfbFactoryBean<?> pfb/** The instances are equal, but do not have object identity. ... */ITestBean test1_1Advised pc1Advised pc2int oldLengthITestBean test2ITestBean test2_1/** Uses its own bean factory XML for clarity ... */int INITIAL_COUNTSideEffectBean rawSideEffectBean prototype2FirstInstanceSideEffectBean prototype2SecondInstanceObject prototypetestPrototypeInstancesAreIndependent(...)/** Test invoker is automatically added to manipulate target. */ITestBean autoInvokerProxyFactoryBean configITestBean tb1/** Test that inner bean for target means that we can use ... */DependsOnITestBean doitdoit.tb/** Try adding and removing interfaces and interceptors on prototype. ... *//** Note that we can't add or remove interfaces without reconfiguring the ... */Advised pcPointcutForVoid.methodNamesDefaultListableBeanFactory fIEcho echoFileNotFoundException expectedFileNotFoundassertThatIOException(...)new Predicate<IOException>(...) { ... }/* @Test ... */// TODO put in sep file to check quality of error message// These two fail the whole bean factory/** Globals must be followed by a target. *//** Checks that globals get invoked, ... */AddedGlobalInterface agiApplicationListener<?> lglobalsAdded(...)AddedGlobalInterface.classAdvice nopProxyFactoryBean pfb2ITestBean bean1ITestBean bean2/** Simple test of a ProxyFactoryBean that has an inner bean as target that specifies autowiring. ... */ProxyFactoryBean fbnew ProxyFactoryBean(...)/** Fires only on void methods. Saves list of methods intercepted. */List<String> methodNames, ...;ITestBean tb, ...;/** Aspect interface *//** Use as a global interceptor. Checks that ... */new GlobalAspectInterfaceInterceptor(...)IntroductionInterceptor gi, ...;this.gi// Now with conversion from arbitrary bean to a TargetSource// We have a counting before advice here//assertTrue("Singleton instances ==", test1 == test1_1);// Initial count value set in bean factory XML// Check it works without AOP// Now try with advised instances// Trigger lazy initialization.// no exception// Add evil interceptor to head of list// Add to head of interceptor chain// Check no change on existing object reference// Won't affect existing reference// Still invoked with old reference// not invoked with new object// Our own timestamped reference should still work// No throws handler method: count should still be 0// Handler knows how to handle this exception// One match// 2 globals + 2 explicit// Add unserializable advice// Check it still works// Remove offending interceptor...//do not expect LockedException"// do not expect LockedException/** TestCase for AdvisorAdapterRegistrationManager mechanism. ... */UnknownAdviceTypeException.classisZero(...)getInvocationCounter(...)getAdviceImpl(...)SimpleBeforeAdvice advicenew SimpleBeforeAdviceInterceptor(...)int invocationCounter, ...;SimpleBeforeAdvice advice, ...;// just invoke any method to see if advice firedimport AbstractBeanFactoryBasedTargetSourceCreator/** Tests for auto proxy creation by advisor recognition. ... */AdvisorAutoProxyCreatorTests.classString COMMON_INTERCEPTORS_CONTEXT, ...;String CUSTOM_TARGETSOURCE_CONTEXT, ...;String QUICK_TARGETSOURCE_CONTEXT, ...;String OPTIMIZED_CONTEXT, ...;/** Check that we can provide a common interceptor that will ... */Lockable lockable1PackageVisibleMethod packageVisibleMethodLockable lockable3/** We have custom TargetSourceCreators but there's no match, and ... */CountingTestBean.countCountingBeforeAdvice beforeAdvice// Locking should be independent; nop is shared// equals 2 calls on shared nop, because it's first and sees calls// against the Lockable interface introduced by the specific advisor// Check that references survived prototype creation// Check that references survived pooling// Now test the pooled one// Now test the ThreadLocal one// Now test the Prototype TargetSourceimport StaticMessageSourceStaticApplicationContext sacRootBeanDefinition proxyCreatorBeanNameAutoProxyCreator.classRootBeanDefinition innerBeanITestBean singletonToBeProxiedTestInterceptor tiITestBean tb2TestInterceptor.classti.nrOfInvocationsint initialNrNoInterfaces noInterfacesContainerCallbackInterfacesOnly containerCallbackInterfacesOnlyITestBean singletonNoInterceptorITestBean prototypeToBeProxiedTestAutoProxyCreator tapcTestAutoProxyCreator.classNoInterfaces.classContainerCallbackInterfacesOnly.classregisterPrototype(...)tapc.testInterceptor.nrOfInvocationstapc.testInterceptorFallbackTestAutoProxyCreator.classCustomProxyFactoryBean.classSpringProxyFactoryBean.classPackageVisibleMethod tbPackageVisibleMethod.classFactoryBean<?> prototypeFactorynew TestInterceptor(...)boolean proxyFactoryBean, ...;boolean proxyObject, ...;this.proxyFactoryBeanthis.proxyObjectStaticMessageSource.classthis.testInterceptor/** Interceptor that counts the number of non-finalize method calls. */int nrOfInvocations, ...;this.nrOfInvocations// test whether autowiring succeeded with auto proxy creation// already 2: getSpouse + getNestedIndexedBean calls above// as well as an empty marker interfacecheck(...)// for post-processing and hence auto-proxying to work.// Note that we need an ApplicationContext, not just a BeanFactory,jdkAssertions(...)cglibAssertions(...)ITestBean lazy1ITestBean alias1ITestBean lazy2/** Also has counting before advice. */// Check two per-instance mixins were distinct// Shouldn't affect second// Can still mod second object// But can't mod firstimport SimpleMapScopeScopedProxyTests.classClassPathResource LIST_CONTEXT, ...;ClassPathResource MAP_CONTEXT, ...;ClassPathResource OVERRIDE_CONTEXT, ...;ClassPathResource TESTBEAN_CONTEXT, ...;Object baseMapObject simpleMapSimpleMapScope scopenew SimpleMapScope(...)ScopedObject scopedScopedObject scopedDeserializedArrayList<?> deserialized// SPR-2108/** Tests for pooling invoker interceptor. ... */SideEffectBean pooledtestFunctionality(...)PoolingConfig confSingletonTargetSource serializedSingletonTargetSource.classPerson pooledPerson serializedint maxSizeCommonsPool2TargetSource targetSourceObject[] pooledInstancessetMaxWait(...)prepareTargetSource(...)NoSuchElementException.classpooledInstances.lengthAdvised personObject firstObject secondStaticApplicationContext applicationContext// Just check that it works--we can't make assumptions// about the count//assertEquals(INITIAL_COUNT + 1, apartment.getCount());// TODO one invocation from setup//assertEquals(1, conf.getInvocations());//	assertEquals("No objects active", 0, conf.getActive());//	assertTrue("Some free", conf.getFree() > 0);//assertEquals(2, conf.getInvocations());//((Advised) pooled).setTargetSource(new SingletonTargetSource(new SerializablePerson()));// should be at maximum now// lets now release an object and try to acquire a new one// release all objectsUserServiceImpl.classgetBean(...).objectFoo object, ...;import AnnotationConfigUtils/** Integration tests for handling JSR-303 {@link javax.inject.Qualifier} annotations. ... */GenericApplicationContext contextQualifiedFieldTestBean.classQualifiedMethodParameterTestBean.classQualifiedConstructorArgumentTestBean.classnew Consumer<UnsatisfiedDependencyException>(...) { ... }QualifiedFieldTestBean beangetPerson(...)QualifiedMethodParameterTestBean beanQualifiedPerson.classQualifiedConstructorArgumentTestBean beanQualifiedFieldWithDefaultValueTestBean beanTestQualifierWithDefaultValue.classQualifiedFieldWithDefaultValueTestBean.classTestQualifierWithMultipleAttributes.classAutowireCandidateQualifier qualifier2QualifiedFieldWithMultipleAttributesTestBean beanQualifiedFieldWithMultipleAttributesTestBean.classQualifiedConstructorArgumentWithBaseQualifierNonDefaultValueTestBean.classPerson person, ...;this.person// qualifier added, but includes no value// qualifier added, and non-default value specified// qualifier added, and value matches the default/** Integration tests for handling {@link Qualifier} annotations. ... */DefaultValueQualifiedPerson.classMetaQualifiedFieldTestBean beanMetaQualifiedFieldTestBean.classQualifiedFieldWithBaseQualifierDefaultValueTestBean beanQualifiedFieldWithBaseQualifierDefaultValueTestBean.classQualifiedConstructorArgumentWithBaseQualifierNonDefaultValueTestBean bean/** Tests lookup methods wrapped by a CGLIB proxy (see SPR-391). ... */LookupMethodWrappedByCglibProxyTests.classresetInterceptor(...)OverloadLookup olupITestBean jennynewTestBean(...)testMethod(...)assertInterceptorCount(...)resetCount(...)import static String.formatimport static ClassUtils.convertClassNameToResourcePathQualifierAnnotationTests.classString CONFIG_LOCATION, ...;StaticApplicationContext contextNonQualifiedTestBean.classQualifiedByValueTestBean testBeangetLarry(...)QualifiedByValueTestBean.classStaticApplicationContext parentGenericBeanDefinition parentLarryGenericBeanDefinition otherLarryQualifiedByParentValueTestBean testBeanQualifiedByParentValueTestBean.classQualifiedByBeanNameTestBean testBeanQualifiedByBeanNameTestBean.classtestBean.myPropsQualifiedByFieldNameTestBean testBeanQualifiedByFieldNameTestBean.classQualifiedByParameterNameTestBean testBeanQualifiedByParameterNameTestBean.classQualifiedByAliasTestBean testBeangetStooge(...)QualifiedByAliasTestBean.classQualifiedByAnnotationTestBean testBeanQualifiedByAnnotationTestBean.classQualifiedByCustomValueTestBean testBeangetCurly(...)QualifiedByCustomValueTestBean.classQualifiedByAnnotationValueTestBean testBeanQualifiedByAnnotationValueTestBean.classQualifiedByAttributesTestBean.classMultiQualifierClient testBeanMultipleAttributeQualifier.classMultiQualifierClient.classtestBean.factoryThetatestBean.implThetaPerson anonymous, ...;Person larry, ...;Properties myProps, ...;Person larryBean, ...;this.larryBeanPerson stooge, ...;Person curly, ...;Person moeSenior, ...;Person moeJunior, ...;String FACTORY_QUALIFIER, ...;String IMPL_QUALIFIER, ...;Theta factoryTheta, ...;Theta implTheta, ...;new Theta(...) { ... }Theta.class/** Tests for combining the expression language and the p namespace. Due to the required EL dependency, this test is in ... */ITestBean fooITestBean barimport MethodReplacer/** Types used by {@link XmlBeanFactoryTests} and its attendant XML config files. ... *//** Bean testing the ability to use both lookup method overrides ... */String setterString, ...;this.setterStringDummyDao dao, ...;this.dao/** Fixed method replacer for String return types ... */String VALUE, ...;getPrototypeDependency(...)/** Overloaded form of replaceMe. *//** Another overloaded form of replaceMe, not getting replaced. ... *//** Subclass of OverrideOneMethod, to check that overriding is ... */reverse(...)boolean singleBoolean, ...;boolean secondBoolean, ...;String testString, ...;this.singleBooleanthis.testStringthis.secondBoolean// This implementation does nothing!// It's not overloaded//public abstract Point getPoint();import StringWriterimport ResourceTestBean/** Miscellaneous tests for XML bean definitions. ... */XmlBeanFactoryTests.classclassPathResource(...)ClassPathResource AUTOWIRE_CONTEXT, ...;ClassPathResource CHILD_CONTEXT, ...;ClassPathResource CLASS_NOT_FOUND_CONTEXT, ...;ClassPathResource COMPLEX_FACTORY_CIRCLE_CONTEXT, ...;ClassPathResource CONSTRUCTOR_ARG_CONTEXT, ...;ClassPathResource CONSTRUCTOR_OVERRIDES_CONTEXT, ...;ClassPathResource DELEGATION_OVERRIDES_CONTEXT, ...;ClassPathResource DEP_CARG_AUTOWIRE_CONTEXT, ...;ClassPathResource DEP_CARG_INNER_CONTEXT, ...;ClassPathResource DEP_CARG_CONTEXT, ...;ClassPathResource DEP_DEPENDSON_INNER_CONTEXT, ...;ClassPathResource DEP_DEPENDSON_CONTEXT, ...;ClassPathResource DEP_PROP, ...;ClassPathResource DEP_PROP_ABN_CONTEXT, ...;ClassPathResource DEP_PROP_ABT_CONTEXT, ...;ClassPathResource DEP_PROP_MIDDLE_CONTEXT, ...;ClassPathResource DEP_PROP_INNER_CONTEXT, ...;ClassPathResource DEP_MATERIALIZE_CONTEXT, ...;ClassPathResource FACTORY_CIRCLE_CONTEXT, ...;ClassPathResource INITIALIZERS_CONTEXT, ...;ClassPathResource INVALID_CONTEXT, ...;ClassPathResource INVALID_NO_SUCH_METHOD_CONTEXT, ...;ClassPathResource COLLECTIONS_XSD_CONTEXT, ...;ClassPathResource MISSING_CONTEXT, ...;ClassPathResource OVERRIDES_CONTEXT, ...;ClassPathResource PARENT_CONTEXT, ...;ClassPathResource NO_SUCH_FACTORY_METHOD_CONTEXT, ...;ClassPathResource RECURSIVE_IMPORT_CONTEXT, ...;ClassPathResource RESOURCE_CONTEXT, ...;ClassPathResource TEST_WITH_DUP_NAMES_CONTEXT, ...;ClassPathResource TEST_WITH_DUP_NAME_IN_ALIAS_CONTEXT, ...;ClassPathResource REFTYPES_CONTEXT, ...;ClassPathResource DEFAULT_LAZY_CONTEXT, ...;ClassPathResource DEFAULT_AUTOWIRE_CONTEXT, ...;TestBean emmaTestBean georgiaITestBean emmasJenksITestBean georgiasJenksTestBean jenksITestBean davesJenITestBean jenksJenTestBean hasInnerBeansDerivedTestBean inner2TestBean innerFactoryTestBean inner5TestBean inner3TestBean inner4TestBean hasInnerBeansForConstructorTestBean innerForConstructorTestBean inheritsTestBean inherits2DerivedTestBean inheritsTestBean davidTestBean derivedDavidMap<?,?> tbsBeanIsAbstractException.classDummyBoImpl bosDummyBoImpl bopDummyBo.classDummyBoImpl.classbos.daobop.dao/** Check that a prototype can't inherit from a bogus parent. ... *//** Note that prototype/singleton distinction is <b>not</b> inherited. ... */TestBean beanFromParentTestBean beanFromChildTestBean egoTestBean complexInnerEgoTestBean complexEgoTestBean ego1TestBean ego3new WrappingPostProcessor(...)ITestBean davidsetAllowRawInjectionDespiteWrapping(...)DummyFactory dbgetOtherTestBean(...)DoubleInitializer in/** Test that if a custom initializer throws an exception, it's handled correctly *//** Check that InitializingBean method is called first. */InitAndIB iibInitAndIB.constructediib.afterPropertiesSetInvokediib.initMethodInvokediib.destroyediib.customDestroyed/** Check that InitializingBean method is not called twice. */doTestAutowire(...)DependenciesBean rod1DependenciesBean rod1aDependenciesBean rod2DependenciesBean rod2aConstructorDependenciesBean rod3IndexedTestBean otherConstructorDependenciesBean rod3aDependenciesBean rod5BeanFactory appCtxgetSpouse2(...)getOther(...)ConstructorDependenciesBean rod1ConstructorDependenciesBean rod2ConstructorDependenciesBean rodConstructorDependenciesBean rod5DerivedConstructorDependenciesBean rod6rod6.initializedrod6.destroyedgetRelatedCauses(...)ConstructorDependenciesBean rod9ConstructorDependenciesBean rod9aConstructorDependenciesBean rod9bConstructorDependenciesBean rod9cConstructorDependenciesBean rod10ConstructorDependenciesBean rod11ConstructorDependenciesBean rod12ConstructorDependenciesBean rod13ConstructorDependenciesBean rod14ConstructorDependenciesBean rod15ConstructorDependenciesBean rod16ConstructorDependenciesBean rod17SimpleConstructorArgBean cd1SimpleConstructorArgBean cd2SimpleConstructorArgBean cd3SimpleConstructorArgBean cd4SimpleConstructorArgBean cd5File.separatordoTestDependencies(...)PreparingBean1.preparedPreparingBean1.destroyedPreparingBean2.preparedPreparingBean2.destroyedDependingBean.destroyCountHoldingBean.destroyCountHoldingBean.class/** When using a BeanFactory. singletons are of course not pre-instantiated. ... */ClassNotFoundException.classCannotLoadBeanClassException.classnew Consumer<CannotLoadBeanClassException>(...) { ... }ResourceTestBean resource1ResourceTestBean resource2StringWriter writernew StringWriter(...)ResourceTestBean.classString file/** See <a href="https://jira.spring.io/browse/SPR-10785">SPR-10785</a> and <a ... */Class<?> firstClassClass<?> currentClassisCglibProxyClass(...)int howManyOverrideOneMethod swappedOomlookupOverrideMethodsWithSetterInjection(...)protectedOverrideSingleton(...)OverrideOneMethod oomTestBean jenny1TestBean jenny2TestBean jenny3invokesOverriddenMethodOnSelf(...)TestBean dave1TestBean dave2TestBean notJennyString reverseOverrideOneMethodSubclass oomsDoSomethingReplacer dosString s1String s2replaceMe(...)FixedMethodReplacer.VALUEdos.lastArgConstructorInjectedOverrides ciocreateFactoryMethods(...)getSetterString(...)SerializableMethodReplacerCandidate sString forwardsString backwardsObject friend1Object friend2SingleSimpleTypeConstructorBean beanSingleSimpleTypeConstructorBean bean2isSingleBoolean(...)isSecondBoolean(...)getTestString(...)DoubleBooleanConstructorBean beanbean.boolean1bean.boolean2LenientDependencyTestBean beanbean.tbStringConstructorTestBean tbConstructorArrayTestBean beanbean.array(...).lengthAtomicInteger beanObject lastArg, ...;/** Init method */...*=...boolean constructed, ...;boolean afterPropertiesSetInvoked, ...;this.initMethodInvokedthis.afterPropertiesSetInvokedthis.customDestroyedboolean prepared, ...;int destroyCount, ...;DependingBean dependingBean, ...;this.dependingBeanthis.dependingBean.destroyedBoolean boolean1, ...;Boolean boolean2, ...;this.boolean1this.boolean2new DoubleBooleanConstructorBean(...)new LenientDependencyTestBean(...)Object array, ...;// SPR-2368// Let's create the outer bean named "innerBean",// to check whether it doesn't create any conflicts// with the actual inner beans named "innerBean".// Check whether message contains outer bean name.// Name property value is overridden// Age property is inherited from bean in parent factory// Shouldn't have changed first instance// the parent bean is autowiring// this fails while it inherits from the child bean// abstract beans should not match// abstract bean should throw exception on creation attempt// non-abstract bean should work, even if it serves as parent// check that unused instances from autowiring got removed// properly create the remaining two instances// Initializer should have doubled value// should have been autowired// should have been set explicitly// Should not have been autowired// cool, no errors, so the rubbish class name in the bean def was not resolved// let's resolve the bean definition; must blow up// comes from "resourceImport.xml"// comes from "resource.xml"// Should work identically on subclass definition, in which lookup// methods are inherited// Check cost of repeated construction of beans with method overrides// Will pick up misuse of CGLIB// System.out.println(sw);// Now test distinct bean with swapped value in factory, to ensure the two are independent// Check that the bean can invoke the overridden method on itself// This differs from Spring's AOP support, which has a distinct notion// of a "target" object, meaning that the target needs explicit knowledge// of AOP proxying to invoke an advised method on itself.// Now try protected method, and singleton// Same contract as for overrides.xml// Check unadvised behaviour// Now test replace// Check that the setter was invoked...// We should be able to combine Constructor and// Setter Injection// Jenny is a singleton// SPR-356: lookup methods & method replacers are not serializable.import AbstractInterceptorDrivenBeanDefinitionDecoratorimport NamespaceHandlerResolverimport PluggableSchemaResolver/** Unit tests for custom XML namespace handler implementations. ... */CustomNamespaceHandlerTests.classString FQ_PATH, ...;String NS_PROPS, ...;String NS_XML, ...;String TEST_XSD, ...;GenericApplicationContext beanFactory, ...;NamespaceHandlerResolver resolversetNamespaceHandlerResolver(...)new DummySchemaResolver(...)assertTestBean(...)havingRootCause(...)List<?> thingsSet<?> thingsMap<?,?> things/** Custom namespace handler implementation. ... */new TestBeanDefinitionParser(...)new PersonDefinitionParser(...)new PropertyModifyingBeanDefinitionDecorator(...)new DebugBeanDefinitionDecorator(...)new NopInterceptorBeanDefinitionDecorator(...)registerBeanDefinitionDecoratorForAttribute(...)new ObjectNameBeanDefinitionDecorator(...)RootBeanDefinition definitionAttr objectNameAttribute// SPR-2728import CachePutimport Cacheableimport Cachingimport CachingConfigurerSupportimport EnableCachingimport ConcurrentMapCacheManagerimport AbstractCacheResolverimport CacheOperationInvocationContext/** Tests to reproduce raised caching issues. ... */AnnotationConfigApplicationContext contextSpr11124Config.classSpr11124Service beanSpr11124Service.classsingle(...)multiple(...)Spr11249Config.classSpr11249Service beanSpr11249Service.classSpr11592Config.classSpr11592Service beanSpr11592Service.classCache.classgetSimple(...)Object cachedResultgetNeverCache(...)Spr13081Config.classMyCacheResolver cacheResolverMyCacheResolver.classSpr13081Service beanSpr13081Service.classSpr14230Config.classSpr14230Service beanSpr14230Service.classfindById(...)insertItem(...)Spr14853Config.classSpr14853Service beanSpr14853Service.classSpr15271ConfigA.classSpr15271Interface beanSpr15271Interface.classSpr15271ConfigB.classnew ConcurrentMapCacheManager(...)new Spr11124ServiceImpl(...)int multipleCount, ...;this.multipleCountnew Spr11249Service(...)SimpleCacheManager cacheManagercache(...)spy(...)new Spr11592Service(...)new MyCacheResolver(...)new Spr13081Service(...)new Spr14230Service(...)new Spr14853Service(...)new Spr15271Service(...)// first call: cache miss// second call: cache hit// no cache hit at all, caching disabled// caching disabled// cache name = id/** Tests for {@link NoOpCacheManager}. ... */CacheManager manager, ...;this.managercreateRandomKey(...)getNativeCache(...)randomUUID(...)/* Copyright 2010-2019 the original author or authors. ... */AnnotationCacheOperationSource source, ...;getOps(...)AnnotatedClass.classIterator<CacheOperation> itCacheOperation nextCacheOperation cacheOperationAnnotatedClassWithFullDefault.classassertSharedConfig(...)AnnotatedClassWithCustomDefault.classMultipleCacheConfig.classInterfaceCacheConfig.classAnnotatedClassWithSomeDefault.classCollection<CacheOperation> resultnew Consumer<String>(...) { ... }// Valid as a CacheResolver might return the cache names to use with other info// cache name can be inherited from CacheConfig. There's none here// multiple sourcesCacheManager cmCache cache1Cache cache1againCache cache2Cache cache2againCache cache3Cache cache3againConcurrentMapCacheManager cmCache cache1xCache cache2xCache cache3xCache cache1ysetAllowNullValues(...)setStoreByValue(...)import AbstractValueAdaptingCacheTestsConcurrentMap<Object,Object> nativeCache, ...;ConcurrentMap<Object,Object> nativeCacheNoNull, ...;ConcurrentMapCache cacheNoNull, ...;this.nativeCachethis.nativeCacheNoNullthis.cacheNoNullConcurrentMapCache serializeCachecreateCacheWithStoreByValue(...)List<String> contentList<String> entryConcurrentMapCacheTests.classimport AbstractCacheAnnotationTestsCacheInterceptor cithis.ctxCacheErrorHandler.classCacheInterceptor bean/** AOP advice specific parsing tests. ... */// TODO better exception handlingimport CacheOperationInvokerimport CacheTestUtilsimport CacheableServiceimport DefaultCacheableServiceConfigurableApplicationContext ctx, ...;CacheableService<?> cs, ...;EnableCachingConfig.classthis.csCacheableService<>.classMap<String,CacheInterceptor> interceptorsTestCacheInterceptor.classthrowUnchecked(...)throwChecked(...)createSimpleCacheManager(...)new DefaultCacheableService(...)CacheInterceptor cacheInterceptornew TestCacheInterceptor(...)/** A test {@link CacheInterceptor} that handles special exception ... */ThrowableWrapper eThrowable original// See TestCacheInterceptorimport AtomicLongimport CacheConfigimport static CacheTestUtils.assertCacheHitimport static CacheTestUtils.assertCacheMiss/** Tests that represent real use cases with advanced configuration. ... */ConfigurableApplicationContext context, ...;FooService serviceFooService.classFooConfig.classfooGetSimple(...)FooConfigCglib.classassertCacheMiss(...)assertCacheHit(...)BeanConditionConfig.classgetWithCondition(...)getBean(...).countBeanConditionConfig.Bar.classBeanConditionConfig.BarSharedConfig.classnew FooServiceImpl(...)new AtomicLong(...)AtomicLong counter, ...;Environment env, ...;boolean enabled, ...;this.enabledimport NamedCacheResolverimport SimpleCacheErrorHandlerimport SimpleCacheResolverimport SomeCustomKeyGeneratorimport SomeKeyGeneratorimport AnnotatedClassCacheableService/** Integration tests for {@code @EnableCaching} and its related ... *//** hook into superclass suite of tests */SingleCacheManagerConfig.classMultiCacheManagerConfig.classMultiCacheManagerConfigurer.classThrowable rootEmptyConfig.classEmptyConfigSupportConfig.classSimpleCacheResolver.classFullCachingConfig.classnew AnnotatedClassCacheableService(...)new SomeKeyGenerator(...)new SomeCustomKeyGenerator(...)cm1(...)new NamedCacheResolver(...)// does not throw an exceptionSpr11692Config.classBaseDao<User> userDaoBaseDao<Order> orderDaopersist(...)new User(...)new UserDaoImpl(...)new OrderDaoImpl(...)// SPR-11692import CacheEvictimport SimpleValueWrapperimport static BDDMockito.willReturnimport static BDDMockito.willThrowCache cache, ...;CacheErrorHandler errorHandler, ...;SimpleService simpleService, ...;this.simpleServiceSimpleService.classUnsupportedOperationException exceptionObject counterObject counter2Object counter3new SimpleService(...)mockCache(...)// result of the invocation// Update of the cache will fail as well/** Integration tests for {@link CacheProxyFactoryBean}. ... */AnnotationConfigApplicationContext applicationContextCacheProxyFactoryBeanConfiguration.classGreeter greeterGreeter.classisCacheMiss(...)greet(...)CacheProxyFactoryBean factoryBeannew CacheProxyFactoryBean(...)newCacheOperationSource(...)newCacheOperation(...)new SimpleGreeter(...)NameMatchCacheOperationSource cacheOperationSourcenew NameMatchCacheOperationSource(...)setCacheName(...)setCacheMiss(...)AtomicBoolean cacheMiss, ...;getAndSet(...)this.cacheMiss/** Tests corner case of using {@link Cacheable} and  {@link CachePut} on the ... */SimpleService service, ...;Long firstgetOrPut(...)Long secondLong expectedLong thirdLong fourthlong keyLong valuegetAndPut(...)Long anotherValue/** Represent a mutual exclusion use case. The boolean flag exclude one of the two operation. *//** Represent an invalid use case. If the result of the operation is non null, then we put ... */// This forces the method to be executed again// See @CachePut// CachePut forced a method call// NOTE: while you might expect the main key to have been updated, it hasn't. @Cacheable operations// are only processed in case of a cache miss. This is why combining @Cacheable with @CachePut// is a very bad idea. We could refine the condition now that we can figure out if we are going// to invoke the method anyway but that brings a whole new set of potential regressions.//assertEquals("Wrong value for @Cacheable key", anotherValue, cache.get(key).get());/** Provides various {@link CacheResolver} customisations scenario ... */CacheManager anotherCacheManager, ...;this.anotherCacheManagergetWithCustomCacheResolver(...)getWithCustomCacheManager(...)Cache defaultCacheCache primaryCachegetWithRuntimeCacheResolution(...)Object key2getWithNamedCacheResolution(...)noCacheResolved(...)unknownCacheResolver(...)new RuntimeCacheResolver(...)NamedCacheResolver resolvernew NullCacheResolver(...)/** Example of {@link CacheResolver} that resolve the caches at ... */// No cache resolved for the operation// No such bean defined/** Provides various failure scenario linked to the use of {@link Cacheable#sync()}. ... */unlessSync(...)severalCachesSync(...)severalCachesWithResolvedSync(...)syncWithAnotherOperation(...)syncWithTwoGetOperations(...)import AnnotationCacheOperationSourceCacheOperationExpressionEvaluator eval, ...;AnnotatedClass targetnew AnnotatedClass(...)Collection<ConcurrentMapCache> cachesEvaluationContext evalCtxthis.evalAnnotatedElementKey keyObject keyAObject keyBEvaluationContext contextVariableNotAvailableException.classnew Consumer<VariableNotAvailableException>(...) { ... }/** Tests for {@link SimpleKeyGenerator} and {@link SimpleKey}. ... */SimpleKeyGenerator generator, ...;Object k1Object k2Object k3SimpleKey.classthis.generator/** Simple bean to test ApplicationContext lifecycle methods for beans ... */ApplicationContext owningContext, ...;this.owningContext/** TCK-style unit tests for handling circular use of the {@link Import} annotation. ... */boolean threwnewParser(...)loadAsConfigurationSource(...)BeanDefinitionParsingException exY.classZ.classZ1.classZ2.classSimpleFactoryBean.classaddBeanFactoryPostProcessor(...)new BeanFactoryPostProcessor(...) { ... }BeanMethodConfiguration.classnew SimpleFactoryBean(...)import DefaultNamedComponent/** Unit tests for {@link AnnotationBeanNameGenerator}. ... */AnnotationBeanNameGenerator beanNameGenerator, ...;AnnotatedBeanDefinition bdComponentWithName.classDefaultNamedComponent.classComponentWithBlankName.classString expectedGeneratedBeanNameAnonymousComponent.classComponentFromStringMeta.classComponentFromNonStringMeta.classComposedControllerAnnotationWithoutName.classComposedControllerAnnotationWithBlankName.classComposedControllerAnnotationWithStringValue.class// SPR-11360import ComponentForScanningimport ConfigForScanningimport Jsr330NamedForScanningimport static StringUtils.uncapitalizeMap<String,Object> beansConfigForScanning.classComponentForScanning.classJsr330NamedForScanning.classNameConfig.classUntypedFactoryBean.classTwoTestBeanConfig.class/** Tests that Configuration classes are registered according to convention ... */Config configObject/** Tests that specifying @Configuration(value="foo") results in registering ... */ConfigWithCustomName.classConfigWithCustomName configObjectAutowiredConfig.classgetBean(...).nameBeanC.classgetBean(...).bgetBean(...).cgetBean(...).applicationContextnew Supplier<BeanA>(...) { ... }new Supplier<BeanB>(...) { ... }new BeanB(...)new Supplier<BeanC>(...) { ... }new BeanC(...)BeanB bBeanC cb.applicationContextNonInstantiatedFactoryBean.classnew Supplier<NonInstantiatedFactoryBean>(...) { ... }new NonInstantiatedFactoryBean(...)TypedFactoryBean.classString autowiredName, ...;BeanB b, ...;BeanC c, ...;this.bthis.cint primeTestBean other// contributed by ConfigForScanning// attempt to retrieve a bean that does not exist// attempt to retrieve the instance by its generated bean name// attempt to retrieve the instance by its specified nameimport SimpleMetadataReaderFactory/** Unit tests for {@link AnnotationScopeMetadataResolver}. ... */AnnotationScopeMetadataResolver scopeMetadataResolver, ...;AnnotatedWithSingletonScope.classAnnotatedWithPrototypeScope.classAnnotatedWithScopedProxy.classAnnotatedWithCustomRequestScope.classMetadataReaderFactory readerFactorynew SimpleMetadataReaderFactory(...)AnnotatedWithCustomRequestScopeWithAttributeOverride.classsetScopeAnnotationType(...)/** Unit test proving that ASM-based {@link ConfigurationClassParser} correctly detects ... */import BeanNameAutoProxyCreatorimport LazyInitTargetSourceCreatorimport ApplicationContextEvent/** Integration tests for {@link BeanNameAutoProxyCreator} and ... */MyBeanImpl.initializedConfigWithStatic.classMyBean beanMyBean.classConfigWithStaticAndInterface.classConfigWithNonStatic.classConfigWithNonStaticAndInterface.classBeanNameAutoProxyCreator autoProxyCreatornew BeanNameAutoProxyCreator(...)setBeanNames(...)setCustomTargetSourceCreators(...)lazyInitTargetSourceCreator(...)new StrictLazyInitTargetSourceCreator(...)new MyBeanImpl(...)Conf.classMyAnnotation.classAnnotatedBeanDefinition.classimport SimpleTraceInterceptor/** Tests regarding overloading and overriding of bean methods. ... */OverridingConfig.classNarrowedOverridingConfig.classConfigWithOverloading.classConfigWithOverloadingAndAdditionalMetadata.classSubConfig.class// SPR-11025SubConfigWithList.class/** When inheritance is not involved, it is still possible to override a bean method from ... */ShadowConfig.classTestAdvisor.classnew ExtendedTestBean(...) { ... }import CustomComponentimport FooServiceimport FooServiceImplimport NamedStubDaoimport StubFooDaoimport NamedStubDao2import CandidateComponentsTestClassLoaderString BASE_PACKAGE, ...;FooServiceImpl fooServiceFooServiceImpl.classAnnotationConfigUtils.CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAMEAnnotationConfigUtils.AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAMEAnnotationConfigUtils.COMMON_ANNOTATION_PROCESSOR_BEAN_NAMEAnnotationConfigUtils.EVENT_LISTENER_PROCESSOR_BEAN_NAMEAnnotationConfigUtils.EVENT_LISTENER_FACTORY_BEAN_NAMElookupFoo(...)ClassPathBeanDefinitionScanner scanner2new ClassPathBeanDefinitionScanner(...) { ... }index(...)ClassPathScanningCandidateComponentProviderTests.classStubFooDao.classint initialBeanCountint scannedBeanCountNamedStubDao.classNamedStubDao2.classCustomComponent.classnew TestBeanNameGenerator(...)GenericApplicationContext singlePackageContextClassPathBeanDefinitionScanner singlePackageScannerGenericApplicationContext multiPackageContextClassPathBeanDefinitionScanner multiPackageScannerint singlePackageBeanCountint addedBeanCountStaticListableBeanFactory myBfMessageSource msStaticListableBeanFactory.classfooService.beanFactoryfooService.listableBeanFactoryfooService.resourceLoaderfooService.resourcePatternResolverfooService.eventPublisherfooService.messageSourcefooService.contextfooService.configurableContext.lengthfooService.configurableContextfooService.genericContextBeanCreationException expected// should not fail!// assertTrue(multiPackageBeanCount > singlePackageBeanCount);// @Lookup method not substitutedimport DependencyBeanimport FactoryMethodComponentFactoryMethodComponent.classFactoryMethodComponent fmcQualifiedClientBean clientBeanQualifiedClientBean.classclientBean.testBeanclientBean.dependencyBeanclientBean.applicationContextDependencyBean dependencyBean, ...;//2//3//4//5import AnnotatedComponentimport DevComponentimport ProfileAnnotatedComponentimport ProfileMetaAnnotatedComponentimport AutowiredQualifierFooServiceimport CustomStereotypeimport FooDaoimport MessageBeanimport NamedComponentimport ScopedProxyTestBeanimport ServiceInvocationCounterimport BarComponentNamedComponent.classString TEST_BASE_PACKAGE, ...;String TEST_PROFILE_PACKAGE, ...;String TEST_DEFAULT_PROFILE_NAME, ...;ClassLoader TEST_BASE_CLASSLOADER, ...;ClassPathScanningCandidateComponentProvider providernew ClassPathScanningCandidateComponentProvider(...)disableIndex(...)testDefault(...)containsBeanClass(...)ServiceInvocationCounter.classBarComponent.classassertBeanDefinitionType(...)testAntStyle(...)resetFilters(...)testCustomAnnotationTypeIncludeFilter(...)testCustomAssignableTypeIncludeFilter(...)AutowiredQualifierFooService.classScopedProxyTestBean.classtestCustomSupportedIncludeAndExcludeFilter(...)Repository.classCustomStereotype.classFooDao.classtestExclude(...)Controller.classMessageBean.classProfileAnnotatedComponent.classProfileMetaAnnotatedComponent.classDefaultProfileAnnotatedComponent.classDefaultProfileAnnotatedComponent.BEAN_NAMEDefaultAndDevProfileAnnotatedComponent.classDefaultAndDevProfileAnnotatedComponent.BEAN_NAMEMetaProfileAnnotatedComponent.classMetaProfileAnnotatedComponent.BEAN_NAMESet<BeanDefinition> componentsAnnotatedComponent.classnew Consumer<BeanDefinition>(...) { ... }ScannedGenericBeanDefinition.class// Interfaces/Abstract class are filtered out automatically.// This annotation type is not directly annotated with Indexed so we can use// the index to find candidates// no active profiles are setimport ExpectedLookupTemplateAnnotatedInitDestroyBean beannew CommonAnnotationBeanPostProcessor(...)AnnotatedInitDestroyBean.classbean.initCalledbean.destroyCallednew InitDestroyBeanPostProcessor(...)InitDestroyBeanPostProcessor.classInitDestroyAnnotationBeanPostProcessor bppnew InitDestroyAnnotationBeanPostProcessor(...)NullFactory.classCommonAnnotationBeanPostProcessor bppCommonAnnotationBeanPostProcessor bpp2new AnnotatedInitDestroyBean(...)InitDestroyAnnotationBeanPostProcessor bpp2setResourceFactory(...)bean.init2Calledbean.init3Calledbean.destroy2Calledbean.destroy3CalledRootBeanDefinition abdRootBeanDefinition tbd1RootBeanDefinition tbd2ResourceInjectionBean anotherBeanExtendedResourceInjectionBean.classExtendedResourceInjectionBean beanINestedTestBean tbgetTestBean6(...)ExtendedResourceInjectionBean anotherBeanINestedTestBean.classNestedTestBean tb7bean.counterSimpleJndiBeanFactory resourceFactoryExpectedLookupTemplate jndiTemplatenew ExpectedLookupTemplate(...)addObject(...)NestedTestBean tb6NamedResourceInjectionBean bean2ConvertedResourceInjectionBean bean3NamedResourceInjectionBean.classConvertedResourceInjectionBean.classbean.testBean5bean.testBean6bean.beanFactorybean2.testBeanbean3.valueNoSuchBeanDefinitionException innerExExtendedEjbInjectionBean beanExtendedEjbInjectionBean.classLazyResourceFieldInjectionBean beanLazyResourceFieldInjectionBean.classLazyResourceMethodInjectionBean beanLazyResourceMethodInjectionBean.classLazyResourceCglibInjectionBean beanLazyResourceCglibInjectionBean.class(...).initCalled(...).destroyCalledboolean init2Called, ...;boolean init3Called, ...;boolean destroy2Called, ...;boolean destroy3Called, ...;this.init2Calledthis.init3Calledthis.destroy2Calledthis.destroy3CalledB testBean4, ...;INestedTestBean testBean5, ...;INestedTestBean testBean6, ...;this.testBean6init2(...)destroy2(...)increaseCounter(...)INestedTestBean testBean, ...;import ImportingConfigimport SimpleComponent/** Tests covering overlapping use of @ComponentScan and @Import annotations. ... */Config1.classConfig2.classSimpleComponent.classConfig3.classImportingConfig.classImportedConfig.class// no conflicts found trying to register SimpleComponent// succeeds -> there is only one bean of type SimpleComponentimport ComponentScanAnnotatedConfigWithImplicitBasePackageimport ConfigurableComponentimport CustomScopeAnnotationBeanimport MyScopeimport CustomAutowireConfigurerimport KustomAnnotationAutowiredBeanimport ClassWithNestedComponents/** Integration tests for processing ComponentScan-annotated Configuration classes. ... */PackageMarker.classComponentScanAnnotatedConfig.classComponentScanAnnotatedConfig_WithValueAttribute.classComponentScanAnnotatedConfigWithImplicitBasePackage.classConfigurableComponent.classComposedAnnotationConfig.classClassWithNestedComponents.NestedComponent.classClassWithNestedComponents.NestedComponentClassWithNestedComponents.OtherNestedComponent.classClassWithNestedComponents.OtherNestedComponentComponentScanWithBeanNameGenerator.classComponentScanWithScopeResolver.classCustomScopeAnnotationBean.classMultiComponentScan.classComponentScanWithCustomTypeFilter.classKustomAnnotationAutowiredBean testBeanKustomAnnotationAutowiredBean.classComponentScanWithAwareTypeFilter.classFooService beanFooService deserializedComponentScanWithScopedProxy.classComponentScanWithScopedProxyThroughRegex.classComponentScanWithScopedProxyThroughAspectJPattern.classComponentScanWithMultipleAnnotationIncludeFilters1.classComponentScanWithMultipleAnnotationIncludeFilters2.classComponentScanWithBasePackagesAndValueAlias.classaddActiveProfile(...)MyBeanNameGenerator.classMyScopeMetadataResolver.classMyScope.classFilterType.CUSTOMComponentScanParserTests.CustomTypeFilter.classComponentScanParserTests.CustomTypeFilterFilterType.ASSIGNABLE_TYPEsetCustomQualifierTypes(...)new HashSet<>(...) { ... }ComponentScanParserTests.CustomAnnotation.classComponentScanParserTests.CustomAnnotationComponentScanParserTests.KustomAnnotationAutowiredBeannew KustomAnnotationAutowiredBean(...)ComponentScanAnnotationIntegrationTests.AwareTypeFilter.classComponentScanAnnotationIntegrationTests.AwareTypeFilterFilterType.REGEXFilterType.ASPECTJ// custom scope annotation makes the bean prototype scoped. subsequent calls// to getBean should return distinct instances.// should cast to the interface// should be dynamic proxy// test serializability// @CustomStereotype-annotated// @CustomComponent-annotated// exclude this class from scanning since it's in the scanned packageimport LeftConfigimport Level1Configimport Level2Configimport Level3Component/** Tests ensuring that configuration classes marked with @ComponentScan ... */Level1Config.classLevel2Config.classLevel3Component.classLeftConfig.class// assert that all levels have been detected// assert that enhancement is working// left scans right, and right scans left// but this is handled gracefully// and beans from both packages are availableimport DefaultBeanNameGenerator/** Unit tests for the @ComponentScan annotation. ... */DefaultBeanNameGenerator.classAnnotationScopeMetadataResolver.classFilterType.ANNOTATION// no-op; the @ComponentScan-annotated MyConfig class below simply exercises// available attributes of the annotation.String TEST_BEAN_NAME, ...;String LOCATION_PREFIX, ...;DefaultsTestBean.INIT_COUNTDefaultsTestBean beangetConstructorDependency(...)getPropertyDependency1(...)getPropertyDependency2(...)int INIT_COUNT, ...;ConstructorDependencyTestBean constructorDependency, ...;PropertyDependencyTestBean propertyDependency1, ...;PropertyDependencyTestBean propertyDependency2, ...;this.constructorDependencythis.propertyDependency1this.propertyDependency2ClassPathXmlApplicationContext contextScopedProxyTestBean beanScopedProxyTestBean deserializedloadContext(...)AutowiredQualifierFooService fooServiceString xmlLocationGenericXmlApplicationContext context/** Intentionally spelling "custom" with a "k" since there are numerous ... */KustomAnnotationDependencyBean dependency, ...;// should exclude the profile-annotated bean if active profiles remains unset// should include the profile-annotated bean with active profiles set// ensure the same works for AbstractRefreshableApplicationContext impls too/** Tests semantics of declaring {@link BeanFactoryPostProcessor}-returning @Bean ... */TestBeanConfig.classAutowiredConfigWithBFPPAsInstanceMethod.classgetBean(...).autowiredTestBeanAutowiredConfigWithBFPPAsStaticMethod.classTestBean autowiredTestBean, ...;ConfigWithStaticBeanMethod.classtestBean(...)// instance method BFPP interferes with lifecycle -> autowiring fails!// WARN-level logging should have been issued about returning BFPP from non-static @Bean method// static method BFPP does not interfere with lifecycle -> autowiring succeeds/** Tests cornering the issue reported in SPR-8080. If the product of a @Bean method ... *//** Prior to the fix for SPR-8080, this method would succeed due to ordering of ... */Config2 config2config2.testBean/** Prior to the fix for SPR-8080, this method would fail due to ordering of ... */Config1 config1config1.beanMethodCallCountint beanMethodCallCount, ...;beanMethod(...)// age == 2import DefaultAdvisorAutoProxyCreatorimport SyncTaskExecutorQualifierAnnotationAutowireCandidateResolver acr/** Enhanced {@link Configuration} classes are only necessary for respecting ... */ConfigurationClassPostProcessor ppnew ConfigurationClassPostProcessor(...)Bar.classSingletonBeanConfig.classNonEnhancedSingletonBeanConfig.classStaticSingletonBeanConfig.class/** Tests the fix for SPR-5655, a special workaround that prefers reflection over ASM ... */UnloadedConfig.classLoadedConfig.class/** Tests whether a bean definition without a specified bean class is handled correctly. */ComposedConfigurationClass.classassertSupportForComposedAnnotation(...)ComposedConfigurationWithAttributeOverrideForBasePackage.classComposedConfigurationWithAttributeOverrideForExcludeFilter.classassertSupportForComposedAnnotationWithExclude(...)ExtendedConfigurationWithAttributeOverrideForExcludeFilter.classComposedComposedConfigurationWithAttributeOverridesClass.classMetaComponentScanConfigurationWithAttributeOverridesClass.classSubMetaComponentScanConfigurationWithAttributeOverridesClass.classSimpleComponent simpleComponentRootBeanDefinition.ROLE_SUPPORTBeanDefinitionHolder proxiedFirstConfiguration.classSecondConfiguration.classOverridingSingletonBeanConfig.classOverridingAgainSingletonBeanConfig.classInvalidOverridingSingletonBeanConfig.classExtendedFoo.classConfigWithOrderedNestedClasses.classConfigWithOrderedInnerClasses.classAutowiredAnnotationBeanPostProcessor bppITestBean injectedScopedProxyConsumer.classScopedProxyConfigurationClass.classDefaultListableBeanFactory bf1DefaultListableBeanFactory bf2RepositoryInjectionBean.classRepositoryInjectionBean beanRepositoryConfiguration.classScopedRepositoryConfiguration.classScopedProxyRepositoryConfiguration.classSpecificRepositoryInjectionBean.classSpecificRepositoryInjectionBean beanSpecificRepositoryConfiguration.classbean.genericRepositoryRepositoryFactoryBeanConfiguration.classbean.qualifiedRepositoryFactoryBeanbean.prefixQualifiedRepositoryFactoryBeanRawMatchingConfiguration.classWildcardMatchingConfiguration.classWildcardWithExtendsConfiguration.classWildcardWithGenericExtendsConfiguration.classRawFactoryMethodRepositoryConfiguration.classRawInstanceRepositoryConfiguration.classDefaultAdvisorAutoProxyCreator autoProxyCreatornew DefaultAdvisorAutoProxyCreator(...)RepositoryInterface<>.classConcreteConfig.classServiceBeanProvider.classServiceBean.classConcreteConfigWithDefaultMethods.classAStrich.classBeanArgumentConfigWithPrototype.classcreateFoo(...)new BarArgument(...)FooFactory.classBeanArgumentConfigWithSingleton.classBeanArgumentConfigWithNull.classFooBarConfiguration.classgetBean(...).barFooImpl.classBarImpl.classVarargConfiguration.classVarargConfiguration beanbean.testBeansbean.testBeans.lengthCollectionArgumentConfiguration.classCollectionArgumentConfiguration beanMapArgumentConfiguration.classDummyRunnable.classMapArgumentConfiguration beanCollectionInjectionConfiguration.classCollectionInjectionConfiguration beanMapInjectionConfiguration.classMapInjectionConfiguration beanBeanLookupConfiguration.classBeanLookupConfiguration beanBeanDefinitionRegistryPostProcessorConfig.class// -------------------------------------------------------------------------new ExtendedFoo(...)new ExtendedAgainFoo(...)Foo foo, ...;new SyncTaskExecutor(...)new Repository<String>(...) { ... }new Repository<Integer>(...) { ... }new Repository<Object>(...) { ... }new Repository<>(...) { ... }GenericRepository<?> genericRepository, ...;new GenericRepository<Object>(...)RepositoryFactoryBean<?> qualifiedRepositoryFactoryBean, ...;RepositoryFactoryBean<?> prefixQualifiedRepositoryFactoryBean, ...;new Repository<>(...)new Repository<String>(...)new Repository<Number>(...)ComponentScan.FilterString parameter, ...;this.parametergetServiceBean(...)provider(...)new ServiceBeanProvider(...)ServiceBeanProvider provider, ...;new ServiceBean(...)Z z, ...;new NullPointerException(...)B b, ...;new Z(...)new DependingFoo(...)new FooFactory(...) { ... }BarImpl bar, ...;new BarImpl(...)new FooImpl(...)...[] testBeans, ...;this.testBeansList<TestBean> testBeans, ...;ConfigurableEnvironment env, ...;Map<String,Runnable> testBeans, ...;// Unrelated, not to be considered as a factory methodnew BeanDefinitionRegistryPostProcessor(...) { ... }// gh-25430// SPR-15384// SPR-16734// first invocation -- should succeed// second invocation for bf1 -- should throw// first invocation for bf2 -- should succeed// second invocation for bf2 -- should throw// intentionally a raw type/* no-op *//** Test for {@link Conditional} beans. ... */BeanOneConfiguration.classBeanTwoConfiguration.classBeanThreeConfiguration.classConfigurationWithMetaCondition.classNonConfigurationClass.classConditionOnMethodConfiguration.classImportsNotCreated.classConfigWithBeanSkipped.classExampleBean.classConfigWithBeanReactivated.classMap<String,ExampleBean> beansConfigWithAlternativeBeans.classnew ExampleBean(...)NoBeanOneCondition.classHasBeanOneCondition.classMetaConditionalFilter.classNeverCondition.classAlwaysCondition.classMetaConditional.classConfigurationNotCreated.classRegistrarNotCreated.classImportSelectorNotCreated.class/** Tests cornering bug SPR-8514. ... */AppConfig.classConcreteFactoryBeanImplementationConfig.classParameterizedFactoryBeanImplementationConfig.classParameterizedFactoryBeanInterfaceConfig.classNonPublicParameterizedFactoryBeanInterfaceConfig.classRawFactoryBeanInterfaceConfig.classWildcardParameterizedFactoryBeanInterfaceConfig.classFactoryBeanCallingConfig.classT obj, ...;new DummyBean(...)DummyBean dummyBean, ...;new MyFactoryBean(...)new MyParameterizedFactoryBean<String>(...)factoryBean(...)/** Test case cornering the bug initially raised with SPR-8762, in which a ... */getBean(...).foonew FooFactoryBean(...)/** Test for {@link AbstractBeanFactory} type inference from ... */assertPreFreeze(...)DirectConfiguration.classassertPostFreeze(...)GenericMethodConfiguration.classGenericClassConfiguration.classAttributeClassConfiguration.classGenericBeanDefinition factoryBeanDefinitionNameCollectingBeanFactoryPostProcessor postProcessornew NameCollectingBeanFactoryPostProcessor(...)assertContainsMyBeanName(...)new Consumer<BeanFactoryPostProcessor>(...) { ... }...[] names, ...;this.namesnew TestFactoryBean<MyBean>(...)AttributeClassRegistrar.classRawWithAbstractObjectTypeFactoryBean.class// Covers the case where a @Configuration is picked up via component scanning// and its bean definition only has a String bean class. In such cases// beanDefinition.hasBeanClass() returns false so we need to actually// call determineTargetType ourselves/** Tests for {@link DeferredImportSelector}. ... */AnnotationMetadata.classWithExplicitDestroyMethod c0WithExplicitDestroyMethod.classWithLocalCloseMethod c1WithLocalCloseMethod.classWithLocalCloseMethod c2WithInheritedCloseMethod c3WithInheritedCloseMethod.classWithInheritedCloseMethod c4WithInheritedCloseMethod c5WithNoCloseMethod c6WithNoCloseMethod.classWithLocalShutdownMethod c7WithLocalShutdownMethod.classWithInheritedCloseMethod c8WithDisposableBean c9WithDisposableBean.classc0.closedc1.closedc2.closedc3.closedc4.closedc5.closedc6.closedc7.closedc8.closedc9.closedWithLocalCloseMethod x1WithLocalCloseMethod x2WithLocalCloseMethod x3WithNoCloseMethod x4WithInheritedCloseMethod x8x1.closedx2.closedx3.closedx4.closedx8.closednew WithExplicitDestroyMethod(...)new WithLocalCloseMethod(...)new WithInheritedCloseMethod(...)new WithInheritedCloseMethod(...) { ... }new WithNoCloseMethod(...)new WithLocalShutdownMethod(...)new WithDisposableBean(...)ConfigWithJdkProxy.classaspectIsApplied(...)ConfigWithCglibProxy.classConfigWithExposedProxy.classFooService fooServiceServiceInvocationCounter counterSampleService.classLoggingAspect.classSampleService sampleServicenew SampleDto(...)new SampleInputBean(...)new FooServiceImpl(...) { ... }// Not matched method on {@link LoggingAspect}.// Matched method on {@link LoggingAspect}/** Unit tests for @EnableLoadTimeWeaving ... */EnableLTWConfig_withAjWeavingDisabled.classEnableLTWConfig_withAjWeavingAutodetect.classEnableLTWConfig_withAjWeavingEnabled.classAspectJWeaving.DISABLEDAspectJWeaving.AUTODETECTAspectJWeaving.ENABLED// no expectations -> a class file transformer should NOT be added// because no META-INF/aop.xml is present on the classpathFooService fooService, ...;this.fooServiceimport AsyncAnnotationBeanPostProcessor/** Tests that an ImportAware @Configuration classes gets injected with the ... */ImportedConfig importAwareConfigAnnotationMetadata importMetadataimportAwareConfig.importMetadataAnnotationAttributes importAttribsClass<?>[] importedClassesAnnotationAttributes enableAttribsEnableImportedConfig.classIndirectlyImportingConfig.classImportedConfigLite importAwareConfigImportedConfigLite.classImportingConfigLite.classImportedRegistrar.calledImportingRegistrarConfig.classImportingRegistrarConfigWithImport.classgetBean(...).importMetadataMetadataHolder.classConfigurationOne.classConfigurationTwo.classConfigurationThree.classApplicationConfiguration.classAnnotationMetadata importMetadata, ...;this.importMetadatanew BPP(...)ImportedRegistrar.classGenericBeanDefinition beanDefinition2OtherImportedConfig.classOnMissingBeanCondition.classSomeConfiguration.classnew MetadataHolder(...)LiteConfiguration.classFeatureConfiguration.classAnnotationAttributes enableFeatureAttributesEnableFeature.classnew Consumer<AnnotationAttributes>(...) { ... }EnableFeature.FeaturePolicy.classEnableFeature.FeaturePolicy/** Integration tests for {@link ImportBeanDefinitionRegistrar}. ... */SampleRegistrar.beanFactorySampleRegistrar.classLoaderSampleRegistrar.resourceLoaderSampleRegistrar.environmentSampleRegistrar.classimport InOrderimport static Mockito.inOrderimport static Mockito.spy/** Tests for {@link ImportSelector} and {@link DeferredImportSelector}. ... */new HashMap<Class<?>,String>(...)Map<Class<?>,String> importFrom, ...;ImportSelectorTests.importFromcleanup(...)InOrder orderedinOrder(...)AwareConfig.classSampleImportSelector.beanFactorySampleImportSelector.classLoaderSampleImportSelector.resourceLoaderSampleImportSelector.environmentIndirectConfig.classString indirectImportIndirectImport.classImportSelector1.classImportSelector2.classDeferredImportSelector1.classDeferredImportSelector2.classGroupedConfig.classTestImportGroup.instancesCountTestImportGroup.importsGroupedConfig1.classGroupedConfig2.classParentConfiguration1.classcontainsOnlyKeys(...)allImports(...)ChildConfiguration1.classDeferredImportedSelector3.classParentConfiguration2.classChildConfiguration2.classTestImportGroup.beanFactoryTestImportGroup.classLoaderTestImportGroup.resourceLoaderTestImportGroup.environmentSampleImportSelector.classImportedSelector1.classImportedSelector2.classDeferredImportedSelector1.classDeferredImportedSelector2.classIndirectImportSelector.classGroupedDeferredImportSelector1.classGroupedDeferredImportSelector2.classTestImportGroup.classParentDeferredImportSelector1.classParentDeferredImportSelector2.classChildDeferredImportSelector1.classChildDeferredImportSelector2.classnew LinkedMultiValueMap<AnnotationMetadata,String>(...)AtomicInteger instancesCount, ...;MultiValueMap<AnnotationMetadata,String> imports, ...;toMap(...)new Function<Entry<AnnotationMetadata,List<String>>,String>(...) { ... }new Function<Entry<AnnotationMetadata,List<String>>,List<String>>(...) { ... }List<Entry> instanceImports, ...;this.instanceImportsArrayList<Entry> content// since ImportedSelector1 got filteredAnnotationConfigApplicationContext directRegistrationAccidentalLiteConfiguration.classThing.classAnnotationConfigApplicationContext viaImportImporter.classnew Thing(...)/** Unit tests covering cases where a user defines an invalid Configuration ... */BeanDefinition configBeanDefAnnotationConfigApplicationContext acTestBeanHolder beanTestBeanHolder.classFieldResourceInjectionBean.classFieldResourceInjectionBean beandoTestLazyResourceInjection(...)FieldResourceInjectionBeanWithCompositeAnnotation.classMethodResourceInjectionBean.classMethodResourceInjectionBeanWithMethodLevelLazy.classMethodResourceInjectionBeanWithCompositeAnnotation.classConstructorResourceInjectionBeanWithConstructorLevelLazy.classConstructorResourceInjectionBeanWithCompositeAnnotation.classOptionalFieldResourceInjectionBean.classOptionalFieldResourceInjectionBean bean/** Tests ensuring that nested static @Configuration classes are automatically detected ... */L0Config.L1Config.classL0Config.L1ConfigL0Config.L1Config.L2Config.classL0Config.L1Config.L2ConfigL0Config.classL0ConfigLight.classL0ConfigLight.L1ConfigLight.classL0ConfigLight.L1ConfigLightL0ConfigLight.L1ConfigLight.L2ConfigLight.classL0ConfigLight.L1ConfigLight.L2ConfigLightS1Config configS1Config.classTestBean obTestBean pb1TestBean pb2S1Importer.classS1ConfigWithProxy configS1ConfigWithProxy.classS1ImporterWithProxy.classObject l0i1L0ConfigEmpty.classObject l0i2Object l1i1L0ConfigEmpty.L1ConfigEmpty.classL0ConfigEmpty.L1ConfigEmptyObject l1i2Object l2i1L0ConfigEmpty.L1ConfigEmpty.L2ConfigEmpty.classL0ConfigEmpty.L1ConfigEmpty.L2ConfigEmptyObject l2i2L0ConfigConcrete.classL0ConfigConcrete.L1ConfigEmpty.classL0ConfigConcrete.L1ConfigEmptyL0ConfigConcrete.L1ConfigEmpty.L2ConfigEmpty.classL0ConfigConcrete.L1ConfigEmpty.L2ConfigEmpty// ensure that override order is correct// ensure that override order is correct and that it is a singletonimport Mockimport MockitoAnnotationsimport static Mockito.reset/** Tests for {@link ParserStrategyUtils}. ... */initMocks(...)NoArgsConstructor instanceNoArgsConstructor.classinstance.setEnvironmentinstance.setBeanFactoryinstance.setBeanClassLoaderinstance.setResourceLoaderArgsConstructor instanceArgsConstructor.classinstance.environmentinstance.beanFactoryinstance.beanClassLoaderinstance.resourceLoaderArgsConstructorAndAware instanceArgsConstructorAndAware.classMultipleConstructors instanceMultipleConstructors.classinstance.usedDefaultConstructorMultipleConstructorsWithNoDefault.classInvalidConstructorParameterType.classInvalidConstructorParameterSubType.classinstance.setBeanClassLoaderCalledEnvironment setEnvironment, ...;BeanFactory setBeanFactory, ...;ClassLoader setBeanClassLoader, ...;boolean setBeanClassLoaderCalled, ...;ResourceLoader setResourceLoader, ...;this.setEnvironmentthis.setBeanFactorythis.setBeanClassLoaderthis.setBeanClassLoaderCalledthis.setResourceLoaderboolean usedDefaultConstructor, ...;this.usedDefaultConstructor// Remain back-compatible by using the default constructor if there's more then one// To keep the algorithm simple we don't support subtypes/** Tests changes introduced for SPR-8874, allowing beans of primitive types to be looked ... */boolean bAutowiredComponent.classgetBean(...).iResourceComponent.classboolean b, ...;int i, ...;import MapPropertySource/** Tests the processing of @PropertySource annotations on @Configuration classes. ... */MutablePropertySources sourcesIterator<PropertySource<?>> iteratorConfigWithExplicitName.classConfigWithImplicitName.classConfigWithTestProfileBeans.class/** Tests the LIFO behavior of @PropertySource annotations. ... */P2Config.classWithCustomFactory.classWithCustomFactoryAsMeta.classConfigWithUnresolvablePlaceholder.classConfigWithUnresolvablePlaceholderAndDefault.classConfigWithResolvablePlaceholder.classConfigWithResolvablePlaceholderAndFactoryBean.classConfigWithEmptyResourceLocations.classConfigWithNameAndMultipleResourceLocations.classcontainsProperty(...)ConfigWithMultipleResourceLocations.classConfigWithPropertySources.classConfigWithRepeatedPropertySourceAnnotations.classConfigWithRepeatedPropertySourceAnnotationsOnComposedAnnotation.classConfigWithNamedPropertySources.classConfigWithMissingPropertySource.classConfigWithIgnoredPropertySource.classConfigWithSameSourceImportedInDifferentOrder.classAnnotationConfigApplicationContext ctxWithNameAnnotationConfigApplicationContext ctxWithoutNameConfigWithFourResourceLocations.classMapPropertySource mySourcenew MapPropertySource(...)new FactoryBean<TestBean>(...) { ... }MyCustomFactory.classnew PropertySource<Properties>(...) { ... }ConfigImportedWithSameSourceImportedInDifferentOrder.class// assert that the property source was added last to the set of sources// p2 should 'win' as it was registered last// p1 should 'win' as it was registered last// p3 should 'win' as it was registered last// SPR-10820: p2 should 'win' as it was registered last// SPR-12198: p4 should 'win' as it was registered last// SPR-12198: mySource should 'win' as it was registered manually/** Tests ReflectionUtils methods as used against CGLIB-generated classes created ... */Class<?> cglibLeafLeaf.classint m1MethodCountimport ComponentWithRoleimport ComponentWithoutRole/** Tests the use of the @Role and @Description annotation on @Bean methods and @Component classes. ... */ComponentWithoutRole.classComponentWithRole.classimport FutureTaskServiceInvocationCounter serviceInvocationCounterFuture<?> futureasyncFoo(...)Wrapper.classSelector.classNoBarCondition.classthis.foo.nameStringHolder holderStringHolder.classholder.itemsListholder.itemsArraynew StringHolder(...)List<String> itemsList, ...;...[] itemsArray, ...;AnnotationConfigApplicationContext context, ...;BaseConfiguration.classSingleConstructorComponent.classgetBean(...).autowiredNameTwoConstructorsComponent.classTwoSpecificConstructorsComponent.class// No @Autowired - implicit wiringthis.autowiredNameimport EnableAsyncUserServiceCollector beanUserServiceCollector.classUserServiceTwo.classUserServiceOne.classbean.userServicesUserService.classUserService serviceOneUserService serviceTwoAsyncConfig.classList<UserService> userServices, ...;this.userServices// Validate those beans are indeed wrapped by a proxyPoolingTargetSourceConfig.classpoolTargetSource(...)CommonsPool2TargetSource poolConfigWithFactoryBean.classFooInterface.classConfigWithAbstractFactoryBean.classConfigWithAbstractFactoryBeanForInterface.classConfigWithAbstractFactoryBeanAsReturnType.classConfigWithFinalFactoryBean.classConfigWithFinalFactoryBeanAsReturnType.classnew FactoryBean<Foo>(...) { ... }new AbstractFactoryBean<Foo>(...) { ... }new AbstractFactoryBean<FooInterface>(...) { ... }new FinalFactoryBean(...)FooInterface foo, ...;// not same due to fallback to raw FinalFactoryBean instance with repeated getObject() invocationsAnnotationConfigApplicationContext bfAssemblerConfig.classAssemblerInjection.classgetBean(...).assembler0getBean(...).assembler3getBean(...).assembler4getBean(...).assembler5getBean(...).assembler6new PageAssemblerImpl<Object>(...)new Assembler<SomeType>(...) { ... }Assembler<SomeType> assembler0, ...;Assembler<SomeOtherType> assembler1, ...;Assembler<Page<String>> assembler2, ...;Assembler<Page<>> assembler3, ...;Assembler<Page<?>> assembler4, ...;PageAssembler<?> assembler5, ...;PageAssembler<String> assem    +n    