#!/usr/bin/env python
# coding: utf-8

#Importing the neccesary libraries
import requests
from bs4 import BeautifulSoup
import os
import re
import csv
import pandas as pd


#Pulling the dedicated page for Java vulnerabilities from http://cve.mitre.org Note: keyword = java
URL = "http://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=java"
#Requesting the URL above by the requests library
page = requests.get(URL)
#Specify a desired format for the “page” using the html parser in BeautifulSoup. 
#This allows Python to read the various components of the page, rather than treating it as a long string.
formated_page = BeautifulSoup(page.text, "html.parser")

def has_valign_but_no_wrap(tag):
    """
    A function to filter the record to return rows only with the 'valign' tag. 
    The tag of the CVE description in the scraped html file
    """
    return tag.has_attr('valign') and not tag.has_attr('nowrap') and not tag.has_attr('style')

def extract_CVE_ids(formated_page):
    """
    The function extracts CVE_id from the formatted HTML page
    """
    CVE_ids =[]
   
    for table in formated_page.find_all(name="div", attrs={"id":"TableWithRules"}):
        for row in table.find_all(name="tr"):
            for column in row.find_all(name="td", attrs={"valign":"top", "nowrap":"nowrap"}):
                for ids in column.find_all(name="a"):
                    CVE_ids.append(ids.string)
    return CVE_ids

def extract_descr(formated_page):
    """
    The function extracts the CVE descriptions from the formatted HTML page
    """
    CVE_descrs =[]
    for table in formated_page.find_all(name="div", attrs={"id":"TableWithRules"}):
        for row in table.find_all(name="tr"):
            for descr in row.find_all(has_valign_but_no_wrap): #The has_valign_but_no_wrap function, defined above is called here
                delimited_descr = re.split("\n+", descr.string)
                CVE_descrs.append(delimited_descr[0])
    return CVE_descrs

#The extract ids and extract CVEs functions are called, and the returned lists are converted into dictionary records
data_list_frame = pd.DataFrame(list(zip(extract_CVE_ids(formated_page),extract_descr(formated_page))),columns=["CVE","vulnerability_description"])
data_list_dict = data_list_frame.to_dict('records')

#Main method
if __name__ == "__main__":
    
    if os.path.exists('../../javavultextdata/mitrejavacve.csv'):
        
        existing_data = pd.read_csv('../../javavultextdata/mitrejavacve.csv', low_memory = False)
        existing_data_dict = existing_data.to_dict('records')
        field_names = ["CVE","vulnerability_description"]
        try:
            with open('../../javavultextdata/mitrejavacve.csv', 'a') as existing_data_to_append:
                write_to_existing_file = csv.DictWriter(existing_data_to_append, fieldnames=field_names)
                for data in data_list_dict:
                    if data not in existing_data_dict:
                        write_to_existing_file.writerow(data)
                    print("I made it!")
        finally:
            existing_data_to_append.close() 
        
    else:
        data_list_frame.to_csv('../../javavultextdata/mitrejavacve.csv', encoding='utf-8', index = None) 
